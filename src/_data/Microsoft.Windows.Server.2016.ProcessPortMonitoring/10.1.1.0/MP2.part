				  EXEC DebugMessageInsert
					 @DatasetId = @DatasetId
					,@MessageLevel = @InfoLevel
					,@MessageText = @MessageText
				END
			
				EXEC(@Statement)
			 -- mark existing affected aggregations as dirty
				UPDATE ah
				SET DirtyInd = 1
				   ,DataLastReceivedDateTime = GETUTCDATE()
				FROM StandardDatasetAggregationHistory ah
					  JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
					  CROSS JOIN ' + @SchemaName + '.ProcessStateStaging2Process p
				WHERE (ah.DatasetId = @DatasetId)
				  AND (ah.AggregationDateTime &gt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()))
				  AND (p.[CollectedDate ] &gt;= ah.AggregationDateTime)
				  AND (p.[CollectedDate] &lt; DATEADD(minute, a.AggregationIntervalDurationMinutes, ah.AggregationDateTime))
			   -- delete processed rows from staging
               DELETE ps
               FROM ' + @SchemaName + '.ProcesStateStaging ps
               JOIN ' + @SchemaName + '.ProcessStateStaging2Process psp ON (ps.ProcessStateStageRowId  = psp.OriginalProcessStateStageRowId )
    
				-- delete all inserted data from staging
				DROP TABLE ' + @SchemaName + '.ProcessStateStaging2Process
                EXEC sp_releaseapplock  @Resource = @LockResourceName 
	COMMIT
    
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Health State DataSet: Finished inserting health state samples  into '' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      
      SET @DebugMessageText = N''Failed to process data in the Process Monitroing Health State DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
DeleteWrongDataSet:
	--------------------------------------------------------------------------
	-- Delete wrong  datasets from staging
	--------------------------------------------------------------------------
	DECLARE
	  @delBatchSize int
	 ,@ErrorIndDel int
	 
	 SET @ErrorIndDel  = 0
	 SET @delBatchSize = @MaxStagingRowsToProcess
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Health State DataSet: Starting deletion of wrong DataSets records from staging ''
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
    END
   SET @InsertStartedDateTime = GETUTCDATE()
	WHILE(1=1)
	BEGIN
	 BEGIN TRY
	     BEGIN TRAN
			DELETE TOP(@delBatchSize) FROM ' + @SchemaName + '.ProcesStateStaging
			WHERE (DatasetId != @DatasetId)
			IF (@@rowcount &lt; @delBatchSize)
			BEGIN
				COMMIT
				BREAK;
			END
 	     COMMIT
	 END TRY
     BEGIN CATCH
		IF (@@TRANCOUNT &gt; 0)
		  ROLLBACK TRAN
  
		SELECT 
		   @ErrorNumber = ERROR_NUMBER()
		  ,@ErrorSeverity = ERROR_SEVERITY()
		  ,@ErrorState = ERROR_STATE()
		  ,@ErrorLine = ERROR_LINE()
		  ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
		  ,@ErrorMessageText = ERROR_MESSAGE()
		SET @ErrorIndDel = 1
	 END CATCH
	 IF (@ErrorIndDel = 1)
	 BEGIN
			BREAK;
     END --IF
    END --WHILE
	 IF (@ErrorIndDel = 1)
	 BEGIN
			IF (@DebugLevel &gt; 0)
			BEGIN
      
				SET @DebugMessageText = N''Failed to delete  data from wromg dataset in the Process Monitroing Health State DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
								+ '', Procedure '' + @ErrorProcedure
								+ '', Line '' + CAST(@ErrorLine AS varchar(15))
								+ '', Message: ''+ @ErrorMessageText
				EXEC DebugMessageInsert
					@DatasetId = @DatasetId
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessageText
			END
      
			SET @AdjustedErrorSeverity = CASE
											WHEN @ErrorSeverity &gt; 18 THEN 18
											ELSE @ErrorSeverity
											END
    
			RAISERROR (777971002, @AdjustedErrorSeverity, 1
				,@ErrorNumber
				,@ErrorSeverity
				,@ErrorState
				,@ErrorProcedure
				,@ErrorLine
				,@ErrorMessageText
			)
     END
	 ELSE
	 BEGIN
		IF (@DebugLevel &gt; 0)
		BEGIN
		  SET @MessageText = ''Process Monitroing Health State DataSet: Finished deleting wrong dataset records from staging ''
          SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
		  EXEC DebugMessageInsert
			 @DatasetId = @DatasetId
			,@MessageLevel = @InfoLevel
			,@MessageText = @MessageText
            ,@OperationDurationMs = @OperationDurationMs
		END
     END --IF
 Endproc:  
END  --Procedure [ProcessMonitoring].[HealthStateProcessStaging]
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create stage processing stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Stage processing stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	 @DatasetId    = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel
	,@MessageText  = @DebugMessage
 END                                
END
Endproc:
GO
</Install><Uninstall>
GO
DECLARE
 @TableSchemaName sysname
SELECT 
	@TableSchemaName  = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
-- drop SPs
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME =  'HealthStateFactsGroom')
	BEGIN
		EXECUTE ('DROP PROCEDURE ' + @TableSchemaName +'.HealthStateFactsGroom')
	END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME = 'HealthStateProcessStaging')
	BEGIN
		EXECUTE ('DROP PROCEDURE ' + @TableSchemaName +'.HealthStateProcessStaging ')
	END
--drop views
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vComputerDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vComputerDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vUserDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vUserDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vTimeDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vTimeDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vDateDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vDateDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vProcessDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vProcessDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vProcessCmdDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.vProcessCmdDim')
END
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ComputerDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ComputerDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'UserDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.UserDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'TimeDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.TimeDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'DateDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.DateDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ProcessDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ProcessDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ProcessCmdDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ProcessCmdDim')
END
-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
</Uninstall><Upgrade /></DataWarehouseDataSet><DataWarehouseDataSet ID="Microsoft.Windows.Server.10.0.MetricsCollection.Dataset" Accessibility="Internal"><Dependencies><DataWarehouseScript>SCDW!Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>SCDW!Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>SCDW!Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Aggregations" type="AggregationsType" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DefaultAggregationIntervalCount" type="xsd:positiveInteger" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime"
type="TimeOfDayType" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger" /></Configuration><Install>
GO
---------------------------------------------------------------
-- Initialize Process Performance Dataset
--------------------------------------------------------------
SET NOCOUNT ON
DECLARE 
        @SchemaName sysname
	   ,@ProcessStagingSp sysname
	   ,@ErrorInd   bit
	   ,@DebugLevel tinyint
	   ,@DebugPrefix  nvarchar(max)
       ,@DebugMessage  nvarchar(max)
	   ,@ErrorLevel      int
	   ,@InfoLevel       int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugLevel   = 0
SET @SchemaName  = 'ProcessMonitoring'
SET @ProcessStagingSp = 'PerformanceProcessStaging'
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + ' Insert new definition.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
BEGIN TRY
	INSERT StandardDataset (
	   DatasetId 
	  ,SchemaName
	  ,DebugLevel
	  ,DefaultAggregationIntervalCount
	  ,RawInsertTableCount
	  ,StagingProcessorStoredProcedureName
	  ,BlockingMaintenanceDailyStartTime
	  ,BlockingMaintenanceDurationMinutes
	)
	VALUES
	(
	   '$Config/DatasetId$'
	  ,@SchemaName
	  ,@DebugLevel
	  ,$Config/DefaultAggregationIntervalCount$
	  ,$Config/RawInsertTableCount$
	  ,@SchemaName + '.' + @ProcessStagingSp
	  ,'$Config/BlockingMaintenanceDailyStartTime$'
	  ,$Config/BlockingMaintenanceDurationMinutes$
	)
	END TRY
	BEGIN CATCH
	 SET @ErrorInd = 1
	END CATCH
	IF (1 = @ErrorInd)
	BEGIN
	    SET @DebugMessage =  @DebugPrefix + 'Insert new definition failed.'
		EXEC DebugMessageInsert
				@DatasetId = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessage
	END
	ELSE
	BEGIN
	    SET @DebugMessage =  @DebugPrefix + ' Insert new definition finished successfully.'
		EXEC DebugMessageInsert
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @InfoLevel
				,@MessageText  = @DebugMessage
	END 
GO
---------------------------------------------------------------------------------------
-- Create the StandardDatasetAggregation for Process Monitoring Performance  Fact Tables
----------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugPrefix  nvarchar(max)
  ,@DebugMessage  nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
SET @ErrorInd     = 0
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DebugPrefix  = 'Process Monitoring Performance DataSet: '
SET @DebugMessage = @DebugPrefix  + 'Starting aggregation setting deployment.'
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText varchar(max)
  ,@BuildAggregationStoredProcedureName  sysname
  ,@DeleteAggregationStoredProcedureName sysname
  ,@GroomStoredProcedureName             sysname
  ,@SchemaName                           sysname
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
  
BEGIN TRY
  SELECT @SchemaName = SchemaName
  FROM
  dbo.StandardDataSet
  WHERE DatasetId = '$Config/DatasetId$'
  IF @SchemaName IS NULL
  BEGIN
    
   SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was failed. Process Monitoring Health State Dataset does not exist.'
  
   EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   RAISERROR( @DebugMessage, 16,1)
  END
  
  
  SET @BuildAggregationStoredProcedureName  = @SchemaName + '.' + 'PerformanceFactsAggregate'
  SET @DeleteAggregationStoredProcedureName = @SchemaName + '.' + 'PerformanceFactsAggregateDelete'
  SET @GroomStoredProcedureName             = @SchemaName + '.' + 'PerformanceFactsGroom'
 
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'Process Monitoring: Health State Aggregation', @ExecResult)
  IF NOT EXISTS (SELECT 1 FROM dbo.StandardDatasetAggregation WHERE  DatasetId = '$Config/DatasetId$' )
  BEGIN
	  INSERT StandardDatasetAggregation
	  (                               
		 DatasetId
		,AggregationTypeId
		,AggregationIntervalDurationMinutes
		,AggregationStartDelayMinutes
		,BuildAggregationStoredProcedureName
		,DeleteAggregationStoredProcedureName
		,GroomStoredProcedureName
		,IndexOptimizationIntervalMinutes
		,MaxDataAgeDays
		,GroomingIntervalMinutes
		,MaxRowsToGroom
		,LastGroomingDateTime
		,DataFileGroupName
		,IndexFileGroupName
	  )
	  SELECT
     '$Config/DatasetId$'
    ,CASE AggregationType
       WHEN 'Raw' THEN 0
       WHEN 'Subhourly' THEN 10
       WHEN 'Hourly' THEN 20
       WHEN 'Daily' THEN 30
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       WHEN 'Subhourly' THEN AggregationIntervalDurationMinutes
       WHEN 'Hourly' THEN 60
       WHEN 'Daily' THEN 24*60
     END
    ,AggregationStartDelayMinutes
    ,@BuildAggregationStoredProcedureName
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       ELSE @DeleteAggregationStoredProcedureName
     END
    ,@GroomStoredProcedureName
    ,IndexOptimizationIntervalMinutes
    ,MaxDataAgeDays
    ,GroomingIntervalMinutes
    ,MaxRowsToGroom
    ,GETUTCDATE()
    ,DataFileGroupName
    ,IndexFileGroupName
     FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
		   AggregationType                    varchar(50)   '@mp:localname'
		  ,MaxTableRowCount                   int
		  ,MaxTableSizeKb                     int
		  ,AggregationStartDelayMinutes       int
		  ,MaxDataAgeDays                     int
		  ,GroomingIntervalMinutes            int
		  ,MaxRowsToGroom                     int
		  ,IndexOptimizationIntervalMinutes   int
		  ,DataFileGroupName                  nvarchar(256)
		  ,IndexFileGroupName                 nvarchar(256)
		  ,AggregationIntervalDurationMinutes int
	  )
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
 SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was failed. Error: ' + @ErrorMessageText
  
 EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was finished successfully.'
  
 EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
END
GO
 
 
------------------------------------------------------------------------------------------------------------
-- Create the StandardDataset Aggregation Tables definitions for Process Monitoring Performance Fact Tables
------------------------------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage    nvarchar(max)
  ,@DebugPrefix     nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugPrefix  =  'Process Monitoring Perfromance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting dataset table definitions deployment.'
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  ,@TableCompressionClause nvarchar(max) 
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
  
BEGIN TRY
  SET @TableCompressionClause = ''
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  -----------------------------------------------------------------------
  -- ENBALE PAGE COMPRESSION ON FACT Tables IF AVILABLE
  -----------------------------------------------------------------------
	IF ( 3 = SERVERPROPERTY('EngineEdition') 
		 OR
		 ('SP1' = SERVERPROPERTY('ProductLevel') AND CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(50)) like '13.0%')
	   )
	BEGIN
	  SET @TableCompressionClause = ' WITH (DATA_COMPRESSION = PAGE)'
	END
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 
  BEGIN
	  SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was failed. Cannot parse dataset definition. Xml definition: ' + @XmlDocText
  
	  EXEC DebugMessageInsert
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel 
				,@MessageText  = @DebugMessage
     RAISERROR(777971000, 16, 1, @DebugMessage, @ExecResult)
  END
  INSERT StandardDatasetAggregationStorage
  (                               
     DatasetId
    ,AggregationTypeId
    ,BaseTableName
    ,DependentTableInd
    ,TableTemplate
    ,CoverViewSelectClause
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  )
  SELECT
     '$Config/DatasetId$'
     ,CASE AggregationType
			WHEN 'Raw' THEN 0
			WHEN 'Hourly' THEN 20
			WHEN 'Daily' THEN 30
		END
    ,BaseTableName
    ,0
    ,CASE AggregationType
       WHEN 'Raw' THEN '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(BaseTableName + 'RowId') + ' bigint  NOT NULL  IDENTITY(1, 1)
                    ,DateKey                        int  NOT NULL
                    ,TimeKey                        int  NOT NULL
                    ,ComputerRowId                  int  NOT NULL
                    ,ProcessRowId                   int  NOT NULL
                    ,ProcessCmdRowId                int  NOT NULL
					,UserRowId                      int  NOT NULL
                    ,PID                            int  NOT NULL
 				    ,CpuUsage                       float             NOT NULL
					,MemoryUsage                    float             NOT NULL
					,HandleCount                    int               NOT NULL 
					,ThreadCount                    int               NOT NULL 
					,PageFaultCount                 int               NOT NULL 
					,CpuTime                        bigint            NOT NULL 
					,TotalProcessTime               bigint            NOT NULL 
					,IOReadPerSecond                float             NOT NULL
					,IOWritePerSecond               float             NOT NULL 
                    ,[DateTime]                       datetime          NOT NULL
                    ,CONSTRAINT ' + QUOTENAME('PK_' + BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       ' + @TableCompressionClause
	   ELSE
	   '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(BaseTableName + 'RowId') + ' bigint  NOT NULL  IDENTITY(1, 1)
                    ,DateKey                           int  NOT NULL
                    ,TimeKey                           int  NOT NULL
                    ,ComputerRowId                     int  NOT NULL
                    ,ProcessRowId                      int  NOT NULL
                    ,ProcessCmdRowId                   int  NOT NULL
					,UserRowId                         int  NOT NULL
                    ,PID                               int  NOT NULL
                    ,CpuUsageSampleCount               int  NOT NULL
                    ,CpuUsageAverageValue              float(53) NOT NULL
                    ,CpuUsageMinValue                  float(53) NOT NULL
                    ,CpuUsageMaxValue                  float(53) NOT NULL
                    ,CpuUsageStandardDeviation         float(53) NOT NULL
                    ,MemoryUsageSampleCount            int       NOT NULL
                    ,MemoryUsageAverageValue           float(53) NOT NULL
                    ,MemoryUsageMinValue               float(53) NOT NULL
                    ,MemoryUsageMaxValue               float(53) NOT NULL
                    ,MemoryUsageStandardDeviation      float(53) NOT NULL
                    ,HandleCountSampleCount            int       NOT NULL
                    ,HandleCountAverageValue           float(53) NOT NULL
                    ,HandleCountMinValue               int       NOT NULL
                    ,HandleCountMaxValue               int       NOT NULL
                    ,HandleCountStandardDeviation      float(53) NOT NULL
                    ,ThreadCountSampleCount            int       NOT NULL
                    ,ThreadCountAverageValue           float(53) NOT NULL
                    ,ThreadCountMinValue               int       NOT NULL
                    ,ThreadCountMaxValue               int       NOT NULL
                    ,ThreadCountStandardDeviation      float(53) NOT NULL
                    ,PageFaultCountSampleCount         int       NOT NULL
                    ,PageFaultCountAverageValue        float(53) NOT NULL
                    ,PageFaultCountMinValue            int       NOT NULL
                    ,PageFaultMaxValue                 int       NOT NULL
                    ,PageFaultCountStandardDeviation   float(53) NOT NULL
					,IOReadPerSecondSampleCount        int       NOT NULL
                    ,IOReadPerSecondAverageValue       float(53) NOT NULL
                    ,IOReadPerSecondMinValue           float(53) NOT NULL
                    ,IOReadPerSecondMaxValue           float(53) NOT NULL
                    ,IOReadPerSecondStandardDeviation  float(53) NOT NULL
					,IOWritePerSecondSampleCount       int       NOT NULL
                    ,IOWritePerSecondAverageValue      float(53) NOT NULL
                    ,IOWritePerSecondMinValue          float(53) NOT NULL
                    ,IOWritePerSecondMaxValue          float(53) NOT NULL
                    ,IOWritePerSecondStandardDeviation float(53) NOT NULL
					,CpuTimeSampleCount                int       NOT NULL
                    ,CpuTimeAverageValue               float(53) NOT NULL
					,CpuTimeMaxValue                   bigint    NOT NULL 
					,CpuTimeMinValue                   bigint    NOT NULL 
					,CpuTimeStandardDeviation          float(53) NOT NULL  
					,TotalProcessTimeMaxValue          bigint     NOT NULL 
                    ,[DateTime]                         datetime          NOT NULL
                    ,CONSTRAINT ' + QUOTENAME('PK_' + BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       ' + @TableCompressionClause	   
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN '
          SELECT
               DateKey
			  ,TimeKey
	          ,ComputerRowId         
              ,ProcessRowID          
              ,ProcessCmdRowID  
			  ,UserRowId 
              ,PID                   
              ,CpuUsage         
              ,MemoryUsage      
              ,HandleCount      
              ,ThreadCount         
			  ,PageFaultCount   
			  ,CpuTime          
			  ,TotalProcessTime 
			  ,IOReadPerSecond  
			  ,IOWritePerSecond 
			  ,[DateTime]
       '
	 ELSE
     '
          SELECT
				 DateKey                          
				,TimeKey                          
				,ComputerRowId                    
				,ProcessRowId                     
				,ProcessCmdRowId                  
				,UserRowId                        
				,PID                              
				,CpuUsageSampleCount              
				,CpuUsageAverageValue             
				,CpuUsageMinValue                 
				,CpuUsageMaxValue                 
				,CpuUsageStandardDeviation        
				,MemoryUsageSampleCount           
				,MemoryUsageAverageValue          
				,MemoryUsageMinValue              
				,MemoryUsageMaxValue              
				,MemoryUsageStandardDeviation     
				,HandleCountSampleCount           
				,HandleCountAverageValue          
				,HandleCountMinValue              
				,HandleCountMaxValue              
				,HandleCountStandardDeviation     
				,ThreadCountSampleCount           
				,ThreadCountAverageValue          
				,ThreadCountMinValue              
				,ThreadCountMaxValue              
				,ThreadCountStandardDeviation     
				,PageFaultCountSampleCount        
				,PageFaultCountAverageValue       
				,PageFaultCountMinValue           
				,PageFaultMaxValue                
				,PageFaultCountStandardDeviation  
				,IOReadPerSecondSampleCount       
				,IOReadPerSecondAverageValue      
				,IOReadPerSecondMinValue          
				,IOReadPerSecondMaxValue          
				,IOReadPerSecondStandardDeviation 
				,IOWritePerSecondSampleCount      
				,IOWritePerSecondAverageValue     
				,IOWritePerSecondMinValue         
				,IOWritePerSecondMaxValue         
				,IOWritePerSecondStandardDeviation
				,CpuTimeSampleCount               
				,CpuTimeAverageValue              
				,CpuTimeMaxValue                  
				,CpuTimeMinValue                  
				,CpuTimeStandardDeviation         
				,TotalProcessTimeMaxValue         
				,[DateTime]
	 
	 '
	 END
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
       AggregationType      varchar(50)   '@mp:localname'
      ,BaseTableName        varchar(256)
      ,MaxTableRowCount     int
      ,MaxTableSizeKb       int
      ,DataFileGroupName    varchar(256)
      ,IndexFileGroupName    varchar(256)
  )
      CROSS JOIN StandardDataset d
  WHERE (d.DatasetId = '$Config/DatasetId$')
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was failed. Error: ' + @ErrorMessageText
  
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel 
			,@MessageText  = @DebugMessage
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was finished successfully.'
 EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
END
GO
  ------------------------------------------------------------------------------------------------------------
-- Create Indexes for the StandardDataset Aggregation Tables  for Process Monitoring Performance Fact Tables
------------------------------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@Statement         nvarchar(max)
  ,@IndeGuid          uniqueidentifier
  ,@ErrorInd          bit
  ,@ErrorMessageText  nvarchar(4000)
  ,@ErrorNumber       int
  ,@ErrorSeverity     int
  ,@ErrorState        int
  ,@ErrorLine         int
  ,@ErrorProcedure    nvarchar(256)
  ,@DebugMessage      nvarchar(max)
  ,@DebugPrefix       nvarchar(max)
  ,@ErrorLevel        int
  ,@InfoLevel         int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting dataset indexes deployment.'
SET @AggregationTypeId = -1
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
BEGIN TRY
		WHILE EXISTS (SELECT *
					  FROM StandardDatasetAggregation
					  WHERE (DatasetId = '$Config/DatasetId$')
						AND (AggregationTypeId &gt; @AggregationTypeId)
					 )
		BEGIN
		  SELECT @IndeGuid = NEWID()
  
		  SELECT TOP 1 
			 @AggregationTypeId = AggregationTypeId
			,@Statement = 
			  ' EXEC StandardDatasetIndexDelete'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			  + '   ,@DeleteIndexOnExistingTablesInd = 0'
			+ ' EXEC StandardDatasetIndexInsert'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
			+ '   ,@DependentTableInd = 0'
			+ '   ,@TableTag = NULL'
			+ '   ,@UniqueInd = 0'
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			+ '   ,@IndexDefinition = ''([DateTime])'''
			+ '   ,@CreateIndexOnExistingTablesInd = 0'
		  FROM StandardDatasetAggregation
		  WHERE (DatasetId = '$Config/DatasetId$')
			AND (AggregationTypeId &gt; @AggregationTypeId)
		  ORDER BY AggregationTypeId
  
		  EXECUTE (@Statement)
		END
		/* raw indexes for UI widget */
		EXEC StandardDatasetIndexDelete
		   @DatasetId = '$Config/DatasetId$'
		  ,@IndexGuid = '29F829DC-FD4D-49CF-8F27-1200EFA53316'
			,@DeleteIndexOnExistingTablesInd = 0
		EXEC StandardDatasetIndexInsert
		   @DatasetId = '$Config/DatasetId$'
		  ,@AggregationTypeId = 0
		  ,@DependentTableInd = 0
		  ,@TableTag = NULL
		  ,@UniqueInd = 0
		  ,@IndexGuid = '29F829DC-FD4D-49CF-8F27-1200EFA53316'
		  ,@IndexDefinition = '(
				 ComputerRowId     
				,ProcessRowId      
				,ProcessCmdRowId   
				,UserRowId         
				,PID               
				,DateTime
			)
			INCLUDE
			(
				 CpuUsage         
				,MemoryUsage      
				,HandleCount      
				,ThreadCount      
				,PageFaultCount   
				,CpuTime          
				,TotalProcessTime 
				,IOReadPerSecond  
				,IOWritePerSecond 
			)
		'
		  ,@CreateIndexOnExistingTablesInd = 0
END TRY
BEGIN CATCH
  SET @ErrorInd = 1
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
END CATCH
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was failed. Error: ' + @ErrorMessageText
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage 
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was finished successfully.'
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
END
GO
------------------------------------------------------------------
--- Create SCHEMA for new Process Monitoring Performance DataSet
-------------------------------------------------------------------
GO
DECLARE 
@SchemaName sysname
SELECT @SchemaName = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = @SchemaName)
BEGIN
  EXECUTE('CREATE SCHEMA ' + @SchemaName)
END
 DECLARE @Statement  nvarchar(max)
 -- change schema ownership to allow index rebuild and reorganize
 SET  @Statement = 'ALTER AUTHORIZATION ON SCHEMA::' + @SchemaName + ' TO OpsMgrWriter'
 EXECUTE(@Statement)
 SET  @Statement = 'GRANT ALTER ON SCHEMA::' + @SchemaName + ' TO OpsMgrWriter'
 EXECUTE(@Statement)
 
 -- grant create table permissions
 GRANT CREATE TABLE TO OpsMgrWriter
GO
-----------------------------------------------------------------------
--- Start standard Process Monitoring Performance dataset  deployment
-----------------------------------------------------------------------
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage    nvarchar(max)
  ,@DebugPrefix     nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
  
SET @ErrorInd     = 0
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
 
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting storage deployment.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
			  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  SET @DebugMessage = @DebugPrefix + 'Cannot parse configuration. Text: ' + @XmlDocText
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0
  BEGIN
          EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText = @DebugMessage
 
   RAISERROR(777971000, 16, 1,@DebugMessage , @ExecResult)
  END
  DECLARE
     @AggregationType varchar(50)
    ,@Statement nvarchar(max)
     
  SET @AggregationType = ''
  WHILE EXISTS (SELECT *
                FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
                      AggregationType      varchar(50)   '@mp:localname')
                WHERE AggregationType &gt; @AggregationType
               )
  BEGIN
    SELECT TOP 1 @AggregationType = AggregationType
    FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
          AggregationType      varchar(50)   '@mp:localname')
    WHERE AggregationType &gt; @AggregationType
    ORDER BY AggregationType
    
    SET @Statement = 'EXEC StandardDatasetAllocateStorage @DatasetId = ''$Config/DatasetId$'', @AggregationTypeId='
                    + CASE @AggregationType
                        WHEN 'Raw' THEN '0'
                        WHEN 'Subhourly' THEN '10'
                        WHEN 'Hourly' THEN '20'
                        WHEN 'Daily' THEN '30'
                      END
    EXECUTE (@Statement)
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  SET @DebugMessage = @DebugPrefix + 'Storage deployment was failed. Error: ' + @ErrorMessageText
  
  EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText = @DebugMessage
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix + 'Storage deployment was finished successfully.' 
 
 EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText = @DebugMessage
END
GO
--------------------------------------------------------------------------------------
--- Start standard Process Monitoring Performance dataset staging tables  deployment
--------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd         bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber      int
  ,@ErrorSeverity    int
  ,@ErrorState       int
  ,@ErrorLine        int
  ,@ErrorProcedure   nvarchar(256)
  ,@Statement        nvarchar(max)
  ,@DebugMessage     nvarchar(max)
  ,@DebugLevel       tinyint
  ,@DebugPrefix      nvarchar(max)
  ,@ErrorLevel       int
  ,@InfoLevel        int
  SET @ErrorInd     = 0
  SET @ErrorLevel   = 3 
  SET @InfoLevel    = 1
  SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
  SET @DebugMessage =  @DebugPrefix + ' Create staging table.'
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
-- insert staging definition into StandardDatasetStagingArea
BEGIN TRY
	BEGIN TRAN
	IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
	BEGIN
	  DELETE StandardDatasetStagingArea
	  WHERE DatasetId = '$Config/DatasetId$'
	END
	INSERT StandardDatasetStagingArea
	(
	   DatasetId
	  ,StagingTableColumnDefinition
	  ,BatchedProcessingSupportedInd
	  ,MaxRowsToProcessPerTransactionCount
	)
	VALUES
	(
	   '$Config/DatasetId$'
	  ,'
	   DatasetId                      uniqueidentifier  NOT NULL
	  ,ManagementGroupGuid            uniqueidentifier  NOT NULL
	  ,ManagedEntityGuid              uniqueidentifier  NOT NULL
	  ,CollectedDate                  datetime          NOT NULL
	  ,DateKey                        int               NOT NULL
	  ,TimeKey                        int               NOT NULL
	  ,ProcessId                      int               NOT NULL
	  ,CpuUsage                       float             NOT NULL
	  ,MemoryUsage                    float             NOT NULL
	  ,HandleCount                    int               NOT NULL 
	  ,ThreadCount                    int               NOT NULL 
	  ,PageFaultCount                 int               NOT NULL 
	  ,CpuTime                        bigint            NOT NULL 
	  ,TotalProcessTime               bigint            NOT NULL 
	  ,IOReadPerSecond                float             NOT NULL
	  ,IOWritePerSecond               float             NOT NULL 
	  ,ProcessName                    nvarchar(256)     NOT NULL
	  ,Description                    nvarchar(2000)    NULL
	  ,CommandLine                    nvarchar(max)     NULL
	  ,CommandLineHash                varchar(64)       NULL
	  ,UserName                       varchar(256)      NULL  
	  ,ManagedEntityRowId	          int               NULL DEFAULT(0)
	  ,ComputerRowId                  int               NULL DEFAULT(0)
	  ,ProcessRowId                   int               NULL DEFAULT(0)
	  ,ProcessCmdRowId                int               NULL DEFAULT(0)
	  ,UserRowId                      int               NULL DEFAULT(0)
	  ,DWCreatedDateTime              datetime          NULL DEFAULT (GETUTCDATE())
	  ,ProcessStageRowId         bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
	  '
	  ,1
	  ,100000
	)
	COMMIT 
END TRY
BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
	SELECT
		@ErrorNumber = ERROR_NUMBER()
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()
		,@ErrorLine = ERROR_LINE()
		,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
		,@ErrorMessageText = ERROR_MESSAGE()
	SET @ErrorInd = 1
END CATCH
IF (@ErrorInd = 1)
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
									WHEN @ErrorSeverity &gt; 18 THEN 18
									ELSE @ErrorSeverity
								END
  
			SET @DebugMessage =  @DebugPrefix + 'staging table creation was failed. Error: ' + @ErrorMessageText
  
			EXEC DebugMessageInsert 
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText  = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
		,@ErrorNumber
		,@ErrorSeverity
		,@ErrorState
		,@ErrorProcedure
		,@ErrorLine
		,@ErrorMessageText
		)
END
ELSE
BEGIN
   DECLARE 
	@SchemaName sysname
	,@TableName  sysname
	SET @TableName = 'ProcesStaging'
	
	SELECT @SchemaName = SchemaName
	FROM
	dbo.StandardDataSet
	WHERE DatasetId = '$Config/DatasetId$'
  BEGIN TRY	
	IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @TableName AND TABLE_SCHEMA = @SchemaName)
	BEGIN
        
		SELECT @Statement = StagingTableColumnDefinition
		FROM StandardDatasetStagingArea
		WHERE DatasetId = '$Config/DatasetId$'
	    IF @Statement IS NOT NULL
		BEGIN
		  SELECT @Statement = 'CREATE TABLE ' + @SchemaName + '.' + @TableName +  '(' + @Statement + ')'
		  EXECUTE (@Statement)
		END
		ELSE
		BEGIN
			SET @DebugMessage =  @DebugPrefix + 'Staging Data definition does not exist.'
  
			EXEC DebugMessageInsert 
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText  = @DebugMessage
		END
	END
 END TRY
 BEGIN CATCH
  	SELECT
		@ErrorNumber = ERROR_NUMBER()
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()
		,@ErrorLine = ERROR_LINE()
		,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
		,@ErrorMessageText = ERROR_MESSAGE()
	SET @ErrorInd = 1
	SET @DebugMessage =  @DebugPrefix + 'staging table creation was failed. Error: ' + @ErrorMessageText
  
    EXEC DebugMessageInsert 
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
 END CATCH
 IF (0 = @ErrorInd)
 BEGIN
  SET @DebugMessage =  @DebugPrefix + 'staging table created successfully. '
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
 END 
END
GO
GO
-------------------------------------------------------------------------
-- Create aggregation procedure for Process Monitoring Performance DataSet
-------------------------------------------------------------------------
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Performance DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure.'
EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
SELECT 
	@fullSpName = BuildAggregationStoredProcedureName
FROM
dbo.StandardDatasetAggregation
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Aggregation processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' + @fullSpName + 
'
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId int
  ,@InsertTableGuid varchar(256)
  ,@IntervalStartDateTime datetime
  ,@IntervalEndDateTime datetime
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)
	,@ErrorLevel        int
	,@InfoLevel         int
	SET @ErrorLevel   = 3 
	SET @InfoLevel    = 1
    SET @ErrorInd     = 0
	
  
  BEGIN TRY
    DECLARE
       @Statement nvarchar(max)
      ,@DebugLevel tinyint
      ,@InsertTableName sysname
      ,@DebugMessage nvarchar(max)
      ,@AggregationStartDateTime datetime
      ,@CoverViewName sysname
      ,@SchemaName sysname
      ,@DebugMessageSmall nvarchar(max)
	  ,@DATEKEY int
	  ,@TIMEKEY int
	  ,@FullViewName nvarchar(max)
	  ,@FullInsertTableName nvarchar(max)
	  ,@InsertEndDateTimeStr  nvarchar(200)
      ,@InsertStartDateTimeStr  nvarchar(200)
	  ,@DebugPrefix nvarchar(200)
	  SET @DebugPrefix  = ''Process Monitoring Performance DataSet: Aggregation procedure: ''
---------------------------------------------------------------
-- Parameter block sanity check
---------------------------------------------------------------
   IF @DatasetId IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Aggregation dataset id is empty. Exiting procedure without calculation.''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @InsertTableGuid IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Aggregation table postfix is empty. Exiting procedure without calculation.''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @IntervalStartDateTime IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Interval Start Time is empty. Exiting procedure without calculation.''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @IntervalEndDateTime IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Interval End Time is empty. Exiting procedure without calculation.''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @AggregationTypeId IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Aggregation type is empty. Exiting procedure without calculation.''
	  RAISERROR (@DebugMessage, 16, 1)
    END
---------------------------------------------------------------
-- End of Parameter block sanity check
---------------------------------------------------------------
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    SELECT @CoverViewName = ''v'' + BaseTableName
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    SELECT @InsertTableName = BaseTableName + ''_'' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), ''-'', '''')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
	SET @FullViewName =  QUOTENAME(@SchemaName) + ''.'' +  QUOTENAME(@CoverViewName)
	SET @FullInsertTableName = QUOTENAME(@SchemaName) + ''.'' + QUOTENAME(@InsertTableName)
--------------------------------------------------------------------------------------------------
-- Sanity check for table and view 
--------------------------------------------------------------------------------------------------
    IF @InsertTableName IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Aggregation table does not  exist for provided aggegation type '' + CONVERT(nvarchar(50),@AggregationTypeId) + '' .''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @SchemaName IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Schema name is not defined for DataSet Id: '' + CONVERT(nvarchar(50),@DatasetId)  +'' .''
      RAISERROR (@DebugMessage, 16, 1)
	END
    IF @CoverViewName IS NULL
	BEGIN
	  SET @DebugMessage = @DebugPrefix + ''Source view does not exist for  DataSet Id: '' + CONVERT(nvarchar(50),@DatasetId)  +'' .''
      RAISERROR (@DebugMessage, 16, 1)
	END
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = @SchemaName)
	BEGIN
	  	  SET @DebugMessage = @DebugPrefix + ''Schema '' + @SchemaName + '' does not exist in the datawarehouse.''
          RAISERROR (@DebugMessage, 16, 1)
	END
	IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = @CoverViewName AND TABLE_SCHEMA = @SchemaName)
	BEGIN
	  	  SET @DebugMessage = @DebugPrefix + ''Source view '' + @FullViewName + '' does not exist in the datawarehouse.''
          RAISERROR (@DebugMessage, 16, 1)
	END
	IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @InsertTableName AND TABLE_SCHEMA = @SchemaName)
	BEGIN
	  	  SET @DebugMessage = @DebugPrefix + ''Target table '' + @InsertTableName + '' does not exist in the schema '' + @SchemaName + ''.''
          RAISERROR (@DebugMessage, 16, 1)
	END
-------------------------------------------------------------------------------------------------
-- End of Sanity check for table and view 
--------------------------------------------------------------------------------------------------    
    IF (@DebugLevel &gt; 0)
    BEGIN
      SET @DebugMessage = ''Starting aggregation of type '' + CAST(@AggregationTypeId AS varchar(10)) + '' for interval from ''
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + ''UTC to ''
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + ''UTC''
      SET @AggregationStartDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @DebugMessage
    END
    
	SET @DATEKEY = Year(@IntervalStartDateTime) *10000 + Month(@IntervalStartDateTime)*100 + Day(@IntervalStartDateTime)
	SET @TimeKEY = DATEPART(hour,@IntervalStartDateTime) *10000 + DATEPART(minute,@IntervalStartDateTime)*100 + DATEPART(second,@IntervalStartDateTime)
	SET @InsertStartDateTimeStr = '' CONVERT(datetime, '''''' + CONVERT(varchar(50), @IntervalStartDateTime, 120) + '''''', 120)''
	SET @InsertEndDateTimeStr = '' CONVERT(datetime, '''''' + CONVERT(varchar(50), @IntervalEndDateTime, 120) + '''''', 120)''
	SET @Statement =
        ''INSERT '' + @FullInsertTableName + '' (''
		+ ''  DateKey''                           
		+ ''  ,TimeKey''                           
		+ ''  ,ComputerRowId''                     
		+ ''  ,ProcessRowId''                      
		+ ''  ,ProcessCmdRowId''                   
		+ ''  ,UserRowId''                         
		+ ''  ,PID''                               
		+ ''  ,CpuUsageSampleCount''               
		+ ''  ,CpuUsageAverageValue''              
		+ ''  ,CpuUsageMinValue''                  
		+ ''  ,CpuUsageMaxValue''                 
		+ ''  ,CpuUsageStandardDeviation''         
		+ ''  ,MemoryUsageSampleCount''            
		+ ''  ,MemoryUsageAverageValue''           
		+ ''  ,MemoryUsageMinValue''               
		+ ''  ,MemoryUsageMaxValue''               
		+ ''  ,MemoryUsageStandardDeviation''      
		+ ''  ,HandleCountSampleCount''            
		+ ''  ,HandleCountAverageValue''           
		+ ''  ,HandleCountMinValue''               
		+ ''  ,HandleCountMaxValue''               
		+ ''  ,HandleCountStandardDeviation''      
		+ ''  ,ThreadCountSampleCount''            
		+ ''  ,ThreadCountAverageValue''           
		+ ''  ,ThreadCountMinValue''               
		+ ''  ,ThreadCountMaxValue''               
		+ ''  ,ThreadCountStandardDeviation''      
		+ ''  ,PageFaultCountSampleCount''         
		+ ''  ,PageFaultCountAverageValue''        
		+ ''  ,PageFaultCountMinValue''            
		+ ''  ,PageFaultMaxValue''                 
		+ ''  ,PageFaultCountStandardDeviation''   
		+ ''  ,IOReadPerSecondSampleCount''        
		+ ''  ,IOReadPerSecondAverageValue''       
		+ ''  ,IOReadPerSecondMinValue''           
		+ ''  ,IOReadPerSecondMaxValue''           
		+ ''  ,IOReadPerSecondStandardDeviation''  
		+ ''  ,IOWritePerSecondSampleCount''       
		+ ''  ,IOWritePerSecondAverageValue''      
		+ ''  ,IOWritePerSecondMinValue''          
		+ ''  ,IOWritePerSecondMaxValue''          
		+ ''  ,IOWritePerSecondStandardDeviation'' 
		+ ''  ,CpuTimeSampleCount''                
		+ ''  ,CpuTimeAverageValue''               
		+ ''  ,CpuTimeMaxValue''                   
		+ ''  ,CpuTimeMinValue''                   
		+ ''  ,CpuTimeStandardDeviation''          
		+ ''  ,TotalProcessTimeMaxValue''          
		+ ''  ,DateTime'' 
      + '')''
      + '' SELECT''
      + ''    '' + CONVERT(varchar(50), @DATEKEY)
      + ''    ,'' + CONVERT(varchar(50), @TimeKEY)
	  + ''   ,ComputerRowId''
	  + ''   ,ProcessRowId''
	  + ''   ,ProcessCmdRowId''
	  + ''   ,UserRowId''  
	  + ''   ,PID''        
	  + ''   ,COUNT(*)''
      + ''   ,AVG(CpuUsage)''
      + ''   ,MIN(CpuUsage)''
      + ''   ,MAX(CpuUsage)''
	  + ''   ,ISNULL(STDEV(CpuUsage), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(MemoryUsage)''
      + ''   ,MIN(MemoryUsage)''
      + ''   ,MAX(MemoryUsage)''
	  + ''   ,ISNULL(STDEV(MemoryUsage), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(CAST(HandleCount AS float))''
      + ''   ,MIN(HandleCount)''
      + ''   ,MAX(HandleCount)''
	  + ''   ,ISNULL(STDEV(HandleCount), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(CAST(ThreadCount AS float))''
      + ''   ,MIN(ThreadCount)''
      + ''   ,MAX(ThreadCount)''
	  + ''   ,ISNULL(STDEV(ThreadCount), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(CAST(PageFaultCount AS float))''
      + ''   ,MIN(PageFaultCount)''
      + ''   ,MAX(PageFaultCount)''
	  + ''   ,ISNULL(STDEV(PageFaultCount), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(IOReadPerSecond)''
      + ''   ,MIN(IOReadPerSecond)''
      + ''   ,MAX(IOReadPerSecond)''
	  + ''   ,ISNULL(STDEV(IOReadPerSecond), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(IOWritePerSecond)''
      + ''   ,MIN(IOWritePerSecond)''
      + ''   ,MAX(IOWritePerSecond)''
	  + ''   ,ISNULL(STDEV(IOWritePerSecond), 0)''
	  + ''   ,COUNT(*)''
      + ''   ,AVG(CAST(CpuTime AS float))''
      + ''   ,MIN(CpuTime)''
      + ''   ,MAX(CpuTime)''
	  + ''   ,ISNULL(STDEV(CpuTime), 0)''
	  + ''   ,MAX(TotalProcessTime)''
	  + ''   ,'' + @InsertStartDateTimeStr
      + '' FROM '' + @FullViewName
      + '' WHERE ([DateTime] &gt;= '' + @InsertStartDateTimeStr + '') ''
      + ''   AND ([DateTime] &lt; '' + @InsertEndDateTimeStr  + '') ''
       + '' GROUP BY ComputerRowId, ProcessRowId,ProcessCmdRowId,UserRowId,PID''
      
    EXECUTE (@Statement)
    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = ''Finished aggregation of type '' + CAST(@AggregationTypeId AS varchar(10)) + '' for interval from ''
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + ''UTC to ''
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + ''UTC''
      
      DECLARE @OperationDurationMs bigint
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @AggregationStartDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      SET @DebugMessageText = N''Failed to build aggregates for process mmonitoring performance data set. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create Aggregation processing stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Aggregation processing stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel
	,@MessageText = @DebugMessage
 END
END
Endproc:
GO
GO
------------------------------------------------------------------------------------
-- Create Aggregation delete procedure for Process Monitoring Performance DataSet
------------------------------------------------------------------------------------
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Performance DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
SELECT 
	@fullSpName = DeleteAggregationStoredProcedureName
FROM
dbo.StandardDatasetAggregation
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create AggregationDelete processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' + @fullSpName + 
'
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@AggregationDateTime datetime
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)
	,@ErrorLevel        int
    ,@InfoLevel         int
  
	SET @ErrorLevel   = 3 
	SET @InfoLevel    = 1
    SET @ErrorInd = 0  
   
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugMessage nvarchar(max)
    ,@DeleteStartedDateTime datetime
    ,@OperationDurationMs bigint
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + ''_'' + REPLACE(CAST(@TableGuid AS varchar(50)), ''-'', '''')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    -- Index hint in the query below ensures that SQL won''t
    -- consider index on DateTime field to be a good source
    -- to find rows to delete - it may happen periodically
    -- if SQL thinks there''s no rows to delete due to
    -- lack of [recently updated] statistics    
    SET @Statement = ''DELETE t'' + 
				   + '' FROM '' + QUOTENAME(@SchemaName) + ''.'' + QUOTENAME(@TableName) + '' t ''
                   + '' WHERE (t.[DateTime] = CONVERT(datetime, '''''' + CONVERT(varchar(50), @AggregationDateTime, 120) + '''''', 120))''
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = ''Starting delete of existing process monitoring performance aggregated data. Table: '' + @TableName + '', aggregation date: '' + CONVERT(varchar(20), @AggregationDateTime, 120)
      
      SET @DeleteStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @DebugMessage
    END
   
    EXECUTE(@Statement)
    
    SET @RowsDeleted = @@ROWCOUNT
  
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = ''Finished delete of existing process monitoring performance aggregated data. Table: '' + @TableName + '', aggregation date: '' + CONVERT(varchar(20), @AggregationDateTime, 120)
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @DeleteStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      SET @DebugMessageText = N''Failed to delete aggregated data for process monitoring performance data set. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @ErrorMessageText
    END
 '
 
  SET @Statement = @Statement +     
   'DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create AggregationDelete processing stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId     = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText  = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'AggregationDelete processing stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId     = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel
	,@MessageText  = @DebugMessage
 END
END
Endproc:
GO
GO
-------------------------------------------------------------------------
-- Create Grooming procedure for Process Monitoring Performance DataSet
-------------------------------------------------------------------------
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Performance DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
SELECT 
	@fullSpName = GroomStoredProcedureName
FROM
dbo.StandardDatasetAggregation
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' + @fullSpName + 
'
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)
    ,@ErrorLevel        int
    ,@InfoLevel         int
  
	SET @ErrorLevel   = 3 
	SET @InfoLevel    = 1
    SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    -- there are no dependent tables in HealthState data set
    SELECT @TableName = BaseTableName + ''_'' + REPLACE(CAST(@TableGuid AS varchar(50)), ''-'', '''')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = ''DELETE TOP ('' + CAST(@MaxRowsToGroom AS varchar(15)) + '')''
                   + '' FROM '' + QUOTENAME(@SchemaName) + ''.'' + QUOTENAME(@TableName)
                   + '' WHERE ([DateTime] &lt; CONVERT(datetime, '''''' + CONVERT(varchar(50), @CutoffDateTime, 120) + '''''', 120))''
    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      SET @DebugMessageText = N''Failed to groom data for Process Monitoring Performance  data set. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create Grooming stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId = '$Config/DatasetId$'
		,@MessageLevel = 1
		,@MessageText = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Grooming stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId     = '$Config/DatasetId$'
	,@MessageLevel = @ErrorLevel
	,@MessageText  = @DebugMessage
 END
END
Endproc:
GO
   
--------------------------------------------------------------------------
-- Create Staging procedure for Process Monitoring Performance DataSet
--------------------------------------------------------------------------
GO
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Performance DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel 
			,@MessageText = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@fullSpName = StagingProcessorStoredProcedureName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' +@fullSpName + 
'
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)
	,@ErrorLevel        int
	,@InfoLevel         int
  
	SET @ErrorLevel   = 3 
	SET @InfoLevel    = 1
    SET @ErrorInd = 0
 
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
	  ,@StagingTableName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
      ,@RawDataMaxAgeDays int
      ,@MaxStagingRowsToProcess int
	  ,@DebugMessageText nvarchar(max)
	  ,@StageSp nvarchar(max)
	  ,@ExecResultDim int
      ,@LockResourceNameDim sysname
	DECLARE 
		@defaultHash nvarchar(64) = ''E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855'';
 
  BEGIN TRY   
    SELECT
       @DebugLevel = DebugLevel
	  ,@SchemaName = SchemaName
	  ,@StageSp    = StagingProcessorStoredProcedureName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
	----------------------------------
	-- Sanity check for datasetId
	----------------------------------
    IF (@StageSp &lt;&gt; '''
	
	SET @Statement = @Statement + @fullSpName + ''')
	BEGIN
	  Goto EndProc
	END
	------------------------------------
	-- Get dataset staging settings
	----------------------------------
	
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = ISNULL(MaxRowsToProcessPerTransactionCount,10000)
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
 	  IF (@Statement IS NULL)
	  BEGIN
	    Goto Endproc
	  END
    -- get the minimum data retention period
    -- to make sure we do not re-aggregate something
    -- that is too old and all raw data is gone
    
    SELECT @RawDataMaxAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
	--------------------------------------------------------------------------
	-- Delete old records from staging
	--------------------------------------------------------------------------
    DELETE ' + @SchemaName + '.ProcesStaging
    WHERE (DatasetId = @DatasetId)
      AND ([CollectedDate] &lt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()) )
    '
     SET @Statement = @Statement + 
'
-------------------------------------------------------
-- Tables Sanity Check
--------------------------------------------------------
			IF  NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ComputerDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ComputerDim table exiting..''
							Goto SanityCheck
				
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''UserDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find UserDim table exiting..''
							Goto SanityCheck
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ProcessDim table exiting..''
							Goto SanityCheck
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessCmdDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ProcessCMdDim table exiting..''
							Goto SanityCheck
			END
			  EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
				SELECT @InsertTableName = BaseTableName + ''_'' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), ''-'', '''')
				FROM StandardDatasetAggregationStorage
				WHERE (DatasetId = @DatasetId)
				  AND (AggregationTypeId = 0)
				  AND (DependentTableInd = 0)
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @InsertTableName AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find '' + @InsertTableName + '' table exiting..''
							Goto SanityCheck
			END
			Goto Staging
SanityCheck:
				EXEC DebugMessageInsert
					@DatasetId = @DatasetId
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessageText
                Goto DeleteWrongDataSet
				 
'
		
	    SET @Statement = @Statement +
	    '
Staging:
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessStaging2Process'' AND TABLE_SCHEMA = @SchemaName)
    BEGIN
      BEGIN TRAN
        -- need to process subset of rows
        -- create extra column to store original row id
        SELECT @Statement =
              ''CREATE TABLE '' + @SchemaName + ''.ProcessStaging2Process ('' 
            + @Statement
            + '',OriginalProcessStageRowId  bigint  NOT NULL''
            + '')''
  
        EXECUTE (@Statement)
      COMMIT
		'
        SET @Statement = @Statement +
	    '
		IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessStaging2Process'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
        BEGIN
		 Goto Endproc
		END
      BEGIN TRAN
	   INSERT INTO ' + @SchemaName + '.ProcessStaging2Process
		(
		   DatasetId             
		  ,ManagementGroupGuid   
		  ,ManagedEntityGuid     
		  ,CollectedDate     
		  ,DateKey               
		  ,TimeKey               
		  ,ManagedEntityRowId	 
		  ,ComputerRowId         
		  ,ProcessRowId          
		  ,ProcessCmdRowId       
		  ,UserRowId             
		  ,ProcessId             
		  ,CpuUsage              
		  ,MemoryUsage           
		  ,HandleCount           
		  ,ThreadCount           
		  ,PageFaultCount        
		  ,CpuTime               
		  ,TotalProcessTime      
		  ,IOReadPerSecond       
		  ,IOWritePerSecond      
		  ,ProcessName           
		  ,Description           
		  ,CommandLine           
		  ,CommandLineHash       
		  ,UserName              
		  ,DWCreatedDateTime     
		  ,OriginalProcessStageRowId
		)
        SELECT TOP (@MaxStagingRowsToProcess)
			 DatasetId                      
			,ManagementGroupGuid           
			,ManagedEntityGuid             
			,CollectedDate             
			,DateKey                       
			,TimeKey                       
			,ManagedEntityRowId	       
			,ComputerRowId                 
			,ProcessRowId                  
			,ProcessCmdRowId               
			,UserRowId                     
			,ProcessId   
			,CpuUsage              
			,MemoryUsage           
			,HandleCount           
			,ThreadCount           
			,PageFaultCount        
			,CpuTime               
			,TotalProcessTime      
			,IOReadPerSecond       
			,IOWritePerSecond      
			,ProcessName           
			,Description           
			,CommandLine           
			,CommandLineHash       
			,UserName              
			,DWCreatedDateTime
			,ProcessStageRowId
			FROM
			' + @SchemaName + '.ProcesStaging
			WHERE DatasetId = @DatasetId
			ORDER BY CollectedDate
     
      COMMIT
    END -- IF NOT EXISTS ' + @SchemaName + '.ProcessStaging2Process
    
    -- create index on datetime field
    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ''IX_ProcessStaging2Process_DateTime'')
    BEGIN
      CREATE INDEX IX_ProcessStaging2Process_DateTime ON ' + @SchemaName + '.ProcessStaging2Process(CollectedDate)
    END
    BEGIN TRAN
 
 -- lock dimension tables  to ensure we insert into dimensions opened for insertion
					SET @LockResourceNameDim = ''ProcessMonitoringDimensions_TableMap''
  
					EXEC @ExecResultDim = sp_getapplock
						   @Resource = @LockResourceNameDim
						  ,@LockMode = ''Exclusive''
						  ,@LockOwner = ''Transaction''
 
				 IF (@ExecResultDim &lt; 0) 
				 BEGIN
				   RETURN
				 END 
		EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
		SELECT @InsertTableName = BaseTableName + ''_'' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), ''-'', '''')
		FROM StandardDatasetAggregationStorage
		WHERE (DatasetId = @DatasetId)
		  AND (AggregationTypeId = 0)
		  AND (DependentTableInd = 0)
      
	-------------------------------------------------------------
	-- Updating Dimensions
	--------------------------------------------------------------
			--------------------------------------------------------------
			--Update Computer Dimension
			--------------------------------------------------------------
			--- 2.1 Update Staging Table with ManagedEntityRowId from Microsoft Windows Computer
					UPDATE stage
					 SET 
						ManagedEntityRowid     = me.ManagedEntityRowid
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
							  JOIN vManagementGroup mg ON (stage.ManagementGroupGuid = mg.ManagementGroupGuid)
							  JOIN vManagedEntity me ON ((me.ManagedEntityGuid = stage.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
 						      JOIN vManagedEntityType met ON (met.ManagedEntityTypeRowId = me.ManagedEntityTypeRowId)
 					 WHERE (stage.DatasetId = @DatasetId) AND ( met.ManagedEntityTypeGuid = ''EA99500D-8D52-FC52-B5A5-10DCD1E9D2BD'')
			---2.2 Insert new Computers in Computer Dimension 
					INSERT INTO ' + @SchemaName + '.ComputerDim
					(
						ManagementEntityRowId
					   ,Name
					   ,NetbiosName
					   ,PrincipalName
					)
					SELECT DISTINCT
						 me.ManagedEntityRowid
						 ,UPPER(me.Name)
						 , CASE CHARINDEX(''.'',me.Name)
						   WHEN 0  THEN UPPER(me.Name)
						   ELSE
							UPPER(LEFT(me.Name,CHARINDEX(''.'',me.Name) - 1))
						   END
						 ,LOWER(me.Name)
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					JOIN vManagedEntity me ON me.ManagedEntityRowId = stage.ManagedEntityRowId
					WHERE 
					 NOT EXISTS (SELECT *
                      FROM ' + @SchemaName + '.ComputerDim 
                      WHERE (ManagementEntityRowId = me.ManagedEntityRowId)
                     )
					 AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
					 AND
					 me.Name IS NOT NULL
			---2.3 Update Staging with Computer Dimension Key
					UPDATE stage
					 SET 
						ComputerRowId     = pc.ComputerRowid
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					JOIN ' + @SchemaName + '.ComputerDim pc ON (stage.ManagedEntityRowId = pc.ManagementEntityRowId)	    
			--------------------------------------------------------------
			--Update User Dimension
			--------------------------------------------------------------
			---3.1 Insert new Users in User Dimension 
					INSERT INTO ' + @SchemaName + '.UserDim
					(
						LogonName
					   ,Domain
					   ,UserName
					)
					SELECT DISTINCT
						 UPPER(stage.UserName) 
						 ,UPPER(
								  CASE CHARINDEX(''\'',stage.UserName)
								   WHEN 0  THEN ''''
								   ELSE
									LEFT(stage.UserName,CHARINDEX(''\'',stage.UserName) - 1)
								  END
								)
						 ,UPPER(
								  CASE CHARINDEX(''\'',stage.UserName)
								   WHEN 0  THEN stage.UserName
								   ELSE
									RIGHT(stage.UserName,LEN(stage.UserName)- CHARINDEX(''\'',stage.UserName))
								  END
								)
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.UserDim u ON (ISNULL(stage.UserName,'''') = u.LogonName)
					WHERE 
					u.UserRowid IS NULL
					AND
					stage.ManagedEntityRowid  &lt;&gt; 0
			---3.3 Update Staging with new User Dimension Key
					UPDATE stage
					 SET 
						UserRowId     = u.UserRowid
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					JOIN ' + @SchemaName + '.UserDim u ON (ISNULL(stage.UserName,'''') = u.LogonName)
					WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
			--------------------------------------------------------------
			--Update Process Dimension
			--------------------------------------------------------------
			---4.1. Insert new Processes in Process Dimension 
			        ;WITH ProcessByName AS
					(
					  SELECT ProcessName,ISNULL([Description],'''') AS [Description], ROW_NUMBER() OVER(PARTITION BY ProcessName ORDER BY [Description]) as Id
					  FROM 
					  ' + @SchemaName + '.ProcessStaging2Process
					  WHERE
					  ManagedEntityRowid  &lt;&gt; 0
					),
					Processes AS
					(
					  SELECT ProcessName, [Description]
					  FROM ProcessByName
					  WHERE 
					  Id = 1
					)
					INSERT INTO ' + @SchemaName + '.ProcessDim
					(
						 ProcessName
						,[Description]
					)
					SELECT 
						   stage.ProcessName
						  ,stage.[Description] 
					FROM
					Processes stage
					LEFT OUTER JOIN ' + @SchemaName + '.ProcessDim p ON (stage.ProcessName = p.ProcessName)
					WHERE 
					p.ProcessRowId IS NULL
			---4.2. Update Staging with new Process Dimension Key
					UPDATE stage
					 SET 
						ProcessRowId     = p.ProcessRowid
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					JOIN ' + @SchemaName + '.ProcessDim p ON (stage.ProcessName = p.ProcessName)
                    WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
			--------------------------------------------------------------
			--Update Process Command Line Dimension
			--------------------------------------------------------------
			---5.1. Insert new Process Command Lines in ProcessCmd Dimension 
					INSERT INTO ' + @SchemaName + '.ProcessCmdDim
					(
						CommandLine
						,CommandLineHash
					)
					SELECT DISTINCT
						  stage.CommandLine
						 ,ISNULL(stage.CommandLineHash, @defaultHash)
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.ProcessCmdDim p ON (ISNULL(stage.CommandLineHash,@defaultHash)  = p.CommandLineHash)
					WHERE 
					p.ProcessCmdRowId IS NULL
					AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
			---5.2. Update Staging with new Process Command Line Dimension Key
					UPDATE stage
					 SET 
						ProcessCmdRowId     = p.ProcessCmdRowid
					FROM
					' + @SchemaName + '.ProcessStaging2Process stage
					JOIN ' + @SchemaName + '.ProcessCmdDim p ON (ISNULL(stage.CommandLineHash,@defaultHash)  = p.CommandLineHash)
					WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
	    EXEC sp_releaseapplock  @Resource = @LockResourceNameDim 
	  COMMIT
    BEGIN TRAN
	   -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + ''_TableMap''
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = ''Shared''
          ,@LockOwner = ''Transaction''
    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, ''Shared:StandardDatasetTableMap'', @ExecResult)
    END
	-------------------------------------------------------------------------------------------------
	-- Updating Fact Process Performance Table
	--------------------------------------------------------------------------------------------------
				SET @Statement = 
				''INSERT INTO ['' + @SchemaName + ''].[''+ @InsertTableName +'']
				(
						 DateKey                        
						,TimeKey                        
						,ComputerRowId                  
						,ProcessRowId                   
						,ProcessCmdRowId
						,UserRowId                
						,Pid                            
						,CpuUsage              
						,MemoryUsage           
						,HandleCount           
						,ThreadCount           
						,PageFaultCount        
						,CpuTime               
						,TotalProcessTime      
						,IOReadPerSecond       
						,IOWritePerSecond      
						,[DateTime]
				)
				SELECT
						DateKey                        
						,TimeKey                        
						,ComputerRowId                  
						,ProcessRowId                   
						,ProcessCmdRowId
						,UserRowId                  
						,ProcessId                         
						,CpuUsage              
						,MemoryUsage           
						,HandleCount           
						,ThreadCount           
						,PageFaultCount        
						,CpuTime               
						,TotalProcessTime      
						,IOReadPerSecond       
						,IOWritePerSecond          
						,CollectedDate                  
				FROM 
					' + @SchemaName + '.ProcessStaging2Process
				WHERE
				ManagedEntityRowid  &lt;&gt; 0
				''
				IF (@DebugLevel &gt; 0)
				BEGIN
				  SELECT @MessageText = ''Starting to insert '' + CAST(COUNT(*) AS varchar(30)) + '' process performance samples into '' + @InsertTableName
				  FROM ' + @SchemaName + '.ProcessStaging2Process
      
				  SET @InsertStartedDateTime = GETUTCDATE()
      
				  EXEC DebugMessageInsert
					 @DatasetId = @DatasetId
					,@MessageLevel = @InfoLevel
					,@MessageText = @MessageText
				END
			
				EXEC(@Statement)
			 -- mark existing affected aggregations as dirty
				UPDATE ah
				SET DirtyInd = 1
				   ,DataLastReceivedDateTime = GETUTCDATE()
				FROM StandardDatasetAggregationHistory ah
					  JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
					  CROSS JOIN ' + @SchemaName + '.ProcessStaging2Process p
				WHERE (ah.DatasetId = @DatasetId)
				  AND (ah.AggregationDateTime &gt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()))
				  AND (p.[CollectedDate] &gt;= ah.AggregationDateTime)
				  AND (p.[CollectedDate] &lt; DATEADD(minute, a.AggregationIntervalDurationMinutes, ah.AggregationDateTime))
			   -- delete processed rows from staging
               DELETE ps
               FROM ' + @SchemaName + '.ProcesStaging ps
               JOIN ' + @SchemaName + '.ProcessStaging2Process psp ON (ps.ProcessStageRowId  = psp.OriginalProcessStageRowId )
    
				-- delete all inserted data from staging
				DROP TABLE ' + @SchemaName + '.ProcessStaging2Process
				
	    EXEC sp_releaseapplock  @Resource = @LockResourceName 
	COMMIT
    
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Performance DataSet: Finished inserting performance state samples  into '' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      
      SET @DebugMessageText = N''Failed to process data in the Process Monitroing Performance DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
DeleteWrongDataSet:
	--------------------------------------------------------------------------
	-- Delete wrong  datasets from staging
	--------------------------------------------------------------------------
	DECLARE
	  @delBatchSize int
	 ,@ErrorIndDel int
	 
	 SET @ErrorIndDel  = 0
	 SET @delBatchSize = @MaxStagingRowsToProcess
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Performance DataSet: Starting deletion of wrong DataSets records from staging ''
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
    END
   SET @InsertStartedDateTime = GETUTCDATE()
	WHILE(1=1)
	BEGIN
	 BEGIN TRY
	     BEGIN TRAN
			DELETE TOP(@delBatchSize) FROM ' + @SchemaName + '.ProcesStaging
			WHERE (DatasetId != @DatasetId)
			IF (@@rowcount &lt; @delBatchSize)
			BEGIN
				COMMIT
				BREAK;
			END
 	     COMMIT
	 END TRY
     BEGIN CATCH
		IF (@@TRANCOUNT &gt; 0)
		  ROLLBACK TRAN
  
		SELECT 
		   @ErrorNumber = ERROR_NUMBER()
		  ,@ErrorSeverity = ERROR_SEVERITY()
		  ,@ErrorState = ERROR_STATE()
		  ,@ErrorLine = ERROR_LINE()
		  ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
		  ,@ErrorMessageText = ERROR_MESSAGE()
		SET @ErrorIndDel = 1
	 END CATCH
	 IF (@ErrorIndDel = 1)
	 BEGIN
			BREAK;
     END --IF
    END --WHILE
	 IF (@ErrorIndDel = 1)
	 BEGIN
			IF (@DebugLevel &gt; 0)
			BEGIN
      
				SET @DebugMessageText = N''Failed to delete  data from wromg dataset in the Process Monitroing Process Performance DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
								+ '', Procedure '' + @ErrorProcedure
								+ '', Line '' + CAST(@ErrorLine AS varchar(15))
								+ '', Message: ''+ @ErrorMessageText
				EXEC DebugMessageInsert
					@DatasetId = @DatasetId
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessageText
			END
      
			SET @AdjustedErrorSeverity = CASE
											WHEN @ErrorSeverity &gt; 18 THEN 18
											ELSE @ErrorSeverity
											END
    
			RAISERROR (777971002, @AdjustedErrorSeverity, 1
				,@ErrorNumber
				,@ErrorSeverity
				,@ErrorState
				,@ErrorProcedure
				,@ErrorLine
				,@ErrorMessageText
			)
     END
	 ELSE
	 BEGIN
		IF (@DebugLevel &gt; 0)
		BEGIN
		  SET @MessageText = ''Process Monitroing Performance DataSet: Finished deleting wrong dataset records from staging ''
          SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
		  EXEC DebugMessageInsert
			 @DatasetId = @DatasetId
			,@MessageLevel = @InfoLevel
			,@MessageText = @MessageText
            ,@OperationDurationMs = @OperationDurationMs
		END
     END --IF
 Endproc:
END  --Procedure [ProcessMonitoring].[PerformanceProcessStaging]
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create stage processing stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Stage processing stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId     = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel 
	,@MessageText  = @DebugMessage
 END
END
Endproc:
GO
</Install><Uninstall>
GO
DECLARE
 @TableSchemaName sysname
SELECT 
	@TableSchemaName  = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
-- drop SPs
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME =  'PerformanceFactsAggregate')
	BEGIN
		EXECUTE('DROP PROCEDURE ' + @TableSchemaName + '.PerformanceFactsAggregate')
	END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME = 'PerformanceFactsAggregateDelete')
	BEGIN
		EXECUTE ('DROP PROCEDURE ' + @TableSchemaName + '.PerformanceFactsAggregateDelete')
	END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME =  'PerformanceFactsGroom')
	BEGIN
		EXECUTE('DROP PROCEDURE ' + @TableSchemaName + '.PerformanceFactsGroom')
	END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME = 'PerformanceProcessStaging')
	BEGIN
		EXECUTE ('DROP PROCEDURE ' + @TableSchemaName + '.PerformanceProcessStaging')
	END
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'ComputerDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.ComputerDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'UserDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.UserDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'TimeDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.TimeDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'DateDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.DateDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'ProcessDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.ProcessDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'ProcessCmdDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP VIEW ' + @TableSchemaName +'.ProcessCmdDim')
END
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ComputerDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ComputerDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'UserDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.UserDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'TimeDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.TimeDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'DateDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.DateDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ProcessDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ProcessDim')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ProcessCmdDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE ('DROP TABLE ' + @TableSchemaName +'.ProcessCmdDim')
END
-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
</Uninstall><Upgrade /></DataWarehouseDataSet><DataWarehouseDataSet ID="Microsoft.Windows.Server.10.0.NetPortsCollection.Dataset" Accessibility="Internal"><Dependencies><DataWarehouseScript>SCDW!Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>SCDW!Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>SCDW!Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Aggregations" type="AggregationsType" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DefaultAggregationIntervalCount" type="xsd:positiveInteger" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime"
type="TimeOfDayType" /><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger" /></Configuration><Install>
GO
---------------------------------------------------------------
-- Initialize Process Port State Dataset
---------------------------------------------------------------
SET NOCOUNT ON
DECLARE 
        @SchemaName sysname
	   ,@ProcessStagingSp sysname
	   ,@ErrorInd   bit
	   ,@DebugLevel tinyint
	   ,@DebugPrefix  nvarchar(max)
       ,@DebugMessage  nvarchar(max)
	   ,@ErrorLevel      int
	   ,@InfoLevel       int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugLevel   = 0
SET @SchemaName  = 'ProcessMonitoring'
SET @ProcessStagingSp = 'PortStateProcessStaging'
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + ' Insert new definition.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
BEGIN TRY
	INSERT StandardDataset (
	   DatasetId 
	  ,SchemaName
	  ,DebugLevel
	  ,DefaultAggregationIntervalCount
	  ,RawInsertTableCount
	  ,StagingProcessorStoredProcedureName
	  ,BlockingMaintenanceDailyStartTime
	  ,BlockingMaintenanceDurationMinutes
	)
	VALUES
	(
	   '$Config/DatasetId$'
	  ,@SchemaName
	  ,@DebugLevel
	  ,$Config/DefaultAggregationIntervalCount$
	  ,$Config/RawInsertTableCount$
	  ,@SchemaName + '.' + @ProcessStagingSp
	  ,'$Config/BlockingMaintenanceDailyStartTime$'
	  ,$Config/BlockingMaintenanceDurationMinutes$
	)
	END TRY
	BEGIN CATCH
	 SET @ErrorInd = 1
	END CATCH
	IF (1 = @ErrorInd)
	BEGIN
	    SET @DebugMessage =  @DebugPrefix + 'Insert new definition failed.'
		EXEC DebugMessageInsert
				@DatasetId = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessage
	END
	ELSE
	BEGIN
	    SET @DebugMessage =  @DebugPrefix + ' Insert new definition finished successfully.'
		EXEC DebugMessageInsert
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @InfoLevel
				,@MessageText  = @DebugMessage
	END 
GO
GO
---------------------------------------------------------------------------------------
-- Create the StandardDatasetAggregation for Process Monitoring PortState Fact Tables
----------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugPrefix  nvarchar(max)
  ,@DebugMessage  nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
SET @ErrorInd     = 0
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DebugPrefix  = 'Process Monitoring PortState DataSet: '
SET @DebugMessage = @DebugPrefix  + 'Starting aggregation setting deployment.'
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText varchar(max)
  ,@BuildAggregationStoredProcedureName  sysname
  ,@DeleteAggregationStoredProcedureName sysname
  ,@GroomStoredProcedureName             sysname
  ,@SchemaName                           sysname
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
  
BEGIN TRY
  SELECT @SchemaName = SchemaName
  FROM
  dbo.StandardDataSet
  WHERE DatasetId = '$Config/DatasetId$'
  IF @SchemaName IS NULL
  BEGIN
    
   SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was failed. Process Monitoring Health State Dataset does not exist.'
  
   EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   RAISERROR( @DebugMessage, 16,1)
  END
  
  SET @BuildAggregationStoredProcedureName  = NULL
  SET @DeleteAggregationStoredProcedureName = NULL
  SET @GroomStoredProcedureName             = @SchemaName + '.' + 'PortStateFactsGroom'
 
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'Process Monitoring: Health State Aggregation', @ExecResult)
  IF NOT EXISTS (SELECT 1 FROM dbo.StandardDatasetAggregation WHERE  DatasetId = '$Config/DatasetId$' )
  BEGIN
	  INSERT StandardDatasetAggregation
	  (                               
		 DatasetId
		,AggregationTypeId
		,AggregationIntervalDurationMinutes
		,AggregationStartDelayMinutes
		,BuildAggregationStoredProcedureName
		,DeleteAggregationStoredProcedureName
		,GroomStoredProcedureName
		,IndexOptimizationIntervalMinutes
		,MaxDataAgeDays
		,GroomingIntervalMinutes
		,MaxRowsToGroom
		,LastGroomingDateTime
		,DataFileGroupName
		,IndexFileGroupName
	  )
	  SELECT
		 '$Config/DatasetId$'
		,CASE AggregationType
		   WHEN 'Raw' THEN 0
		   WHEN 'Subhourly' THEN 10
		   WHEN 'Hourly' THEN 20
		   WHEN 'Daily' THEN 30
		 END
		,CASE AggregationType
		   WHEN 'Raw' THEN NULL
		   WHEN 'Subhourly' THEN AggregationIntervalDurationMinutes
		   WHEN 'Hourly' THEN 60
		   WHEN 'Daily' THEN 24*60
		 END
		,AggregationStartDelayMinutes
		,@BuildAggregationStoredProcedureName
		,CASE AggregationType
		   WHEN 'Raw' THEN NULL
		   ELSE @DeleteAggregationStoredProcedureName
		 END
		,@GroomStoredProcedureName
		,IndexOptimizationIntervalMinutes
		,MaxDataAgeDays
		,GroomingIntervalMinutes
		,MaxRowsToGroom
		,GETUTCDATE()
		,DataFileGroupName
		,IndexFileGroupName
	  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
		   AggregationType                    varchar(50)   '@mp:localname'
		  ,MaxTableRowCount                   int
		  ,MaxTableSizeKb                     int
		  ,AggregationStartDelayMinutes       int
		  ,MaxDataAgeDays                     int
		  ,GroomingIntervalMinutes            int
		  ,MaxRowsToGroom                     int
		  ,IndexOptimizationIntervalMinutes   int
		  ,DataFileGroupName                  nvarchar(256)
		  ,IndexFileGroupName                 nvarchar(256)
		  ,AggregationIntervalDurationMinutes int
	  )
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
 SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was failed. Error: ' + @ErrorMessageText
  
 EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix  + 'Aggregation setting deployment was finished successfully.'
  
 EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
END
GO
 
------------------------------------------------------------------------------------------------------------
-- Create the StandardDataset Aggregation Tables definitions for Process Monitoring PortState Fact Tables
------------------------------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage    nvarchar(max)
  ,@DebugPrefix     nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting dataset table definitions deployment.'
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  ,@TableCompressionClause nvarchar(max) 
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
  
BEGIN TRY
  SET @TableCompressionClause = ''
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  -----------------------------------------------------------------------
  -- ENBALE PAGE COMPRESSION ON FACT Tables IF AVILABLE
  -----------------------------------------------------------------------
	IF ( 3 = SERVERPROPERTY('EngineEdition') 
		 OR
		 ('SP1' = SERVERPROPERTY('ProductLevel') AND CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(50)) like '13.0%')
	   )
	BEGIN
	  SET @TableCompressionClause = ' WITH (DATA_COMPRESSION = PAGE)'
	END
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 
  BEGIN
	  SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was failed. Cannot parse dataset definition. Xml definition: ' + @XmlDocText
  
	  EXEC DebugMessageInsert
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel 
				,@MessageText  = @DebugMessage
     RAISERROR(777971000, 16, 1, @DebugMessage, @ExecResult)
  END
  INSERT StandardDatasetAggregationStorage
  (                               
     DatasetId
    ,AggregationTypeId
    ,BaseTableName
    ,DependentTableInd
    ,TableTemplate
    ,CoverViewSelectClause
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  )
  SELECT
     '$Config/DatasetId$'
    ,CASE AggregationType
       WHEN 'Raw' THEN 0
     END
    ,BaseTableName
    ,0
    ,CASE AggregationType
       WHEN 'Raw' THEN '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(BaseTableName + 'RowId') + ' bigint  NOT NULL  IDENTITY(1, 1)
                    ,DateKey                        int  NOT NULL
                    ,TimeKey                        int  NOT NULL
                    ,ComputerRowId                  int  NOT NULL
                    ,ProcessRowId                   int  NOT NULL
                    ,ProcessCmdRowId                int  NOT NULL
					,UserRowId                      int  NOT NULL
                    ,PID                            int  NOT NULL
		            ,LocalAddressRowId              bigint   NOT NULL
					,RemoteAddressRowId             bigint   NOT NULL
                    ,PortType                       tinyint   NOT NULL
                    ,LocalPort                      int   NOT NULL
					,RemotePort                     int   NOT NULL
					,OldPortState                   tinyint   NOT NULL
					,PortState                      tinyint   NOT NULL
                    ,TimeInOldState                 int   NOT NULL
					,IPV6                           bit   NOT NULL
                    ,[DateTime]                  datetime  NOT NULL
                    ,CONSTRAINT ' + QUOTENAME('PK_' + BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       ' + @TableCompressionClause
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN '
          SELECT
               DateKey
			  ,TimeKey
	          ,ComputerRowId         
             ,ProcessRowID          
             ,ProcessCmdRowID  
             ,PID 
			 ,UserRowId  
			 ,LocalAddressRowId
			 ,RemoteAddressRowId
			 ,PortType
			 ,LocalPort
			 ,RemotePort                  
             ,OldPortState        
             ,PortState     
             ,TimeInOldState      
			 ,[DateTime]
			 ,IPV6
       '
     END
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
       AggregationType      varchar(50)   '@mp:localname'
      ,BaseTableName        varchar(256)
      ,MaxTableRowCount     int
      ,MaxTableSizeKb       int
      ,DataFileGroupName    varchar(256)
      ,IndexFileGroupName    varchar(256)
  )
      CROSS JOIN StandardDataset d
  WHERE (d.DatasetId = '$Config/DatasetId$' AND AggregationType = 'Raw')
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
   
  SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was failed. Error: ' + @ErrorMessageText
  
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel 
			,@MessageText  = @DebugMessage
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix + 'Dataset table definitions deployment was finished successfully.'
 EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
END
GO
  ------------------------------------------------------------------------------------------------------------
-- Create Indexes for the StandardDataset Aggregation Tables  for Process MonitoringPortState Fact Tables
------------------------------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@IndeGuid uniqueidentifier
  ,@ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage      nvarchar(max)
  ,@DebugPrefix       nvarchar(max)
  ,@ErrorLevel        int
  ,@InfoLevel         int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting dataset indexes deployment.'
SET @AggregationTypeId = -1
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
BEGIN TRY
		WHILE EXISTS (SELECT *
					  FROM StandardDatasetAggregation
					  WHERE (DatasetId = '$Config/DatasetId$')
						AND (AggregationTypeId &gt; @AggregationTypeId)
					 )
		BEGIN
		  SELECT @IndeGuid = NEWID()
  
		  SELECT TOP 1 
			 @AggregationTypeId = AggregationTypeId
			,@Statement = 
			  ' EXEC StandardDatasetIndexDelete'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			  + '   ,@DeleteIndexOnExistingTablesInd = 0'
			+ ' EXEC StandardDatasetIndexInsert'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
			+ '   ,@DependentTableInd = 0'
			+ '   ,@TableTag = NULL'
			+ '   ,@UniqueInd = 0'
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			+ '   ,@IndexDefinition = ''([DateTime])'''
			+ '   ,@CreateIndexOnExistingTablesInd = 0'
		  FROM StandardDatasetAggregation
		  WHERE (DatasetId = '$Config/DatasetId$')
			AND (AggregationTypeId &gt; @AggregationTypeId)
		  ORDER BY AggregationTypeId
  
		  EXECUTE (@Statement)
		END
		/* raw indexes for UI widget p*/
		-- Hourly data index to support Top N reports and dashboards
		EXEC StandardDatasetIndexDelete
		   @DatasetId = '$Config/DatasetId$'
		  ,@IndexGuid = '6D30F2F6-82A9-4B38-AFBE-3A1F7A17BA9E'
			,@DeleteIndexOnExistingTablesInd = 0
		EXEC StandardDatasetIndexInsert
			@DatasetId = '$Config/DatasetId$'
		  ,@AggregationTypeId = 0
		  ,@DependentTableInd = 0
		  ,@TableTag = NULL
		  ,@UniqueInd = 0
		  ,@IndexGuid = '6D30F2F6-82A9-4B38-AFBE-3A1F7A17BA9E'
		  ,@IndexDefinition = '(
				 ComputerRowId     
				,ProcessRowId      
				,ProcessCmdRowId   
				,UserRowId         
				,PID               
				,LocalAddressRowId 
				,RemoteAddressRowId               
				,DateTime
			  )
			  INCLUDE
			  (
				 PortType      
				,LocalPort     
				,RemotePort    
				,OldPortState  
				,PortState     
				,TimeInOldState
				,IPV6          
			  )
		  '
		,@CreateIndexOnExistingTablesInd = 0
		-- Index for dashboard
		EXEC StandardDatasetIndexDelete
		   @DatasetId = '$Config/DatasetId$'
		  ,@IndexGuid = 'F747FA4B-577A-4952-B77A-751212594317'
			,@DeleteIndexOnExistingTablesInd = 1
		EXEC StandardDatasetIndexInsert
			@DatasetId = '$Config/DatasetId$'
		  ,@AggregationTypeId = 0
		  ,@DependentTableInd = 0
		  ,@TableTag = NULL
		  ,@UniqueInd = 0
		  ,@IndexGuid = 'F747FA4B-577A-4952-B77A-751212594317'
		  ,@IndexDefinition = '([ComputerRowId] ASC,
	[DateTime])'
		,@CreateIndexOnExistingTablesInd = 1
END TRY
BEGIN CATCH
  SET @ErrorInd = 1
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
END CATCH
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was failed. Error: ' + @ErrorMessageText
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage 
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was finished successfully.'
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
END
GO
------------------------------------------------------------------
--- Create SCHEMA for new Process Monitoring Port State DataSet
-------------------------------------------------------------------
GO
DECLARE 
@SchemaName sysname
SELECT @SchemaName = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = @SchemaName)
BEGIN
  EXECUTE('CREATE SCHEMA ' + @SchemaName)
END
 DECLARE @Statement  nvarchar(max)
 -- change schema ownership to allow index rebuild and reorganize
 SET  @Statement = 'ALTER AUTHORIZATION ON SCHEMA::' + @SchemaName + ' TO OpsMgrWriter'
 EXECUTE(@Statement)
 SET  @Statement = 'GRANT ALTER ON SCHEMA::' + @SchemaName + ' TO OpsMgrWriter'
 EXECUTE(@Statement)
 
 -- grant create table permissions
 GRANT CREATE TABLE TO OpsMgrWriter
GO
-----------------------------------------------------------------------
--- Start standard Process Monitoring Port State dataset  deployment
-----------------------------------------------------------------------
SET NOCOUNT ON
DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage    nvarchar(max)
  ,@DebugPrefix     nvarchar(max)
  ,@ErrorLevel      int
  ,@InfoLevel       int
  
SET @ErrorInd     = 0
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
 
SET @DebugPrefix  =  'Process Monitoring Performance DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting storage deployment.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText = @DebugMessage
			  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'
  SET @DebugMessage = @DebugPrefix + 'Cannot parse configuration. Text: ' + @XmlDocText
  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0
  BEGIN
          EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText = @DebugMessage
 
   RAISERROR(777971000, 16, 1,@DebugMessage , @ExecResult)
  END
  DECLARE
     @AggregationType varchar(50)
    ,@Statement nvarchar(max)
     
  SET @AggregationType = ''
  WHILE EXISTS (SELECT *
                FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
                      AggregationType      varchar(50)   '@mp:localname')
                WHERE AggregationType &gt; @AggregationType
               )
  BEGIN
    SELECT TOP 1 @AggregationType = AggregationType
    FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
          AggregationType      varchar(50)   '@mp:localname')
    WHERE AggregationType &gt; @AggregationType
    ORDER BY AggregationType
    
    SET @Statement = 'EXEC StandardDatasetAllocateStorage @DatasetId = ''$Config/DatasetId$'', @AggregationTypeId='
                    + CASE @AggregationType
                        WHEN 'Raw' THEN '0'
                        WHEN 'Subhourly' THEN '10'
                        WHEN 'Hourly' THEN '20'
                        WHEN 'Daily' THEN '30'
                      END
    EXECUTE (@Statement)
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
END CATCH
IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  SET @DebugMessage = @DebugPrefix + 'Storage deployment was failed. Error: ' + @ErrorMessageText
  
  EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText = @DebugMessage
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage = @DebugPrefix + 'Storage deployment was finished successfully.' 
 
 EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText = @DebugMessage
END
GO
--------------------------------------------------------------------------------------
--- Start standard Process Monitoring Port State dataset staging tables  deployment
--------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
DECLARE 
   @ErrorInd         bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber      int
  ,@ErrorSeverity    int
  ,@ErrorState       int
  ,@ErrorLine        int
  ,@ErrorProcedure   nvarchar(256)
  ,@Statement        nvarchar(max)
  ,@DebugMessage     nvarchar(max)
  ,@DebugLevel       tinyint
  ,@DebugPrefix      nvarchar(max)
  ,@ErrorLevel       int
  ,@InfoLevel        int
  
  SET @ErrorInd     = 0
  SET @ErrorLevel   = 3 
  SET @InfoLevel    = 1
  SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
  SET @DebugMessage =  @DebugPrefix + ' Create staging table.'
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
-- insert staging definition into StandardDatasetStagingArea
BEGIN TRY
	-- sometimes SCOM starts this twice...
	BEGIN TRAN
	IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
	BEGIN
	  DELETE StandardDatasetStagingArea
	  WHERE DatasetId = '$Config/DatasetId$'
	END
	INSERT StandardDatasetStagingArea
	(
	   DatasetId
	  ,StagingTableColumnDefinition
	  ,BatchedProcessingSupportedInd
	  ,MaxRowsToProcessPerTransactionCount
	)
	VALUES
	(
	   '$Config/DatasetId$'
	  ,'
	   DatasetId                      uniqueidentifier  NOT NULL
	  ,ManagementGroupGuid            uniqueidentifier  NOT NULL
	  ,ManagedEntityGuid              uniqueidentifier  NOT NULL
	  ,CollectedDate                  datetime          NOT NULL
	  ,DateKey                        int               NOT NULL
	  ,TimeKey                        int               NOT NULL
	  ,ProcessId                      int               NOT NULL
	  ,LocalAddress                   varchar(256)      NULL
	  ,RemoteAddress                  varchar(256)      NULL
	  ,LocalPort                      int               NULL
	  ,RemotePort                     int               NULL
	  ,OldPortState                   tinyint           NOT NULL
	  ,PortState                      tinyint           NOT NULL
          ,TimeInOldState                 int               NOT NULL
	  ,PortType                       tinyint           NOT NULL
	  ,IPV6                           bit               NOT NULL
	  ,ProcessName                    nvarchar(256)     NOT NULL
	  ,Description                    nvarchar(2000)    NULL
	  ,CommandLine                    nvarchar(max)     NULL
	  ,CommandLineHash                varchar(64)       NULL
	  ,UserName                       varchar(256)      NULL   
	  ,ManagedEntityRowId	          int               NULL DEFAULT(0)
	  ,ComputerRowId                  int               NULL DEFAULT(0)
	  ,ProcessRowId                   int               NULL DEFAULT(0)
	  ,ProcessCmdRowId                int               NULL DEFAULT(0)
	  ,UserRowId                      int               NULL DEFAULT(0)
	  ,LocalAddressRowId              bigint            NULL 
	  ,RemoteAddressRowId             bigint            NULL
	  ,DWCreatedDateTime              datetime          NULL DEFAULT (GETUTCDATE())
	  ,PortStageRowId                 bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
	  '
	  ,1
	  ,100000
	)
	COMMIT
END TRY
BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
	SELECT
		@ErrorNumber = ERROR_NUMBER()
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()
		,@ErrorLine = ERROR_LINE()
		,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
		,@ErrorMessageText = ERROR_MESSAGE()
	SET @ErrorInd = 1
END CATCH
IF (@ErrorInd = 1)
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
									WHEN @ErrorSeverity &gt; 18 THEN 18
									ELSE @ErrorSeverity
								END
 
			SET @DebugMessage =  @DebugPrefix + 'staging table creation was failed. Error: ' + @ErrorMessageText
  
			EXEC DebugMessageInsert 
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText  = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
		,@ErrorNumber
		,@ErrorSeverity
		,@ErrorState
		,@ErrorProcedure
		,@ErrorLine
		,@ErrorMessageText
		)
END
ELSE
BEGIN
    DECLARE 
	@SchemaName sysname
	,@TableName  sysname
	SET @TableName = 'PortStaging'
	SELECT @SchemaName = SchemaName
	FROM
	dbo.StandardDataSet
	WHERE DatasetId = '$Config/DatasetId$'
 BEGIN TRY	
	IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @TableName AND TABLE_SCHEMA = @SchemaName)
	BEGIN
        
		SELECT @Statement = StagingTableColumnDefinition
		FROM StandardDatasetStagingArea
		WHERE DatasetId = '$Config/DatasetId$'
	    IF @Statement IS NOT NULL
		BEGIN
		  SELECT @Statement = 'CREATE TABLE ' + @SchemaName + '.' + @TableName +  '(' + @Statement + ')'
		  EXECUTE (@Statement)
		END
		ELSE
		BEGIN
			SET @DebugMessage =  @DebugPrefix + 'Staging Data definition does not exist.'
  
			EXEC DebugMessageInsert 
				@DatasetId     = '$Config/DatasetId$'
				,@MessageLevel = @ErrorLevel
				,@MessageText  = @DebugMessage
		END
	END
 END TRY
 BEGIN CATCH
  	SELECT
		@ErrorNumber = ERROR_NUMBER()
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()
		,@ErrorLine = ERROR_LINE()
		,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
		,@ErrorMessageText = ERROR_MESSAGE()
	SET @ErrorInd = 1
	SET @DebugMessage =  @DebugPrefix + 'staging table creation was failed. Error: ' + @ErrorMessageText
  
    EXEC DebugMessageInsert 
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
 END CATCH
 IF (0 = @ErrorInd)
 BEGIN
  SET @DebugMessage =  @DebugPrefix + 'staging table created successfully. '
  EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
 END 
END
GO
GO
DECLARE 
@SchemaName sysname
,@TableName sysname
,@Statement nvarchar(max)
SET @TableName = 'IpAddressDim'
SELECT @SchemaName = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
IF @SchemaName IS NULL 
BEGIN
  RAISERROR('Process Monitoring Port State Dataset SCHEMA  is not defined. Cannot create dimension tables.', 16,1)
  GOTO Endproc
END
IF  NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @TableName AND TABLE_SCHEMA = @SchemaName)
BEGIN
  SET @Statement =
	'CREATE TABLE ' + @SchemaName + '.' + @TableName + 
	'(                               
			IpAddressRowId                bigint           NOT NULL IDENTITY(1,1)
			,IpAddress                    varchar(256) NOT NULL
			,DWCreatedDateTime            datetime NOT NULL    DEFAULT (GETUTCDATE())
 
			,CONSTRAINT PK_' + @TableName +'IpAddressDim PRIMARY KEY CLUSTERED (IpAddressRowId)
	)'
	EXECUTE(@Statement)
	SET @Statement =
	'CREATE INDEX  IX_' + @TableName + '_LastReceivedDateTime ON ' + @SchemaName + '.' + @TableName + ' (DWCreatedDateTime)'
    EXECUTE(@Statement)
    SET @Statement =
	'CREATE INDEX  IX_' + @TableName + '_IpAddress ON ' + @SchemaName + '.' + @TableName + ' (IpAddress)'
    EXECUTE(@Statement)
	
	SET @Statement =
	'INSERT INTO ' + @SchemaName + '.' + @TableName + 
     '(IpAddress)
	 SELECT N''''
	 '
	EXECUTE(@Statement)
	EXEC DomainTableRegisterIndexOptimization
		   @TableName = @TableName
		  ,@SchemaName = @SchemaName
		  ,@DatasetId = '$Config/DatasetId$'
END
Endproc:
GO
GO
DECLARE 
@SchemaName sysname
,@TableName sysname
,@ViewName  sysname
,@Statement nvarchar(max)
SET @TableName = 'IpAddressDim'
SET @ViewName  = 'v' + @TableName
SELECT @SchemaName = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
IF @SchemaName IS NULL 
BEGIN
  RAISERROR('Process Monitoring Port State Dataset SCHEMA  is not defined. Cannot create dimension views.', 16,1)
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = @ViewName AND TABLE_SCHEMA = @SchemaName)
BEGIN
  EXECUTE ('CREATE VIEW ' + @SchemaName + '.' + @ViewName + ' AS SELECT A = 1')
END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @TableName AND TABLE_SCHEMA = @SchemaName)
BEGIN
	SET @Statement = ' ALTER VIEW '  + @SchemaName + '.' + @ViewName + 
	'
	AS
	  SELECT 
		  IpAddressRowId          
		  ,IpAddress         
		  ,DWCreatedDateTime 
  	  FROM ' + @SchemaName + '.' + @TableName + ' (NOLOCK)'
	EXECUTE(@Statement)
	EXECUTE('GRANT SELECT ON ' + @SchemaName + '.' + @ViewName + '  TO OpsMgrReader')
END
Endproc:
GO
GO
-------------------------------------------------------------------------
-- Create Grooming procedure for Process Monitoring Port State DataSet
-------------------------------------------------------------------------
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Port State DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure.'
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
SELECT 
	@fullSpName = GroomStoredProcedureName
FROM
dbo.StandardDatasetAggregation
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create Grooming stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' + @fullSpName + 
'
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)
	,@ErrorLevel      int
  SET @ErrorInd   = 0
  SET @ErrorLevel = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    -- there are no dependent tables in PortState data set
    SELECT @TableName = BaseTableName + ''_'' + REPLACE(CAST(@TableGuid AS varchar(50)), ''-'', '''')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = ''DELETE TOP ('' + CAST(@MaxRowsToGroom AS varchar(15)) + '')''
                   + '' FROM '' + QUOTENAME(@SchemaName) + ''.'' + QUOTENAME(@TableName)
                   + '' WHERE ([DateTime] &lt; CONVERT(datetime, '''''' + CONVERT(varchar(50), @CutoffDateTime, 120) + '''''', 120))''
    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      SET @DebugMessageText = N''Failed to groom data for Process Monitoring Port State  data set. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create Grooming stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId     = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText  = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Grooming stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId     = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel
	,@MessageText  = @DebugMessage
 END
END
Endproc:
GO
 
--------------------------------------------------------------------------
-- Create Staging procedure for Process Monitoring Port State DataSet
--------------------------------------------------------------------------
GO
DECLARE
 @SchemaName        sysname
,@TableSchemaName   sysname
,@defaultSchemaName sysname
,@spName            sysname
,@fullSpName        sysname
,@Statement         nvarchar(max)
,@DataSetMessage    nvarchar(max)
,@DebugPrefix       nvarchar(max)
,@DebugMessage      nvarchar(max)
,@index             int
,@spLength          int
,@DebugLevel        tinyint
,@ErrorLevel        int
,@InfoLevel         int
  
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @DataSetMessage = 'Process Monitoring: Process Port State DataSet'
SET @defaultSchemaName = 'dbo'
SET @index = 0
SET @spLength = 0
----------------------------------------------------------------------------------
--- 0 - Logging disabled
--- 1 - Informational
--- 2 - Warning
--- 3 - Error
-----------------------------------------------------------------------------------
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure.'
EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel =  @InfoLevel
			,@MessageText  = @DebugMessage
SELECT 
	 @TableSchemaName  = SchemaName
	,@fullSpName = StagingProcessorStoredProcedureName
	,@DebugLevel = DebugLevel
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
------------------------------------------------------------------------------------------------
-- Check if ETL procedure is defined in dataset
------------------------------------------------------------------------------------------------
IF @TableSchemaName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF @fullSpName IS NULL
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
ELSE
BEGIN
     SET @index    =  CHARINDEX('.',@fullSpName)  
     SET @spLength = LEN(@fullSpName)
	 --------------------------------------------------------------
	 -- if procedure does not have schema name use dbo by default 
	 --------------------------------------------------------------
     IF (0 = @index)
	 BEGIN
	   SET @SchemaName = @defaultSchemaName
	   SET @spName     = @fullSpName
	   SET @fullSpName = @SchemaName + '.' + @fullSpName
	 END
	 ELSE
	 BEGIN
	     IF (1 = @index)
		 BEGIN
		   SET @SchemaName = @defaultSchemaName
		 END
		 ELSE
		 BEGIN
		   SET @SchemaName = LEFT(@fullSpName,@index - 1)
		 END
		 SET @spname     = LTRIM(RTRIM(RIGHT(@fullSpName,@spLength - @index)))
	     	 
		 IF (0 = LEN(@spname) )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not defined', 16, 1, @DataSetMessage )
			  IF @DebugLevel &gt; 0 
			  BEGIN
				SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not defined.'
   
				EXEC DebugMessageInsert
						@DatasetId     = '$Config/DatasetId$'
						,@MessageLevel = @ErrorLevel
						,@MessageText  = @DebugMessage
   
			  END
   	       GOTO Endproc
		 END
		 IF (CHARINDEX('.',@spName) &gt; 0 )
		 BEGIN
		   RAISERROR ('Cannot create ETL stored procedure for %s. Stored procedure name is not correct [%s]', 16, 1, @DataSetMessage,@fullSpName)
			IF @DebugLevel &gt; 0 
			BEGIN
			  SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Stored procedure name is not correct.'
   
			  EXEC DebugMessageInsert
					@DatasetId     = '$Config/DatasetId$'
					,@MessageLevel = @ErrorLevel
					,@MessageText  = @DebugMessage
   
			END
   	       GOTO Endproc
		 END
		 SET @fullSpName = @SchemaName + '.' + @spName
	 END
END
IF NOT EXISTS (SELECT 1 FROM sys.schemas WHERE NAME = @SchemaName)
BEGIN
  RAISERROR ('Cannot create ETL stored procedure for %s. Dataset schema %s is not exist.', 16, 1, @DataSetMessage,@SchemaName )
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Trying to create stage processing stored procedure. Cannot create ETL stored procedure. Dataset schema is not exist.'
   
    EXEC DebugMessageInsert
			@DatasetId     = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage
   
  END
  GOTO Endproc
END
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @SchemaName AND ROUTINE_NAME = @spName)
BEGIN
		EXECUTE ('CREATE PROCEDURE ' + @fullSpName +  ' AS RETURN 1')
END
SET @Statement = 'ALTER PROCEDURE ' +@fullSpName + 
'
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)
    ,@ErrorLevel        int
    ,@InfoLevel         int
  
    SET @ErrorLevel   = 3 
    SET @InfoLevel    = 1
    SET @ErrorInd = 0
 
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
	  ,@StagingTableName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
      ,@RawDataMaxAgeDays int
      ,@MaxStagingRowsToProcess int
      ,@DebugMessageText nvarchar(max)
	  ,@StageSp nvarchar(max)
	  ,@ExecResultDim int
      ,@LockResourceNameDim sysname
	DECLARE 
		@defaultHash nvarchar(64) = ''E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855'';
 
  BEGIN TRY   
     SELECT
       @DebugLevel = DebugLevel
	  ,@SchemaName = SchemaName
	  ,@StageSp    = StagingProcessorStoredProcedureName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
	----------------------------------
	-- Sanity check for datasetId
	----------------------------------
	IF (@StageSp &lt;&gt; '''
	
	SET @Statement = @Statement + @fullSpName + ''')
	BEGIN
	  Goto EndProc
	END
	------------------------------------
	-- Get dataset staging settings
	----------------------------------
	
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = ISNULL(MaxRowsToProcessPerTransactionCount,10000)
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
 	  IF (@Statement IS NULL)
	  BEGIN
	    Goto Endproc
	  END
    -- get the minimum data retention period
    -- to make sure we do not re-aggregate something
    -- that is too old and all raw data is gone
    
    SELECT @RawDataMaxAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
	--------------------------------------------------------------------------
	-- Delete old records from staging
	--------------------------------------------------------------------------
    DELETE ' + @SchemaName + '.ProcesStaging
    WHERE (DatasetId = @DatasetId)
      AND ([CollectedDate] &lt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()) )
    '
     SET @Statement = @Statement + 
'
-------------------------------------------------------
-- Tables Sanity Check
--------------------------------------------------------
			IF  NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ComputerDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ComputerDim table exiting..''
							Goto SanityCheck
				
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''UserDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find UserDim table exiting..''
							Goto SanityCheck
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ProcessDim table exiting..''
							Goto SanityCheck
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''ProcessCmdDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find ProcessCMdDim table exiting..''
							Goto SanityCheck
			END
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''IpAddressDim'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find IpAddressDim table exiting..''
							Goto SanityCheck
			END
			  EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
				SELECT @InsertTableName = BaseTableName + ''_'' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), ''-'', '''')
				FROM StandardDatasetAggregationStorage
				WHERE (DatasetId = @DatasetId)
				  AND (AggregationTypeId = 0)
				  AND (DependentTableInd = 0)
			IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @InsertTableName AND TABLE_SCHEMA = ''' + @SchemaName + ''')
			BEGIN
							SET @DebugMessageText = N''Cannot find '' + @InsertTableName + '' table exiting..''
							Goto SanityCheck
			END
			Goto Staging
SanityCheck:
				EXEC DebugMessageInsert
					@DatasetId = @DatasetId
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessageText
                Goto DeleteWrongDataSet
				 
'
		
	    SET @Statement = @Statement +
	    '
Staging:
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''PortStaging2Process'' AND TABLE_SCHEMA = @SchemaName)
    BEGIN
      BEGIN TRAN
        -- need to process subset of rows
        -- create extra column to store original row id
		 SELECT @Statement =
              ''CREATE TABLE '' + @SchemaName + ''.PortStaging2Process ('' 
            + @Statement
            + '',OriginalPortStageRowId  bigint  NOT NULL''
            + '')''
        EXECUTE (@Statement)
	  COMMIT
		'
      
	    SET @Statement = @Statement + 
	    '
		IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''PortStaging2Process'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')
        BEGIN
		 Goto Endproc
		END
      BEGIN TRAN
	    INSERT INTO ' + @SchemaName + '.PortStaging2Process
		(
		   DatasetId                    
		  ,ManagementGroupGuid          
		  ,ManagedEntityGuid            
		  ,CollectedDate                
		  ,DateKey                      
		  ,TimeKey                      
		  ,ManagedEntityRowId	        
		  ,ComputerRowId                
		  ,ProcessRowId                 
		  ,ProcessCmdRowId              
		  ,UserRowId                    
		  ,ProcessId                    
		  ,LocalAddress                 
		  ,RemoteAddress                
		  ,LocalPort                    
		  ,RemotePort                   
		  ,OldPortState                 
		  ,PortState                    
		  ,TimeInOldState  
		  ,PortType  
		  ,IPV6            
		  ,ProcessName                  
		  ,Description                  
		  ,CommandLine                  
		  ,CommandLineHash              
		  ,UserName                     
		  ,DWCreatedDateTime            
 		  ,OriginalPortStageRowId
		)
        SELECT TOP (@MaxStagingRowsToProcess)
		   DatasetId                    
		  ,ManagementGroupGuid          
		  ,ManagedEntityGuid            
		  ,CollectedDate                
		  ,DateKey                      
		  ,TimeKey                      
		  ,ManagedEntityRowId	        
		  ,ComputerRowId                
		  ,ProcessRowId                 
		  ,ProcessCmdRowId              
		  ,UserRowId                    
		  ,ProcessId                    
		  ,LocalAddress                 
		  ,RemoteAddress                
		  ,LocalPort                    
		  ,RemotePort                   
		  ,OldPortState                 
		  ,PortState                    
		  ,TimeInOldState               
		  ,PortType  
		  ,IPV6                 
		  ,ProcessName 
		  ,[Description]                  
		  ,CommandLine                  
		  ,CommandLineHash              
		  ,UserName                     
		  ,DWCreatedDateTime            
 		  ,PortStageRowId
		 FROM
			' + @SchemaName + '.PortStaging
		 WHERE DatasetId = @DatasetId
		 ORDER BY CollectedDate
   
      COMMIT
    END 
    
    -- create index on datetime field
    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = ''IX_PortStaging2Process_DateTime'')
    BEGIN
      CREATE INDEX IX_PortStaging2Process_DateTime ON ' + @SchemaName + '.PortStaging2Process(CollectedDate)
    END
    BEGIN TRAN
 -- lock dimension tables  to ensure we insert into dimensions opened for insertion
					SET @LockResourceNameDim = ''ProcessMonitoringDimensions_TableMap''
  
					EXEC @ExecResultDim = sp_getapplock
						   @Resource = @LockResourceNameDim
						  ,@LockMode = ''Exclusive''
						  ,@LockOwner = ''Transaction''
 
				 IF (@ExecResultDim &lt; 0) 
				 BEGIN
				   RETURN
				 END 
   
    
    -- get the minimum data retention period
    -- to make sure we do not re-aggregate something
    -- that is too old and all raw data is gone
    
    SELECT @RawDataMaxAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + ''_'' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), ''-'', '''')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
	--------------------------------------------------------------------------
	-- Delete old records from staging
	--------------------------------------------------------------------------
    DELETE ' + @SchemaName + '.PortStaging
    WHERE (DatasetId = @DatasetId)
      AND ([CollectedDate] &lt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()) )
	-------------------------------------------------------------
	-- Updating Dimensions
	--------------------------------------------------------------
			--------------------------------------------------------------
			--Update Computer Dimension
			--------------------------------------------------------------
			--- 2.1 Update Staging Table with ManagedEntityRowId from Microsoft Windows Computer
					UPDATE stage
					 SET 
						ManagedEntityRowid     = me.ManagedEntityRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
							  JOIN vManagementGroup mg ON (stage.ManagementGroupGuid = mg.ManagementGroupGuid)
							  JOIN vManagedEntity me ON ((me.ManagedEntityGuid = stage.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
 						      JOIN vManagedEntityType met ON (met.ManagedEntityTypeRowId = me.ManagedEntityTypeRowId)
 					 WHERE (stage.DatasetId = @DatasetId) AND ( met.ManagedEntityTypeGuid = ''EA99500D-8D52-FC52-B5A5-10DCD1E9D2BD'')
			---2.2 Insert new Computers in Computer Dimension 
					INSERT INTO ' + @SchemaName + '.ComputerDim
					(
						ManagementEntityRowId
					   ,Name
					   ,NetbiosName
					   ,PrincipalName
					)
					SELECT DISTINCT
						 me.ManagedEntityRowid
						 ,UPPER(me.Name)
						 , CASE CHARINDEX(''.'',me.Name)
						   WHEN 0  THEN UPPER(me.Name)
						   ELSE
							UPPER(LEFT(me.Name,CHARINDEX(''.'',me.Name) - 1))
						   END
						 ,LOWER(me.Name)
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN vManagedEntity me ON me.ManagedEntityRowId = stage.ManagedEntityRowId
					WHERE 
					 NOT EXISTS (SELECT *
                      FROM ' + @SchemaName + '.ComputerDim 
                      WHERE (ManagementEntityRowId = me.ManagedEntityRowId)
                     )
					 AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
					 AND
					 me.Name IS NOT NULL
			---2.3 Update Staging with Computer Dimension Key
					UPDATE stage
					 SET 
						ComputerRowId     = pc.ComputerRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.ComputerDim pc ON (stage.ManagedEntityRowId = pc.ManagementEntityRowId)	    
			--------------------------------------------------------------
			--Update User Dimension
			--------------------------------------------------------------
			---3.1 Insert new Users in User Dimension 
					INSERT INTO ' + @SchemaName + '.UserDim
					(
						LogonName
					   ,Domain
					   ,UserName
					)
					SELECT DISTINCT
						 UPPER(stage.UserName) 
						 ,UPPER(
								  CASE CHARINDEX(''\'',stage.UserName)
								   WHEN 0  THEN ''''
								   ELSE
									LEFT(stage.UserName,CHARINDEX(''\'',stage.UserName) - 1)
								  END
								)
						 ,UPPER(
								  CASE CHARINDEX(''\'',stage.UserName)
								   WHEN 0  THEN stage.UserName
								   ELSE
									RIGHT(stage.UserName,LEN(stage.UserName)- CHARINDEX(''\'',stage.UserName))
								  END
								)
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.UserDim u ON (ISNULL(stage.UserName,'''') = u.LogonName)
					WHERE 
					u.UserRowid IS NULL
					AND
					stage.ManagedEntityRowid  &lt;&gt; 0
			---3.3 Update Staging with new User Dimension Key
					UPDATE stage
					 SET 
						UserRowId     = u.UserRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.UserDim u ON (ISNULL(stage.UserName,'''') = u.LogonName)
					WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
			--------------------------------------------------------------
			--Update Process Dimension
			--------------------------------------------------------------
			---4.1. Insert new Processes in Process Dimension 
			        ;WITH ProcessByName AS
					(
					  SELECT ProcessName,ISNULL([Description],'''') AS [Description], ROW_NUMBER() OVER(PARTITION BY ProcessName ORDER BY [Description]) as Id
					  FROM 
					  ' + @SchemaName + '.PortStaging2Process
					  WHERE
					  ManagedEntityRowid  &lt;&gt; 0
					),
					Processes AS
					(
					  SELECT ProcessName, [Description]
					  FROM ProcessByName
					  WHERE 
					  Id = 1
					)
					INSERT INTO ' + @SchemaName + '.ProcessDim
					(
						 ProcessName
						,[Description]
					)
					SELECT 
						   stage.ProcessName
						  ,stage.[Description] 
					FROM
					Processes stage
					LEFT OUTER JOIN ' + @SchemaName + '.ProcessDim p ON (stage.ProcessName = p.ProcessName)
					WHERE 
					p.ProcessRowId IS NULL
			---4.2. Update Staging with new Process Dimension Key
					UPDATE stage
					 SET 
						ProcessRowId     = p.ProcessRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.ProcessDim p ON (stage.ProcessName = p.ProcessName)
                    WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
			--------------------------------------------------------------
			--Update Process Command Line Dimension
			--------------------------------------------------------------
			---5.1. Insert new Process Command Lines in ProcessCmd Dimension 
					INSERT INTO ' + @SchemaName + '.ProcessCmdDim
					(
						CommandLine
						,CommandLineHash
					)
					SELECT DISTINCT
						  stage.CommandLine
						 ,ISNULL(stage.CommandLineHash, @defaultHash)
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.ProcessCmdDim p ON (ISNULL(stage.CommandLineHash,@defaultHash)  = p.CommandLineHash)
					WHERE 
					p.ProcessCmdRowId IS NULL
					AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
			---5.2. Update Staging with new Process Command Line Dimension Key
					UPDATE stage
					 SET 
						ProcessCmdRowId     = p.ProcessCmdRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.ProcessCmdDim p ON (ISNULL(stage.CommandLineHash,@defaultHash)  = p.CommandLineHash)
					WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
					 
	    EXEC sp_releaseapplock  @Resource = @LockResourceNameDim 
	  COMMIT
	  ----------------------------------------------------------------------
	  --Update Address dimension
	  ----------------------------------------------------------------------
	  BEGIN TRAN
	        INSERT INTO ' + @SchemaName + '.IpAddressDim
					(
						IpAddress
					)
					SELECT DISTINCT
						  stage.LocalAddress
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.IpAddressDim i ON (ISNULL(stage.LocalAddress,'''') = i.IpAddress)
					WHERE 
					i.IpAddressRowId IS NULL
					AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
	        INSERT INTO ' + @SchemaName + '.IpAddressDim
					(
						IpAddress
					)
					SELECT DISTINCT
						  stage.RemoteAddress
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					LEFT OUTER JOIN ' + @SchemaName + '.IpAddressDim i ON (ISNULL(stage.RemoteAddress,'''') = i.IpAddress)
					WHERE 
					i.IpAddressRowId IS NULL
					AND
					 stage.ManagedEntityRowid  &lt;&gt; 0
					UPDATE stage
					 SET 
						LocalAddressRowId      = i.IpAddressRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.IpAddressDim i ON (ISNULL(stage.LocalAddress,'''') = i.IpAddress)
                    WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
					UPDATE stage
					 SET 
						RemoteAddressRowId      = i.IpAddressRowid
					FROM
					' + @SchemaName + '.PortStaging2Process stage
					JOIN ' + @SchemaName + '.IpAddressDim i ON (ISNULL(stage.RemoteAddress,'''') = i.IpAddress)
					WHERE
					 stage.ManagedEntityRowid  &lt;&gt; 0
	  COMMIT
    BEGIN TRAN
	   -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + ''_TableMap''
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = ''Shared''
          ,@LockOwner = ''Transaction''
    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, ''Shared:StandardDatasetTableMap'', @ExecResult)
    END
	-------------------------------------------------------------------------------------------------
	-- Updating Fact Process HealthState Table
	--------------------------------------------------------------------------------------------------
				SET @Statement = 
				''INSERT INTO ['' + @SchemaName + ''].[''+ @InsertTableName +'']
				(
				   DateKey                
				  ,TimeKey                
				  ,ComputerRowId          
				  ,ProcessRowId           
				  ,ProcessCmdRowId        
				  ,UserRowId              
				  ,PID                    
				  ,LocalAddressRowId      
				  ,RemoteAddressRowId     
				  ,PortType               
				  ,LocalPort              
				  ,RemotePort             
				  ,OldPortState           
				  ,PortState              
				  ,TimeInOldState         
				  ,IPV6                   
				  ,DateTime          
				)
				SELECT
						 DateKey                        
						,TimeKey                        
						,ComputerRowId                  
						,ProcessRowId                   
						,ProcessCmdRowId 
						,UserRowId               
						,ProcessId                         
  					    ,LocalAddressRowId      
				        ,RemoteAddressRowId 
						,PortType               
						,LocalPort              
						,RemotePort             
						,OldPortState           
						,PortState              
						,TimeInOldState         
						,IPV6              
						,CollectedDate                  
				FROM 
					' + @SchemaName + '.PortStaging2Process
					WHERE DateKey IS NOT NULL                      
						 AND TimeKey IS NOT NULL                        
						 AND ComputerRowId IS NOT NULL                  
						 AND ProcessRowId IS NOT NULL                   
						 AND ProcessCmdRowId IS NOT NULL 
						 AND UserRowId IS NOT NULL                                       
  					     AND LocalAddressRowId IS NOT NULL      
				         AND RemoteAddressRowId IS NOT NULL 
						 AND PortType IS NOT NULL               
						 AND LocalPort IS NOT NULL              
						 AND RemotePort IS NOT NULL
						 AND ManagedEntityRowid  &lt;&gt; 0''
				IF (@DebugLevel &gt; 0)
				BEGIN
				  SELECT @MessageText = ''Starting to insert '' + CAST(COUNT(*) AS varchar(30)) + '' process Port State samples into '' + @InsertTableName
				  FROM ' + @SchemaName + '.PortStaging2Process
      
				  SET @InsertStartedDateTime = GETUTCDATE()
      
				  EXEC DebugMessageInsert
					 @DatasetId = @DatasetId
					,@MessageLevel = @InfoLevel
					,@MessageText = @MessageText
				END
			
				EXEC(@Statement)
			 -- mark existing affected aggregations as dirty
				UPDATE ah
				SET DirtyInd = 1
				   ,DataLastReceivedDateTime = GETUTCDATE()
				FROM StandardDatasetAggregationHistory ah
					  JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
					  CROSS JOIN ' + @SchemaName + '.PortStaging2Process p
				WHERE (ah.DatasetId = @DatasetId)
				  AND (ah.AggregationDateTime &gt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()))
				  AND (p.[CollectedDate] &gt;= ah.AggregationDateTime)
				  AND (p.[CollectedDate] &lt; DATEADD(minute, a.AggregationIntervalDurationMinutes, ah.AggregationDateTime))
			   -- delete processed rows from staging
               DELETE ps
               FROM ' + @SchemaName + '.PortStaging ps
               JOIN ' + @SchemaName + '.PortStaging2Process psp ON (ps.PortStageRowId  = psp.OriginalPortStageRowId )
    
				-- delete all inserted data from staging
				DROP TABLE ' + @SchemaName + '.PortStaging2Process
				
	    EXEC sp_releaseapplock  @Resource = @LockResourceName 
	COMMIT
    
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Port State DataSet: Finished inserting port state samples  into '' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
      ,@ErrorMessageText = ERROR_MESSAGE()
    SET @ErrorInd = 1
  END CATCH
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      
      SET @DebugMessageText = N''Failed to process data in the Process Monitroing Port State DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
                      + '', Procedure '' + @ErrorProcedure
                      + '', Line '' + CAST(@ErrorLine AS varchar(15))
                      + '', Message: ''+ @ErrorMessageText
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @ErrorLevel
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int
    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
DeleteWrongDataSet:	
	--------------------------------------------------------------------------
	-- Delete wrong  datasets from staging
	--------------------------------------------------------------------------
	DECLARE
	  @delBatchSize int
	 ,@ErrorIndDel int
	 
	 SET @ErrorIndDel  = 0
	 SET @delBatchSize = @MaxStagingRowsToProcess
	IF (@DebugLevel &gt; 0)
    BEGIN
      SET @MessageText = ''Process Monitroing Port State DataSet: Starting deletion of wrong DataSets records from staging ''
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = @InfoLevel
        ,@MessageText = @MessageText
    END
   SET @InsertStartedDateTime = GETUTCDATE()
	WHILE(1=1)
	BEGIN
	 BEGIN TRY
	     BEGIN TRAN
			DELETE TOP(@delBatchSize) FROM ' + @SchemaName + '.PortStaging
			WHERE (DatasetId != @DatasetId)
			IF (@@rowcount &lt; @delBatchSize)
			BEGIN
				COMMIT
				BREAK;
			END
 	     COMMIT
	 END TRY
     BEGIN CATCH
		IF (@@TRANCOUNT &gt; 0)
		  ROLLBACK TRAN
  
		SELECT 
		   @ErrorNumber = ERROR_NUMBER()
		  ,@ErrorSeverity = ERROR_SEVERITY()
		  ,@ErrorState = ERROR_STATE()
		  ,@ErrorLine = ERROR_LINE()
		  ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), ''-'')
		  ,@ErrorMessageText = ERROR_MESSAGE()
		SET @ErrorIndDel = 1
	 END CATCH
	 IF (@ErrorIndDel = 1)
	 BEGIN
			BREAK;
     END --IF
    END --WHILE
	 IF (@ErrorIndDel = 1)
	 BEGIN
			IF (@DebugLevel &gt; 0)
			BEGIN
      
				SET @DebugMessageText = N''Failed to delete  data from wrong dataset in the Process Monitroing Port State DataSet staging area. Error '' + CAST(@ErrorNumber AS varchar(15))
								+ '', Procedure '' + @ErrorProcedure
								+ '', Line '' + CAST(@ErrorLine AS varchar(15))
								+ '', Message: ''+ @ErrorMessageText
				EXEC DebugMessageInsert
					@DatasetId = @DatasetId
				,@MessageLevel = @ErrorLevel
				,@MessageText = @DebugMessageText
			END
      
			SET @AdjustedErrorSeverity = CASE
											WHEN @ErrorSeverity &gt; 18 THEN 18
											ELSE @ErrorSeverity
											END
    
			RAISERROR (777971002, @AdjustedErrorSeverity, 1
				,@ErrorNumber
				,@ErrorSeverity
				,@ErrorState
				,@ErrorProcedure
				,@ErrorLine
				,@ErrorMessageText
			)
     END
	 ELSE
	 BEGIN
		IF (@DebugLevel &gt; 0)
		BEGIN
		  SET @MessageText = ''Process Monitroing Port State DataSet: Finished deleting wrong dataset records from staging ''
          SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
		  EXEC DebugMessageInsert
			 @DatasetId = @DatasetId
			,@MessageLevel = @InfoLevel
			,@MessageText = @MessageText
            ,@OperationDurationMs = @OperationDurationMs
		END
     END --IF
 Endproc:
END  --Procedure [ProcessMonitoring].[StatePortStaging]
'
DECLARE  @ErrorInd bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
SET @ErrorInd  = 0
BEGIN TRY
	EXECUTE (@Statement)
END TRY
BEGIN CATCH
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
       SET @ErrorInd  = 1
	   SET @DebugMessage = @DebugPrefix +  'Cannot create stage processing stored procedure. Error: ' + @ErrorMessageText
END CATCH
       
IF (1 = @ErrorInd) 
BEGIN
	DECLARE @AdjustedErrorSeverity int
	SET @AdjustedErrorSeverity = CASE
                            WHEN @ErrorSeverity &gt; 18 THEN 18
                            ELSE @ErrorSeverity
                        END
  
   IF @DebugLevel &gt; 0
      EXEC DebugMessageInsert
		@DatasetId = '$Config/DatasetId$'
		,@MessageLevel = @ErrorLevel
		,@MessageText = @DebugMessage
	RAISERROR (777971002, @AdjustedErrorSeverity, 1
	,@ErrorNumber
	,@ErrorSeverity
	,@ErrorState
	,@ErrorProcedure
	,@ErrorLine
	,@ErrorMessageText
	)
END
ELSE
BEGIN
  IF @DebugLevel &gt; 0 
  BEGIN
    SET @DebugMessage =  @DebugPrefix + 'Stage processing stored procedure was created successfully.'
   
	EXEC DebugMessageInsert
	@DatasetId     = '$Config/DatasetId$'
	,@MessageLevel = @InfoLevel
	,@MessageText  = @DebugMessage
 END
END
Endproc:
GO
</Install><Uninstall>GO
DECLARE
 @TableSchemaName sysname
SELECT 
	@TableSchemaName  = SchemaName
FROM
dbo.StandardDataSet
WHERE DatasetId = '$Config/DatasetId$'
-- drop SPs
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME =  'PortStateProcessStaging')
	BEGIN
		EXECUTE('DROP PROCEDURE ' + @TableSchemaName + '.PortStateProcessStaging')
	END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_SCHEMA = @TableSchemaName AND ROUTINE_NAME = 'PortStateFactsGroom')
	BEGIN
		EXECUTE ('DROP PROCEDURE ' + @TableSchemaName + '.PortStateFactsGroom ')
	END
--drop views
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'vIpAddressDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE('DROP VIEW ' + @TableSchemaName + '.vIpAddressDim')
END
IF  EXISTS (SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'IpAddressDim' AND TABLE_SCHEMA = @TableSchemaName)
BEGIN
  EXECUTE('DROP Table ' + @TableSchemaName + '.IpAddressDim')
END
-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
</Uninstall><Upgrade>
GO
---------------------------------------------------------------
-- Update Port State Dataset
--------------------------------------------------------------
DECLARE 
         @SchemaName sysname
	    ,@ProcessStagingSp sysname
	    ,@ErrorInd        bit
		,@ErrorMessageText nvarchar(4000)
		,@ErrorNumber     int
		,@ErrorSeverity   int
		,@ErrorState      int
		,@ErrorLine       int
		,@ErrorProcedure  nvarchar(256)
	    ,@DebugMessage    nvarchar(max)
        ,@DebugLevel tinyint
	    ,@DebugPrefix  nvarchar(max)
SET @SchemaName  = 'ProcessMonitoring'
SET @ProcessStagingSp = 'PortStateProcessStaging'
SET @ErrorInd = 0
SET @DebugLevel = 0
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + ' Update dataset definition.'
EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = 1
			,@MessageText = @DebugMessage
 BEGIN TRY
	
	UPDATE StandardDataset 
	SET
		DebugLevel = @DebugLevel
   WHERE DatasetId = '$Config/DatasetId$'
 END TRY
 BEGIN CATCH
    SET @ErrorInd = 1
 END CATCH
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
 SET @DebugMessage =  @DebugPrefix + 'Update dataset definition was failed. Error: ' + @ErrorMessageText
  
 EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = 3
			,@MessageText = @DebugMessage
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
 SET @DebugMessage =  @DebugPrefix + 'Update dataset definition was finished successfully.'
  
 EXEC DebugMessageInsert
			@DatasetId = '$Config/DatasetId$'
			,@MessageLevel = 1
			,@MessageText = @DebugMessage
END
GO
------------------------------------------------------------------------------------------------------------
-- Create Indexes for the StandardDataset Aggregation Tables  for Process MonitoringPortState Fact Tables
------------------------------------------------------------------------------------------------------------
GO
SET NOCOUNT ON
-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@IndeGuid uniqueidentifier
  ,@ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@DebugMessage      nvarchar(max)
  ,@DebugPrefix       nvarchar(max)
  ,@ErrorLevel        int
  ,@InfoLevel         int
SET @ErrorLevel   = 3 
SET @InfoLevel    = 1
SET @ErrorInd     = 0
SET @DebugPrefix  =  'Process Monitoring Port State DataSet: '
SET @DebugMessage =  @DebugPrefix + 'Starting dataset indexes deployment.'
SET @AggregationTypeId = -1
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
BEGIN TRY
		WHILE EXISTS (SELECT *
					  FROM StandardDatasetAggregation
					  WHERE (DatasetId = '$Config/DatasetId$')
						AND (AggregationTypeId &gt; @AggregationTypeId)
					 )
		BEGIN
		  SELECT @IndeGuid = NEWID()
  
		  SELECT TOP 1 
			 @AggregationTypeId = AggregationTypeId
			,@Statement = 
			  ' EXEC StandardDatasetIndexDelete'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			  + '   ,@DeleteIndexOnExistingTablesInd = 0'
			+ ' EXEC StandardDatasetIndexInsert'
			+ '    @DatasetId = ''$Config/DatasetId$'''
			+ '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
			+ '   ,@DependentTableInd = 0'
			+ '   ,@TableTag = NULL'
			+ '   ,@UniqueInd = 0'
			+ '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
			+ '   ,@IndexDefinition = ''([DateTime])'''
			+ '   ,@CreateIndexOnExistingTablesInd = 0'
		  FROM StandardDatasetAggregation
		  WHERE (DatasetId = '$Config/DatasetId$')
			AND (AggregationTypeId &gt; @AggregationTypeId)
		  ORDER BY AggregationTypeId
  
		  EXECUTE (@Statement)
		END
		/* raw indexes for UI widget p*/
		-- Hourly data index to support Top N reports and dashboards
		EXEC StandardDatasetIndexDelete
		   @DatasetId = '$Config/DatasetId$'
		  ,@IndexGuid = '6D30F2F6-82A9-4B38-AFBE-3A1F7A17BA9E'
			,@DeleteIndexOnExistingTablesInd = 0
		EXEC StandardDatasetIndexInsert
			@DatasetId = '$Config/DatasetId$'
		  ,@AggregationTypeId = 0
		  ,@DependentTableInd = 0
		  ,@TableTag = NULL
		  ,@UniqueInd = 0
		  ,@IndexGuid = '6D30F2F6-82A9-4B38-AFBE-3A1F7A17BA9E'
		  ,@IndexDefinition = '(
				 ComputerRowId     
				,ProcessRowId      
				,ProcessCmdRowId   
				,UserRowId         
				,PID               
				,LocalAddressRowId 
				,RemoteAddressRowId               
				,DateTime
			  )
			  INCLUDE
			  (
				 PortType      
				,LocalPort     
				,RemotePort    
				,OldPortState  
				,PortState     
				,TimeInOldState
				,IPV6          
			  )
		  '
		,@CreateIndexOnExistingTablesInd = 0
		-- Index for dashboard
		EXEC StandardDatasetIndexDelete
		   @DatasetId = '$Config/DatasetId$'
		  ,@IndexGuid = 'F747FA4B-577A-4952-B77A-751212594317'
			,@DeleteIndexOnExistingTablesInd = 1
		EXEC StandardDatasetIndexInsert
			@DatasetId = '$Config/DatasetId$'
		  ,@AggregationTypeId = 0
		  ,@DependentTableInd = 0
		  ,@TableTag = NULL
		  ,@UniqueInd = 0
		  ,@IndexGuid = 'F747FA4B-577A-4952-B77A-751212594317'
		  ,@IndexDefinition = '([ComputerRowId] ASC,
	[DateTime])'
		,@CreateIndexOnExistingTablesInd = 1
END TRY
BEGIN CATCH
  SET @ErrorInd = 1
     SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()
END CATCH
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int
  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was failed. Error: ' + @ErrorMessageText
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @ErrorLevel
			,@MessageText  = @DebugMessage 
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
ELSE
BEGIN
  SET @DebugMessage = @DebugPrefix + 'Indexes deployment was finished successfully.'
  EXEC DebugMessageInsert
			 @DatasetId    = '$Config/DatasetId$'
			,@MessageLevel = @InfoLevel
			,@MessageText  = @DebugMessage 
END
GO
</Upgrade></DataWarehouseDataSet></DataWarehouseDataSets><Reports><Report ID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" Accessibility="Public" Visible="true"><Dependencies><DataWarehouseScript>Microsoft.Window.Server.10.0.Dashboard.DWScript.Microsoft.Window.Server.GetTopNProcesses.Procedure</DataWarehouseScript><ReportParameterControl>DWReport!Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.RelativeDateTimePicker</ReportParameterControl><ReportParameterControl>DWReport!Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox</ReportParameterControl><ReportParameterControl>DWReport!Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.NumericUpDown</ReportParameterControl></Dependencies><ParameterBlock xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings" columns="3"><Controls><Control columnSpan="1" rowSpan="1"
type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox"><ReportParameters><ReportParameter name="OrderBy"><Prompt>Microsoft.Windows.Server.10.0.ProcessMonitoring!Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.OrderBy</Prompt></ReportParameter></ReportParameters></Control><Control columnSpan="1" rowSpan="1" type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.NumericUpDown"><ReportParameters><ReportParameter name="N"><Prompt>Microsoft.Windows.Server.10.0.ProcessMonitoring!Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.N</Prompt></ReportParameter></ReportParameters><Properties><Property name="Minimum"><Value>1</Value></Property></Properties></Control><Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.RelativeDateTimePicker" columnSpan="1" rowSpan="6"><ReportParameters><ReportParameter name="TimeZone"
binding="TimeZone"><Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt></ReportParameter><ReportParameter name="TimeZoneName" binding="TimeZoneName" /><ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" /><ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue"><Prompt>Microsoft.Windows.Server.10.0.ProcessMonitoring!Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.StartDate</Prompt></ReportParameter><ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" /><ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" /><ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" /><ReportParameter name="EndDate_BaseValue"
binding="EndDate_BaseValue"><Prompt>Microsoft.Windows.Server.10.0.ProcessMonitoring!Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.EndDate</Prompt></ReportParameter><ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" /><ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" /></ReportParameters><Properties><Property name="MaxWidth"><Value>400</Value></Property></Properties></Control></Controls></ParameterBlock><ReportDefinition>Microsoft.Windows.Server.10.0.ProcessMonitoring.TopNProcesses.rdl</ReportDefinition><ReportStrings><ReportString ID="R.TopNProcesses" /><ReportString ID="R.OrderBy" /><ReportString ID="R.ComputerName" /><ReportString ID="R.ProcessName" /><ReportString ID="R.MaxCpuUsage" /><ReportString ID="R.MaxMemoryUsage" /><ReportString ID="R.MaxHandleCount" /><ReportString ID="R.MaxThreadCount" /><ReportString ID="R.MaxPageFaultCount" /><ReportString ID="R.MaxCpuTime" /><ReportString
ID="R.MaxTotalProcessTime" /><ReportString ID="R.MaxReadPerSecond" /><ReportString ID="R.MaxWritePerSecond" /></ReportStrings></Report></Reports></Reporting><LanguagePacks><LanguagePack ID="ENU" IsDefault="true"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Folder.Root"><Name>Process and Port Monitoring</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.Dashboard.Process"><Name>Process Dashboard</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.Dashboard.Port"><Name>Port Dashboard</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.Components.ProcessList.Widget"><Name>Processes</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.Components.PortList.Widget"><Name>Ports</Name></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.Presentation.Components.ProcessTopN.Widget"><Name>Top 10 Processes</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessSeed.Full.Discovery"><Name>Windows Server 2016 and above Process and Port Monitoring Seed Discovery (Full)</Name><Description>Discovery of process and port monitoring seed objects of Windows Server 2016 and above (Full).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessSeed.Core.Discovery"><Name>Windows Server 2016 and above Process and Port Monitoring Seed Discovery (Core)</Name><Description>Discovery of Core process and port monitoring seed objects of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessCount.Collection"><Name>Process Monitoring: Number of Processes Collection</Name><Description>This rule collects the Number of Processes performance counter for
Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessHandleCount.Alert"><Name>Process Monitoring: High Handle Count</Name><Description>This rule generates an alert when handle count increases too fast.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource" SubElementID="SampleCount"><Name>Sample Count</Name><Description>Sample Count</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource" SubElementID="HandleCountIncreaseThreshold"><Name>Handle Count Increase Threshold</Name><Description>Handle Count Increase
Threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify thresholds for specific processes and processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessHandleCount.Alert.AlertMessage"><Name>Handle Count Increases Too Fast</Name><Description>Handle Count for process {1} with PID {0} has increased more than by {2}%.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessPercentProcessorTime.Alert"><Name>Process Monitoring: High Processor Time Percentage</Name><Description>This rule generates an alert when the percentage of processor time is too high.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource" SubElementID="SampleCount"><Name>Sample Count</Name><Description>Sample
Count</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource" SubElementID="PercentProcessorTimeThreshold"><Name>Percent Processor Time Threshold</Name><Description>Percent processor time threshold.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify thresholds for specific processes and processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessPercentProcessorTime.Alert.AlertMessage"><Name>Processor Time Percentage is too high</Name><Description>Processor Time Percentage for process {1} with PID {0} is greater than threshold value: {2}%.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMemoryPercentage.Alert"><Name>Process Monitoring: High Memory Percentage</Name><Description>This rule generates an alert when the memory percentage is too high.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource" SubElementID="SampleCount"><Name>Sample Count</Name><Description>Sample
Count</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource" SubElementID="MemoryPercentageThreshold"><Name>Memory Percentage Threshold</Name><Description>Memory Percentage Threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify thresholds for specific processes and processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMemoryPercentage.Alert.AlertMessage"><Name>Memory Percentage is too high</Name><Description>Memory Percentage for process {1} with PID {0} is greater than threshold value: {2}%.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.TemplateFolder.ProcessesAndPorts"><Name>Processes and Ports</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.ContainsWindowsServer.10.0.Computer"><Name>Windows Server 2016 and above Enabled Process Monitoring Group Contains Windows Server 2016 and
above</Name><Description>A relationship between Windows Server 2016 and above Enabled Process Monitoring Group and computers with Windows Server 2016 or above operating systems installed.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.ContainsWindowsServer.10.0.Computer"><Name>Windows Server 2016 and above Enabled Port Monitoring Group Contains Windows Server 2016 and above</Name><Description>A relationship between Windows Server 2016 and above Enabled Port Monitoring Group and computers with Windows Server 2016 or above operating systems installed.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringSeedGroup.ContainsProcessSeed"><Name>Windows Server 2016 and above Process and Port Monitoring Seed Group Contains Process Seed</Name><Description>A relationship between Windows Server 2016 and above Process and Port Monitoring Seed Group and the process and port monitoring
seeds.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.Group"><Name>Windows Server 2016 and above Enabled Process Monitoring Group</Name><Description>This group contains seeds related to Windows Server 2016 and above operating systems for which process monitoring is enabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.Group"><Name>Windows Server 2016 and above Enabled Port Monitoring Group</Name><Description>This group contains seeds of Windows Server 2016 and above operating systems for which port monitoring is enabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.Group.Discovery"><Name>Populate Windows Server 2016 and above Enabled Process Monitoring Group</Name><Description>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which process
monitoring is enabled via "Add Monitoring Wizard".</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.Group.Discovery"><Name>Populate Windows Server 2016 and above Enabled Port Monitoring Group</Name><Description>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which port monitoring is enabled via "Add Monitoring Wizard".</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Seed.Group"><Name>Windows Server 2016 and above Process and Port Monitoring Seed Group</Name><Description>This group contains process and port monitoring seeds of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringSeed.Group.Discovery"><Name>Populate Windows Server 2016 and above Process and Port Monitoring Seed Group</Name><Description>This rule populates the
Process and Port Monitoring Seed Group of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringDisabled.Group"><Name>Windows Server 2016 and above Disabled Process Monitoring Group</Name><Description>This group contains seeds of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringDisabled.Group.Discovery"><Name>Populate Windows Server 2016 and above Disabled Process Monitoring Group</Name><Description>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which process monitoring is disabled via "Add Monitoring Wizard".</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringDisabled.Group"><Name>Windows Server 2016 and above Disabled Port Monitoring Group</Name><Description>This group contains seeds of
Windows Server 2016 and above operating systems for which port monitoring is disabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringDisabled.Group.Discovery"><Name>Populate Windows Server 2016 and above Disabled Port Monitoring Group</Name><Description>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which port monitoring is disabled via "Add Monitoring Wizard".</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.Components.ServerList.Widget"><Name>Servers</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.HealthStatesCollection.Dataset"><Name>Process Monitoring: Process Health State data warehouse dataset</Name><Description>Process Health State data warehouse for Process Monitoring.</Description></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.HealthStatesCollection.Dataset.DefaultConfiguration"><Name>Process monitoring: Process Health State data warehouse dataset configuration</Name><Description>
            &lt;Configuration&gt;
            &lt;Aggregations&gt;
            &lt;Raw&gt;
            &lt;BaseTableName&gt;ProcessHealthFactsRaw&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;
            &lt;MaxDataAgeDays&gt;10&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
            &lt;/Raw&gt;
            &lt;/Aggregations&gt;
            &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
            &lt;DefaultAggregationIntervalCount&gt;10&lt;/DefaultAggregationIntervalCount&gt;
            &lt;BlockingMaintenanceDailyStartTime&gt;04:00&lt;/BlockingMaintenanceDailyStartTime&gt;
            &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
            &lt;/Configuration&gt;
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MetricsCollection.Dataset"><Name>Process Monitoring: Performance Metric  State data warehouse dataset</Name><Description>Process Performance Metric  data warehouse for Process Monitoring.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MetricsCollection.Dataset.DefaultConfiguration"><Name>Process monitoring: Process Performance Metric data warehouse dataset configuration</Name><Description>
            &lt;Configuration&gt;
            &lt;Aggregations&gt;
            &lt;Raw&gt;
            &lt;BaseTableName&gt;ProcessMetricFactsRaw&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;
            &lt;MaxDataAgeDays&gt;10&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
            &lt;/Raw&gt;
            &lt;Hourly&gt;
            &lt;BaseTableName&gt;ProcessMetricFactsHourly&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;
            &lt;MaxDataAgeDays&gt;90&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
            &lt;AggregationStartDelayMinutes&gt;20&lt;/AggregationStartDelayMinutes&gt;
            &lt;/Hourly&gt;
            &lt;Daily&gt;
            &lt;BaseTableName&gt;ProcessMetricFactsDaily&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;
            &lt;MaxDataAgeDays&gt;180&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
            &lt;AggregationStartDelayMinutes&gt;40&lt;/AggregationStartDelayMinutes&gt;
            &lt;/Daily&gt;
            &lt;/Aggregations&gt;
            &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
            &lt;DefaultAggregationIntervalCount&gt;10&lt;/DefaultAggregationIntervalCount&gt;
            &lt;BlockingMaintenanceDailyStartTime&gt;04:00&lt;/BlockingMaintenanceDailyStartTime&gt;
            &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
            &lt;/Configuration&gt;
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetPortsCollection.Dataset"><Name>Process Monitoring: Process Network Ports data warehouse dataset</Name><Description>Process Network Ports data warehouse for Process Monitoring.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetPortsCollection.Dataset.DefaultConfiguration"><Name>Process monitoring: Process Network Ports data warehouse dataset configuration</Name><Description>
            &lt;Configuration&gt;
            &lt;Aggregations&gt;
            &lt;Raw&gt;
            &lt;BaseTableName&gt;PortFactsRaw&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;
            &lt;MaxDataAgeDays&gt;10&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
            &lt;/Raw&gt;
            &lt;/Aggregations&gt;
            &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
            &lt;DefaultAggregationIntervalCount&gt;10&lt;/DefaultAggregationIntervalCount&gt;
            &lt;BlockingMaintenanceDailyStartTime&gt;04:00&lt;/BlockingMaintenanceDailyStartTime&gt;
            &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
            &lt;/Configuration&gt;
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthStateSubscription.Rule"><Name>Process Monitoring: Process Health State Subscription</Name><Description>This rule saves Process Health State information to the SCOM data warehouse. To start information collection, make sure that “Process Monitoring: Health State Collection” rule is enabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetricsSubscription.Rule"><Name>Process Monitoring: Process Performance Metric Subscription</Name><Description>This rule saves Process Performance Metric information to the SCOM data warehouse. To start information collection, make sure that “Process Monitoring: Performance Collection” rule is enabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PortSubscription.Rule"><Name>Process Monitoring: Process Network Port
Subscription</Name><Description>This rule saves Process Network Port information to the SCOM data warehouse. To start information collection, make sure that “Process Monitoring: Network Port State Collection” rule is enabled.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection"><Name>Process Monitoring: Health State Collection</Name><Description>This rule collects information about the health state of the processes.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection"><Name>Process Monitoring: Performance Collection</Name><Description>This rule collects information about the processes' performance metrics.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Ports.Collection"><Name>Process Monitoring: Network Port State Collection</Name><Description>This rule collects information about Network Port
State.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetricsDW.WriteAction"><Name>Process Monitoring: Process Performance Collection Write Action</Name><Description>This write action writes the Process Performance into SCOM data warehouse.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthStateDW.WriteAction"><Name>Process Monitoring: Process Health State Collection Write Action</Name><Description>This write action writes the Process Health State into SCOM data warehouse.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PortDW.WriteAction"><Name>Process Monitoring: Process Health State Collection Write Action</Name><Description>This write action writes the Process Health State into SCOM data warehouse.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthStatePublish.WriteAction"><Name>Process
Monitoring: Write Action For Publishing Process Health States Data</Name><Description>This write action publishes Process Health State data to a custom channel.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetricsPublish.WriteAction"><Name>Process Monitoring: Write Action For Publishing Process Performance Data</Name><Description>This write action publishes Process Performance data to a custom channel.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PortsPublish.WriteAction"><Name>Process Monitoring: Write Action For Publishing Process Network Ports Data</Name><Description>This write action publishes Process Network Ports  data to a custom channel.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Template.ProcessesAndPorts"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This template allows you to monitor Windows
Server 2016 and above processes and ports</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.MainPage" SubElementID="Title"><Name>Monitoring Configuration</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.MainPage" SubElementID="SubTitle"><Name>Monitoring Configuration</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.MainPage" SubElementID="TabName"><Name>Monitoring Configuration</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.ProcessThresholdsPage" SubElementID="Title"><Name>Optional Configuration</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.ProcessThresholdsPage" SubElementID="SubTitle"><Name>Optional Configuration</Name></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.ProcessThresholdsPage" SubElementID="TabName"><Name>Optional Configuration</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.Summary" SubElementID="Title"><Name>Summary</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.Summary" SubElementID="SubTitle"><Name>Summary</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.UIPageSet.ProcessesAndPortsTemplate.Summary" SubElementID="TabName"><Name>Summary</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.AlertSubscription.DataSource"><Name>Process Monitoring: Alert Subscription Datasource</Name><Description>Alert subscription datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.CountMonitoring.DataSource"
SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountAlerting.DataSource"><Name>Process Monitoring: Handle Count Alerting Datasource</Name><Description>Handle count alerting datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.CountMonitoring.DataSource"><Name>Process Monitoring: Count Monitoring Datasource</Name><Description>Count monitoring datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HandleCountMonitoring.DataSource"><Name>Process Monitoring: Handle Count Monitoring Datasource</Name><Description>Handle count monitoring datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource"><Name>Process Monitoring: Alerting Datasource</Name><Description>Alerting
datasource</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource" SubElementID="SampleCount"><Name>Sample Count</Name><Description>Sample count</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource" SubElementID="HandleCountIncreaseThreshold"><Name>Handle Count Increase Threshold</Name><Description>Handle count increase threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource" SubElementID="MemoryPercentageThreshold"><Name>Memory Percentage Threshold</Name><Description>Memory percentage threshold</Description></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.Process.Alerting.DataSource" SubElementID="PercentProcessorTimeThreshold"><Name>Process Monitoring: Processor Time Percentage Threshold</Name><Description>Processor time percentage threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.MemoryPercentageAlerting.DataSource"><Name>Process Monitoring: Memory Percentage Alerting Datasource</Name><Description>Memory percentage alerting datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.Monitoring.DataSource"><Name>Process Monitoring: Monitoring Datasource</Name><Description>Monitoring datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PercentProcessorTimeAlerting.DataSource"><Name>Process Monitoring: Processor Time Percentage Alerting Datasource</Name><Description>Processor time percentage alerting
datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessSeedDiscovery.ModuleType"><Name>Process Monitoring: Seed Discovery Module Type</Name><Description>Seed discovery module type.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessSeedDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessCountMonitoring.Inner.DataSource"><Name>Process Monitoring: Count Monitoring Inner Data Source</Name><Description>Count monitoring data source.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringDisabledGroup.ContainsWindowsServer.10.0.ProcessSeed"><Name>Process Monitoring: Disabled Group Contains Windows Server 2016 and above Process Seed</Name><Description>Monitoring disabled group contains process seed of
Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PortMonitoringDisabledGroup.ContainsWindowsServer.10.0.ProcessSeed"><Name>Port Monitoring: Disabled Group Contains Windows Server 2016 and above Process Seed</Name><Description>Port monitoring disabled group contains process seed of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.ProbeAction"><Name>Process and Port Monitoring: Probe Action</Name><Description>Process and Port monitoring probe action.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.CloseAlertWriteAction"><Name>Process Monitoring: Close Alert Write Action</Name><Description>Close alert write action.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Presentation.ActiveAlert.View"><Name>Active
Alerts</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.RunAs.CollectionRules"><Name>Microsoft Windows Server Process Rules Run As Profile</Name><Description>This Run As profile is used for collecting metrics from the following process collection rules: "Process Monitoring: Network Port State Collection", "Process Monitoring: Performance Collection", and "Process Monitoring: Health State Collection" and for generating alerts for the following alert rules: "Process Monitoring: High Memory Percentage", "Process Monitoring: High Processor Time Percentage" and "Process Monitoring: High Handle Count".</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection.DataSource"><Name>Process Monitoring: Process Performance Collection Datasource</Name><Description>Process performance collection datasource.</Description></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource"><Name>Process Monitoring: Process Health State Collection Datasource</Name><Description>Process health state collection datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="SampleCount"><Name>Sample Count</Name><Description>Sample Count</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="MemoryPercentageThreshold"><Name>Memory Percentage Threshold</Name><Description>Memory Percentage Threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="PercentProcessorTimeThreshold"><Name>Percent Processor Time Threshold</Name><Description>Percent Processor Time Threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="HandleCountIncreaseThreshold"><Name>Handle Count Increase Threshold</Name><Description>Handle Count Increase
Threshold</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify thresholds for specific processes and processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection.DataSource.Internal"><Name>Process Monitoring: Process Health State Collection Internal Datasource</Name><Description>Process health state collection internal datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Port.PerfMetrics.Collection.DataSource"><Name>Process Monitoring: Port State Collection Datasource</Name><Description>Port state collection datasource.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Port.PerfMetrics.Collection.DataSource"
SubElementID="IntervalSeconds"><Name>Interval Seconds</Name><Description>Interval (seconds)</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Port.PerfMetrics.Collection.DataSource" SubElementID="MonitoringConfiguration"><Name>Monitoring Configuration</Name><Description>Allows to specify thresholds for specific processes and processes to exclude from monitoring in XML format</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Port.PerfMetrics.Collection.DataSource" SubElementID="LogLevel"><Name>Log Level</Name><Description>
            Determines which events should be written to Event Log.
            0 – All,  1 – Informational, 2 – Warning, 4 – Error,  8 – Verbose,
            16 – Debug,  255 – None
          </Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.ProcessSeed"><Name>Windows Server 2016 and above Process Monitoring Seed</Name><Description>Process monitoring seed of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Port.DWSubscription.DataSource"><Name>Process Monitoring: Internal datasource for subscribing for Port Data</Name><Description>Process Monitoring: Internal datasource for subscribing for Port Data</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessInfo.DWSubscription.HealthState.DataSource"><Name>Process Monitoring: Internal datasource for subscribing for Process Data</Name><Description>Process Monitoring: Internal datasource for subscribing for Process Data</Description></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.ProcessInfo.DWSubscription.PerfMetrics.DataSource"><Name>Process Monitoring: Internal datasource for subscribing for Process Data</Name><Description>Process Monitoring: Internal datasource for subscribing for Process Data</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.N"><Name>N</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.OrderBy"><Name>Order By</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.StartDate"><Name>Start Date</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses.EndDate"><Name>End Date</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses"><Name>Top N
Processes</Name><Description>Top N Processes</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.TopNProcesses"><Name>Top ##(N)## Processes</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.OrderBy"><Name>Order by ##(OrderBy)##</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.ComputerName"><Name>Computer Name</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.ProcessName"><Name>Process Name</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxCpuUsage"><Name>Max CPU Usage (Percent)</Name></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxMemoryUsage"><Name>Max Memory Usage (Percent)</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxHandleCount"><Name>Max Handle Count Usage</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxThreadCount"><Name>Max Thread Count Usage</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxPageFaultCount"><Name>Max Page Fault Count</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxCpuTime"><Name>Max CPU Time</Name></DisplayString><DisplayString
ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxTotalProcessTime"><Name>Max Total Process Time</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxReadPerSecond"><Name>Max IO Read (KiloBytes/s)</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" SubElementID="R.MaxWritePerSecond"><Name>Max IO Write (KiloBytes/s)</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.GenerateAlertWriteAction"><Name>Process Monitoring: Generate Alert Write Action</Name><Description>Generate alert write action.</Description></DisplayString></DisplayStrings><KnowledgeArticles><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessSeed.Full.Discovery" Visible="true"><MamlContent><maml:section
xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>Discovery of process and port monitoring seed objects of Windows Server 2016 Full. Note that this Management Pack is not supported on Nano Server.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessSeed.Core.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>Discovery of Core process and port monitoring seed objects of Windows Server 2016 and above operating systems. Note that this Management Pack is not supported on Nano Server.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessHandleCount.Alert" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule
generates an alert when handle count increases too fast.</maml:para><maml:para><maml:ui>Note:</maml:ui> If the threshold for this rule differs from the corresponding threshold for the "Process Monitoring: Health State Collection" rule, it may lead to inconsistency between alerts and process health states.
              </maml:para><maml:para>To avoid generating excessive alerts, a minimal threshold for the rule was implemented. The default value for minimal threshold is 15%. The threshold can be changed to any value via the overrides for the rule in the Operations Manager console, but if it is changed to a value lower than 15%, then the effective threshold will be 15% by default.</maml:para><maml:para>A user can change the minimal threshold by creating MinimalHandleCountIncreaseThreshold registry DWORD (32-bit) value on the appropriate agent and under the appropriate key. The effective threshold will be equal to maximum of two values: the default/overridden threshold via the Operations Manager console and the minimal threshold set in the registry.</maml:para><maml:para>The following registry key is used for the minimal threshold:</maml:para><maml:para>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft Operations
Manager\3.0\Modules\Global\BaseOSProcessMonitoring</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessPercentProcessorTime.Alert" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule generates an alert when processor time consumption by specific process is too high.</maml:para><maml:para><maml:ui>Note:</maml:ui> If the threshold for this rule differs from the corresponding threshold for the "Process Monitoring: Health State Collection" rule, it may lead to inconsistency between alerts and process health states.
              </maml:para><maml:para>To avoid generating excessive alerts, a minimal threshold for the rule was implemented. The default value for minimal threshold is 7%. The threshold can be changed to any value via the overrides for the rule in the Operations Manager console, but if it is changed to a value lower than 7%, then the effective threshold will be 7% by default.</maml:para><maml:para>A user can change the minimal threshold by creating MinimalPercentProcessorTimeThreshold registry DWORD (32-bit) value on the appropriate agent and under the appropriate key. The effective threshold will be equal to maximum of two values: the default/overridden threshold via the Operations Manager console and the minimal threshold set in the registry.</maml:para><maml:para>The following registry key is used for the minimal threshold:</maml:para><maml:para>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft Operations
Manager\3.0\Modules\Global\BaseOSProcessMonitoring</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMemoryPercentage.Alert" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule generates an alert when memory consumption by specific process is too high.</maml:para><maml:para><maml:ui>Note:</maml:ui> Note that if the threshold for this rule differs from the corresponding threshold for the "Process Monitoring: Health State Collection" rule, it may lead to inconsistency between alerts and process health states.
              </maml:para><maml:para>To avoid generating excessive alerts, a minimal threshold for the rule was implemented. The default value for minimal threshold is 7%. The threshold can be changed to any value via the overrides for the rule in the Operations Manager console, but if it is changed to a value lower than 7%, then the effective threshold will be 7% by default.</maml:para><maml:para>A user can change the minimal threshold by creating MinimalMemoryPercentageThreshold registry DWORD (32-bit) value on the appropriate agent and under the appropriate key. The effective threshold will be equal to maximum of two values: the default/overridden threshold via the Operations Manager console and the minimal threshold set in the registry.</maml:para><maml:para>The following registry key is used for the minimal threshold:</maml:para><maml:para>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft Operations
Manager\3.0\Modules\Global\BaseOSProcessMonitoring</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessCount.Collection" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects the Number of Processes performance counter for Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle
ElementID="Microsoft.Windows.Server.10.0.Process.HealthStateSubscription.Rule" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule saves Process and Port Health State information to the SCOM data warehouse. To start information collection, make sure that “Process and Port Monitoring: Health State Collection” rule is enabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetricsSubscription.Rule" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule saves Process and Port Performance Metric information to the SCOM data warehouse. To start information collection, make sure that “Process and Port Monitoring: Performance Collection” rule is
enabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Process.PortSubscription.Rule" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule saves Process Network Port information to the SCOM data warehouse. To start information collection, make sure that “Process and Port Monitoring: Network Port State Collection” rule is enabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Process.HealthState.Collection" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects information about health state of the processes.</maml:para><maml:para><maml:ui>Note:</maml:ui> The thresholds for this rule should be overridden carefully; if the thresholds differ from
those set for the alert rules, it may lead to inconsistency between alerts and process health states.
              </maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Process.PerfMetrics.Collection" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects information about performance metric of the processes.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Process.Ports.Collection" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects information about Network Port State of the ports.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringDisabled.Group" Visible="true"><MamlContent><maml:section
xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This group contains seeds of Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringDisabled.Group.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which process monitoring is disabled via "Add Monitoring Wizard".</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PortMonitoringDisabled.Group" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This group contains seeds of Windows Server 2016 and above
operating systems for which port monitoring is disabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PortMonitoringDisabled.Group.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which port monitoring is disabled via "Add Monitoring Wizard".</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Seed.Group" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This group contains process and port monitoring seeds of Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle
ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringSeedGroup.ContainsProcessSeed" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A relationship between Windows Server 2016 Process and Port Monitoring Seed Group and the process monitoring seeds.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.RunAs.CollectionRules" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Run As profile is used for collecting metrics from the following process collection rules: "Process Monitoring: Network Port State Collection", "Process Monitoring: Performance Collection", and "Process Monitoring: Health State Collection" and for generating alerts for the following alert rules: "Process Monitoring: High Memory Percentage", "Process Monitoring: High
Processor Time Percentage" and "Process Monitoring: High Handle Count".</maml:para><maml:para>Note: High-privilege "NT AUTHORITY\SYSTEM" account should be configured in SCOM for the Run As profile to receive the data regarding username and command line. If a non-system account is used (even with admin rights), the data mentioned above will not be collected properly, because it will be collected in low-privilege mode.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.ContainsWindowsServer.10.0.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A relationship between Windows Server 2016 Enabled Process Monitoring Group and Windows Server 2016 computers.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle
ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.ContainsWindowsServer.10.0.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A relationship between Windows Server 2016 Enabled Port Monitoring Group and Windows Server 2016 computers.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.Group" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This group contains seeds related to Windows Server 2016 and above operating systems for which process monitoring is enabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.Group" Visible="true"><MamlContent><maml:section
xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This group contains seeds of Windows Server 2016 and above operating systems for which port monitoring is enabled.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringEnabled.Group.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule populates the group containing seeds of Windows Server 2016 and above operating systems for which process monitoring is enabled via "Add Monitoring Wizard".</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PortMonitoringEnabled.Group.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule populates
the group containing seeds of Windows Server 2016 and above operating systems for which port monitoring is enabled via "Add Monitoring Wizard".</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.Views.Report.TopNProcesses" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para><maml:ui>How does this report work?</maml:ui></maml:para><maml:para>The Top N Processes report generates a table containing a top number (N) of the processes according to the following metrics:</maml:para><maml:list><maml:listItem><maml:para>CPU Usage</maml:para></maml:listItem><maml:listItem><maml:para>Memory Usage</maml:para></maml:listItem><maml:listItem><maml:para>Handle Count Usage</maml:para></maml:listItem><maml:listItem><maml:para>Thread Count</maml:para></maml:listItem><maml:listItem><maml:para>Page Fault
Count</maml:para></maml:listItem><maml:listItem><maml:para>CPU Time</maml:para></maml:listItem><maml:listItem><maml:para>Total Process Time</maml:para></maml:listItem><maml:listItem><maml:para>IO Read (KiloBytes/s)</maml:para></maml:listItem><maml:listItem><maml:para>IO Write (KiloBytes/s)</maml:para></maml:listItem></maml:list><maml:para /><maml:para>The report table contains a list of records gradated according to the selected metric. The number of displayed records and the time interval can be set manually.</maml:para><maml:para><maml:ui>How to use this report?</maml:ui></maml:para><maml:list><maml:listItem><maml:para>1. Open the Reporting menu in the Operations Manager.</maml:para></maml:listItem><maml:listItem><maml:para>2. Go to Windows Server 2016 and above Process and Port Monitoring tab.</maml:para></maml:listItem><maml:listItem><maml:para>3. Run the Top N Processes report.</maml:para></maml:listItem><maml:listItem><maml:para>4. Select a metric to set an order for the
table.</maml:para></maml:listItem><maml:listItem><maml:para>5. Select a number of the records in the table.</maml:para></maml:listItem><maml:listItem><maml:para>6. Select a time interval and the corresponding time zone for the report.</maml:para></maml:listItem><maml:listItem><maml:para>7. Click the Run button. The report data will be displayed.</maml:para></maml:listItem></maml:list></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoring.ProcessSeed" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>Process monitoring seed of Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ProcessMonitoringSeed.Group.Discovery" Visible="true"><MamlContent><maml:section
xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule populates the Process and Port Monitoring Seed Group of Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle></KnowledgeArticles></LanguagePack><LanguagePack ID="CHS" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="CHT" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and
ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="DEU" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="ESN" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="FRA"
IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="HUN" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="ITA" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port
Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="JPN" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="KOR" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating
systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="NLD" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="PLK" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="PTB" IsDefault="false"><DisplayStrings><DisplayString
ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="PTG" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="RUS" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the
monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="SVE" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating systems..</Description></DisplayString></DisplayStrings></LanguagePack><LanguagePack ID="TRK" IsDefault="false"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.2016.ProcessPortMonitoring"><Name>Windows Server 2016 and above Process and Port Monitoring</Name><Description>This Management Pack enables the monitoring of processes and ports of Microsoft Windows Server 2016 and above operating
systems..</Description></DisplayString></DisplayStrings></LanguagePack></LanguagePacks><Resources><Assembly ID="Res.Microsoft.Windows.Server.2016.Assembly.UI" Accessibility="Public" FileName="Microsoft.Windows.Server.2016.UI.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.2016.UI, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><Assembly ID="Res.Microsoft.Windows.Server.2016.Assembly.Components.WPF" Accessibility="Internal" FileName="Microsoft.Windows.Server.2016.Components.WPF.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.2016.Components.WPF, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><Assembly ID="Res.Microsoft.Windows.Server.2016.Assembly.Visualization.DataProviders.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.2016.Visualization.DataProviders.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.2016.Visualization.DataProviders, Version=10.1.1.0,
Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.GetAllProcessDimension.InstallUpdateScript" Accessibility="Internal" FileName="ProcessMonitoring_Microsoft_Window_Server_GetAllProcessDimension_CreateAlter.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.GetAllProcessDimension.DropScript" Accessibility="Internal" FileName="ProcessMonitoring_Microsoft_Window_Server_GetAllProcessDimension_Drop.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.GetPortState.InstallUpdateScript" Accessibility="Internal" FileName="ProcessMonitoring.Microsoft_Window_Server_GetPortState.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.GetProcessMetricAndState.InstallUpdateScript" Accessibility="Internal"
FileName="ProcessMonitoring.Microsoft_Window_Server_GetProcessMetricAndState.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.GetTopNProcesses.InstallUpdateScript" Accessibility="Internal" FileName="ProcessMonitoring.Microsoft_Window_Server_GetTopNProcesses.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="ProcessMonitoring.Microsoft.Window.Server.DashboardSP.DropScript" Accessibility="Internal" FileName="ProcessMonitoring.Microsoft_Window_Server_SP_Drop.sql" HasNullStream="false" MIMEType="application/octet-stream" /><ReportResource ID="Microsoft.Windows.Server.10.0.ProcessMonitoring.TopNProcesses.rdl" Accessibility="Internal" FileName="TopNProcesses.rdl" HasNullStream="false" MIMEType="application/octet-stream" /><DeployableAssembly ID="Microsoft.Windows.Server.NativeApi.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.NativeApi.dll"
HasNullStream="false" QualifiedName="Microsoft.Windows.Server.NativeApi, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><DeployableAssembly ID="Microsoft.Windows.Server.ProcessMonitoring.Common.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.ProcessMonitoring.Common.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.ProcessMonitoring.Common, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><DeployableAssembly ID="Microsoft.Windows.Server.Common.Loggers.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.Common.Loggers.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.Common.Loggers, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" /><DeployableAssembly ID="Microsoft.Windows.Server.ProcessMonitoring.DataTypes.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.ProcessMonitoring.DataTypes.dll" HasNullStream="false"
QualifiedName="Microsoft.Windows.Server.ProcessMonitoring.DataTypes, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"><Dependency ID="Microsoft.Windows.Server.ProcessMonitoring.Common.Assembly" /></DeployableAssembly><DeployableAssembly ID="Microsoft.Windows.Server.Monitoring.Providers.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.Monitoring.Providers.dll" HasNullStream="false" QualifiedName="Microsoft.Windows.Server.Monitoring.Providers, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"><Dependency ID="Microsoft.Windows.Server.NativeApi.Assembly" /><Dependency ID="Microsoft.Windows.Server.ProcessMonitoring.Common.Assembly" /><Dependency ID="Microsoft.Windows.Server.Common.Loggers.Assembly" /></DeployableAssembly><DeployableAssembly ID="Microsoft.Windows.Server.2016.Modules.Assembly" Accessibility="Public" FileName="Microsoft.Windows.Server.2016.Modules.dll" HasNullStream="false"
QualifiedName="Microsoft.Windows.Server.2016.Modules, Version=10.1.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"><Dependency ID="Microsoft.Windows.Server.NativeApi.Assembly" /><Dependency ID="Microsoft.Windows.Server.ProcessMonitoring.Common.Assembly" /><Dependency ID="Microsoft.Windows.Server.Common.Loggers.Assembly" /><Dependency ID="Microsoft.Windows.Server.ProcessMonitoring.DataTypes.Assembly" /><Dependency ID="Microsoft.Windows.Server.Monitoring.Providers.Assembly" /></DeployableAssembly></Resources></ManagementPack>
