<ManagementPack xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.0"><Manifest><Identity><ID>Microsoft.Windows.Server.2016.Discovery</ID><Version>10.1.0.6</Version></Identity><Name>Microsoft Windows Server 2016 Discovery MP</Name><References><Reference Alias="SCDW"><ID>Microsoft.SystemCenter.DataWarehouse.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="ReportLibrary"><ID>Microsoft.SystemCenter.DataWarehouse.Report.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="SC"><ID>Microsoft.SystemCenter.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="Windows"><ID>Microsoft.Windows.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="SystemHealth"><ID>System.Health.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="System"><ID>System.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="SystemPerf"><ID>System.Performance.Library</ID><Version>6.0.6278.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="WindowsServer"><ID>Microsoft.Windows.Server.Library</ID><Version>10.0.8.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference></References></Manifest><TypeDefinitions><EntityTypes><ClassTypes><ClassType ID="Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.Server.Computer" Hosted="false" Singleton="false" Extension="false"><Property ID="InstallType" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/></ClassType><ClassType ID="Microsoft.Windows.Server.10.0.Nano.Computer" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.Computer" Hosted="false" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Core.Computer" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.Computer" Hosted="false" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Full.Computer" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.Computer" Hosted="false" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.OperatingSystem" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.Server.OperatingSystem" Hosted="true" Singleton="false" Extension="false"><Property ID="InstallType" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="PowerPlan" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/></ClassType><ClassType ID="Microsoft.Windows.Server.10.0.Nano.OperatingSystem" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.OperatingSystem" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Core.OperatingSystem" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.OperatingSystem" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Full.OperatingSystem" Accessibility="Public" Abstract="false" Base="Microsoft.Windows.Server.10.0.OperatingSystem" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.ComputerGroup" Accessibility="Public" Abstract="false" Base="SC!Microsoft.SystemCenter.ComputerGroup" Hosted="false" Singleton="true" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Nano.ComputerGroup" Accessibility="Public" Abstract="false" Base="SC!Microsoft.SystemCenter.ComputerGroup" Hosted="false" Singleton="true" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Core.ComputerGroup" Accessibility="Public" Abstract="false" Base="SC!Microsoft.SystemCenter.ComputerGroup" Hosted="false" Singleton="true" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Full.ComputerGroup" Accessibility="Public" Abstract="false" Base="SC!Microsoft.SystemCenter.ComputerGroup" Hosted="false" Singleton="true" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.DiskPartition" Accessibility="Public" Abstract="false" Base="WindowsServer!Microsoft.Windows.Server.DiskPartition" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public" Abstract="false" Base="WindowsServer!Microsoft.Windows.Server.LogicalDisk" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.NetworkAdapter" Accessibility="Public" Abstract="false" Base="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" Hosted="true" Singleton="false" Extension="false"><Property ID="SlotNumber" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/></ClassType><ClassType ID="Microsoft.Windows.Server.10.0.PhysicalDisk" Accessibility="Public" Abstract="false" Base="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.Processor" Accessibility="Public" Abstract="false" Base="WindowsServer!Microsoft.Windows.Server.Processor" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.Windows.Server.10.0.LogicalProcessor" Accessibility="Public" Abstract="false" Base="System!System.LogicalHardware" Hosted="true" Singleton="false" Extension="false"><Property ID="DeviceID" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="Name" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="Description" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="Manufacturer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="Speed" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="MaxClockSpeed" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/><Property ID="PerfmonInstance" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0"/></ClassType></ClassTypes><RelationshipTypes><RelationshipType ID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk" Accessibility="Public" Abstract="false" Base="System!System.Containment"><Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.DiskPartition"/><Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.LogicalDisk"/></RelationshipType><RelationshipType ID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition" Accessibility="Public" Abstract="false" Base="System!System.Containment"><Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.PhysicalDisk"/><Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.DiskPartition"/></RelationshipType><RelationshipType ID="Microsoft.Windows.Server.10.0.ProcessorHostsLogicalProcessor" Accessibility="Public" Abstract="false" Base="System!System.Hosting"><Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.Processor"/><Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.Windows.Server.10.0.LogicalProcessor"/></RelationshipType></RelationshipTypes></EntityTypes><SecureReferences><SecureReference ID="Microsoft.Windows.Server.10.0.RunAsUnDiscoveryProfile" Accessibility="Public"/></SecureReferences><ModuleTypes><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.CPUDiscovery.ModuleType" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>Microsoft.Windows.Server.DiscoverWindows.10.0.CPU.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID)</PSparam><ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 MPElement ID ($MPElement$)
# 1 Target Id for ME this rule is running against ($Target/Id$)
# 2 Computer (FQDN) that the CPU will be hosted on
# 3 Computer ID (Key) that the CPU will be hosted on

Function Main()
{
	$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)

	if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData) -ne 0)
    { 
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
    }

	$oDiscoveryData
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc)

	$ProcessorTypes = @{[Uint16]1 ="Other";[Uint16]2 = "Unknown";[Uint16]3 ="Central Processor";[Uint16]4 = "Math Processor";[Uint16]5 = "DSP Processor";[Uint16]6 = "Video Processor"}
	$CpuFamilys = @{
					[Uint16]1="Other";[Uint16]2="Unknown";[Uint16]3="8086";[Uint16]4="80286";[Uint16]5="80386";[Uint16]6="80486";[Uint16]7="8087";[Uint16]8="80287";[Uint16]9="80387";[Uint16]10="80487";[Uint16]11="Pentium brand";
					[Uint16]12="Pentium Pro";[Uint16]13="Pentium II";[Uint16]14="Pentium processor with MMX technology";[Uint16]15="Celeron";[Uint16]16="Pentium II Xeon";[Uint16]17="Pentium III";[Uint16]18="M1 Family";[Uint16]19="M2 Family";
					[Uint16]24="K5 Family";[Uint16]25="K6 Family";[Uint16]26="K6-2";[Uint16]27="K6-3";[Uint16]28="AMD Athlon Processor Family";[Uint16]29="AMD Duron Processor";[Uint16]30="AMD29000 Family";[Uint16]31="K6-2+";[Uint16]32="Power PC Family";
					[Uint16]33="Power PC 601";[Uint16]34="Power PC 603";[Uint16]35="Power PC 603+";[Uint16]36="Power PC 604";[Uint16]37="Power PC 620";[Uint16]38="Power PC X704";[Uint16]39="Power PC 750";[Uint16]48="Alpha Family";[Uint16]49="Alpha 21064";
					[Uint16]50="Alpha 21066";[Uint16]51="Alpha 21164";[Uint16]52="Alpha 21164PC";[Uint16]53="Alpha 21164a";[Uint16]54="Alpha 21264";[Uint16]55="Alpha 21364";[Uint16]64="MIPS Family";[Uint16]65="MIPS R4000";[Uint16]66="MIPS R4200";[Uint16]67="MIPS R4400";
					[Uint16]68="MIPS R4600";[Uint16]69="MIPS R10000";[Uint16]80="SPARC Family";[Uint16]81="SuperSPARC";[Uint16]82="microSPARC II";[Uint16]83="microSPARC IIep";[Uint16]84="UltraSPARC";[Uint16]85="UltraSPARC II";[Uint16]86="UltraSPARC IIi";[Uint16]87="UltraSPARC III";
					[Uint16]88="UltraSPARC IIIi";[Uint16]96="68040";[Uint16]97="68xxx Family";[Uint16]98="68000";[Uint16]99="68010";[Uint16]100="68020";[Uint16]101="68030";[Uint16]112="Hobbit Family";[Uint16]120="Crusoe TM5000 Family";[Uint16]121="Crusoe TM3000 Family";
					[Uint16]122="Efficeon TM8000 Family";[Uint16]128="Weitek";[Uint16]130="Itanium Processor";[Uint16]131="AMD Athlon 64 Processor Family";[Uint16]132="AMD Opteron Family";[Uint16]144="PA-RISC Family";[Uint16]145="PA-RISC 8500";[Uint16]146="PA-RISC 8000";
					[Uint16]147="PA-RISC 7300LC";[Uint16]148="PA-RISC 7200";[Uint16]149="PA-RISC 7100LC";[Uint16]150="PA-RISC 7100";[Uint16]160="V30 Family";[Uint16]176="Pentium III Xeon";[Uint16]177="Pentium III Processor with Intel SpeedStep Technology";[Uint16]178="Pentium 4";
					[Uint16]179="Intel Xeon";[Uint16]180="AS400 Family";[Uint16]181="Intel Xeon processor MP";[Uint16]182="AMD AthlonXP Family";[Uint16]183="AMD AthlonMP Family";[Uint16]184="Intel Itanium 2";[Uint16]185="Intel Pentium M Processor";[Uint16]190="K7";
					[Uint16]198="Intel Corei7-2760QM";[Uint16]200="IBM390 Family";[Uint16]201="G4";[Uint16]202="G5";[Uint16]203="G6";[Uint16]204="z/Architecture base";[Uint16]250="i860";[Uint16]251="i960";[Uint16]260="SH-3";[Uint16]261="SH-4";[Uint16]280="ARM";
					[Uint16]281="StrongARM";[Uint16]300="6x86";[Uint16]301="MediaGX";[Uint16]302="MII";[Uint16]320="WinChip";[Uint16]350="DSP";[Uint16]500="Video Processor"
	}

	$error.Clear()
    $WMISet = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_Processor"
	if (0 -ne $error.Count)
	{
		return 1
	}

	$LcpuNumber = [UInt32]0
    $errorCount = 0
	$ErrorActionPreference="SilentlyContinue"

	foreach ($owObj in $WMISet)
    {
		$ProcessorType =  $ProcessorTypes[$owObj.ProcessorType]
		$CpuFamily     =  $CpuFamilys[$owObj.Family]
 		$PerfInstance  =  $owObj.DeviceID.Substring(3)

		$ProcessorType =  Get-StringProperty -Property $ProcessorType
		$CpuFamily     =  Get-StringProperty -Property $CpuFamily
		$PerfInstance  =  Get-StringProperty -Property $PerfInstance
		$PCache        =  Get-CpuCacheSize -oCpu $owObj
		
		$NumberOfLCpu  =  $owObj.NumberOfLogicalProcessors
		$oCPUInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.Processor']$")
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $owObj.DeviceID)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", $owObj.Name)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", $owObj.Description)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Processor']/Family$", $CpuFamily)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Processor']/MaxClockSpeed$", $owObj.MaxClockSpeed)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Processor']/Type$", $ProcessorType)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Processor']/PCache$", $PCache)
		$oCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Processor']/CPUKey$", $owObj.ProcessorId)
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/PerfmonInstance$", $PerfInstance )
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/Speed$", $owObj.CurrentClockSpeed)
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/Manufacturer$", $owObj.Manufacturer)
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/DataWidth$", $owObj.DataWidth)
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/Revision$", $owObj.Revision)
		$oCPUInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor']/Version$", $owObj.Version)

		if (0 -eq $error.Count)
      	{
			  $oDisc.AddInstance($oCPUInstance)
		}

		$errorCount += $error.Count
	    $error.Clear() 

		for ($i = [UInt32]0; $i -lt  $NumberOfLCpu; $i++)
		{
			$LcpuId = "CPU $PerfInstance Logical Cpu $i"
			$LcpuPerfInstance = $LcpuNumber + $i
			$oLCPUInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']$")
			$oLCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
			$oLCPUInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $owObj.DeviceID)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/DeviceID$",$LcpuId)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/Name$", $owObj.Name)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/Description$", $owObj.Description)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/Manufacturer$", $owObj.Manufacturer)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/Speed$", $owObj.CurrentClockSpeed)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/MaxClockSpeed$", $owObj.MaxClockSpeed)
			$oLCPUInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalProcessor']/PerfmonInstance$", $LcpuPerfInstance.ToString() )

			if (0 -eq $error.Count)
      		{
				  $oDisc.AddInstance($oLCPUInstance)
			}

			$errorCount += $error.Count
			$error.Clear() 

      		
            
		}

		$LcpuNumber = $LcpuNumber + $NumberOfLCpu
	}

	return $errorCount
}


Function Get-CpuCacheSize($oCpu)
{
	$CacheSize = 0

	if ([string]::IsNullOrEmpty($oCpu) )
	{
		return "$CacheSize"
	}

	$L2Cache        = $oCpu.L2CacheSize
	$L3Cache        = $oCpu.L3CacheSize

	if ([string]::IsNullOrEmpty($L2Cache))
	{
		$L2Cache = 0
	}

	if ([string]::IsNullOrEmpty($L3Cache))
	{
		$L3Cache = 0
	}

	$CacheSize = $L2Cache + $L3Cache 

	return "$CacheSize"
}

Main

</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.Discovery.DataSource" Accessibility="Internal" RunAs="System!System.PrivilegedMonitoringAccount" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="IntervalSeconds" type="xsd:unsignedInt"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="TimeoutSeconds" type="xsd:unsignedInt"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="SourceId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="0" name="VersionMask" type="xsd:string"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="Microsoft.Windows.Universal.Script.Discovery.DS"><IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds><cScriptName>Microsoft.Windows.Server.10.0.Discovery.Probe.vbs</cScriptName><cScriptParameters>"$Config/SourceId$" "$Target/Id$" "$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$" "$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$" "$Target/Property[Type="Windows!Microsoft.Windows.Server.Computer"]/IsVirtualNode$" "$Config/VersionMask$"</cScriptParameters><cScriptBody>
'Copyright (c) Microsoft Corporation. All rights reserved.

'*************************************************************************
' $ScriptName: "Microsoft.Windows.Server.Common"$
'
' Purpose: To have one place for common stuff across various BaseOS VBScripts
'
' $File: Microsoft.Windows.Server.Common.vbs$
'*************************************************************************

Option Explicit

SetLocale("en-us")

' LogScripEvent Constants
Const lsEventError                 = 1
Const lsEventWarning               = 2
Const lsEventInformation           = 3

' WMI Constants
Const wbemCimtypeUseDefault        = 0   'Use Default Type CIM type - Custom
Const wbemCimtypeSint16            = 2   'Signed 16-bit integer 
Const wbemCimtypeSint32            = 3   'Signed 32-bit integer 
Const wbemCimtypeReal32            = 4   '32-bit real number 
Const wbemCimtypeReal64            = 5   '64-bit real number 
Const wbemCimtypeString            = 8   'String 
Const wbemCimtypeBoolean           = 11  'Boolean value 
Const wbemCimtypeObject            = 13  'CIM object 
Const wbemCimtypeSint8             = 16  'Signed 8-bit integer 
Const wbemCimtypeUint8             = 17  'Unsigned 8-bit integer 
Const wbemCimtypeUint16            = 18  'Unsigned 16-bit integer 
Const wbemCimtypeUint32            = 19  'Unsigned 32-bit integer 
Const wbemCimtypeSint64            = 20  'Signed 64-bit integer  
Const wbemCimtypeUint64            = 21  'Unsigned 64-bit integer 
Const wbemCimtypeDatetime          = 101 'Date/time value 
Const wbemCimtypeReference         = 102 'Reference to a CIM object 
Const wbemCimtypeChar16            = 103 '16-bit character 

Const ErrAction_None               = 0
Const ErrAction_Trace              = 1
Const ErrAction_ThrowError         = 16
Const ErrAction_Abort              = 32
Const ErrAction_ThrowErrorAndAbort = 48

Const DISKSIZE_BYTES_IN_MB = 1048576 

Dim g_ErrorEventNumber, g_TraceEventNumber, g_DebugFlag
g_ErrorEventNumber = 4001
g_TraceEventNumber = 4002
g_DebugFlag = False

'---------------------------------------------------------------------------
' Returns WMI Instance requested. Tries to execute WMI query a N times.
'---------------------------------------------------------------------------
Function WMIGetInstanceExTryN(oWMI, ByVal sInstance, ByVal N)
    Dim oInstance, nInstanceCount
    Dim e, i
    Set e = New Error

    For i = 0 To i &lt; N
        On Error Resume Next
        Set oInstance = oWMI.InstancesOf(sInstance)
        e.Save
        On Error Goto 0
        If IsEmpty(oInstance) Or e.Number &lt;&gt; 0 Then
            If i = N - 1 Then
                ThrowScriptError "The class name '" &amp; sInstance &amp; "' returned no instances.  Please check to see if this is a valid WMI class name.", e
            End If
        Else
            On Error Resume Next
            nInstanceCount = oInstance.Count
            e.Save
            On Error Goto 0
            If e.Number &lt;&gt; 0 Then
                If i = N - 1 Then
                    ThrowScriptError "The class name '" &amp; sInstance &amp; "' did not return any valid instances.  Please check to see if this is a valid WMI class name.", e
                End If
            Else
                Exit For
            End If
        End If
        WScript.Sleep(1000)
    Next

    Set WMIGetInstanceExTryN = oInstance
End Function

'---------------------------------------------------------------------------
' Returns WMI Instance requested.
'---------------------------------------------------------------------------
Function WMIGetInstanceEx(oWMI, ByVal sInstance)
    Dim oInstance, nInstanceCount
    Dim e
    Set e = New Error

    On Error Resume Next
    Set oInstance = oWMI.InstancesOf(sInstance)
    e.Save
    On Error Goto 0
    If IsEmpty(oInstance) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError "The class name '" &amp; sInstance &amp; "' returned no instances.  Please check to see if this is a valid WMI class name.", e
    End If

    'Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oInstance.Count
    e.Save
    On Error Goto 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError "The class name '" &amp; sInstance &amp; "' did not return any valid instances.  Please check to see if this is a valid WMI class name.", e
    End If

    Set WMIGetInstanceEx = oInstance
End Function

'---------------------------------------------------------------------------
' Connect to WMI.
'---------------------------------------------------------------------------
Function WMIConnect(ByVal sNamespace)
    Dim oWMI
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error Goto 0
    If IsEmpty(oWMI) Then
        ThrowScriptError "Unable to open WMI Namespace '" &amp; sNamespace &amp; "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.", e
    End If
    Set WMIConnect = oWMI
End Function

'---------------------------------------------------------------------------
' Returns WMI Instance requested.
'---------------------------------------------------------------------------
Function WMIGetInstance(ByVal sNamespace, ByVal sInstance)
    Dim oWMI, oInstance
    Set oWMI = WMIConnect(sNamespace)
    Set oInstance = WMIGetInstanceEx(oWMI, sInstance)
    Set WMIGetInstance = oInstance
End Function

'---------------------------------------------------------------------------
' Returns WMI Instance requested.
'---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort(ByVal sNamespace, ByVal sInstance)
    Dim oWMI, oInstance, nInstanceCount
    
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    If Not IsEmpty(oWMI) Then
        Set oInstance = oWMI.InstancesOf(sInstance)
        If Not IsEmpty(oInstance) And Err.Number = 0 Then
            'Determine if we queried a valid WMI class - Count will return 0 or empty
            nInstanceCount = oInstance.Count
            If Err.Number = 0 Then
                Set WMIGetInstanceNoAbort = oInstance
                On Error Goto 0
                Exit Function
            End If
        End If
    End If
    
    On Error Goto 0
    Set WMIGetInstanceNoAbort = Nothing
End Function

'---------------------------------------------------------------------------
' Executes the WMI query and returns the result set.
'---------------------------------------------------------------------------
Function WMIExecQuery(ByVal sNamespace, ByVal sQuery)
    Dim oWMI, oQuery, nInstanceCount
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error Goto 0
    If IsEmpty(oWMI) Then
        ThrowScriptError "Unable to open WMI Namespace '" &amp; sNamespace &amp; "'.  Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.", e
    End If

    On Error Resume Next
    Set oQuery = oWMI.ExecQuery(sQuery)
    e.Save
    On Error Goto 0
    If IsEmpty(oQuery) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError "The Query '" &amp; sQuery &amp; "' returned an invalid result set.  Please check to see if this is a valid WMI Query.", e
    End If

    'Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oQuery.Count
    e.Save
    On Error Goto 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError "The Query '" &amp; sQuery &amp; "' did not return any valid instances.  Please check to see if this is a valid WMI Query.", e
    End If

    Set WMIExecQuery = oQuery
End Function

'---------------------------------------------------------------------------
' Executes the WMI query and returns the result set, no abort version.
'---------------------------------------------------------------------------
Function WMIExecQueryNoAbort(ByVal sNamespace, ByVal sQuery)
    Dim oWMI, oQuery
    Set oWMI = GetObject(sNamespace)
    Set oQuery = oWMI.ExecQuery(sQuery)
    Set WMIExecQueryNoAbort = oQuery
End Function

'---------------------------------------------------------------------------
' Retrieves WMI property.
'---------------------------------------------------------------------------
Function GetWMIProperty(oWmi, sPropName, nCIMType, ErrAction)
    Dim sValue, oWmiProp, oError
    Set oError = New Error
    
    ' Check that object is valid.
    If Not IsValidObject(oWmi) Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort "Accessing property on invalid WMI object.", oError
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        GetWMIProperty = ""
        Exit Function
    End If
    
    ' Get properties...
    On Error Resume Next
    Set oWmiProp = oWmi.Properties_.Item(sPropName)
    oError.Save
    If oError.Number &lt;&gt; 0 Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort "An error occurred while accessing WMI property: '" &amp; sPropName &amp; "'.", oError
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
    End If
    On Error Goto 0
    
    If IsValidObject(oWmiProp) Then
        sValue = oWmiProp.Value
        
        If IsNull(sValue) Then ' If value is null, return blank to avoid any issues
            GetWMIProperty = ""
        Else
            Select Case (oWmiProp.CIMType)
                Case wbemCimtypeString, wbemCimtypeSint16, wbemCimtypeSint32, wbemCimtypeReal32, wbemCimtypeReal64, wbemCimtypeSint8, wbemCimtypeUint8, wbemCimtypeUint16, wbemCimtypeUint32, wbemCimtypeSint64, wbemCimtypeUint64:
                    If Not oWmiProp.IsArray Then
                        GetWMIProperty = Trim(CStr(sValue))
                    Else
                        GetWMIProperty = Join(sValue, ", ")
                    End If
                Case wbemCimtypeBoolean:
                    If sValue = 1 Or UCase(sValue) = "TRUE" Then
                        GetWMIProperty = "True"
                    Else
                        GetWMIProperty = "False"
                    End If	
                Case wbemCimtypeDatetime:
                    Dim sTmpStrDate
                    
                    ' First attempt to convert the whole wmi date string
                    sTmpStrDate = Mid(sValue, 5, 2) &amp; "/" &amp; _
                            Mid(sValue, 7, 2) &amp; "/" &amp; _
                            Left(sValue, 4) &amp; " " &amp; _
                            Mid (sValue, 9, 2) &amp; ":" &amp; _
                            Mid(sValue, 11, 2) &amp; ":" &amp; _
                            Mid(sValue, 13, 2)
                    If IsDate(sTmpStrDate) Then
                        GetWMIProperty = CDate(sTmpStrDate)
                    Else
                        ' Second, attempt just to convert the YYYYMMDD 
                        sTmpStrDate = Mid(sValue, 5, 2) &amp; "/" &amp; _
                                Mid(sValue, 7, 2) &amp; "/" &amp; _
                                Left(sValue, 4)
                        If IsDate(sTmpStrDate) Then
                            GetWMIProperty = CDate(sTmpStrDate)
                        Else
                            ' Nothing works - return passed in string 
                            GetWMIProperty = sValue
                        End If
                    End If
                Case Else:
                    GetWMIProperty = ""
            End Select
        End If
    Else
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort "An error occurred while accessing WMI property: '" &amp; sPropName &amp; "'.", oError
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        GetWMIProperty = ""
    End If
    
    If (ErrAction And ErrAction_Trace) = ErrAction_Trace Then _
        WScript.Echo "  + " &amp; sPropName &amp; " :: '" &amp; GetWMIProperty &amp; "'"
End Function

'---------------------------------------------------------------------------
' Class for error handling.
'---------------------------------------------------------------------------
Class Error
    Private m_lNumber
    Private m_sSource
    Private m_sDescription
    Private m_sHelpContext
    Private m_sHelpFile
    Public Sub Save()
        m_lNumber = Err.number
        m_sSource = Err.Source
        m_sDescription = Err.Description
        m_sHelpContext = Err.HelpContext
        m_sHelpFile = Err.helpfile
    End Sub
    Public Sub Raise()
        Err.Raise m_lNumber, m_sSource, m_sDescription, m_sHelpFile, m_sHelpContext
    End Sub
    Public Sub Clear()
        m_lNumber = 0
        m_sSource = ""
        m_sDescription = ""
        m_sHelpContext = ""
        m_sHelpFile = ""
    End Sub
    Public Default Property Get Number()
        Number = m_lNumber
    End Property
    Public Property Get Source()
        Source = m_sSource
    End Property
    Public Property Get Description()
        Description = m_sDescription
    End Property
    Public Property Get HelpContext()
        HelpContext = m_sHelpContext
    End Property
    Public Property Get HelpFile()
        HelpFile = m_sHelpFile
    End Property    
End Class

'---------------------------------------------------------------------------
' Creates an event and sends it back to the mom server.
'---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort(ByVal sMessage, ByVal oErr)
    ' Retrieve the name of this (running) script
    Dim FSO, ScriptFileName
    Set FSO = CreateObject("Scripting.FileSystemObject")
    ScriptFileName = FSO.GetFile(WScript.ScriptFullName).Name
    Set FSO = Nothing
    
    If Not IsNull(oErr) Then _
        sMessage = sMessage &amp; ". " &amp; oErr.Description
    
    On Error Resume Next
    Dim oAPITemp
    Set oAPITemp = CreateObject("MOM.ScriptAPI")
    oAPITemp.LogScriptEvent ScriptFileName, g_ErrorEventNumber, lsEventError, sMessage
    On Error Goto 0
    
    WScript.Echo sMessage
End Function

'---------------------------------------------------------------------------
' Creates an event and sends it back to the mom server.
'---------------------------------------------------------------------------
Function ThrowScriptError(Byval sMessage, ByVal oErr)
    On Error Resume Next
    ThrowScriptErrorNoAbort sMessage, oErr
    Quit()
End Function

'---------------------------------------------------------------------------
' Creates automation objects and returns it.
'---------------------------------------------------------------------------
Function MomCreateObject(ByVal sProgramId)
    Dim oError
    Set oError = New Error
    
    On Error Resume Next
    Set MomCreateObject = CreateObject(sProgramId)
    oError.Save
    On Error Goto 0
    
    If oError.Number &lt;&gt; 0 Then
        ThrowScriptError "Unable to create automation object '" &amp; sProgramId &amp; "'", oError
    End If
End Function

'---------------------------------------------------------------------------
' Quits the script.
'---------------------------------------------------------------------------
Function Quit()
    WScript.Quit()
End Function

'---------------------------------------------------------------------------
' Checks whether oObject is valid.
'---------------------------------------------------------------------------
Function IsValidObject(ByVal oObject)
    IsValidObject = False
    If IsObject(oObject) Then
        If Not oObject Is Nothing Then
            IsValidObject = True
        End If
    End If
End Function

'---------------------------------------------------------------------------
' Outputs arguments for debugging purposes
'---------------------------------------------------------------------------
Function TraceLogArguments
    Dim oArgs
    Set oArgs = WScript.Arguments
    Dim i, sArgs
    For i = 0 To oArgs.Count - 1
        sArgs = sArgs &amp; " {" &amp; oArgs(i) &amp; "}"
    Next
    TraceLogMessage "Arguments:" &amp; sArgs
End Function

'---------------------------------------------------------------------------
' Verifies that number of arguments is correct
'---------------------------------------------------------------------------
Function VerifyNumberOfArguments(ByVal NumberOfArguments)
    Dim oArgs
    Set oArgs = WScript.Arguments
    If oArgs.Count &lt;&gt; NumberOfArguments Then
       Dim i, sArgs
       For i = 0 To oArgs.Count - 1
           sArgs = sArgs &amp; " {" &amp; oArgs(i) &amp; "}"
       Next
       ThrowScriptError "Invalid number of arguments (" &amp; oArgs.Count &amp; " instead of " &amp; NumberOfArguments &amp; "). Arguments:" &amp; sArgs, Null
    End If
End Function

'---------------------------------------------------------------------------
' Outputs to file and echo for debugging purposes
'---------------------------------------------------------------------------
Function TraceLogMessage(ByVal sMessage)
    WScript.Echo sMessage
    
    If g_DebugFlag = True Then
        ' Retrieve the name of this (running) script
        Dim FSO, ScriptFileName
        Set FSO = CreateObject("Scripting.FileSystemObject")
        ScriptFileName = FSO.GetFile(WScript.ScriptFullName).Name
        Set FSO = Nothing
        
        On Error Resume Next
        Dim oAPITemp
        Set oAPITemp = MOMCreateObject("MOM.ScriptAPI")
        oAPITemp.LogScriptEvent ScriptFileName, g_TraceEventNumber, lsEventInformation, sMessage
        On Error Goto 0
    End If
End Function

'---------------------------------------------------------------------------
' Verifies the expression. If equals to False then generates an error and quits the script
'   Usage:
'     Verify Not WMISet Is Nothing, "WMISet is invalid!"
'     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
'---------------------------------------------------------------------------
Function Verify(ByVal bBool, ByVal sMessage)
    If bBool = False Then
        ThrowScriptError sMessage, Null
    End If
End Function

Function GetRegistryKeyValue(ByVal keyPath, ByVal key)
  Dim oReg, strKeyValue

  strKeyValue = ""
  GetRegistryKeyValue = strKeyValue
  On Error Resume Next
    Err.Clear
    Set oReg = CreateObject("WScript.Shell")
    If Err.Number &lt;&gt; 0 Then
      Err.Clear
      Exit Function
    End If
    strKeyValue = oReg.RegRead(keyPath &amp; key)
    If Err.Number &lt;&gt; 0 Then
        Err.Clear
        Exit Function
    End If

    GetRegistryKeyValue = strKeyValue

' resume error
  On Error Goto 0

End Function


'---------------------------------------------------------------------------
' Function: ExpressedInMB
'   Usage:
'     Parameter (SizeInBytes) 
'     Returns the Size Expressed in MBytes
'---------------------------------------------------------------------------
Function ExpressedInMB(byref SizeInBytes)
   Dim NumberSizeExpInMB
   NumberSizeExpInMB = Round(SizeInBytes / DISKSIZE_BYTES_IN_MB, 0)
   ExpressedInMB = NumberSizeExpInMB
End Function

Private Function HasValue(Value)

    Dim bNothing
    
    bNothing = false

    IF ( IsObject(Value) ) THEN
   	    IF (Nothing is Value) THEN
     		bNothing = true
   		END IF
    END IF	

	HasValue = Not ( IsEmpty(Value) or bNothing or IsNull(Value) )
End Function

Function GetServerOsVersionCheck(sComputerName,OsVersion,ByRef IsError)

    On Error Resume Next 
      
        Err.Clear

        Dim strQuery,oWmiSet, sWmiTarget, RegExp, ver, CountOWmi
        IsError = False
        GetServerOsVersionCheck = False

        If ( IsObject(OsVersion)) Then
          Exit Function 
        End If

        sWmiTarget = "."

        If ( Not IsObject(sComputerName)) Then
          If (HasValue(sComputerName) and Len(sComputerName) &gt;0 ) Then
           sWmiTarget = "" &amp; sComputerName
         End If
        End If

        sWmiTarget =  "winmgmts:\\" &amp; sWmiTarget &amp; "\root\cimv2"

        StrQuery    = "select Version from Win32_OperatingSystem where ProductType != 1"
        Set oWmiSet =  WMIExecQueryNoAbort(sWmiTarget, strQuery)
         CountOWmi = oWmiSet.Count
        If Err.Number =  0 Then
            If CountOWmi &gt; 0 Then
                IsError = False
            Else
                IsError = True
                Exit Function
	        End If  
        Else
            IsError = True
            Exit Function
        End If

        Set RegExp = CreateObject("VBScript.RegExp")
	    RegExp.Pattern = OsVersion
        If Err.Number &lt;&gt; 0 Then
           IsError = True
           Exit Function
        End If
         
	    For each ver in oWmiSet 
	    	If (True = RegExp.Test(ver.Version)) Then		    
            	GetServerOsVersionCheck = True
		    Exit For
		End If
	    Next

    On Error Goto 0
End Function
'Copyright (c) Microsoft Corporation. All rights reserved.
                      
' Parameters that should be passed to this script
' 0 MPElement ID 
' 1 Target Id for ME this rule is running against 
' 2 Computer (FQDN) that the OS will be hosted on
' 3 Computer ID (Key) that the OS will be hosted on
' 4 IsVirtualNode

Const Start_SnapShotDiscovery     = 0
Const Exit_SnapShotDiscovery      = 1
Const Exit_IncrementalDiscovery   = 2

Call Main()

Sub Main()
    On Error Resume Next
 
    Dim oArgs
    Dim  SourceID, ManagedEntityId, TargetComputer, TargetComputerID, boolIsVirtualNode, VersionMask, iResult
    Dim ArgCount  
    Dim oAPI, oDiscoveryData
    Dim oError

    Set oError = New Error

    Err.Clear
    Set oAPI = MOMCreateObject("MOM.ScriptAPI")
    Set oArgs = WScript.Arguments
    If (0 &lt;&gt; Err.Number) Then
      oError.Save
      ThrowScriptError "Cannot get script arguments.", oError
    End If
    
    ArgCount = oArgs.Count
    
    If (ArgCount &lt; 4) Then
       ThrowScriptError "Invalid number of arguments (" &amp; ArgCount &amp; " instead of 5." ,Null
    End If    

    SourceID = oArgs(0)
    ManagedEntityId = oArgs(1)
    TargetComputer = oArgs(2)
    TargetComputerID = oArgs(3)

    If (ArgCount &gt;= 5) then
        boolIsVirtualNode = oArgs(4)
    Else
        boolIsVirtualNode = False
    End If
    

    If (ArgCount &gt;= 6) then
        VersionMask = oArgs(5)
    Else
        VersionMask = "10\."
    End If


    Err.Clear
    Set oDiscoveryData = oAPI.CreateDiscoveryData(0, SourceID, ManagedEntityId)
    If (0 &lt;&gt; Err.Number) Then
      ThrowScriptError "Cannot create discovery data object." ,Null
      Quit()
    End If

    iResult = GetSnapshotDiscovery(VersionMask, boolIsVirtualNode)

    If (Start_SnapShotDiscovery = iResult) Then
       If ( False = DoDiscovery(TargetComputer, TargetComputerID, oDiscoveryData) ) Then
          Set oDiscoveryData = oAPI.CreateDiscoveryData(0, SourceID, ManagedEntityId)
          oDiscoveryData.IsSnapShot = False
       End If
    Else
       If  (Exit_IncrementalDiscovery  = iResult) Then
         oDiscoveryData.IsSnapShot = False
       End If
    End If

    Call oAPI.Return(oDiscoveryData)

End Sub


Function DoDiscovery(ByVal sTargetComputer, ByVal sTargetComputerID, ByVal oDisc)
    Dim oInstanceComputer, oInstanceOperatingSystem, InstallationType, IsCore, CoreFull, WMIPowerSet, oPlan, PowerPlan
    Dim computerClassId, OsClassId

    DoDiscovery = False
    On Error Resume Next
        InstallationType = GetRegistryKeyValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\", "InstallationType")
            computerClassId =  "$MPElement[Name='Microsoft.Windows.Server.10.0.Full.Computer']$"
            OsClassId       = "$MPElement[Name='Microsoft.Windows.Server.10.0.Full.OperatingSystem']$"
            CoreFull        = "Full" 

        If (InstallationType = "Server Core") Then
            computerClassId =  "$MPElement[Name='Microsoft.Windows.Server.10.0.Core.Computer']$"
            OsClassId       = "$MPElement[Name='Microsoft.Windows.Server.10.0.Core.OperatingSystem']$"
            CoreFull        = "Core" 
        Else
          If (InstallationType = "Nano Server") Then
            	computerClassId  =  "$MPElement[Name='Microsoft.Windows.Server.10.0.Nano.Computer']$"
            	OsClassId        = "$MPElement[Name='Microsoft.Windows.Server.10.0.Nano.OperatingSystem']$"
            	CoreFull         = "Nano" 
          End If
        End If

        Err.Clear

            Set oInstanceComputer = oDisc.CreateClassInstance(computerClassId)
            Set oInstanceOperatingSystem = oDisc.CreateClassInstance(OsClassId)

       If Err.Number &lt;&gt; 0 Then
            Set oInstanceComputer = Nothing
            Set oInstanceOperatingSystem = Nothing
            Exit Function
        End If
       

        ' Some group policies can restrict accessing to Win32_PowerPlan,
        ' need to handle it gracefully (for more information please see
        ' PS# 162496 in Server Management)
        
        Set WMIPowerSet = WMIExecQueryNoAbort("winmgmts:\\" + sTargetComputer + "\root\cimv2\power", "select ElementName from Win32_PowerPlan where IsActive=true")
        For Each oPlan In WMIPowerSet 
            PowerPlan = oPlan.ElementName
        Next
        If Err.Number &lt;&gt; 0 Then
            PowerPlan = ""
            Err.Clear
        End If
        Set WMIPowerSet = Nothing

        With oInstanceComputer
            .AddProperty "$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", sTargetComputerID
            .AddProperty "$MPElement[Name='Microsoft.Windows.Server.10.0.Computer']/InstallType$", CoreFull
        End With
        With oInstanceOperatingSystem
            .AddProperty "$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", sTargetComputerID
            .AddProperty "$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem']/InstallType$", CoreFull
            .AddProperty "$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem']/PowerPlan$", PowerPlan
        End With

       If Err.Number &lt;&gt; 0 Then
            Exit Function
        End If
 
        Call oDisc.AddInstance(oInstanceComputer)
        Call oDisc.AddInstance(oInstanceOperatingSystem)

        If 0 = Err.Number Then
            DoDiscovery = True
        End If
 
   On Error Goto 0

End Function

Function GetSnapshotDiscovery(OsVersion,IsVirtualNode)

  Dim bIsOsValid,bIsError,iResult,bIsVirtualNode

  On Error Resume Next
        If (HasValue(IsVirtualNode)) Then
              If (0 = Len(IsVirtualNode)) Then
                IsVirtualNode = False
              End If
        Else
          IsVirtualNode = False
        End if

   Err.Clear 
   bIsVirtualNode = CBool(IsVirtualNode)
   
   If Err.Number &lt;&gt; 0 Then
        GetSnapshotDiscovery = Exit_SnapShotDiscovery
        On Error Goto 0
        Exit Function
   End If 

   If (True = bIsVirtualNode)  Then
        GetSnapshotDiscovery = Exit_SnapShotDiscovery
        On Error Goto 0
        Exit Function
   End If

   bIsOsValid = GetServerOsVersionCheck(".",OsVersion,bIsError)

   If (bIsOsValid) Then
     iResult = Start_SnapShotDiscovery
   Else
    If (bIsError) Then
     iResult = Exit_IncrementalDiscovery
    Else
     iResult = Exit_SnapShotDiscovery
    End IF

   End If

   GetSnapshotDiscovery = iResult
End Function
</cScriptBody><PsScriptName>Microsoft.Windows.Server.10.0.Discovery.Probe.ps1</PsScriptName><PowerShellScriptParameters>'$Config/SourceId$' '$Target/Id$' '$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$' '$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$' '$Target/Property[Type="Windows!Microsoft.Windows.Server.Computer"]/IsVirtualNode$'  '$Config/VersionMask$'</PowerShellScriptParameters><PowerShellScriptParam>param($SourceId, $ManagedEntityId, $TargetComputer, $TargetComputerID, $boolIsVirtualNode, $VersionMask)</PowerShellScriptParam><PowerShellScriptBody>$ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$WMI_Partition_To_LogicalDisk = "Win32_LogicalDiskToPartition"
$WMI_Drive_To_Partition       = "Win32_DiskDriveToDiskPartition"
$WMI_DISk_To_Partition        = "Win32_DiskDriveToDiskPartition"

$momAPI = new-object -comObject MOM.ScriptAPI
if ($null -eq $momAPI)
{
   exit
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
	}
}

Load-CimModules

# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576
$DriveLetterMaxSize = 3

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();

		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();
    
	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


    Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    
	$ErrorActionPreference = "SilentlyContinue"

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function CheckCluster
{
    param ([string]$sTargetComputer)

    $error.Clear()
    $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\cimv2" "Select ID, Name from Win32_ServerFeature where Name = 'Failover Clustering'"

    if ($error.Count -gt 0 -or $oInstances.Count -eq 0)
    {
        return $false
    }
    else
    {
        	$ClusterName = (Get-ItemProperty -Path "HKLM:\Cluster" -Name "ClusterName" -ErrorAction SilentlyContinue ).ClusterName
	        return -Not [string]::IsNullOrEmpty($ClusterName)   
    }
}

Function CheckIsClusterDisk
{
    param ([string]$sDeviceID, [string]$sSerialNumber, [bool]$IsCluster, [hashtable]$ClusterVolumes)
    

    $bFlag = $false
	   
    if ($IsCluster -eq $false -or [string]::IsNullOrEmpty($sSerialNumber) )
    {
		return $bFlag
	}
	
	    $SerialNumber = $sSerialNumber.TrimStart("0")
	    $DiskId = $SerialNumber + $sDeviceID
	    $VolId =  $ClusterVolumes[$DiskId]       
	 
	    $bFlag = $VolId -ne $null
         	   
	    return $bFlag
 
}

Function GetClusterDiskCollection
{
    param ([string]$sTargetComputer)

	$Volumes = @{}
    $error.Clear()
    $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\MSCluster" "Select Path, SerialNumber From MSCluster_DiskPartition"

    if ($error.Count -eq 0)
    {
		foreach ($item in $oInstances)
		{
			$hexsn = "{0:X}" -f $item.SerialNumber
			$Path  = $item.Path
			$VolId = $hexsn + $Path  

			if ([string]::IsNullOrEmpty($VolId))
			{
				continue
			}

		   $Volumes[$VolId] = $VolId

		} 
	}

	return $Volumes
}

#---------------------------------------------------------------------------
# Function: SwitchBoolean
#   Usage:
#     Parameter (bIn) 
#     Returns a Boolean
#---------------------------------------------------------------------------
Function SwitchBoolean([string]$bIn)
{
    if ($bIn.ToLower() -eq "false")
    {
        return "true"
    }
    else
    {
        return "false"
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	$error.Clear()
	$IsNano = $IsNano -eq 1

	return $IsNano

}

Function GetPerfmonInstance($sName)
{
    $sName = $sName -replace("\(","[")
    $sName = $sName -replace("\)","]")
    $sName = $sName -replace("/","_")
    $sName = $sName -replace("#","_")

    return $sName
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

Function Get-StringProperty([string]$Property,[int]$MaxSize = 256)
{
	if ([string]::IsNullOrEmpty($Property))
	{
		return [string]::Empty
	}

	if ($Property.Length -gt $MaxSize)
	{
		return $Property.Substring(0,$MaxSize)
	}

	return $Property
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }


Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 MPElement ID 
# 1 Target Id for ME this rule is running against 
# 2 Computer (FQDN) that the OS will be hosted on
# 3 Computer ID (Key) that the OS will be hosted on
# 4 IsVirtualNode

$Start_SnapShotDiscovery     = 0
$Exit_SnapShotDiscovery      = 1
$Exit_IncrementalDiscovery   = 2

Function Main()
{   
	
	$result = Init-ScomHelper

	if ($false -eq $result)
	{
		return
	}

    $oDiscoveryData = Get-DiscoveryData

	if ($null -eq $oDiscoveryData)
	{
		return
	} 

	$ErrorActionPreference  = "SilentlyContinue"

	$SerializeDiscoveryData =  [Scom.Helper.ConvertData]::GetDataItemFromOutput($oDiscoveryData)
	Write-Host "$SerializeDiscoveryData"
}

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc)
    
	$ErrorActionPreference  = "SilentlyContinue"
	$result = $false

        $CoreFull          = "Full"
        $ComputerClassId   = "$MPElement[Name='Microsoft.Windows.Server.10.0.Full.Computer']$"
        $OsClassId         = "$MPElement[Name='Microsoft.Windows.Server.10.0.Full.OperatingSystem']$"
    $InstallationType = GetRegistryKeyValue "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\" "InstallationType"

    if ($InstallationType -eq "Server Core")
    {
        $CoreFull          = "Core"
        $ComputerClassId   = "$MPElement[Name='Microsoft.Windows.Server.10.0.Core.Computer']$"
        $OsClassId         = "$MPElement[Name='Microsoft.Windows.Server.10.0.Core.OperatingSystem']$"
    }
    elseif($InstallationType -eq "Nano Server")
    {
        $CoreFull          = "Nano"
        $ComputerClassId   = "$MPElement[Name='Microsoft.Windows.Server.10.0.Nano.Computer']$"
        $OsClassId         = "$MPElement[Name='Microsoft.Windows.Server.10.0.Nano.OperatingSystem']$"
    }

	$Error.Clear()

        $oInstanceComputer = $oDisc.CreateClassInstance($ComputerClassId)
        $oInstanceOperatingSystem = $oDisc.CreateClassInstance($OsClassId)
 	if (0 -ne $Error.Count)
	{
		return $result
	}

	$PowerPlan = Get-PowerPlan
	$Error.Clear()
    

    $oInstanceComputer.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
    $oInstanceComputer.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.Computer']/InstallType$", $CoreFull)
    $oInstanceOperatingSystem.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
    $oInstanceOperatingSystem.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem']/InstallType$", $CoreFull)
    $oInstanceOperatingSystem.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem']/PowerPlan$", $PowerPlan)

	if (0 -ne $Error.Count)
	{
		return $result
	}


    $oDisc.AddInstance($oInstanceComputer)
    $oDisc.AddInstance($oInstanceOperatingSystem)

	$result =  0 -eq $Error.Count

	return $result

}

Function Get-SnapshotDiscovery($OsVersion,$IsVirtualNode)
{
	$ErrorActionPreference = "SilentlyContinue"

	$bIsVirtualNode = Convert-ToBoolean -sBool $IsVirtualNode
 
	if ($bIsVirtualNode)
	{
		return $Exit_SnapShotDiscovery
	}

	$Filter = "ProductType != 1"
    	$Error.Clear()

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -SessionOption $cimSessionOption 
        $result = Get-CimInstance -CimSession $cimsession -ClassName "Win32_OperatingSystem" -Filter $Filter
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

	if(0 -ne $Error.Count)
	{
		$Error.Clear()
		$result = Get-WmiObject -Class "Win32_OperatingSystem" -Filter $Filter

		if (0 -ne $Error.Count)
		{
			return $Exit_IncrementalDiscovery
		}

	}
	
	if([string]::IsNullOrEmpty($OsVersion))
	{
		$OsVersion = "10\."
	}

	if ($null -eq $result -or -not ($result.Version -match $OsVersion))
	{
		$result = $Exit_SnapShotDiscovery
	}
	else
	    {
			$result = $Start_SnapShotDiscovery
		}

	return $result
}

Function Get-DiscoveryData
{
    $ErrorActionPreference = "SilentlyContinue"
    $Error.Clear()	
    $oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceId, $ManagedEntityId)
	if (0 -ne $Error.Count)
	{
		return $null
	}

    $discoveryType = Get-SnapshotDiscovery -OsVersion $VersionMask -IsVirtualNode $boolIsVirtualNode

    If ($Start_SnapShotDiscovery -eq $discoveryType)
    {
	   $result = DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData
       if ($false -eq $result)
	   {
		      $Error.Clear()	
			  $oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		      $oDiscoveryData.IsSnapshot = $false
	   }
    }
    else
    {
	   if ($Exit_IncrementalDiscovery -eq $discoveryType)
		{
			$oDiscoveryData.IsSnapshot = $false
		}
    }

    return $oDiscoveryData

}

Function Get-PowerPlan
{
	$ErrorActionPreference = "SilentlyContinue"
    $error.Clear()
	$Filter = "IsActive=true"
	$PowerPlan = ""

    # Some group policies can restrict accessing to Win32_PowerPlan,
    # need to handle it gracefully (for more information please see
    # PS# 162496 in Server Management)

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -SessionOption $cimSessionOption 
        $WMIPowerSet = Get-CimInstance -CimSession $cimsession -ClassName "Win32_PowerPlan" -Namespace "root\cimv2\power" -Filter $Filter
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

	if(0 -ne $Error.Count)
	{
		$Error.Clear()
		$WMIPowerSet = Get-WmiObject -Class "Win32_PowerPlan" -Namespace "root\cimv2\power" -Filter $Filter
	}

	if ($null -eq $WMIPowerSet)
	{
	
		return $PowerPlan
	}

	foreach ($oPlan in $WMIPowerSet)
	{ 
		$PowerPlan = $oPlan.ElementName
		break
	}

	if ($error.Count -ne 0)
	{
		$PowerPlan = ""
	}

	return $PowerPlan
}

Main

</PowerShellScriptBody><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></DataSource></MemberModules><Composition><Node ID="Scheduler"/></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType" Accessibility="Internal" RunAs="System!System.PrivilegedMonitoringAccount" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID)</PSparam><ScriptBody>#Copyright (c) Microsoft Corporation. All rights reserved.
                     
# Parameters that should be passed to this script
# 0 MPElement ID ($MPElement$)
# 1 Target Id for ME this rule is running against ($Target/Id$)
# 2 Computer (FQDN) that the Mount Point will be hosted on
# 3 Computer ID (Key) that the Mount Point will be hosted on

Function Main()
{
    $ClusterVolumes = @{}
    $IsCluster = CheckCluster $TargetComputer

    if ($IsCluster -eq $true)
    {
        $ClusterVolumes = GetClusterDiskPartitionCollection $TargetComputer
    }

    $oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)

    if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData $IsCluster $ClusterVolumes) -ne 0)
    { 
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
    } 

	$oDiscoveryData
}


#---------------------------------------------------------------------------
# Function: DoDiscovery
#   Usage:
#     Parameter (sTargetComputer, sTargetComputerID, oDisc) 
#     Returns the Discovery Data Collection
#---------------------------------------------------------------------------
Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc,$IsCluster, [hashtable]$ClusterVolumes)
	
	$error.Clear()
	$IsNano = Is_NanoServer
	if ( $true -eq $IsNano)
	{
		$IsLoad = Load-Module -ModuleName "Storage"

		if($false -eq $IsLoad)
		{
			return 1
		
		}

		$iResult = DiscoverOnNano -oDisc $oDisc -sTargetComputerID $sTargetComputerID -ClusterVolumes $ClusterVolumes -IsCluster $IsCluster
	}
	else
		{
			 $error.Clear()
			 $iResult = DoFullDiscovery -oDisc $oDisc -sTargetComputer $sTargetComputer -sTargetComputerID $sTargetComputerID -ClusterVolumes $ClusterVolumes -IsCluster $IsCluster
			
	       
	    }

    return $iResult
}


Function DiscoverOnNano ($oDisc,$sTargetComputerID,[hashtable]$ClusterVolumes,$IsCluster)
{
	if ([string]::IsNullOrEmpty($sTargetComputerID) -or $null -eq $oDisc )
	{
		return 1 
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
		 
    $objVolumes = Get-Volume
   
	if(0 -ne $error.Count)
	{
		return 1
	}  
	
	$errorCount = 0
   foreach ($objVol in $objVolumes)
   {
            $DeviceId    = $objVol.UniqueId
	        $DriveLetter = $objVol.Driveletter
			$IsClusterVolume = CheckIsClusterVolume -sDeviceID $DeviceId -IsCluster $IsCluster -ClusterVolumes $ClusterVolumes
			if([string]::IsNullOrEmpty($Driveletter) -and ($objVol.DriveType -eq "Fixed") -and ($IsClusterVolume -eq $false) -and $false -eq [string]::IsNullOrEmpty($DeviceId))
			{
				$oInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalDisk']$")
			    if ($null -eq $oInstance -or $null -eq $objVol)
				{
					continue
				}

				Add-VolumePropertyNano -oInstance $oInstance -objVol $objVol -sTargetComputerID $sTargetComputerID
				if(0 -eq $error.Count)
				{
					$oDisc.AddInstance($oInstance)
				}
				
			}
				$errorCount += $error.Count
	            $error.Clear() 
  }

	return $errorCount
}

Function DoFullDiscovery($oDisc,$sTargetComputer,$sTargetComputerID,[hashtable]$ClusterVolumes,$IsCluster)
{

		     $objVolumes  = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" ("Win32_Volume where DriveType = 3 and driveletter = null")
			 $ErrorCount  = $error.Count 
			 if ($ErrorCount -ne 0)
			 {
			   return 1
			 }

		     $MountPoints = Get-MountPoints -sTargetComputer $sTargetComputer
			 $ErrorCount  = $error.Count 
			 $MountDirs   = Get-MountDirs  -sTargetComputer $sTargetComputer
			 $ErrorCount += $error.Count
			 if ($ErrorCount -ne 0)
			 {
			   return 1
			 }

             $ErrorActionPreference="SilentlyContinue"

			 foreach ($objVol in $objVolumes)
			 {
				 $DeviceId = $objVol.DeviceID
				 $IsClusterVolume = CheckIsClusterVolume -sDeviceID $DeviceId -IsCluster $IsCluster -ClusterVolumes $ClusterVolumes
				 $VolName         = StripEndChar -sName $objVol.Name
				 $VolName         = Get-MountDir -MountPoints $MountPoints -MountDirs $MountDirs -VolName $VolName -VolId $DeviceId

				if($false -eq $IsClusterVolume -and $false -eq [string]::IsNullOrEmpty($VolName) )
				{
					$VolumeName = Get-StringProperty -Property $objVol.Label
					$oInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalDisk']$")
					$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $VolName)
					$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", $VolName )
					$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
					$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", "Mounted Disk") #"Description" property of win32_volume is &lt;null&gt;
					$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDisk']/VolumeName$", $VolumeName) 
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/FileSystem$", $objVol.FileSystem)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/Compressed$", $objVol.Compressed)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/Size$", $objVol.Capacity)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeNumeric$", -1)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeInMBs$", (ExpressedInMB $objVol.Capacity) )
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/DriveType$", $objVol.DriveType)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SupportsDiskQuota$", $objVol.SupportsDiskQuotas)
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/QuotasDisabled$", (SwitchBoolean $objVol.QuotasEnabled) )
					$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SupportsFileBasedCompression$", $objVol.SupportsFileBasedCompression)
 			
			        if (0-eq $error.Count) 
					{
							$oDisc.AddInstance($oInstance)
					}
				}

				$errorCount += $error.Count
	            $error.Clear() 

			}

	  return $errorCount
}

Function Add-VolumePropertyNano($oInstance,$objVol,[string]$sTargetComputerID)
{
	if ($null -eq $oInstance -or $null -eq $objVol -or [string]::IsNullOrEmpty($sTargetComputerID) )
	{
		return 
	}

	$VolumeName = Get-StringProperty -Property $objVol.FileSystemLabel
    $oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
	$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", (StripEndChar $objVol.UniqueId) )
	$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", (StripEndChar $objVol.UniqueId) )
	$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", "Mounted Disk")
	$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDisk']/VolumeName$", $VolumeName) 
	$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/FileSystem$", $objVol.FileSystem)
    $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/Size$", $objVol.Size)
    $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeNumeric$", -1)
	$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeInMBs$", (ExpressedInMB $objVol.Size) )
	$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/DriveType$", $objVol.DriveType)

}

#---------------------------------------------------------------------------
# Function: StripEndChar
#   Usage:
#     Parameter (sName) 
#     Returns the sName without last special Character "\"
#---------------------------------------------------------------------------
Function StripEndChar([string]$sName)
{
    if ([string]::IsNullOrEmpty($sName))
    { 
        return [string]::Empty
    }
    else
    {
        return $sName.Substring(0, $sName.Length-1)
    }
}




Function CheckIsClusterVolume
{
    param ([string]$sDeviceID, [bool]$IsCluster, [hashtable]$ClusterVolumes)
    
    $bFlag = $false
	   
    if ($IsCluster -eq $false -or [string]::IsNullOrEmpty($sDeviceID) -or $null -eq $ClusterVolumes )
    {
		return $bFlag
	}

	$ClusterVolId = $ClusterVolumes[$sDeviceID]
    $bflag = $ClusterVolId -ne $null

   return $bFlag
}

Function GetClusterDiskPartitionCollection
{
    param ([string]$sTargetComputer)

    $error.Clear()
	$Volumes = @{}

    $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\MSCluster" "Select VolumeGuid From MSCluster_DiskPartition"

    if ($error.Count -eq 0)
    {
		foreach ($item in $oInstances)
		{
			$VolumeId = "\\?\Volume$($item.VolumeGuid)\" 
			$VolumeId2 =  "\\?\Volume{$($item.VolumeGuid)}\" 
			$Volumes[$VolumeId]  = $VolumeId
			$Volumes[$VolumeId2] = $VolumeId2 

		}
    }

	return $Volumes
}


Function Get-MountDir($MountPoints,$MountDirs,[string]$VolName,[string]$VolId)
{
	if ($null -eq $MountPoints -or $null -eq $MountDirs)
	{
		return $VolName
	}

	if ( [string]::IsNullOrEmpty($VolName) -or [string]::IsNullOrEmpty($VolId) )
	{
		return [string]::Empty
	}

	$MptDirs = $MountPoints[$VolId]
	if ($null -eq $MptDirs -or 0 -eq $MptDirs.Count)
	{
		return [string]::Empty
	}

	$MountDir = [string]::Empty
	foreach ($Dir in $MptDirs.Keys)
	{
		if ($null -ne $MountDirs[$Dir])
		{
			$MountDir = $Dir
			break
		}
	}

	return $MountDir

}

Function Get-MountPoints($sTargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

   $MntPoints = @{}

	if ([string]::IsNullOrEmpty($sTargetComputer))
	{
		return $MntPoints
	}

	$oMnts = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_MountPoint"
	foreach($oMnt in $oMnts)
	{
		$Dir       =  $oMnt.Directory.Name 
		$VolId     =  $oMnt.Volume.DeviceID
			
		if ($true -eq [string]::IsNullOrEmpty($Dir) -or $true -eq [string]::IsNullOrEmpty($VolId) -or $Dir.Length -le $DriveLetterMaxSize)
		{
			continue
		}

		$Dirs = $MntPoints[$VolId]
		if ($null -eq $Dirs)
		{
			$Dirs = @{}
		}

		$Dirs[$Dir] = $Dir

		$MntPoints[$VolId] = $Dirs
	}

   return $MntPoints
}

Function Get-MountDirs($sTargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

   $MntDirs = @{}

	if ([string]::IsNullOrEmpty($sTargetComputer))
	{
		return $MntPoints
	}

	$oMnts = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_PerfFormattedData_PerfDisk_LogicalDisk"
	foreach($oMnt in $oMnts)
	{
		$Dir =   $oMnt.Name 
 		if ($true -eq [string]::IsNullOrEmpty($Dir) -or $Dir.Length -le $DriveLetterMaxSize)
		{
			continue
		}

		$MntDirs[$Dir] = $Dir
	}

   return $MntDirs
}




Main</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType" Accessibility="Internal" RunAs="System!System.PrivilegedMonitoringAccount" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID)</PSparam><ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 MPElement ID ($MPElement$)
# 1 Target Id for ME this rule is running against ($Target/Id$)
# 2 Computer (FQDN) that the Mount Point will be hosted on
# 3 Computer ID (Key) that the Mount Point will be hosted on
# 4 MP Element to be discovered (version-specific type)

Function Main()
{
    $ClusterVolumes = @{}
    
    $IsCluster = CheckCluster $TargetComputer

    if ($IsCluster -eq $true)
    {
        $ClusterVolumes = GetClusterDiskCollection $TargetComputer
    }
    
    $oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)

    if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData $IsCluster $ClusterVolumes) -ne 0)
    { 
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
    }

	$oDiscoveryData
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc, [bool]$IsCluster, [hashtable]$ClusterVolumes)
	
	if($null -eq $oDisc)
	{
		return 0
	}

    $error.Clear()
    $WMISet = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_LogicalDisk WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"
	if (0 -ne $error.Count)
	{
		return 1
	}

	$ErrorActionPreference="SilentlyContinue"
    $error.Clear()
	$errorCount = 0

	foreach ($owObj in $WMISet)
    {
		$sDeviceId     = $owObj.DeviceID
        $IsClusterDisk  = CheckIsClusterDisk $sDeviceId $owObj.VolumeSerialNumber $IsCluster $ClusterVolumes
       
        if ($IsClusterDisk -eq $false -and $false -eq [string]::IsNullOrEmpty($sDeviceId))
        {
			$VolumeName = Get-StringProperty -Property $owObj.VolumeName
            $oInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalDisk']$")
            $oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
            $oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $sDeviceId)
            $oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", $sDeviceId)
            $oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", $owObj.Description)
			$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDisk']/VolumeName$", $VolumeName) 
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/FileSystem$", $owObj.FileSystem)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/Compressed$", $owObj.Compressed)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/Size$", $owObj.Size)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeNumeric$", -1)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SizeInMBs$", (ExpressedInMB $owObj.Size) )
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/DriveType$", $owObj.DriveType)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SupportsDiskQuota$", $owObj.SupportsDiskQuotas)
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/QuotasDisabled$", ((Get-Quota -QuotasDisabled $owObj.QuotasDisabled)) )
            $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDisk']/SupportsFileBasedCompression$", $owObj.SupportsFileBasedCompression)
 
			if (0 -eq $error.Count)
			{
			 	$oDisc.AddInstance($oInstance)
			}
        }

		$errorCount += $error.Count
	    $error.Clear() 
    }

    return $errorCount
}

Function  Get-Quota ($QuotasDisabled)
{
	If ([string]::IsNullOrEmpty($QuotasDisabled))
	{
	   return "true"
	}

			$quota = Convert-ToBoolean -sBool $QuotasDisabled
			$quota = Get-StringProperty -Property $quota.ToString()

	       return $quota
}

Main
</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DiscoverDisabledNetworkAdapters" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="UseMacAddress" type="xsd:boolean"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/><OverrideableParameter ID="DiscoverDisabledNetworkAdapters" Selector="$Config/DiscoverDisabledNetworkAdapters$" ParameterType="bool"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID, $IsDiscoverDisabled, $IsUseMacAddress)</PSparam><ScriptBody>#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 MPElement ID ($MPElement$)
# 1 Target Id for ME this rule is running against ($Target/Id$)
# 2 Computer (FQDN) that the Network Adapter will be hosted on
# 3 Computer ID (Key) that the Network Adapter will be hosted on
# 4 Should we discover disabled Network Adapters or not
# 5 Use MacAddress for discovery (true), otherwise NetConnectionID

Function Main()
{   
	$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)

	if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData $IsDiscoverDisabled $IsUseMacAddress) -ne 0)
    { 
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
    } 

	$oDiscoveryData
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc, $IsDiscoverDisabled, $IsUseMacAddress)

	$ErrorActionPreference = "SilentlyContinue"

	$bIsUseMacAddress        = Convert-ToBoolean -sBool $IsUseMacAddress
	$bIsDiscoverDisabled     = Convert-ToBoolean -sBool $IsDiscoverDisabled
    
	$bLoad = Load-Module -ModuleName "NetAdapter"
    if ($false -eq $bLoad)
	{
		return 1
	} 
	
	$bLoad = Load-Module -ModuleName "DnsClient"
    if ($false -eq $bLoad)
	{
		return 1
	}

	$error.Clear()
		$netAdapters = Get-NetAdapter | Where  `
		 { 
		   (
			  (($true -eq $bIsUseMacAddress -and $false -eq [string]::IsNullOrEmpty($_.MacAddress))  -or $false-eq $bIsUseMacAddress)  `
			 -and (($true -eq $bIsDiscoverDisabled -and $_.MediaConnectState -ne 2 ) -or $false -eq $bIsDiscoverDisabled )  `
			 -and $false -eq [string]::IsNullOrEmpty($_.Name)
		   )
	     } 

	  if ($error.Count -ne 0)
	  {
		  $iResult = 1
		  return $iResult
	  }  

	    $errorCount = 0
		foreach ($netAdapter in $netAdapters)
		{
			$sDeviceId      = Get-StringProperty -Property $netAdapter.DeviceID
			$InterfaceIndex = $netAdapter.InterfaceIndex
			if ([string]::IsNullOrEmpty($sDeviceId))
			{
			  continue
			}
			    $error.Clear()
			    $oInstance = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.NetworkAdapter']$")
			    if ($error.Count -ne 0)
			    {
				  $errorCount    += $error.Count 
				  break
				}
			    
				Add-MainDiscovery -oInstance $oInstance -netAdapter $netAdapter -sDeviceId $sDeviceId -sTargetComputerID $sTargetComputerID -InterfaceIndex $InterfaceIndex 
				$errorCount    += $error.Count 
			    
				Add-NetConfig -oInstance $oInstance -ifIndex $InterfaceIndex
				$errorCount    += $error.Count 
               
			    if ($null -ne $oInstance)
				{
				    $oDisc.AddInstance($oInstance)
				}
			    
		}
	  
	  if ($errorCount -eq 0)
	  {
		 $iResult = 0
	  }  
	  else
	      {
			  $iResult = 1
		  }

		return $iResult;
}

    Function Add-MainDiscovery($oInstance,$netAdapter,$sDeviceId,$sTargetComputerID,$InterfaceIndex)
    {
		$ErrorActionPreference = "SilentlyContinue"
		if ($null -eq $oInstance -or $null -eq $netAdapter)
		{
			return
		}

			    $InterfaceGuid  = $netAdapter.InstanceID
			    $InterfaceDesc  = GetPerfmonInstance $netAdapter.InterfaceDescription  
				$serviceName    = Get-ServiceName -DriverName $netAdapter.DriverName
			    $SlotNumber     = Get-SlotNumber -InterfaceGuid $InterfaceGuid
			    $DhcpServers    = Get-IpV4DhcpServers -InterfaceId $InterfaceGuid
		        $AdapterType    = Get-NicAdapterType -MediaType $netAdapter.MediaType

				$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
				$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $sDeviceId)
				$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", (Get-StringProperty -Property $netAdapter.Name))
				$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", (Get-StringProperty -Property $netAdapter.Description))
				$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.NetworkAdapter']/ProductName$", (Get-StringProperty -Property $netAdapter.DriverDescription))
				$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/AdapterType$", (Get-StringProperty -Property $AdapterType))
				$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/Index$", (Get-StringProperty -Property $InterfaceIndex))
				$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/Manufacturer$", (Get-StringProperty -Property $netAdapter.DriverProvider))
				$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/MACAddress$", (Get-StringProperty -Property $netAdapter.MACAddress))
			    $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/ServiceName$",(Get-StringProperty -Property  $serviceName))
				$oInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", (Get-StringProperty -Property $netAdapter.Name))
				$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/PerfmonInstance$", (Get-StringProperty -Property  $InterfaceDesc) )
			    $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/DHCPServer$", (Get-StringProperty -Property  $DhcpServers) )
				$oInstance.AddProperty("$MPElement[Name='Microsoft.Windows.Server.10.0.NetworkAdapter']/SlotNumber$", $SlotNumber )

	}

	Function Get-NicAdapterType($MediaType)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$result = "Unknown"

	if([string]::IsNullOrEmpty($MediaType) )
	{
		return $result
	}

    $NdisMediaType = Convert-ToUint32 -Value $MediaType
	
	$AdapterTypes = @{
		[uint32]0 = "Ethernet 802.3";[uint32]1 = "Ethernet 802.5";[uint32]2 = "FDDI";[uint32]3 = "WAN";[uint32]4 = "LocalTalk";[uint32]5 = "DIX";[uint32]6 = "Raw Arcnet";
		[uint32]7 = "Ethernet 878.2";[uint32]8 = "ATM";[uint32]9 = "Wireless WAN";[uint32]10 = "IRDA";[uint32]11 = "BPC";[uint32]12 = "Connection Oriented WAN";[uint32]13 = "IP 1394";
		[uint32]14 = "IB";[uint32]15 = "Tunnel";[uint32]16 = "Native 802.11";[uint32]17 = "Loopback";[uint32]18 = "WiMAX";[uint32]19 = "IP"
	}

	$result = $AdapterTypes[$NdisMediaType]
	if ($null -eq $result)
	{
		$result = "Unknown"
	}

	return $result
}

Function Convert-ToUint32($Value)
{
	$ErrorActionPreference = "SilentlyContinue"

	$result = [uint32]0

	if ([string]::IsNullOrEmpty($value))
	{
		return $result
	}

	$result = [uint32]::MaxValue
	$type = $Value.GetType()
	$error.Clear()

	$result = [uint32]$Value
	if (0 -eq $error.Count)
	{
		return $result
	}
	else
	{
		$error.Clear()
		$Value = [int32]$Value 
		if (0 -ne $error.Count)
		{
			$error.Clear()
			return $result
		}
		else
		    {
               if ($Value -lt 0)
				{
					$result = [uint32](-bnot $Value) + [uint32]([int32]::MaxValue) + 1
				}
				else
				    {
						$result = [uint32]$Value
					}
				
			}
	}

	return $result
}

	Function Get-ServiceName($DriverName)
	{
		$ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

		$DriverNameProperty = Get-ServiceNameHelper -DriverName $DriverName
		if ($error.Count -ne 0)
		{
			$DriverNameProperty = [string]::Empty
		}

		return $DriverNameProperty
		
	}

	Function Get-ServiceNameHelper([string]$DriverName)
	{
		$ErrorActionPreference = "SilentlyContinue"

		if ([string]::IsNullOrEmpty($DriverName))
		{
			return [string]::Empty
		}

		$PathIndex = $DriverName.LastIndexOf("\")

		if ($PathIndex -eq ($DriverName.Length - 1))
		{
			return [string]::Empty
		}

		$DriverNamePostfix = $DriverName.Substring($PathIndex + 1)
		$PathIndex = $DriverNamePostfix.IndexOf(".")

		$ServiceName = $DriverNamePostfix
		if (-1 -ne $PathIndex )
		{
			$ServiceName = $DriverNamePostfix.Substring(0,$PathIndex)
		}


		return $ServiceName
		
	}

	Function Get-NetIpConfig($ifIndex)
	{
		$ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

		$netcfg = Get-NetIPConfiguration -ifIndex $ifIndex
		$error.Clear()

		return $netcfg
	}

	Function Get-IPAddressString ($NetIpConfig,[int]$MaxSize=256)
	{
		$ips = $NetIpConfig.AllIPAddresses | Where {($_.PrefixOrigin -ieq "Dhcp" -or $_.PrefixOrigin -ieq "Manual") -or ($_.AddressFamily -eq "IPV6")}

		return Get-StringFromIpArray -ips $ips
	}

	Function Get-DefaultGW ($NetIpConfig,[int]$MaxSize=256)
	{
		if ($null -eq $NetIpConfig)
		{
			return [string]::Empty
		}

		$ips = $NetIpConfig.IPv4DefaultGateway 

		return Get-StringFromIpArray -ips $ips -Property "NextHop" -MaxSize $MaxSize
	}

	Function Get-DhcpStatus ($NetIpConfig)
	{
		$dhcp = $NetIpConfig.AllIPAddresses | Where {$_.PrefixOrigin -ieq "Dhcp" }
		if ($null -eq $dhcp -or 0 -eq $dhcp.Count)
		{
			$DhcpEnabled = "false"
		}
		else
		    {
				$DhcpEnabled = "true"

			}

		return $DhcpEnabled
	}

	Function Get-IPSubNetString ($NetIpConfig,[int]$MaxSize=256)
	{
		if ($null -eq $NetIpConfig)
		{
			return [string]::Empty
		}

		$ips = $NetIpConfig.AllIPAddresses | Where {$_.PrefixOrigin -ieq "Dhcp" -or $_.PrefixOrigin -ieq "Manual"}
		return Get-SubNetFromIpArray -ips $ips
		
	}
	Function Get-IpSubnetFromPrefix([int]$Prefix)
	{
		if ($Prefix -gt 32)
		{
			return "$Prefix"
		}

		$Subnet = @(0..3)
		$Subnet[0] = 0
		$Subnet[1] = 0
		$Subnet[2] = 0
		$Subnet[3] = 0

		if ($Prefix -le 8)
		{
			$Subnet[0] = (1 -shl 8) - (1 -shl (8 - $Prefix))
		}
		elseif ($Prefix -le 16)
		                       {
								   $tprefix = $Prefix - 8
								   $Subnet[0] = 255
								   $Subnet[1] = (1 -shl 8) - (1 -shl (8 - $tprefix)) 
							   }
			elseif ($Prefix -le 24)
								   {
									   $tprefix = $Prefix - 16
									   $Subnet[0] = 255
									   $Subnet[1] = 255
									   $Subnet[2] = (1 -shl 8) - (1 -shl (8 - $tprefix))
								   }
								   elseif ($Prefix -le 32)
														 {
															$tprefix = $Prefix - 24
															$Subnet[0] = 255
															$Subnet[1] = 255
															$Subnet[2] = 255
															$Subnet[3] = (1 -shl 8) - (1 -shl (8 - $tprefix))
														}

		return [string]::Join(".",$Subnet)
		    
	}

	Function Get-StringFromIpArray($ips,[string]$Property="IPAddress",[int]$MaxSize=256)
	{
		$ErrorActionPreference = "SilentlyContinue"

		$IpCount = Get-IpCount -ips $ips
		if ( 0 -eq $IpCount -or $null -eq $IpCount)
		{
				return [string]::Empty
		}

		$Length = 0;
		$IpRealCount = 0

		$IpArray = @(1..$IpCount)


		foreach ($ip in $ips)
		{
			$ipAddr = $ip.$Property
			$IpLength = $ipAddr.Length
			if ($null -eq $IpLength -or 0 -eq $IpLength)
			{
				continue
			}

			$delta = $MaxSize - $Length
			if (0 -ne $IpRealCount)
			{
				$delta--
			}

			if ( $IpLength -gt $delta)
			{
				continue
			}

			$IpArray[$IpRealCount] = $ipAddr
			$Length += $IpLength
			if (0 -ne $IpRealCount)
			{
				$Length++
			}

			$IpRealCount++
		}

		$sResult = [string]::Empty
		if (0 -ne $IpRealCount)
		{
 			for ($i = $IpRealCount;$i -lt $IpCount; $i++)
			{
				$IpArray[$i] = [string]::Empty
			}

			$sResult = [string]::join(",",$IpArray).Trim(",")
		}
		
		return $sResult
	}

	Function Get-SubNetFromIpArray($ips,[string]$Property="PrefixLength",[int]$MaxSize=256)
	{
		$ErrorActionPreference = "SilentlyContinue"

		$IpCount = $ips.Count
		$IpCount = Get-IpCount -ips $ips
		if ( 0 -eq $IpCount -or $null -eq $IpCount)
		{
				return [string]::Empty
		}

		$Length = 0;
		$IpRealCount = 0

		$IpArray = @(1..$IpCount)

		$ipSubNetPrefix = [int]0
		foreach ($ip in $ips)
		{
			$subnetP = $ip.$Property
			if ([string]::IsNullOrEmpty($subnetP))
			{
				$ipSubNetPrefix = 0
			}
			else
			    {
					[void][int]::TryParse($subnetP,[ref]$ipSubNetPrefix)
				}

			$ipSubnet = Get-IpSubnetFromPrefix -Prefix $ipSubNetPrefix
			$IpLength = $ipSubnet.Length
			if ($null -eq $IpLength -or 0 -eq $IpLength)
			{
				continue
			}

			$delta = $MaxSize - $Length
			if (0 -ne $IpRealCount)
			{
				$delta--
			}

			if ( $IpLength -gt $delta)
			{
				continue
			}

			$IpArray[$IpRealCount] = $ipSubnet
			$Length += $IpLength
			if (0 -ne $IpRealCount)
			{
				$Length++
			}

			$IpRealCount++
		}

		$sResult = [string]::Empty
		if (0 -ne $IpRealCount)
		{
 			for ($i = $IpRealCount;$i -lt $IpCount; $i++)
			{
				$IpArray[$i] = [string]::Empty
			}

			$sResult = [string]::join(",",$IpArray).Trim(",")
		}
		
		return $sResult
	}


	Function Get-SlotNumber([string]$InterfaceGuid)
	{
		$ErrorActionPreference = "SilentlyContinue"

		$nic = Get-NetAdapterHardwareInfo | Where {$_.InstanceId -ieq $InterfaceGuid}
		$SlotNumber = $nic.SlotNumber
		$error.Clear()
		
		return "$SlotNumber"
	}

	Function Add-NetConfig($oInstance,$ifIndex)
	{
		$ErrorActionPreference = "SilentlyContinue"
		if ($null -eq $oInstance)
		{
			return
		}

		$netcfg = Get-NetIpConfig -ifIndex $ifIndex

		if ($null -eq $netcfg)
		{
			return
		}

		$dhcp      = Get-DhcpStatus -NetIpConfig $netcfg
		$IpAddr    = Get-IPAddressString -NetIpConfig $netcfg 
		$IpSubnets = Get-IPSubNetString  -NetIpConfig $netcfg 
		$IpEnabled = (-Not [string]::IsNullOrEmpty($IpAddr)).ToString()
		$DefaultGw = Get-DefaultGW -NetIpConfig $netcfg

		$dnsData   = Get-DnsClientGlobalSetting  
		if ($null -eq $dnsData)
		{
			$domain = [string]::Empty
		}
		else
		    {
				$domain = [string]::Join(",",$dnsData.DNSSuffixesToAppend)
				$domain = Get-StringProperty -Property $domain

			}

		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.NetworkAdapter']/IPEnabled$", $IpEnabled)
		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.NetworkAdapter']/DefaultIPGateway$", $DefaultGw)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/IPAddress$", $IPAddr )		
        $oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/IPSubnet$", $IPSubnets )
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/DHCPEnabled$", $dhcp )
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.NetworkAdapter']/DNSDomain$", $domain )
		
	}

Function Get-IpV4DhcpServers([string]$InterfaceId)
{
	$ErrorActionPreference="SilentlyContinue"
	$DhcpServers = (Get-Item "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\$InterfaceId").GetValue("DhcpServer")
	
	if ([string]::IsNullOrEmpty($DhcpServers))
	{
		$DhcpServers = [string]::Empty
	}

	$error.Clear()

	return $DhcpServers

}

Function Get-IpCount($ips)
{
	$ErrorActionPreference = "SilentlyContinue"
	$IpCount = $ips.Count
	if ( $null -eq $IpCount)
	{
        if ($null -ne $ips) 
		{
			$IpCount = 1
		}
 	}
    
	return $IpCount
}

Main
</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter><Parameter><Name>IsDiscoverDisabled</Name><Value>$Config/DiscoverDisabledNetworkAdapters$</Value></Parameter><Parameter><Name>IsUseMacAddress</Name><Value>$Config/UseMacAddress$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.PhysicalDiskDiscovery.ModuleType" Accessibility="Internal" RunAs="System!System.PrivilegedMonitoringAccount" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>Microsoft.Windows.Server.DiscoverWindows.10.0.PhysicalDisks.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID)</PSparam><ScriptBody>Function Add-LogicalDiskToPartition([string]$PartitionId,[string]$LogicalDiskPerfId,[HashTable]$PartToLogicalDisk)
{
		if ([string]::IsNullOrEmpty($PartitionId) -or [string]::IsNullOrEmpty($LogicalDiskPerfId) )
		{
			return 
		}

		$PartToLogicalDisk[$PartitionId] = $LogicalDiskPerfId
}

Function Add-DiskToPartition([string]$PartitionId,[string]$DiskId,[HashTable]$DiskToPartition)
{

		if ([string]::IsNullOrEmpty($PartitionId) -or [string]::IsNullOrEmpty($DiskId) -or $null -eq $DiskToPartition)
		{
			return 
		}

	    $Partitions = $DiskToPartition[$DiskId]
        
	    if ($null -eq $Partitions)
		{
		   $Partitions = @()
		}

	    $Partitions +=  $PartitionId

		$DiskToPartition[$DiskId] = $Partitions
}

Function Get-PerfInstancePostFix($oSet,[HashTable]$PartToLogicalDisk,[bool]$IsSet = $true)
{
	$PerfPostFix = [string]::Empty
	$iCount      = $oSet.Count

	if (0 -eq $iCount -or $null -eq $oSet)
	{
		return $PerfPostFix 
	}

	if ($null -eq $iCount)
	{
		$iCount = 1 
	}

	$PerfInstance = @(1..$iCount)
    $Index = 0

	foreach ($owObj in $oSet)
    {
		if ($true -eq $IsSet)
		{
			$PartitionId = $owObj.DeviceID
		}
		else
			{
				$PartitionId = $owObj
			}

		if ([string]::IsNullOrEmpty($PartitionId))
		{
			continue
		}
				$PerfPostFix = $PartToLogicalDisk[$PartitionId]
				if($null -ne $PerfPostFix)
				{
					$PerfInstance[$Index] = $PerfPostFix
					$Index++
				}
	
	}

	if (0 -ne $Index)
	{
			for ($i = $Index;$i -lt $iCount; $i++)
			{
				$PerfInstance[$i] = [string]::Empty
			}

		$PerfPostFix = [string]::Join(" ",$PerfInstance).Trim(" ")
	}

	return $PerfPostFix
}

Function Get-PartitionToLogicalDiskTable($sTargetComputer)
{
	$PartToLogicalDisk = @{}
	$oWMISet= WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" $WMI_Partition_To_LogicalDisk

	foreach ($owObj in $oWMISet)
	{
		$PartitionId        = $owObj.Antecedent.DeviceId
		$LogicalDiskPerfId  = $owObj.Dependent.DeviceId

		Add-LogicalDiskToPartition -PartitionId $PartitionId -LogicalDiskPerfId $LogicalDiskPerfId -PartToLogicalDisk $PartToLogicalDisk

	}

	return $PartToLogicalDisk 
}

Function Get-DiskToPartitionTable($sTargetComputer)
{

	$DiskToPartition = @{}
	$oWMISet= WMIGetInstanceNoAbort $sTargetComputer "root\cimv2"  $WMI_DISk_To_Partition

	foreach ($owObj in $oWMISet)
	{
		$DiskId        = $owObj.Antecedent.DeviceId
		$PartitionId  = $owObj.Dependent.DeviceId

		Add-DiskToPartition -PartitionId $PartitionId -DiskId $DiskId -DiskToPartition $DiskToPartition

	}

	return $DiskToPartition
}

Function Get-DiskToPartitionPerfInstance($sTargetComputer)
{

	$DiskToPerfInstance = @{}
    $PartToLogicalDisk     =  Get-PartitionToLogicalDiskTable -sTargetComputer $sTargetComputer
	$DiskToPartitionTable  =  Get-DiskToPartitionTable -sTargetComputer $sTargetComputer
	foreach ($DiskId in $DiskToPartitionTable.Keys)
	{
		$sPerfInstance      = [string]::Empty
		$oSet               = $DiskToPartitionTable[$DiskId]

		$PerfInstancePostfix = Get-PerfInstancePostFix -oSet $oSet -PartToLogicalDisk $PartToLogicalDisk -IsSet $false

		if (-Not [string]::IsNullOrEmpty($PerfInstancePostfix))
		{
			$sPerfInstance += $PerfInstancePostfix
		}

		$DiskToPerfInstance[$DiskId] = $sPerfInstance
	}	

	return $DiskToPerfInstance
}

Function Get-LogicalDiskSerialNmber([string]$TargetComputer,[string]$LogicalDiskId)
{
	if ([string]::IsNullOrEmpty($LogicalDiskId) )
	{
	   return [string]::Empty
	}

	 $Query = "Select VolumeSerialNumber From Win32_LogicalDisk Where DeviceID='$LogicalDiskId'"
     $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\cimv2" $Query
	 
	 $SerialNumber = [string]::Empty
	 if (0 -ne $oInstances.Count )
	 {
		 $SerialNumber = $oInstances[0].VolumeSerialNumber
		 if($null -eq $SerialNumber)
		 {
			 $SerialNumber = [string]::Empty
		 }
	 }

	return $SerialNumber
}

Function GetHddPerfmonInstance
{
    param ( [string]$DriveId, [string]$Index,[HashTable]$DiskPerfInstance)

	$sPerfInstance      = "$Index "

	$PerfInstancePostfix    = $DiskPerfInstance[$DriveId]
	if (-Not [string]::IsNullOrEmpty($PerfInstancePostfix))
	{
		$sPerfInstance += $PerfInstancePostfix
	}
	
	return $sPerfInstance
}

#Copyright (c) Microsoft Corporation. All rights reserved.
#Include DiskLibrary First               
# Parameters that should be passed to this script
# 0 MPElement ID ($MPElement$)
# 1 Target Id for ME this rule is running against ($Target/Id$)
# 2 Computer (FQDN) that the CPU will be hosted on
# 3 Computer ID (Key) that the CPU will be hosted on

Function Main()
{
	$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)

	if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData) -ne 0)
    { 
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
    } 

	$oDiscoveryData
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc)

    $WMISet                = WMIGetInstance $sTargetComputer "root\cimv2" "Win32_DiskDrive"
	$ErrorActionPreference = "SilentlyContinue"
    $error.Clear()
    $DiskPerfInstance     =  Get-DiskToPartitionPerfInstance -sTargetComputer "."
	if(0 -ne $error.Count -or $null -eq $DiskPerfInstance)
	{
		return 1
	}
	
    $errorCount = 0
	foreach ($owObj in $WMISet)
    {
		$DeviceId      = $owObj.DeviceId
		$Index         = $owObj.Index

		if ([string]::IsNullOrEmpty($DeviceId) -or [string]::IsNullOrEmpty($Index))
		{
			continue
		}

        $PerfInstance  = GetHddPerfmonInstance -DriveId $DeviceId -Index $Index  -DiskPerfInstance $DiskPerfInstance
 		$Model        = $owObj.Model
		$Manufacturer = Get-HddManufacturer -Model $Model -sManufacturer $owObj.Manufacturer
		$Model        = Get-StringProperty -Property $Model
		$Manufacturer = Get-StringProperty -Property $Manufacturer

		$oInstance    = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.PhysicalDisk']$")
		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $DeviceId)
		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Name$", $owObj.Name)
		$oInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/Description$", $owObj.Description)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/Caption$", $owObj.Caption)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/Index$", $Index)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/InterfaceType$", $owObj.InterfaceType)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/Manufacturer$", $Manufacturer)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/Model$",$Model )
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/SCSIBus$", $owObj.SCSIBus)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/SCSILogicalUnit$", $owObj.SCSILogicalUnit)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/SCSIPort$", $owObj.SCSIPort)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/SCSITargetID$", $owObj.SCSITargetID)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/Size$", $owObj.Size)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/TotalCylinders$", $owObj.TotalCylinders)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/TotalHeads$", $owObj.TotalHeads)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/TotalSectors$", $owObj.TotalSectors)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/TotalTracks$", $owObj.TotalTracks)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/TracksPerCylinder$", $owObj.TracksPerCylinder)
		$oInstance.AddProperty("$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDisk']/PerfmonInstance$", $PerfInstance)
		$oInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", "Disk " + $owObj.Index)

		if (0 -eq $error.Count)
		{
      		$oDisc.AddInstance($oInstance)
		}

	    $errorCount += $error.Count
	    $error.Clear() 
	}
	
	return $errorCount
}

Function Get-HddManufacturer ([string]$Model,[string]$sManufacturer)
{
	$Manufacturer = [string]::Empty
	if([string]::IsNullOrEmpty($Model))
	{
		return $Manufacturer
	}

	$HModel = $Model.Trim(" ")

	$Manufacturer = Get-HddManuFacturerByCode -Model $HModel

	if([string]::IsNullOrEmpty($Manufacturer) )
	{
		$SpaceIndex = $HModel.IndexOf(" ")

		if (-1 -ne $SpaceIndex)
		{
			$Manufacturer = $HModel.Substring(0,$SpaceIndex)
		}
		else
		    {
				$Manufacturer = [string]::Empty
			}
	}
	
	if([string]::IsNullOrEmpty($Manufacturer) )
	{
	   $Manufacturer = $sManufacturer
	}

	return $Manufacturer
}

Function Get-HddManuFacturerByCode([string]$Model)
{
	$Manufacturer = [string]::Empty
	if([string]::IsNullOrEmpty($Model))
	{
		return $Manufacturer
	}

	if ($Model.Length -lt 2)
	{
		return $Manufacturer
	}

	$M2Prefix = $Model.Substring(0,2)

	$Vendors2Prefix = @{
     "HT" = "Hitachi";"HM" = "Hitachi";"IC" = "Hitachi";"DK" = "Hitachi";"DJ" = "Hitachi";"ST" = "Seagate";"WD" = "Western Digital";
	 "HE" = "Samsung";"MQ" = "Toshiba";"MG" = "Toshiba";"MK" = "Toshiba";"MD" = "Toshiba";"MC" = "Toshiba";"PX" = "Toshiba";"AL" = "Toshiba";"PT" = "Patriot";

	}

	$Vendors3Prefix = @{
     "HUS" = "Hitachi";"HUA" = "Hitachi";"HUH" = "Hitachi";"HMH" = "Hitachi";"HTS" = "Hitachi";"HDP" = "Hitachi";"HDS" = "Hitachi";
	 "HDT" = "Hitachi";"HCS" = "Hitachi";"HCP" = "Hitachi";"HCC" = "Hitachi";"HEN" = "Hitachi";"HEJ" = "Hitachi";"OCZ" = "OCZ Technology"
	}

	$Vendors4Prefix = @{
	"DYSA" = "Hitachi";"DARA" = "Hitachi";"DCXA" = "Hitachi";"DCYA" = "Hitachi";"DTLA" = "Hitachi";"DPTA" = "Hitachi";"DJNA" = "Hitachi";"DTTA" = "Hitachi";"DDYS" = "Hitachi";"DPSS" = "Hitachi";	
	"DRHS" = "Hitachi";"DMVS" = "Hitachi";"DGHS" = "Hitachi";"DRVS" = "Hitachi";"DDRS" = "Hitachi";"DGVS" = "Hitachi";	"DT01" = "Toshiba"
	
	}

	$ML = $Vendors2Prefix[$M2Prefix]
	if ($null -eq $ML -or "HE" -eq $M2Prefix)
	{
		if ($Model.Length -gt 2)
		{
			$M3Prefix = $Model.Substring(0,3)
			$ML       = $Vendors3Prefix[$M3Prefix]
			if ($null -eq $ML -and $Model.Length -gt 3)
			{
              $M4Prefix = $Model.Substring(0,4)
			  $ML       = $Vendors4Prefix[$M4Prefix]

			}
		}
	}

	if( $null -ne $ML)
	{
		$Manufacturer = $ML
	}

	return $Manufacturer
}

Main




</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDiskDiscovery.ModuleType" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ComputerID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DeviceID" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="IntervalSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler"><Scheduler><SimpleReccuringSchedule><Interval Unit="Seconds">$Config/IntervalSeconds$</Interval></SimpleReccuringSchedule><ExcludeDates/></Scheduler></DataSource><ProbeAction ID="ScriptProbe" TypeID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><ScriptName>DiskPartitionContainsLogicalDisk.ps1</ScriptName><PSparam>param ($SourceID, $ManagedEntityId, $TargetComputer, $TargetComputerID, $DeviceID)</PSparam><ScriptBody>Function Add-LogicalDiskToPartition([string]$PartitionId,[string]$LogicalDiskPerfId,[HashTable]$PartToLogicalDisk)
{
		if ([string]::IsNullOrEmpty($PartitionId) -or [string]::IsNullOrEmpty($LogicalDiskPerfId) )
		{
			return 
		}

		$PartToLogicalDisk[$PartitionId] = $LogicalDiskPerfId
}

Function Add-DiskToPartition([string]$PartitionId,[string]$DiskId,[HashTable]$DiskToPartition)
{

		if ([string]::IsNullOrEmpty($PartitionId) -or [string]::IsNullOrEmpty($DiskId) -or $null -eq $DiskToPartition)
		{
			return 
		}

	    $Partitions = $DiskToPartition[$DiskId]
        
	    if ($null -eq $Partitions)
		{
		   $Partitions = @()
		}

	    $Partitions +=  $PartitionId

		$DiskToPartition[$DiskId] = $Partitions
}

Function Get-PerfInstancePostFix($oSet,[HashTable]$PartToLogicalDisk,[bool]$IsSet = $true)
{
	$PerfPostFix = [string]::Empty
	$iCount      = $oSet.Count

	if (0 -eq $iCount -or $null -eq $oSet)
	{
		return $PerfPostFix 
	}

	if ($null -eq $iCount)
	{
		$iCount = 1 
	}

	$PerfInstance = @(1..$iCount)
    $Index = 0

	foreach ($owObj in $oSet)
    {
		if ($true -eq $IsSet)
		{
			$PartitionId = $owObj.DeviceID
		}
		else
			{
				$PartitionId = $owObj
			}

		if ([string]::IsNullOrEmpty($PartitionId))
		{
			continue
		}
				$PerfPostFix = $PartToLogicalDisk[$PartitionId]
				if($null -ne $PerfPostFix)
				{
					$PerfInstance[$Index] = $PerfPostFix
					$Index++
				}
	
	}

	if (0 -ne $Index)
	{
			for ($i = $Index;$i -lt $iCount; $i++)
			{
				$PerfInstance[$i] = [string]::Empty
			}

		$PerfPostFix = [string]::Join(" ",$PerfInstance).Trim(" ")
	}

	return $PerfPostFix
}

Function Get-PartitionToLogicalDiskTable($sTargetComputer)
{
	$PartToLogicalDisk = @{}
	$oWMISet= WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" $WMI_Partition_To_LogicalDisk

	foreach ($owObj in $oWMISet)
	{
		$PartitionId        = $owObj.Antecedent.DeviceId
		$LogicalDiskPerfId  = $owObj.Dependent.DeviceId

		Add-LogicalDiskToPartition -PartitionId $PartitionId -LogicalDiskPerfId $LogicalDiskPerfId -PartToLogicalDisk $PartToLogicalDisk

	}

	return $PartToLogicalDisk 
}

Function Get-DiskToPartitionTable($sTargetComputer)
{

	$DiskToPartition = @{}
	$oWMISet= WMIGetInstanceNoAbort $sTargetComputer "root\cimv2"  $WMI_DISk_To_Partition

	foreach ($owObj in $oWMISet)
	{
		$DiskId        = $owObj.Antecedent.DeviceId
		$PartitionId  = $owObj.Dependent.DeviceId

		Add-DiskToPartition -PartitionId $PartitionId -DiskId $DiskId -DiskToPartition $DiskToPartition

	}

	return $DiskToPartition
}

Function Get-DiskToPartitionPerfInstance($sTargetComputer)
{

	$DiskToPerfInstance = @{}
    $PartToLogicalDisk     =  Get-PartitionToLogicalDiskTable -sTargetComputer $sTargetComputer
	$DiskToPartitionTable  =  Get-DiskToPartitionTable -sTargetComputer $sTargetComputer
	foreach ($DiskId in $DiskToPartitionTable.Keys)
	{
		$sPerfInstance      = [string]::Empty
		$oSet               = $DiskToPartitionTable[$DiskId]

		$PerfInstancePostfix = Get-PerfInstancePostFix -oSet $oSet -PartToLogicalDisk $PartToLogicalDisk -IsSet $false

		if (-Not [string]::IsNullOrEmpty($PerfInstancePostfix))
		{
			$sPerfInstance += $PerfInstancePostfix
		}

		$DiskToPerfInstance[$DiskId] = $sPerfInstance
	}	

	return $DiskToPerfInstance
}

Function Get-LogicalDiskSerialNmber([string]$TargetComputer,[string]$LogicalDiskId)
{
	if ([string]::IsNullOrEmpty($LogicalDiskId) )
	{
	   return [string]::Empty
	}

	 $Query = "Select VolumeSerialNumber From Win32_LogicalDisk Where DeviceID='$LogicalDiskId'"
     $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\cimv2" $Query
	 
	 $SerialNumber = [string]::Empty
	 if (0 -ne $oInstances.Count )
	 {
		 $SerialNumber = $oInstances[0].VolumeSerialNumber
		 if($null -eq $SerialNumber)
		 {
			 $SerialNumber = [string]::Empty
		 }
	 }

	return $SerialNumber
}

Function GetHddPerfmonInstance
{
    param ( [string]$DriveId, [string]$Index,[HashTable]$DiskPerfInstance)

	$sPerfInstance      = "$Index "

	$PerfInstancePostfix    = $DiskPerfInstance[$DriveId]
	if (-Not [string]::IsNullOrEmpty($PerfInstancePostfix))
	{
		$sPerfInstance += $PerfInstancePostfix
	}
	
	return $sPerfInstance
}
Function Main()
{
    $objWMIColl = $null

    $IsCluster = CheckCluster $TargetComputer

    if ($IsCluster -eq $true)
    {
        $objWMIColl = GetClusterDiskCollection $TargetComputer
    }
    
	$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
 
    if ((DoDiscovery $TargetComputer $TargetComputerID $oDiscoveryData $IsCluster $objWMIColl $DeviceID) -eq 0)
    { 
		$oDiscoveryData
    }
	else
	{
		$oDiscoveryData = $momAPI.CreateDiscoveryData(0, $SourceID, $ManagedEntityId)
		$oDiscoveryData.IsSnapshot = $false
	}
}

Function DoDiscovery
{
    param ([string]$sTargetComputer, [string]$sTargetComputerID, $oDisc, [bool]$IsCluster, $objWMIColl, $sDeviceID)

	if ([string]::IsNullOrEmpty($sDeviceID) )
	{
	   return 0
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$PartToLogicalDisk     = Get-PartitionToLogicalDiskTable -sTargetComputer $sTargetComputer
	if (0 -ne $error.Count)
	{
		return $error.Count
	}

	$LogicalDiskId           = $PartToLogicalDisk[$sDeviceID]

	if (0 -ne $error.Count)
	{
		return $error.Count
	}

	if([string]::IsNullOrEmpty($LogicalDiskId))
	{
		return 0
	}

	$LogicalDiskSerialNumber = Get-LogicalDiskSerialNmber -TargetComputer $sTargetComputer -LogicalDiskId $LogicalDiskId

	#Cannot get Logical disk Serial Number. So cannot check for Cluster Disk
	if([string]::IsNullOrEmpty($LogicalDiskSerialNumber) -and $true -eq $IsCluster)
	{
		return 1
	}

	$IsClusterDisk = CheckIsClusterDisk $LogicalDiskId $LogicalDiskSerialNumber $IsCluster $objWMIColl
		        
    if ($true -eq $IsClusterDisk)
    {
		return 0
	}

	$error.Clear()


	$oInstancePartition = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.DiskPartition']$")
	$oInstancePartition.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
	$oInstancePartition.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $sDeviceID)

	$oInstanceLogicalDisk = $oDisc.CreateClassInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalDisk']$")
	$oInstanceLogicalDisk.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $sTargetComputerID)
	$oInstanceLogicalDisk.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.LogicalDevice']/DeviceID$", $LogicalDiskId)

	$oInstanceRelationship = $oDisc.CreateRelationshipInstance("$MPElement[Name='Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk']$")
	$oInstanceRelationship.source = $oInstancePartition
	$oInstanceRelationship.target = $oInstanceLogicalDisk

	$oDisc.AddInstance($oInstanceRelationship)
       

    return $error.Count
}


Main





</ScriptBody><Parameters><Parameter><Name>SourceID</Name><Value>$MPElement$</Value></Parameter><Parameter><Name>ManagedEntityId</Name><Value>$Target/Id$</Value></Parameter><Parameter><Name>TargetComputer</Name><Value>$Config/ComputerName$</Value></Parameter><Parameter><Name>TargetComputerID</Name><Value>$Config/ComputerID$</Value></Parameter><Parameter><Name>DeviceID</Name><Value>$Config/DeviceID$</Value></Parameter></Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds></ProbeAction></MemberModules><Composition><Node ID="ScriptProbe"><Node ID="Scheduler"/></Node></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.Windows.Universal.Script.Discovery.DS" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="IntervalSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="cScriptName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="0" name="cScriptParameters" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="cScriptBody" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="PsScriptName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="0" name="PowerShellScriptParameters" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="0" name="PowerShellScriptParam" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="PowerShellScriptBody" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" minOccurs="1" name="TimeoutSeconds" type="xsd:integer"/></Configuration><OverrideableParameters><OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="string"/><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS" TypeID="System!System.CommandExecuterDiscoveryDataSource"><IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds><ApplicationName>%SystemRoot%\system32\cmd.exe</ApplicationName><WorkingDirectory/><CommandLine>/c $file/Main.cmd$</CommandLine><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds><RequireOutput>true</RequireOutput><Files><File><Name>Main.cmd</Name><Contents>
                      
                        @echo off
                        set psscript=$Config/PsScriptName$
                        set vbscript=$Config/cScriptName$
                        set cscript=%windir%\system32\cscript.exe
set ps=%windir%\system32\WindowsPowerShell\v1.0\powershell.exe
set params=
	   
    if Exist "%ps%" goto pshell
    if Exist "%cscript%" goto vb

    goto end
:vb
  if  not exist "%~dp0%vbscript%" goto end

   if exist "%~dp0vbparams.txt" (
     set /p params=&lt;"%~dp0vbparams.txt"  
   )

   "%cscript%" /nologo "%~dp0%vbscript%" %params% 
 goto end
:pshell
    if  not exist "%~dp0%psscript%" goto end

   if exist "%~dp0psparams.txt" (
     set /p params=&lt;"%~dp0psparams.txt"  
   )
     "%ps%" -nologo -EP bypass -command "&amp; '%~dp0%psscript%'"  %params% 
 goto end

:end



</Contents><Unicode>false</Unicode></File><File><Name>$Config/PsScriptName$</Name><Contents>
                      
                                $Config/PowerShellScriptParam$
                                Function Init-ScomHelper
{
	$DiscHelper = @'
	namespace SCOM.Helper
	{
		using System;
		using System.Runtime.InteropServices;
		public class ConvertData
		{

			public static string GetDataItemFromOutput(
				Object oData)
			{
				NativeMethods.ISerialize discoverySerializer = null;
				discoverySerializer = oData as NativeMethods.ISerialize;
				string xmlString = null;
				if (null != discoverySerializer)
				{
					int hr = discoverySerializer.SaveToString(out xmlString);
					Marshal.ThrowExceptionForHR(hr);
				}

				return xmlString;
			}

			public static class NativeMethods
			{
				[Guid("A4E79E8A-9494-47A4-A280-8C7D35C88A2F"),
				InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
				public interface ISerialize
				{
					int SaveToString([MarshalAs(UnmanagedType.BStr)] out string output);
					int LoadFromString([MarshalAs(UnmanagedType.BStr)] string input);
				}
			}
		}
	}

'@
    
	$ErrorActionPreference = "SilentlyContinue"
	$Error.Clear()
	Add-Type $DiscHelper

	$result = 0 -eq $Error.Count

	return $result
}
                                $Config/PowerShellScriptBody$
                               

                    </Contents><Unicode>true</Unicode></File><File><Name>$Config/cScriptName$</Name><Contents>$Config/cScriptBody$</Contents><Unicode>false</Unicode></File><File><Name>vbparams.txt</Name><Contents>$Config/cScriptParameters$</Contents><Unicode>false</Unicode></File><File><Name>psparams.txt</Name><Contents>$Config/PowerShellScriptParameters$</Contents><Unicode>false</Unicode></File></Files></DataSource></MemberModules><Composition><Node ID="DS"/></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType></DataSourceModuleType><ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe" Accessibility="Public" Batching="false" PassThrough="false"><Configuration><IncludeSchemaTypes><SchemaType>Windows!Microsoft.Windows.PowerShellSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ScriptName" type="NonNullString"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="PSparam" type="xsd:string" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ScriptBody" type="NonNullString"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SnapIns" type="SnapInsType" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Parameters" type="NamedParametersType" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeoutSeconds" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StrictErrorHandling" type="xsd:boolean" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><ProbeAction ID="PowerShellPA" TypeID="Windows!Microsoft.Windows.PowerShellDiscoveryProbe"><ScriptName>$Config/ScriptName$</ScriptName><ScriptBody>
                      
                                $Config/PSparam$
                                $ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$WMI_Partition_To_LogicalDisk = "Win32_LogicalDiskToPartition"
$WMI_Drive_To_Partition       = "Win32_DiskDriveToDiskPartition"
$WMI_DISk_To_Partition        = "Win32_DiskDriveToDiskPartition"

$momAPI = new-object -comObject MOM.ScriptAPI
if ($null -eq $momAPI)
{
   exit
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
	}
}

Load-CimModules

# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576
$DriveLetterMaxSize = 3

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();

		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();
    
	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


    Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    
	$ErrorActionPreference = "SilentlyContinue"

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function CheckCluster
{
    param ([string]$sTargetComputer)

    $error.Clear()
    $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\cimv2" "Select ID, Name from Win32_ServerFeature where Name = 'Failover Clustering'"

    if ($error.Count -gt 0 -or $oInstances.Count -eq 0)
    {
        return $false
    }
    else
    {
        	$ClusterName = (Get-ItemProperty -Path "HKLM:\Cluster" -Name "ClusterName" -ErrorAction SilentlyContinue ).ClusterName
	        return -Not [string]::IsNullOrEmpty($ClusterName)   
    }
}

Function CheckIsClusterDisk
{
    param ([string]$sDeviceID, [string]$sSerialNumber, [bool]$IsCluster, [hashtable]$ClusterVolumes)
    

    $bFlag = $false
	   
    if ($IsCluster -eq $false -or [string]::IsNullOrEmpty($sSerialNumber) )
    {
		return $bFlag
	}
	
	    $SerialNumber = $sSerialNumber.TrimStart("0")
	    $DiskId = $SerialNumber + $sDeviceID
	    $VolId =  $ClusterVolumes[$DiskId]       
	 
	    $bFlag = $VolId -ne $null
         	   
	    return $bFlag
 
}

Function GetClusterDiskCollection
{
    param ([string]$sTargetComputer)

	$Volumes = @{}
    $error.Clear()
    $oInstances = WMIExecQueryNoAbort $sTargetComputer "root\MSCluster" "Select Path, SerialNumber From MSCluster_DiskPartition"

    if ($error.Count -eq 0)
    {
		foreach ($item in $oInstances)
		{
			$hexsn = "{0:X}" -f $item.SerialNumber
			$Path  = $item.Path
			$VolId = $hexsn + $Path  

			if ([string]::IsNullOrEmpty($VolId))
			{
				continue
			}

		   $Volumes[$VolId] = $VolId

		} 
	}

	return $Volumes
}

#---------------------------------------------------------------------------
# Function: SwitchBoolean
#   Usage:
#     Parameter (bIn) 
#     Returns a Boolean
#---------------------------------------------------------------------------
Function SwitchBoolean([string]$bIn)
{
    if ($bIn.ToLower() -eq "false")
    {
        return "true"
    }
    else
    {
        return "false"
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	$error.Clear()
	$IsNano = $IsNano -eq 1

	return $IsNano

}

Function GetPerfmonInstance($sName)
{
    $sName = $sName -replace("\(","[")
    $sName = $sName -replace("\)","]")
    $sName = $sName -replace("/","_")
    $sName = $sName -replace("#","_")

    return $sName
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

Function Get-StringProperty([string]$Property,[int]$MaxSize = 256)
{
	if ([string]::IsNullOrEmpty($Property))
	{
		return [string]::Empty
	}

	if ($Property.Length -gt $MaxSize)
	{
		return $Property.Substring(0,$MaxSize)
	}

	return $Property
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }


Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
                                $Config/ScriptBody$
                               
                    </ScriptBody><SnapIns>$Config/SnapIns$</SnapIns><Parameters>$Config/Parameters$</Parameters><TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds><StrictErrorHandling>$Config/StrictErrorHandling$</StrictErrorHandling></ProbeAction></MemberModules><Composition><Node ID="PowerShellPA"/></Composition></Composite></ModuleImplementation><OutputType>System!System.Discovery.Data</OutputType><InputType>System!System.BaseData</InputType></ProbeActionModuleType></ModuleTypes></TypeDefinitions><Monitoring><Discoveries><Discovery ID="Microsoft.Windows.Server.10.0.AllServersComputerGroupDiscovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.ComputerGroup" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator"><RuleId>$MPElement$</RuleId><GroupInstanceId>$Target/Id$</GroupInstanceId><MembershipRules><MembershipRule><MonitoringClass>$MPElement[Name="Microsoft.Windows.Server.10.0.Computer"]$</MonitoringClass><RelationshipClass>$MPElement[Name="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"]$</RelationshipClass></MembershipRule></MembershipRules></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.Computer.Discovery" Enabled="true" Target="Windows!Microsoft.Windows.Server.Computer" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Computer"><Property TypeID="Microsoft.Windows.Server.10.0.Computer" PropertyID="InstallType"/></DiscoveryClass><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.OperatingSystem"><Property TypeID="Microsoft.Windows.Server.10.0.OperatingSystem" PropertyID="InstallType"/><Property TypeID="Microsoft.Windows.Server.10.0.OperatingSystem" PropertyID="PowerPlan"/></DiscoveryClass><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Core.Computer"/><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Core.OperatingSystem"/><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Full.Computer"/><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Full.OperatingSystem"/></DiscoveryTypes><DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.Discovery.DataSource"><IntervalSeconds>86400</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds><SourceId>$MPElement$</SourceId><VersionMask>10\.</VersionMask></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.Core.AllServersComputerGroupDiscovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.Core.ComputerGroup" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator"><RuleId>$MPElement$</RuleId><GroupInstanceId>$Target/Id$</GroupInstanceId><MembershipRules><MembershipRule><MonitoringClass>$MPElement[Name="Microsoft.Windows.Server.10.0.Core.Computer"]$</MonitoringClass><RelationshipClass>$MPElement[Name="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"]$</RelationshipClass></MembershipRule></MembershipRules></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.Nano.AllServersComputerGroupDiscovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.Nano.ComputerGroup" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator"><RuleId>$MPElement$</RuleId><GroupInstanceId>$Target/Id$</GroupInstanceId><MembershipRules><MembershipRule><MonitoringClass>$MPElement[Name="Microsoft.Windows.Server.10.0.Nano.Computer"]$</MonitoringClass><RelationshipClass>$MPElement[Name="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"]$</RelationshipClass></MembershipRule></MembershipRules></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.CPU.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.Processor"><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="Manufacturer"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="Speed"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="DataWidth"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="Revision"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="Version"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.Processor" PropertyID="PerfmonInstance"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.CPUDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86640</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.DiskPartition.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.DiskPartition"><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.DiskPartition" PropertyID="DiskIndex"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.DiskPartition" PropertyID="BlockSize"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.DiskPartition" PropertyID="PrimaryPartition"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.DiskPartition" PropertyID="Bootable"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.DiskPartition" PropertyID="Size"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Windows!Microsoft.Windows.WmiProviderWithClassSnapshotDataMapper"><NameSpace>\\$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$\root\cimv2</NameSpace><Query>SELECT DeviceID, Name, DiskIndex, BlockSize, Description, PrimaryPartition, BootPartition, Size FROM Win32_DiskPartition</Query><Frequency>86700</Frequency><ClassId>$MPElement[Name="Microsoft.Windows.Server.10.0.DiskPartition"]$</ClassId><InstanceSettings><Settings><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name><Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value></Setting><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Name><Value>$Data/Property[@Name='DeviceID']$</Value></Setting><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/Name$</Name><Value>$Data/Property[@Name='Name']$</Value></Setting><Setting><Name>$MPElement[Name="WindowsServer!Microsoft.Windows.Server.DiskPartition"]/DiskIndex$</Name><Value>$Data/Property[@Name='DiskIndex']$</Value></Setting><Setting><Name>$MPElement[Name="WindowsServer!Microsoft.Windows.Server.DiskPartition"]/BlockSize$</Name><Value>$Data/Property[@Name='BlockSize']$</Value></Setting><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/Description$</Name><Value>$Data/Property[@Name='Description']$</Value></Setting><Setting><Name>$MPElement[Name="WindowsServer!Microsoft.Windows.Server.DiskPartition"]/PrimaryPartition$</Name><Value>$Data/Property[@Name='PrimaryPartition']$</Value></Setting><Setting><Name>$MPElement[Name="WindowsServer!Microsoft.Windows.Server.DiskPartition"]/Bootable$</Name><Value>$Data/Property[@Name='BootPartition']$</Value></Setting><Setting><Name>$MPElement[Name="WindowsServer!Microsoft.Windows.Server.DiskPartition"]/Size$</Name><Value>$Data/Property[@Name='Size']$</Value></Setting></Settings></InstanceSettings></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk.Discovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.DiskPartition" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDiskDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><DeviceID>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DeviceID><IntervalSeconds>14400</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.Full.AllServersComputerGroupDiscovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.Full.ComputerGroup" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator"><RuleId>$MPElement$</RuleId><GroupInstanceId>$Target/Id$</GroupInstanceId><MembershipRules><MembershipRule><MonitoringClass>$MPElement[Name="Microsoft.Windows.Server.10.0.Full.Computer"]$</MonitoringClass><RelationshipClass>$MPElement[Name="SC!Microsoft.SystemCenter.ComputerGroupContainsComputer"]$</RelationshipClass></MembershipRule></MembershipRules></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.LogicalDisk.Discovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.LogicalDisk"><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="FileSystem"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="Compressed"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="Size"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SizeNumeric"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SizeInMBs"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="DriveType"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SupportsDiskQuota"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="QuotasDisabled"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SupportsFileBasedCompression"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86460</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.MountPoint.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.LogicalDisk"><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="FileSystem"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="Compressed"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="Size"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SizeNumeric"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SizeInMBs"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="DriveType"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SupportsDiskQuota"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="QuotasDisabled"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.LogicalDisk" PropertyID="SupportsFileBasedCompression"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86520</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.NetworkAdapter.All.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter"><Property TypeID="System!System.Entity" PropertyID="DisplayName"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="AdapterType"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="Index"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="Manufacturer"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="MACAddress"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="ServiceName"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="PerfmonInstance"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86760</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds><DiscoverDisabledNetworkAdapters>true</DiscoverDisabledNetworkAdapters><UseMacAddress>true</UseMacAddress></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.NetworkAdapter.Discovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter"><Property TypeID="System!System.Entity" PropertyID="DisplayName"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="AdapterType"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="Index"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="Manufacturer"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="MACAddress"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="ServiceName"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.NetworkAdapter" PropertyID="PerfmonInstance"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86820</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds><DiscoverDisabledNetworkAdapters>false</DiscoverDisabledNetworkAdapters><UseMacAddress>true</UseMacAddress></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.PhysicalDisk.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="Microsoft.Windows.Server.10.0.PhysicalDisk"><Property TypeID="System!System.Entity" PropertyID="DisplayName"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="DeviceID"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Name"/><Property TypeID="Windows!Microsoft.Windows.LogicalDevice" PropertyID="Description"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="Caption"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="Index"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="InterfaceType"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="Manufacturer"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="Model"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="SCSIBus"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="SCSILogicalUnit"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="SCSIPort"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="SCSITargetID"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="Size"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="TotalCylinders"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="TotalHeads"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="TotalSectors"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="TotalTracks"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="TracksPerCylinder"/><Property TypeID="WindowsServer!Microsoft.Windows.Server.PhysicalDisk" PropertyID="PerfmonInstance"/></DiscoveryClass><DiscoveryRelationship TypeID="Windows!Microsoft.Windows.ComputerHostsLogicalDevice"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Microsoft.Windows.Server.10.0.PhysicalDiskDiscovery.ModuleType"><ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName><ComputerID>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID><IntervalSeconds>86880</IntervalSeconds><TimeoutSeconds>360</TimeoutSeconds></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition.Discovery" Enabled="false" Target="Microsoft.Windows.Server.10.0.PhysicalDisk" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryRelationship TypeID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition"/></DiscoveryTypes><DataSource ID="DiscoveryDataSource" TypeID="Windows!Microsoft.Windows.WmiProviderWithRelationshipSnapshotDataMapper"><NameSpace>\\$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$\root\cimv2</NameSpace><Query>associators of {win32_diskdrive='$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$'} where ResultClass=Win32_DiskPartition</Query><Frequency>86940</Frequency><RelationshipId>$MPElement[Name="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition"]$</RelationshipId><SourceRoleSettings><Settings><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name><Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value></Setting><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Name><Value>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Value></Setting></Settings></SourceRoleSettings><TargetRoleSettings><Settings><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name><Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value></Setting><Setting><Name>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Name><Value>$Data/Property[@Name='DeviceID']$</Value></Setting></Settings></TargetRoleSettings></DataSource></Discovery><Discovery ID="Microsoft.Windows.Server.10.0.StandardLicense.Discovery" Enabled="true" Target="Microsoft.Windows.Server.10.0.Computer" ConfirmDelivery="false" Remotable="true" Priority="Normal"><Category>Discovery</Category><DiscoveryTypes><DiscoveryClass TypeID="SC!Microsoft.SystemCenter.License.Standard"><Property TypeID="System!System.Entity" PropertyID="DisplayName"/></DiscoveryClass></DiscoveryTypes><DataSource ID="DS" TypeID="SC!Microsoft.SystemCenter.SetStandardLicense"><ComputerID>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerID></DataSource></Discovery></Discoveries><Tasks><Task ID="Microsoft.Windows.Server.10.0.Undiscovery.Improper.Cluster.Objects.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="3600" Remotable="true"><Category>Maintenance</Category><WriteAction ID="Undiscover" RunAs="Microsoft.Windows.Server.10.0.RunAsUnDiscoveryProfile" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction"><ScriptName>UndiscoveryImProperClusterObjects.ps1</ScriptName><ScriptBody>
Function Get-OmClass ($mg,[string]$ClassName)
{
   if ($null -eq $mg -or $true -eq [string]::IsNullOrEmpty($ClassName))
   {
     return $null
   }
  
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()

  $scriteria = "Name='$ClassName'"
  $Criteria = New-Object Microsoft.EnterpriseManagement.Configuration.MonitoringClassCriteria($scriteria)

  if (0 -ne $error.Count)
  {
    return $null
  }

  $EntityTypes = $mg.EntityTypes

  if($null -eq $EntityTypes)
  {
	  return $null
  } 

  $mtypes = $mg.EntityTypes.GetClasses($Criteria)

  if (0 -ne $error.Count)
  {
    return $null
  }

  $result = $mtypes[0]

  return $result
 }
Function Get-OmClassById ($mg,[string]$ClassId)
{
   if ($null -eq $mg -or $true -eq [string]::IsNullOrEmpty($ClassId))
   {
     return $null
   }
  
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()

  $scriteria = "Id='$ClassId'"
  $Criteria = New-Object Microsoft.EnterpriseManagement.Configuration.MonitoringClassCriteria($scriteria)

  if (0 -ne $error.Count)
  {
    return $null
  }

  $EntityTypes = $mg.EntityTypes

  if($null -eq $EntityTypes)
  {
	  return $null
  } 

  $mtypes = $mg.EntityTypes.GetClasses($Criteria)

  if (0 -ne $error.Count)
  {
    return $null
  }

  $result = $mtypes[0]

  return $result
 }

Function Get-OmDiscoveries($mg,[string]$TargetClassName)
{
   
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()
  $TargetClass = Get-OmClass -mg $mg -ClassName $TargetClassName
  if($null -eq $TargetClass.Id)
  {
	  return $null
  }

  $ClassId     =  $TargetClass.Id.ToString()
  if ($true -eq [string]::IsNullOrEmpty($ClassId))
  {
		return $null
  } 

  $error.Clear()
  $StrCriteria = "Target='$ClassId'"
  $criteria = New-Object Microsoft.EnterpriseManagement.Configuration.MonitoringDiscoveryCriteria($StrCriteria)

  if (0 -ne $error.Count)
  {
    return $null
  }

  $error.Clear()
  $result = $mg.GetMonitoringDiscoveries($criteria)
  
  if (0 -ne $error.Count)
  {
    return $null
  }

  return $result
 }

 Function Get-DiscoveryObjectType($mg,$ObjectType,[HashTable]$types)
 {
	      $TypeId = $ObjectType.TypeId.Id
	 	  if ($null -eq $TypeId -or $null -eq $mg)
		  {
			  return
		  }
	      
	      $sTypeId = $TypeId.ToString() 
		  $Class = Get-OmClassById -mg $mg -ClassId $sTypeId
          
	      if ($null -eq $Class)
		  {
		    return
		  }  

          if (-Not $types.ContainsKey($Class))
	      {
			  $types[$Class] = [string]::Empty
		  } 

 }

Function Get-OmDiscoveriesObjectTypes($mg,[string]$TargetClassName)
{
  $result = @{}
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()
  $discoveries = Get-OmDiscoveries -mg $mg -TargetClassName $TargetClassName
  if($null -eq $discoveries )
  {
    return $result
  }

  $error.Clear() 
  foreach($discovery in $discoveries)
  {
	  foreach($ObjectType in $discovery.DiscoveryClassCollection)
	  {
		  Get-DiscoveryObjectType -mg $mg -ObjectType $ObjectType -types $result
	  }
  }	 

	return $result
}

 Function Get-OmClusterComputerInstance($mg)
{
   $ErrorActionPreference = "SilentlyContinue"
   $error.Clear()
 
   $ClassName = "Microsoft.Windows.Server.Computer"
   $class = Get-OmClass -mg $mg -ClassName $ClassName

   if ($null -eq $Class)
   {
     return $null
   }

   $error.Clear()
   $query = "IsVirtualNode = 'true'"

  $criteria = New-Object Microsoft.EnterpriseManagement.Monitoring.MonitoringObjectCriteria($query,$class)
  if (0 -ne $error.Count)
  {
    return $null
  }

  $result = $mg.GetMonitoringObjects($criteria)
  
  return $result 
}    

Function Get-RelatedObjects($ObjectColl,[HashTable]$MonObjects)
 {
	      
	 	  if ($null -eq $ObjectColl -or $null -eq $MonObjects )
		  {
			  return 
		  }
	      
		  foreach($object in $ObjectColl)
		  {
				  $MonObjects[$object] = [string]::Empty
		  }  

	     return 
 }


Function Get-RelatedMonitoringObjects($monObject,[HashTable]$types,[HashTable]$relObjects)
{
   $ErrorActionPreference = "SilentlyContinue"
   $error.Clear()

   if ($null -eq $monObject -or 0 -eq $types.Count -or $null -eq $relObjects)
   {
		return    
   }

	foreach($class in $types.Keys)
	{
		$Objects = $monObject.GetRelatedMonitoringObjects($Class,[Microsoft.EnterpriseManagement.Common.TraversalDepth]::OneLevel)
		Get-RelatedObjects -ObjectColl $Objects -MonObjects $relObjects
	}

}

Function Get-ClusterImproperObjects($mg)
{
   $ErrorActionPreference = "SilentlyContinue"
   $error.Clear()

	$result = @{}

	$Target = "Microsoft.Windows.Server.10.0.OperatingSystem"
	$Clusters = Get-OmClusterComputerInstance -mg $mg

	if($null -eq $Clusters)
	{
		return $result
	}

	$ObjectTypes = Get-OmDiscoveriesObjectTypes -mg $mg -TargetClassName $Target
	if($null -eq $ObjectTypes)
	{
		return $result
	}

	foreach($Cluster in $Clusters)
	{
		Get-RelatedMonitoringObjects -monObject $Cluster -types $ObjectTypes -relObjects $result
	}

	$Count = $result.Count 

	if (0 -ne $Count)
	{
		Write-Host "Improper windows 2016 cluster objects search ended."
        Write-Host "Improper windows 2016 cluster objects: $Count"
 
	}

	return $result
}

Function Start-Undiscovery($mg)
{
	  $ErrorActionPreference = "SilentlyContinue"
          $error.Clear()

      Write-Host "Checking security permissions.." 
	  $IsAdministrator = $false
	  $IsAdministrator = $mg.IsUserAdministrator()

	  if ($false -eq $IsAdministrator)
	  {
		 $message = "User doesn't have enough permission to perform undisovery."
		 Write-Host $message
		 return
	  }

	  $undiscovery = New-Object Microsoft.EnterpriseManagement.ConnectorFramework.IncrementalDiscoveryData

	  if ($null -eq $undiscovery -or $errror.Count -ne 0)
	  {
		 $message = "Cannot create undiscovery data item. " + $error[0]
		 Write-Host $message
		 return ;
	  }

    Write-Host "Finding Improper cluster objects.." 
	$Objects = Get-ClusterImproperObjects -mg $mg 


	if (0 -eq $Objects.Count)
	{
		Write-Host "Improper windows 2016 cluster objects were not found."
		return
	}

	Write-Host "Marking Improper windows 2016 cluster objects for removal.."
    $error.Clear()
    foreach ($Object in $Objects.Keys)
    {
 		 $undiscovery.Remove($Object)
    }

	if (0 -eq $error.Count)
	{
		Write-Host "Marking Improper windows 2016 cluster objects for removal finished successfully."
	}
	else
	    {
			$Count = $Error.Count
			Write-Host "Marking Improper windows 2016 cluster objects for removal finished with errors."
			Write-Host " $Count Improper windows 2016 cluster objests are affected."
		}

	$error.Clear()
	Write-Host "Trying to remove marked Improper windows 2016 cluster objects."

   $undiscovery.Commit($mg)

	  if ($error.Count -ne 0)
	  {
		 $message = "Cannot commit undiscovery data. " + $error[0]
		 Write-Host $message
		return
	  }
	  else
		  {
			  Write-Host "Successfully remove marked Improper windows 2016 cluster objects."
		  }
     
}

Function Load-SCOMAssemblies()
{
  $ErrorActionPreference = "Stop"
  $result = $true
  $OpsMgrMainLib     = "Microsoft.EnterpriseManagement.OperationsManager,Version=7.0.5000.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
  $ScomDiscoverySdk  = "Microsoft.EnterpriseManagement.Core,Version=7.0.5000.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"

  try
  {
    [void][Reflection.Assembly]::Load($OpsMgrMainLib)
    [void][Reflection.Assembly]::Load($ScomDiscoverySdk)
  }
  catch
      {
        $result = $false
      }

  return $result 
}

Function Start-FullUndiscovery
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
 	Write-Host "Connecting to Management Group.." 

	$mg = New-Object Microsoft.EnterpriseManagement.ManagementGroup("localhost")
	if ($Null -eq $mg -or 0 -ne $error.Count)
	{
		$message = "Cannot connect to Management Group. " + $error[0]
		Write-Host $message
		return
	}

	Start-Undiscovery -mg $mg
}

Function Main
{
  $message = "Starting Undiscovery of Improper windows 2016 cluster objects..."
  Write-Host $message
  Write-Host "Loading SCOM SDK Libraries.." 

    $result = Load-SCOMAssemblies 
    if ($true -eq $result)
    {
        Start-FullUndiscovery
    }
	else
	    {
			$message = "Cannot Load SCOM SDK Libraries."
  
		}
}

Main</ScriptBody><TimeoutSeconds>3600</TimeoutSeconds></WriteAction></Task></Tasks></Monitoring><LanguagePacks><LanguagePack ID="ENU" IsDefault="true"><DisplayStrings><DisplayString ElementID="Microsoft.Windows.Server.10.0.AllServersComputerGroupDiscovery"><Name>Populate All Windows Server 2016 and above Computer Group</Name><Description>This Discovery Rule discovers and populates the Windows Server Computer group named " Windows Server 2016 and above Computer Group" with instances of computers that are running Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.Discovery"><Name>Discover Windows 2016 and above Servers</Name><Description>This Discovery Rule discovers and populates the Windows Server class named “Windows Server 2016 and above Computer" with instances of computers that are running Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Core.AllServersComputerGroupDiscovery"><Name>Populate All Windows Server 2016 and above Computer Group (Core)</Name><Description>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 and above Computer Group (Core)" with instances of computers that are running Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.CPU.Discovery"><Name>Discover Windows CPUs</Name><Description>This rule uses WMI to discover all processors reported by Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUDiscovery.ModuleType"><Name>Windows CPU Discovery</Name><Description>Discover individual CPUs on Windows Servers</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDiskDiscovery.ModuleType"><Name>Disk Partition to Logical Disk Discovery Module</Name><Description>Discover Disk Partition to Logical Disk Relationship on Windows Servers</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDiskDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDiskDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.2016.Discovery"><Name>Windows Server 2016 and above Operating Systems (Discovery)</Name><Description>Microsoft Windows Server 2016 and above Operating System Management Pack: This management pack discovers Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Discovery.DataSource"><Name>Windows Server 2016 and above Discovery (Discovery)</Name><Description>This data source discovers Windows Server 2016 and above.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Discovery.DataSource" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Discovery.DataSource" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition.Discovery"><Name>Discover Windows Disk Partitions</Name><Description>This rule uses WMI to discover all disk partitions of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk.Discovery"><Name>Disk Partition to Logical Disk Discovery Rule</Name><Description>This rule discovers the relationships between disk partitions and logical disks</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Full.AllServersComputerGroupDiscovery"><Name>Populate All Windows Server 2016 Computer Group (Full)</Name><Description>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 Computer Group (Full)" with instances of computers that are running Windows Server 2016.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Nano.AllServersComputerGroupDiscovery"><Name>Populate All Windows Server 2016 Computer Group (Nano)</Name><Description>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 Computer Group (Nano)" with instances of computers that are running Windows Server 2016.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Discovery"><Name>Discover Windows Logical Disks</Name><Description>This Discovery Rule discovers and populates the Windows Server Class named “Windows Server 2016 and above Logical Disk" with instances of Logical Disks (for example C:, D:) that are discovered on Windows Server 2016 and above operating systems. Please note that only Local Disks are detected. Logical Disks that are classified as Removable, Compact Disk, Network Drive, and RAM Disks are excluded.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MountPoint.Discovery"><Name>Mount Point Discovery Rule</Name><Description>This Discovery Rule discovers and populates the Windows Server Class named “Windows Server 2016 and above Logical Disk" with instances of Mount Points that are discovered on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType"><Name>Windows Mount Point Discovery Data Source</Name><Description>Windows Mount Point Discovery Data Source</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.MountPointDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType"><Name>Windows Logical Disk Discovery Data Source</Name><Description>Windows Logical Disk Discovery Data Source</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDiskDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.All.Discovery"><Name>Discover Network Adapters (Both Enabled and Disabled)</Name><Description>This rule uses WMI to discover all network adapters reported by Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Discovery"><Name>Discover Network Adapters (Only Enabled)</Name><Description>This rule uses WMI to discover all enabled network adapters reported by Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType"><Name>Windows Network Adapter Discovery</Name><Description>This rule discovers network adapters.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType" SubElementID="DiscoverDisabledNetworkAdapters"><Name>Discover Disabled Network Adapters</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.Discovery"><Name>Discover Windows Physical Disks</Name><Description>This rule uses WMI to discover all physical disks of Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition"><Name>Physical Disk Contains Disk Partition</Name><Description>Windows Server 2016 and above Physical Disk Contains Disk Partition</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition.Discovery"><Name>Physical Disk to Disk Partition Discovery Rule</Name><Description>This rule discovers the relationships between physical disks and disk partitions</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskDiscovery.ModuleType"><Name>Windows Physical Disk Discovery</Name><Description>Windows Physical Disk Discovery</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskDiscovery.ModuleType" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskDiscovery.ModuleType" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.StandardLicense.Discovery"><Name>License Discovery for Microsoft Windows Server</Name><Description>This discovery rule discovers and populates the class named “System Center Operations Manager Standard License"</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk"><Name>Disk Partition Contains Logical Disk</Name><Description>Windows Server 2016 and above Disk Partition Contains Logical Disk</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer"><Name>Windows Server 2016 and above Computer</Name><Description>All instances of computers running the Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer" SubElementID="InstallType"><Name>Install Type</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ComputerGroup"><Name>Windows Server 2016 and above Computer Group</Name><Description>A group containing all computers that are running Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Core.Computer"><Name>Windows Server 2016 and above Computer (Core)</Name><Description>All instances of computers running the Windows Server 2016 (Core) and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Core.ComputerGroup"><Name>Windows Server 2016 and above Computer Group (Core)</Name><Description>A group containing all computers that are running Windows Server 2016 (Core) and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Core.OperatingSystem"><Name>Windows Server 2016 and above Operating System (Core)</Name><Description>All instances of the Windows Server 2016 (Core) and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Nano.Computer"><Name>Windows Server 2016 Computer (Nano)</Name><Description>All instances of computers running the Windows Server 2016 operating system (Nano).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Nano.ComputerGroup"><Name>Windows Server 2016 Computer Group (Nano)</Name><Description>A group containing all computers that are running Windows Server 2016 operating system (Nano).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Nano.OperatingSystem"><Name>Windows Server 2016 Operating System (Nano)</Name><Description>All instances of the Windows Server 2016 operating system (Nano).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition"><Name>Windows Server 2016 and above Disk Partition</Name><Description>All instances of a disk partition on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Full.Computer"><Name>Windows Server 2016 Computer (Full)</Name><Description>All instances of computers running the Windows Server 2016 operating system (Full).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Full.ComputerGroup"><Name>Windows Server 2016 Computer Group (Full)</Name><Description>A group containing all computers that are running a Windows Server 2016 operating system (Full).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Full.OperatingSystem"><Name>Windows Server 2016 Operating System (Full)</Name><Description>All instances of the Windows Server 2016 operating system (Full).</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk"><Name>Windows Server 2016 and above Logical Disk</Name><Description>All instances of a logical disk on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter"><Name>Windows Server 2016 and above Network Adapter</Name><Description>All instances of a network adapter on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter" SubElementID="SlotNumber"><Name>Slot ID</Name><Description>The Slot number of a PCI network adapter.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem"><Name>Windows Server 2016 and above Operating System</Name><Description>All instances of the Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem" SubElementID="InstallType"><Name>Install Type</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem" SubElementID="PowerPlan"><Name>Power Plan</Name><Description>Power plan of the Windows Server 2016 operating system.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk"><Name>Windows Server 2016 and above Physical Disk</Name><Description>All instances of a physical disk on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor"><Name>Windows Server 2016 and above Processor</Name><Description>All instances of a processor on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor"><Name>Windows Server 2016 and above Logical Processor</Name><Description>All instances of a Logical processor on Windows Server 2016 and above operating systems.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="DeviceID"><Name>Device Identifier</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="Name"><Name>Device Name</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="Description"><Name>Device Description</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="Manufacturer"><Name>Manufacturer</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="Speed"><Name>Clock Speed</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="MaxClockSpeed"><Name>Max Clock Speed</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" SubElementID="PerfmonInstance"><Name>Performance Instance</Name><Description>Performance Instance of the Windows Server 2016 Logical Processor.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.ProcessorHostsLogicalProcessor"><Name>Physical Processor Hosts Logical Processor</Name><Description>Windows Server 2016 and above Physical Processor Hosts Logical Processor</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Universal.Script.Discovery.DS"><Name>Universal script discovery data source module</Name><Description>This module runs VbScript/JScript or PowerShell if VbScript does not exist and return discovery data</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Universal.Script.Discovery.DS" SubElementID="IntervalSeconds"><Name>Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Universal.Script.Discovery.DS" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe"><Name>PowerShell Script Discovery Probe</Name><Description>Use this module as a part of a composition in a custom data source module type, which will be used in discovery workflows and that uses a PowerShell script to conduct discovery.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellDiscoveryProbe" SubElementID="TimeoutSeconds"><Name>Timeout Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.Undiscovery.Improper.Cluster.Objects.Task"><Name>Undiscovery of improper Windows cluster objects [2016 and above]</Name><Description>The task provides undiscovery of improper cluster entities (logical disks, CPUs, network adapters, disk partitions) for Agentless Managed virtual cluster computers (Cluster Instances and Cluster Groups) and Agent Managed cluster node computers.</Description></DisplayString><DisplayString ElementID="Microsoft.Windows.Server.10.0.RunAsUnDiscoveryProfile"><Name>Windows Server 2016 : Undiscovery improper cluster objects RunAs Account</Name><Description>Windows Server 2016 : Undiscovery improper cluster objects RunAs Account</Description></DisplayString></DisplayStrings><KnowledgeArticles><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.AllServersComputerGroupDiscovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 and above Computer Group" with instances of computers that are running Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Computer.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server class named “Windows Server 2016 and above Computer" with instances of computers that are running Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Nano.AllServersComputerGroupDiscovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 Computer Group (Nano)" with instances of computers that are running Windows Server 2016.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Core.AllServersComputerGroupDiscovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 and above Computer Group (Core)" with instances of computers that are running Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.CPU.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server class named "Windows Server 2016 and above Processor" with instances of Processors that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.2016.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>The Microsoft Windows Server 2016 and above Operating System Management Pack monitors the availability and performance of Windows Server 2016 and above operating systems. By detecting, alerting, and automatically responding to critical events and performance indicators, the Management Pack helps identify, correct, and prevent possible outages related to Windows Server 2016 and above operating systems. As a result, this Management Pack can play an important role in ensuring that your Windows Server infrastructure and related components are available and working correctly.</maml:para><maml:para>By using embedded expertise, this Management Pack highlights performance, health, and availability conditions that indicate problems. In some cases, it can even identify issues before they become critical thus providing you with a level of customer responsiveness that increases the overall availability and performance of your Windows Server  infrastructure and related components. Therefore, this Management Pack will reduce the total cost of ownership (TOC) by enabling proactive management and reducing resolution times for the issues identified.</maml:para><maml:para>The Microsoft Windows Server 2016 and above Operating System Management Pack includes the following features and capabilities:</maml:para><maml:para><maml:ui>Application Structure</maml:ui></maml:para><maml:para>A rich Application Structure is discovered by the Management pack. This Application Structure exposes the relationships between all Windows components and logical devices. For instance, the relationships between the Computer, Operating System, Logical Disks, Partitions, and Physical Disks can all be discovered and viewed from diagram and topology surfaces.</maml:para><maml:para><maml:ui>Monitors and Rules</maml:ui></maml:para><maml:para>A complete set of Monitors and Rules have been provided to monitor Windows services, components, and infrastructure. The Management Pack includes monitoring capabilities for:</maml:para><maml:list><maml:listItem><maml:para>Service and Application Management</maml:para></maml:listItem><maml:listItem><maml:para>Local Storage Management</maml:para></maml:listItem><maml:listItem><maml:para>Performance Management</maml:para></maml:listItem><maml:listItem><maml:para>Reliability Management</maml:para></maml:listItem></maml:list><maml:para/><maml:para><maml:ui>Tasks</maml:ui></maml:para><maml:para>A set of commonly used Tasks have been provided to assist in the diagnosis and remediation of issues that affect the availability, performance, and configuration of Windows Server related services and components.</maml:para><maml:para><maml:ui>Knowledge</maml:ui></maml:para><maml:para>A complete set of Knowledge has been provided for all Monitors, Rules, and Discoveries. For Alert generating Monitors and Rules, you will find Knowledge that will help expedite resolution process. Where applicable, Inline Tasks, Views, and Reports have been added to the Knowledge enable quick diagnostics and the fastest possible resolution.</maml:para><maml:para><maml:ui>Reports</maml:ui></maml:para><maml:para>A series of reports have been provided which will provide administrators with the ability to take a historical look at the Windows Server 2016 and above environment.</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Configuration</maml:title><maml:para>This Management Pack does not require any out-of-the-box configuration. Overrides may be applied to features to modify the out of the box configuration (e.g.: enable/disable monitors and rules, change thresholds, etc.).</maml:para><maml:para>Note: This Management Pack depends on the Microsoft Windows Server Library. Therefore, this Management Pack must be imported during or after the import of the Windows Server Library Management Pack.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.DiskPartition.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Class named "Windows Server 2016 and above Disk Partition" with instances Disk Partitions that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server relationship class named "Disk Partition Contains Logical Disk" with instances of the Disk Partition contains Logical Disk relationship.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Full.AllServersComputerGroupDiscovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Computer group named "Windows Server 2016 Computer Group (Full)" with instances of computers that are running Windows Server 2016.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Class named “Windows Server 2016 and above Logical Disk" with instances of Logical Disks (for example C:, D:) that are discovered on Windows Server 2016 and above operating systems. Please note that only Local Disks are detected. Logical Disks that are classified as Removable, Compact Disk, Network Drive, and RAM Disks are excluded.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.MountPoint.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server Class named “Windows Server 2016 and above Logical Disk" with instances of Mount Points that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.All.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server class named “Windows Server 2016 and above Network Adapter" with instances Network Adapters that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server class named “Windows Server 2016 and above Network Adapter" with instances Network Adapters that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server class named “Windows Server 2016 and above Physical Disk" with instances of Physical Disks that are discovered on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDiskContainsDiskPartition.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This Discovery Rule discovers and populates the Windows Server relationship class named “Physical Disk Contains Disk Partition" with instances of the Physical Disk contains Disk Partition relationship.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.StandardLicense.Discovery" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This discovery rule discovers and populates the class named “System Center Operations Manager Standard License"</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of computers running the Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Nano.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of computers running the Windows Server 2016 operating system (Nano).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Core.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of computers running the Windows Server 2016 (Core) and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Full.Computer" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of computers running the Windows Server 2016 operating system (Full).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of the Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Nano.OperatingSystem" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of the Windows Server 2016 operating system (Nano).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Core.OperatingSystem" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of the Windows Server 2016 (Core) and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Full.OperatingSystem" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of the Windows Server 2016 operating system (Full).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.ComputerGroup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A group containing all computers that are running Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Nano.ComputerGroup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A group containing all computers that are running Windows Server 2016 operating system (Nano).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Core.ComputerGroup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A group containing all computers that are running Windows Server 2016 (Core) and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Full.ComputerGroup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>A group containing all computers that are running a Windows Server 2016 operating system (Full).</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.DiskPartition" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a disk partition on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a logical disk on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a network adapter on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a physical disk on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a processor on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>All instances of a Logical processor on Windows Server 2016 and above operating systems.</maml:para></maml:section></MamlContent></KnowledgeArticle></KnowledgeArticles></LanguagePack></LanguagePacks></ManagementPack>
