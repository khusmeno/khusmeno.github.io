    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_T_hashvalue'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_hashvalue] ON [APM].[PERFHOURLY] 
	(
		[HASHVALUE] ASC
	)
	INCLUDE ( 
	[MINVALUE],
	[MAXVALUE],
	[SAMPLECOUNT],
	[SUMVALUE],
	[PACKAGECOUNTER]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYMACHINEID                                */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYMACHINEID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYMACHINEID on APM.PERFHOURLY (
		MACHINEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYSOURCEID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYSOURCEID'
)
BEGIN
	create index FK_PERFHOURLYSOURCEID on APM.PERFHOURLY (
	SOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYPCTYPEID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYPCTYPEID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYPCTYPEID on APM.PERFHOURLY (
		PCTYPEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYPCPROCESSID                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYPCPROCESSID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYPCPROCESSID on APM.PERFHOURLY (
		PCPROCESSID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PERFHOURLY'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: PERFORMANCENODE                                       */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PERFORMANCENODE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.PERFORMANCENODE (
	   PERFORMANCENODEID    bigint               identity,
	   EVENTID              bigint               not null,
	   RESOURCEID           int                  null,
	   RESOURCEGROUPNODEID  int                  null,
	   DESCRIPTION          nvarchar(255)        null,
	   FUNCTIONNAME         nvarchar(255)        null,
	   RESOURCEMETHOD       nvarchar(255)        null,
	   DURATION             decimal(35)          not null,
	   HASHCODE             nvarchar(255)        null,
	   ENTRYID              int                  not null,
	   SELFDURATION         decimal(35)          null,
	   ROWGUID              nvarchar(15)         null,
	   ISHEAVIESTNODE       bit              not null,
	   constraint PK_PERFORMANCENODE primary key (PERFORMANCENODEID)
	)
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'PERFORMANCENODE' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'IsHeaviestNode' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE APM.PERFORMANCENODE ADD CONSTRAINT DF_PERFORMANCENODE_ISHAVIESTNODE DEFAULT 0 FOR IsHeaviestNode
END	
GO
------------------------ Application Performance index-----------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_EventIdResourceIdSelfDuration1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceIdSelfDuration1] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID] ASC,
		[RESOURCEID] ASC,
		[SELFDURATION] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_EventIdResourceIdDuration'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceIdDuration] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID] ASC,
		[RESOURCEID] ASC,
		[DURATION] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Transfer indexes ------------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performancenode]') AND name = N'idx_T_eventIdResourceId'
)
BEGIN
	CREATE INDEX idx_T_eventIdResourceId on APM.performancenode(eventid, resourceid)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performanceNode]') AND name = N'idx_T_EventIdEntryId'
)
BEGIN
	CREATE INDEX idx_T_EventIdEntryId on APM.performanceNode(EventId, EntryId) WITH (SORT_IN_TEMPDB = ON)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_T_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_EventId] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID]
	)
	INCLUDE ( [PerformanceNodeId],[RESOURCEMETHOD], ResourceGroupNodeId, [EntryId], [RESOURCEID], [SELFDURATION]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performancenode]') AND name = N'idx_T_RowGuid'
)
BEGIN
	CREATE INDEX idx_T_RowGuid on APM.performancenode(rowguid)  
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_T_ResourceIdEventId'
)
BEGIN
	CREATE INDEX idx_T_ResourceIdEventId ON APM.PERFORMANCENODE 
	(
		 RESOURCEID,
		 EVENTID
	) WITH (SORT_IN_TEMPDB = ON) 
END
GO
----------------------- Event Window Indexes ----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PerformanceNode]') AND name = N'idx_W_EventIdResourceIdSelfDuration2'
)
BEGIN
	CREATE INDEX idx_W_EventIdResourceIdSelfDuration2 on APM.PerformanceNode
	( 
		EventId, ResourceId, SelfDuration Desc
	)
	INCLUDE(
	  [Description],
	  [DURATION],
	  [ENTRYID]
	 ) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODERESOURCEID                          */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODERESOURCEID'
)
BEGIN
	create index FK_PERFORMANCENODERESOURCEID on APM.PERFORMANCENODE (
		RESOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODERESOURCEGROUPID                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODERESOURCEGROUPID'
)
BEGIN
	create index FK_PERFORMANCENODERESOURCEGROUPID on APM.PERFORMANCENODE (
		RESOURCEGROUPNODEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODEEVENTID                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODEEVENTID'
)
BEGIN
	create index FK_PERFORMANCENODEEVENTID on APM.PERFORMANCENODE (
		EVENTID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODEVENTIDRESOURCEID                    */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODEVENTIDRESOURCEID'
)
BEGIN
	CREATE INDEX FK_PERFORMANCENODEVENTIDRESOURCEID on APM.PERFORMANCENODE (
		EVENTID ASC,
		RESOURCEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PERFORMANCENODE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: RELATIVEDATES                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RELATIVEDATES'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RELATIVEDATES (
	   ID                   int                  not null,
	   NAME                 nvarchar(255)        not null,
	   ORDERBY              int                  not null
	)
	INSERT INTO APM.RELATIVEDATES VALUES(0, '', 0)
	INSERT INTO APM.RelativeDates([Id], [Name], [OrderBy])
	SELECT 10, 'This Week: First Day', 6 
		UNION ALL
	SELECT 20, 'This Week: Last Day', 7
		UNION ALL
	SELECT 30, 'Previous Week: First Day', 10
		UNION ALL
	SELECT 40, 'Previous Week: Last Day', 11
		UNION ALL
	SELECT 50, 'This Month: First Day', 4
		UNION ALL
	SELECT 60, 'This Month: Last Day', 5
		UNION ALL
	SELECT 70, 'Previous Month: First Day', 8
		UNION ALL
	SELECT 80, 'Previous Month: Last Day', 9
		UNION ALL
	SELECT 90, 'Today', 1
		UNION ALL
	SELECT 100, 'Yesterday', 2
END	
GO
 
/*==============================================================*/
/* Table: RESOURCE                                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.RESOURCE (
	   RESOURCEID           int                  identity,
	   RESOURCEGROUPID      int                  not null,
	   SOURCEID             int                  not null,
	   RESOURCEURIFORMAT    nvarchar(255)        not null,
	   RESOURCEURI          nvarchar(255)        not null,
	   constraint PK_RESOURCE primary key (RESOURCEID)
	)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_GroupResourceUri'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_GroupResourceUri] ON [APM].[RESOURCE] 
	(
		[RESOURCEGROUPID] ASC,
		[RESOURCEID] ASC,
		[RESOURCEURI] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Transfer indexes -----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_T_SourceResourceUri'
)
BEGIN
	CREATE INDEX idx_T_SourceResourceUri ON APM.RESOURCE(sourceId, resourceUri) 
	include(resourceid, resourcegroupid) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_T_ResGroupUri'
)
BEGIN
	CREATE INDEX idx_T_ResGroupUri ON APM.RESOURCE(ResourceGroupId, ResourceUri) include (sourceId, resourceid)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Event WINDOW indexes -----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_W_ResourceUri'
)
BEGIN
	CREATE INDEX idx_W_ResourceUri ON APM.RESOURCE (ResourceUri) INCLUDE(ResourceGroupId) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCERESOURCEGROUPID                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'FK_RESOURCERESOURCEGROUPID'
)
BEGIN
	create index FK_RESOURCERESOURCEGROUPID on APM.RESOURCE (
		RESOURCEGROUPID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCESOURCEID                                   */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'FK_RESOURCESOURCEID'
)
BEGIN
	CREATE INDEX FK_RESOURCESOURCEID on APM.RESOURCE (
		SOURCEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'RESOURCE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: RESOURCEGROUP                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCEGROUP'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RESOURCEGROUP (
	   RESOURCEGROUPID      int                  identity,
	   NAME                 nvarchar(255)        not null,
	   constraint PK_RESOURCEGROUP primary key (RESOURCEGROUPID)
	)
END
GO
/*==============================================================*/
/* Table: RESOURCEGROUPNODE                                     */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCEGROUPNODE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RESOURCEGROUPNODE (
	   RESOURCEGROUPNODEID  int                  identity,
	   EVENTID              bigint               not null,
	   RESOURCEGROUPID      int                  not null,
	   DURATION             bigint               not null,
	   CALLCOUNT            int                  null,
	   constraint PK_RESOURCEGROUPNODE primary key (RESOURCEGROUPNODEID)
	)
END
GO
---------------------- Application Performance index-----------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'idx_EventIdResourceGroupNodeIdResourceGroupId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceGroupNodeIdResourceGroupId] ON [APM].[RESOURCEGROUPNODE] 
	(
		[EVENTID] ASC,
		[RESOURCEGROUPNODEID] ASC,
		[RESOURCEGROUPID] ASC
	)
	INCLUDE ( [DURATION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCEGROUPNODERESOURCEGROUPID                   */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'FK_RESOURCEGROUPNODERESOURCEGROUPID'
)
BEGIN
	CREATE INDEX FK_RESOURCEGROUPNODERESOURCEGROUPID on APM.RESOURCEGROUPNODE (
		RESOURCEGROUPID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCEGROUPNODEEVENTID                           */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'FK_RESOURCEGROUPNODEEVENTID'
)
BEGIN
	CREATE INDEX FK_RESOURCEGROUPNODEEVENTID on APM.RESOURCEGROUPNODE (
		EVENTID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'RESOURCEGROUPNODE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: SEVIEWERDB                                            */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.SEVIEWERDB'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.SEVIEWERDB (
	   SEVIEWERDBID         int                  identity,
	   DATABASEID           uniqueidentifier     not null,
	   ADDRESS              nvarchar(max)        null,
	   constraint PK_SEVIEWERDB primary key (SEVIEWERDBID)
	)
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'SEVIEWERDB' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'database_id_uniq'
)
BEGIN
	ALTER TABLE APM.SEVIEWERDB add constraint database_id_uniq unique(databaseId)
END	
GO
/*==============================================================*/
/* Table: SOURCE                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.SOURCE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.SOURCE (
	   SOURCEID             int                  identity,
	   SOURCE               nvarchar(255)        NOT NULL,
	   CONSTRAINT PK_SOURCE primary key (SOURCEID),
	   CONSTRAINT UC_SOURCE_SOURCE UNIQUE (SOURCE)
	)
END
GO
/*==============================================================*/
/* Index: IX_SOURCE                                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[SOURCE]') AND name = N'IX_SOURCE'
)
BEGIN
	create unique index IX_SOURCE on APM.SOURCE (
		SOURCE ASC
	)
END
GO
/*==============================================================*/
/* Table: TASKS                                                 */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.TASKS'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.TASKS (
	   TASKID               int                  identity,
	   TABLENAME            nvarchar(50)         not null,
	   STARTDATE            datetime             null,
	   ENDDATE              datetime             null,
	   OPERATIONID          int                  not null,
	   LASTTIMESTAMP        bigint               null,
	   STATUS               nvarchar(50)         null,
	   SEVIEWERDBID         int                  null,
	   constraint PK_TASKS primary key (TASKID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[TASKS]') AND name = N'idx_T_TableNameDatabase'
)
BEGIN
	CREATE INDEX idx_T_TableNameDatabase ON APM.TASKS
		(tablename, seviewerdbid) INCLUDE(lasttimestamp) 
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'TASKS'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: TIMEZONE                                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.TIMEZONE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.TIMEZONE (
	   NAME                 nvarchar(255)        null,
	   OFFSET               int                  null
	)
	
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-12:00', -720)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-11:00', -660)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-10:00', -600)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-9:00', -540)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-8:00', -480)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-7:00', -420)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-6:00', -360)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-5:00', -300)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-4:00', -240)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-3:30', -210)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-3:00', -180)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-2:00', -120)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-1:00', -60)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-0:00', 0)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+1:00', 60)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+2:00', 120)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+3:00', 180)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+3:30', 210)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+4:00', 240)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+4:30', 270)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:00', 300)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:30', 330)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:45', 345)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:00', 360)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:30', 390)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+7:00', 420)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+8:00', 480)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+9:00', 540)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+9:30', 570)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+10:00', 600)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+11:00', 660)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+12:00', 720)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+13:00', 780)
	/* Daylight Saving time zones*/
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-2:30', -150)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:45', 405)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+10:30', 630)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+14:00', 840)
END
GO
/*==============================================================*/
/* Table: USERS                                                 */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.USERS'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.USERS (
	   USERID               int                  identity,
	   NAME                 nvarchar(255)        not null,
	   constraint PK_USERS primary key (USERID)
	)
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'Users' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'Name_Unique'
)
BEGIN
	ALTER TABLE [APM].[Users] ADD  CONSTRAINT Name_Unique UNIQUE  (NAME) 
END	
GO
/*==============================================================*/
/* Table: EVENTDETAIL                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.EVENTDETAIL'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE [APM].[EVENTDETAIL](
		[EVENTDETAILID] [int] IDENTITY(1,1) NOT NULL,
		[EVENTID] [bigint] NULL,
		[NAME] [nvarchar](50) NULL,
		[VALUE] [nvarchar](255) NULL,
		[VALUETYPE] [nvarchar](50) NULL
	 CONSTRAINT [PK_EVENTDETAIL] PRIMARY KEY CLUSTERED 
	(
		[EVENTDETAILID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
END
GO
/****** Object:  Index [IX_EVENTID]    ******/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTDETAIL]') AND name = N'IX_EVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [IX_EVENTID] ON [APM].[EVENTDETAIL] 
	(
		  [EVENTID] ASC
	)WITH (MAXDOP = 1, SORT_IN_TEMPDB = ON, ONLINE = OFF) ON [PRIMARY]
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EVENTDETAIL'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSEVENTDETAIL                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSEVENTDETAIL'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE [APM].[CSEVENTDETAIL](
		[CSEVENTDETAILID] [int] IDENTITY(1,1) NOT NULL,
		[CSEVENTID] [int] NULL,
		[NAME] [nvarchar](50) NULL,
		[VALUE] [nvarchar](255) NULL,
		[VALUETYPE] [nvarchar](50) NULL
	 CONSTRAINT [PK_CSEVENTDETAIL] PRIMARY KEY CLUSTERED 
	(
		[CSEVENTDETAILID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
END
GO
/****** Object:  Index [[IX_CSEVENTID]]    ******/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENTDETAIL]') AND name = N'IX_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [IX_CSEVENTID] ON [APM].[CSEVENTDETAIL] 
	(
		  [CSEVENTID] ASC
	)WITH (MAXDOP = 1, SORT_IN_TEMPDB = ON, ONLINE = OFF) ON [PRIMARY]
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSEVENTDETAIL'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* View: V_APPLICATIONSOURCEMACHINE                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_APPLICATIONSOURCEMACHINE'), 'IsView') IS NULL) 
BEGIN
    EXECUTE('CREATE VIEW APM.V_APPLICATIONSOURCEMACHINE
				AS				
				select clmn=1')
END
GO
ALTER VIEW APM.V_APPLICATIONSOURCEMACHINE as
SELECT A.APPLICATIONID, B.SOURCEID, M.MACHINEID, A.APPLICATION, B.SOURCE, M.MACHINE AS MACHINENAME
FROM APM.APPLICATION A 
    INNER JOIN APM.APPLICATIONSOURCEMACHINE C ON A.APPLICATIONID = C.APPLICATIONID
    LEFT JOIN APM.SOURCE B ON B.SOURCEID = C.SOURCEID 
    LEFT JOIN APM.MACHINE M ON M.MACHINEID = C.MACHINEID
GO
/*==============================================================*/
/* View: V_EVENTWINDOW                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_EVENTWINDOW'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_EVENTWINDOW
				AS				
				select clmn=1')
END
GO
ALTER VIEW APM.V_EVENTWINDOW as
SELECT E.EVENTID, E.EVENTGROUPID, E.CATEGORY, E.DESCRIPTION, E.EVENTDURATION, E.ROOTNODENAME,
    E.UTCEVENTDATE, E.EVENTCLASSTYPE, E.ASPECT,E.EXCEPTIONCLASS, E.RESOURCEID, E.ROWGUID, E.HEAVYLIGHT,E.SEVIEWEREGID,
    S.SOURCE, S.SOURCEID, M.MACHINE, M.MACHINEID, SDB.ADDRESS AS PATH,
    E.USERID,USR.NAME AS USERNAME, E.PMSTATUS
FROM APM.EVENT (NOLOCK) AS E  INNER JOIN APM.SOURCE AS S ON S.SOURCEID=E.SOURCEID
    INNER JOIN APM.MACHINE (NOLOCK) AS M ON M.MACHINEID=E.MACHINEID
    INNER JOIN APM.SEVIEWERDB (NOLOCK) AS SDB ON SDB.SEVIEWERDBID=E.SEVIEWERDBID
    LEFT JOIN APM.USERS (NOLOCK) AS USR ON E.USERID=USR.USERID
GO
/* foreign key to trace */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMSERVEREVENTTRACE_PMTRACE')
BEGIN
	ALTER TABLE APM.PMSERVEREVENTTRACE ADD CONSTRAINT FK_PMSERVEREVENTTRACE_PMTRACE FOREIGN KEY (PMTRACEID) REFERENCES APM.PMTRACE(PMTRACEID)
END 
GO
/* foreign key to event delete cascade */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMSERVEREVENTTRACE_PMEVENT')
BEGIN
	ALTER TABLE APM.PMSERVEREVENTTRACE ADD CONSTRAINT FK_PMSERVEREVENTTRACE_PMEVENT FOREIGN KEY (EVENTID) REFERENCES APM.EVENT(EVENTID) ON DELETE CASCADE
END 
GO
GO
/* foreign key to trace */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMCLIENTEVENTTRACE_PMTRACE')
BEGIN
	ALTER TABLE APM.PMCLIENTEVENTTRACE ADD CONSTRAINT FK_PMCLIENTEVENTTRACE_PMTRACE FOREIGN KEY (PMTRACEID) REFERENCES APM.PMTRACE(PMTRACEID)
END 
GO
/* foreign key to csevent delete cascade */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMCLIENTEVENTTRACE_PMEVENT')
BEGIN
	ALTER TABLE APM.PMCLIENTEVENTTRACE ADD CONSTRAINT FK_PMCLIENTEVENTTRACE_PMEVENT FOREIGN KEY (CSEVENTID) REFERENCES APM.CSEVENT(CSEVENTID) ON DELETE CASCADE
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENTDET_REFERENCE_EVENT')
BEGIN
	ALTER TABLE [APM].[EVENTDETAIL]  WITH CHECK ADD  CONSTRAINT [FK_EVENTDET_REFERENCE_EVENT] FOREIGN KEY([EVENTID])
	REFERENCES [APM].[EVENT] ([EVENTID])
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENTDET_REFERENCE_CSEVENT')
BEGIN
	ALTER TABLE [APM].[CSEVENTDETAIL]  WITH CHECK ADD  CONSTRAINT [FK_CSEVENTDET_REFERENCE_CSEVENT] FOREIGN KEY([CSEVENTID])
	REFERENCES [APM].[CSEVENT] ([CSEVENTID])
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_APPLIC_APPLICAT')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_APPLIC_APPLICAT foreign key (APPLICATIONID)
		  references APM.APPLICATION (APPLICATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_MACHIN_MACHINE')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_MACHIN_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_SOURCE_SOURCE')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_SOURCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSAJAX_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSAJAX
	   add constraint FK_CSAJAX_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSASYNCA_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSASYNCAJAX
	   add constraint FK_CSASYNCA_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_MACHINE')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_SOURCE')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_CSEVENTG')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_CSEVENTG foreign key (CSEVENTGROUPID)
		  references APM.CSEVENTGROUP (CSEVENTGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_IP')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_IP foreign key (IPID)
		  references APM.IP (IPID)
END 
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSEVENT_USERS'
)
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_USERS foreign key (USERID)
		  references APM.USERS (USERID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSEXEVEN_REFERENCE_CSEVENT'
)
BEGIN
	alter table APM.CSEXEVENT
	   add constraint FK_CSEXEVEN_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSHEAVIE_REFERENCE_CSEVENT'
)
BEGIN
	alter table APM.CSHEAVIESTRESOURCE
	   add constraint FK_CSHEAVIE_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSJSCRIP_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSJSCRIPTEVENT
	   add constraint FK_CSJSCRIP_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPAGEEV_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSPAGEEVENT
	   add constraint FK_CSPAGEEV_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPERIPH_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSPERIPHERAL
	   add constraint FK_CSPERIPH_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPERIPH_REFERENCE_CSPERIPH')
BEGIN
	alter table APM.CSPERIPHERALDETAIL
	   add constraint FK_CSPERIPH_REFERENCE_CSPERIPH foreign key (CSPERIPHERALID)
		  references APM.CSPERIPHERAL (CSPERIPHERALID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_DATASET_AGGREGATION')
BEGIN
	alter table APM.DATASET
	   add constraint FK_DATASET_AGGREGATION foreign key (AGGREGATIONTYPEID)
		  references APM.AGGREGATIONTYPE (AGGREGATIONTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_DATASET_HISTORY')
BEGIN
	alter table APM.DATASETAGGREGATIONHISTORY
	   add constraint FK_DATASET_HISTORY foreign key (DATASETID)
		  references APM.DATASET (DATASETID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENTG_EVENTGRO')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENTG_EVENTGRO foreign key (EVENTGROUPID)
		  references APM.EVENTGROUP (EVENTGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENT__IP')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENT__IP foreign key (IPID)
		  references APM.IP (IPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENT__SEVIEWER')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENT__SEVIEWER foreign key (SEVIEWERDBID)
		  references APM.SEVIEWERDB (SEVIEWERDBID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_SOURCE_SOURCE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_SOURCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_REFERENCE_MACHINE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_REFERENCE_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_REFERENCE_RESOURCE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_USERS')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_USERS foreign key (USERID)
		  references APM.USERS (USERID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EXCEPTIO_FK_EXCEPT_EVENT')
BEGIN
	alter table APM.EXCEPTIONNODE
	   add constraint FK_EXCEPTIO_FK_EXCEPT_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EXCEPTIO_REFERENCE_RESOURCE')
BEGIN
	alter table APM.EXCEPTIONNODE
	   add constraint FK_EXCEPTIO_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_MEMBERAP_FK_APPLIC_APPLICAT')
BEGIN
	alter table APM.MEMBERAPPLICATION
	   add constraint FK_MEMBERAP_FK_APPLIC_APPLICAT foreign key (APPLICATIONID)
		  references APM.APPLICATION (APPLICATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_MEMBERAP_FK_USER_MEMBER')
BEGIN
	alter table APM.MEMBERAPPLICATION
	   add constraint FK_MEMBERAP_FK_USER_MEMBER foreign key (MEMBERID)
		  references APM.MEMBER (MEMBERID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_TYPE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_TYPE foreign key (PCTYPEID)
		  references APM.PCTYPE (PCTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_MACHINE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_SOURCE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAIL_REFERENCE_PCPROCES')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAIL_REFERENCE_PCPROCES foreign key (PCPROCESSID)
		  references APM.PCPROCESS (PCPROCESSID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_PCTYPE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_PCTYPE foreign key (PCTYPEID)
		  references APM.PCTYPE (PCTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_MACHINE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_SOURCE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOUR_REFERENCE_PCPROCES')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOUR_REFERENCE_PCPROCES foreign key (PCPROCESSID)
		  references APM.PCPROCESS (PCPROCESSID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMANCENODE_EVENT')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMANCENODE_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMA_REFERENCE_RESOURCEGROUP')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMA_REFERENCE_RESOURCEGROUP foreign key (RESOURCEGROUPNODEID)
		  references APM.RESOURCEGROUPNODE (RESOURCEGROUPNODEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMA_REFERENCE_RESOURCE')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMA_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_RESOURCE')
BEGIN
	alter table APM.RESOURCE
	   add constraint FK_RESOURCE_REFERENCE_RESOURCE foreign key (RESOURCEGROUPID)
		  references APM.RESOURCEGROUP (RESOURCEGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_SOURCE')
BEGIN
	alter table APM.RESOURCE
	   add constraint FK_RESOURCE_REFERENCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_RESOURCENODE')
BEGIN
	alter table APM.RESOURCEGROUPNODE
	   add constraint FK_RESOURCE_REFERENCE_RESOURCENODE foreign key (RESOURCEGROUPID)
		  references APM.RESOURCEGROUP (RESOURCEGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_EVENT')
BEGIN
	alter table APM.RESOURCEGROUPNODE
	   add constraint FK_RESOURCE_REFERENCE_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_TASKS_TaskMode')
BEGIN
	alter table APM.TASKS
	   add constraint FK_TASKS_TaskMode foreign key (OPERATIONID)
		  references APM.OPERATION (OPERATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_TASKS_REFERENCE_SEVIEWER')
BEGIN
	alter table APM.TASKS
	   add constraint FK_TASKS_REFERENCE_SEVIEWER foreign key (SEVIEWERDBID)
		  references APM.SEVIEWERDB (SEVIEWERDBID)
END 
GO
/*==============================================================*/
/* Common security reporting functions                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.FN_ADMINUSER'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.FN_ADMINUSER ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/*==============================================================*/
/* Function: FN_ADMINUSER                                       */
/*==============================================================*/
ALTER FUNCTION APM.FN_ADMINUSER(@USERNAME NVARCHAR(100))  
RETURNS INT AS  
BEGIN  
  DECLARE @A INT 
  SET @A = (SELECT MEMBERID FROM APM.MEMBER WHERE LOGINNAME = @USERNAME AND USERTYPE='a')
  RETURN @A
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FN_ISSECURE'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.FN_ISSECURE ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/*==============================================================*/
/* Function: FN_ISSECURE                                        */
/*==============================================================*/
ALTER FUNCTION APM.FN_ISSECURE ()  
RETURNS INT AS  
BEGIN  
    DECLARE @A INT
    SELECT @A = CAST(CAST(CONFIGVALUE AS NCHAR)  AS INT) FROM APM.CONFIG WHERE CONFIGNAME = 'SECURITYMODE'
    RETURN @A
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATASETAGGREGATE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.DATASETAGGREGATE AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.DATASETAGGREGATE
   @DATASETNAME NVARCHAR(50)
  ,@DESCRIPTORS NTEXT
  ,@AGGREGATIONTARGETSTARTDATETIME DATETIME = NULL
  ,@INTERVALSTOAGGREGATE INT = NULL
  ,@RETURN BIT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE
     @DATASETID INT
    ,@AGGREGATIONINTERVALCOUNT INT
    ,@LASTMIDNIGHTDATETIME DATETIME
    ,@CURRENTAGGREGATIONSTARTDELAYMINUTES INT
    ,@CURRENTAGGREGATIONTYPEID TINYINT
    ,@CURRENTAGGREGATIONINTERVALDURATIONMINUTES INT
    ,@INTERVALSTARTDATETIME DATETIME
    ,@INTERVALENDDATETIME DATETIME
    ,@DATASETAGGREGATIONHISTORYID INT
    ,@I INT
    ,@AGGREGATIONSTARTDATETIME DATETIME
    ,@STATEMENT NVARCHAR(255)
    ,@UTCOFFSETMINUTES INT
    ,@MAXDATAAGEDAYS INT    
    ,@MAXHISTORYDATE DATETIME
  DECLARE
     @ERROR INT
  SET @UTCOFFSETMINUTES = DATEDIFF(MINUTE, GETDATE(), GETUTCDATE())
    
  SELECT
    @DATASETID                = DATASETID, 
    @AGGREGATIONINTERVALCOUNT = ISNULL(@INTERVALSTOAGGREGATE, DEFAULTAGGREGATIONINTERVALCOUNT),
    @CURRENTAGGREGATIONTYPEID = AGTYPE.AGGREGATIONTYPEID,
    @CURRENTAGGREGATIONINTERVALDURATIONMINUTES = AGTYPE.AGGREGATIONINTERVALDURATIONMINUTES,
    @CURRENTAGGREGATIONSTARTDELAYMINUTES = AGTYPE.AGGREGATIONSTARTDELAYMINUTES,
    @STATEMENT = AGGREGATIONMETHODNAME
  FROM APM.DATASET DATASET
    JOIN APM.AGGREGATIONTYPE AGTYPE ON AGTYPE.AGGREGATIONTYPEID = DATASET.AGGREGATIONTYPEID
  WHERE DATASET.DATASETNAME = @DATASETNAME
   SET @ERROR = 0
              
    IF (@AGGREGATIONINTERVALCOUNT &lt; 1)
      SET @AGGREGATIONINTERVALCOUNT = 1
      
    IF (@AGGREGATIONTARGETSTARTDATETIME IS NULL)
      SET @AGGREGATIONTARGETSTARTDATETIME = GETUTCDATE()
      
    -- FIND THE LAST AGGREGATION INTERVAL WHICH ENDED BEFORE
    -- THE AGGREGATION START DATE TIME
    IF (@CURRENTAGGREGATIONTYPEID &lt; 30)
    BEGIN
      --HOURLY AGGREGATION
      SET @LASTMIDNIGHTDATETIME = CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME)
      SET @INTERVALSTARTDATETIME = DATEADD(
             MINUTE
            ,ABS(DATEDIFF(MINUTE, @LASTMIDNIGHTDATETIME, @AGGREGATIONTARGETSTARTDATETIME)) / @CURRENTAGGREGATIONINTERVALDURATIONMINUTES * @CURRENTAGGREGATIONINTERVALDURATIONMINUTES - @CURRENTAGGREGATIONINTERVALDURATIONMINUTES
            ,CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME))
    END
    ELSE IF (@CURRENTAGGREGATIONTYPEID = 30)
    BEGIN
      --DAILY AGGREGATION
--      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), GETDATE(), 112) AS DATETIME))
      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME))
    END
    SET @I = @AGGREGATIONINTERVALCOUNT
    DECLARE @AGGREGATION TABLE
    (
      AGGREGATIONDATETIME  DATETIME  NOT NULL,
      AGGREGATIONTYPEID BIT NOT NULL
    )     
    WHILE (@I &gt; 0)
    BEGIN
      INSERT @AGGREGATION(AGGREGATIONDATETIME, AGGREGATIONTYPEID)
        VALUES (@INTERVALSTARTDATETIME, @CURRENTAGGREGATIONTYPEID)
      
      SET @I = @I - 1
      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, -@CURRENTAGGREGATIONINTERVALDURATIONMINUTES, @INTERVALSTARTDATETIME)
    END
        
    -- GROOM AGGREGATION HISTORY
    SELECT @MAXDATAAGEDAYS = ISNULL(MAXDATAAGEDAYS, 30) 
    FROM DATASET WHERE DATASETID = @DATASETID 
    SELECT @MAXHISTORYDATE = DATEADD(DD, -@MAXDATAAGEDAYS, ISNULL(MAX(AGGREGATIONDATETIME), GETUTCDATE())) 
    FROM DATASETAGGREGATIONHISTORY WHERE DIRTYIND = 0 AND DATASETID = @DATASETID
    
    DELETE DATASETAGGREGATIONHISTORY       
      WHERE (AGGREGATIONDATETIME &lt; @MAXHISTORYDATE) AND (DIRTYIND = 0)
    
    INSERT APM.DATASETAGGREGATIONHISTORY (
       DATASETID
      ,AGGREGATIONDATETIME
    )
    SELECT
       @DATASETID
      ,A.AGGREGATIONDATETIME
    FROM @AGGREGATION A
    WHERE NOT EXISTS (SELECT * FROM APM.DATASETAGGREGATIONHISTORY
                      WHERE (DATASETID = @DATASETID)
                        AND (AGGREGATIONDATETIME = A.AGGREGATIONDATETIME)
                     )
    
    
    -- SELECT AGGREGATION PERIOD TO WORK ON
    -- FIRST SELECT OLDEST NEVER AGGREGATED INTERVAL
    -- IF NONE EXIST SELECT OLDEST DIRTY INTERVAL
    SELECT TOP 1
       @DATASETAGGREGATIONHISTORYID = DATASETAGGREGATIONHISTORYID
      ,@INTERVALSTARTDATETIME = AH.AGGREGATIONDATETIME
      ,@INTERVALENDDATETIME = DATEADD(MINUTE, @CURRENTAGGREGATIONINTERVALDURATIONMINUTES, AH.AGGREGATIONDATETIME)
    FROM APM.DATASETAGGREGATIONHISTORY AH
    WHERE (AH.DATASETID = @DATASETID)
      AND (DATEADD(MINUTE, @CURRENTAGGREGATIONINTERVALDURATIONMINUTES + @CURRENTAGGREGATIONSTARTDELAYMINUTES, AH.AGGREGATIONDATETIME) &lt; GETUTCDATE()) -- AGGREGATION INTERVAL + SLIGHT DELAY IS IN THE PAST
      AND (DIRTYIND = 1)
    ORDER BY AH.AGGREGATIONDATETIME ASC
            
    IF (@RETURN = 1) 
    BEGIN
      CREATE TABLE #DATASETAGGREGATETABLE 
      (
        UTCDATE      DATETIME
       ,PCTYPEID     INT
       ,MACHINEID    INT
       ,SOURCEID     INT
       ,PCPROCESSID  INT 
       ,IS_STATE     INT 
       ,AVERAGEVALUE DECIMAL(18, 4)
       ,SUMVALUE     DECIMAL(18, 4)
       ,MINVALUE     DECIMAL(18, 4)
       ,MAXVALUE     DECIMAL(18, 4)
       ,SAMPLECOUNT  INT
       ,PACKAGECOUNTER INT      
      )
      SET @ERROR = @@ERROR
    
      IF (@ERROR &lt;&gt; 0) 
    GOTO ERRORQUIT
    END
 
    IF (@DATASETAGGREGATIONHISTORYID IS NOT NULL)
    BEGIN
      DECLARE @SQL NVARCHAR(1000)
      SET @SQL = 
        N'EXEC APM.' + QUOTENAME(@STATEMENT) + 
        '
          @DESCRIPTORS 
         ,@INTERVALSTARTDATETIME
         ,@INTERVALENDDATETIME                      
        '
      IF (@RETURN = 1)
        SET @SQL = N'INSERT INTO #DATASETAGGREGATETABLE ' + @SQL
        
      EXECUTE SP_EXECUTESQL @SQL, N'@DESCRIPTORS ntext, @INTERVALSTARTDATETIME datetime, @INTERVALENDDATETIME datetime',
         @DESCRIPTORS,
         @INTERVALSTARTDATETIME,
         @INTERVALENDDATETIME
      SET @ERROR = @@ERROR
      IF (@ERROR = 0)
      BEGIN      
        -- UPDATE AGGREGATION HISTORY
        UPDATE DATASETAGGREGATIONHISTORY
        SET DIRTYIND = 0
        WHERE (DATASETID = @DATASETID)
          AND (AGGREGATIONDATETIME = @INTERVALSTARTDATETIME)
      END
    END
    IF (@RETURN = 1)
      SELECT * FROM #DATASETAGGREGATETABLE
   ERRORQUIT:
     RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCOUNTERAGGREGATE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCOUNTERAGGREGATE AS RETURN 1')
  END
GO
alter PROCEDURE APM.PCOUNTERAGGREGATE
   @DESCRIPTORS NTEXT 
  ,@INTERVALSTARTDATETIME DATETIME
  ,@INTERVALENDDATETIME DATETIME
AS
BEGIN
  SET NOCOUNT ON
  DECLARE @ERROR INT
  SET @ERROR = 0
  CREATE TABLE #PCOUNTERAGGREGATE_TMP (PCTYPEID INT, MACHINEID INT, PACKAGECOUNTER INT) 
  INSERT INTO  #PCOUNTERAGGREGATE_TMP(PCTYPEID, MACHINEID, PACKAGECOUNTER)  
    SELECT 
        P.PCTYPEID,
        P.MACHINEID,
        COUNT(DISTINCT P.UTCDATE) PACKAGE_COUNT
    FROM 
        PERFHOURLY P WITH (NOLOCK)      
        JOIN PCTYPE T WITH (NOLOCK) ON T.PCTYPEID = P.PCTYPEID AND
                T.TYPE IN (
                    N'\Processor\% Processor Time', 
                    N'\PROCESS\PRIVATE BYTES', 
                    N'\PROCESS\IO DATA BYTES/SEC'
                    )
    WHERE 
        (COALESCE(P.SUMVALUE, 0) &lt;&gt; 0) 
        AND (P.UTCDATE &gt;= @INTERVALSTARTDATETIME)
        AND (P.UTCDATE &lt; @INTERVALENDDATETIME)    
    GROUP BY
        P.PCTYPEID, 
        P.MACHINEID
   INSERT PERFDAILY (
       UTCDATE
      ,PCTYPEID
      ,MACHINEID
      ,SOURCEID
      ,PCPROCESSID 
      ,IS_STATE
      ,AVERAGEVALUE
      ,SUMVALUE
      ,MINVALUE
      ,MAXVALUE
      ,SAMPLECOUNT
      ,PACKAGECOUNTER
      )
      SELECT
       @INTERVALSTARTDATETIME 
       ,P.PCTYPEID
       ,P.MACHINEID
       ,P.SOURCEID
       ,P.PCPROCESSID  
       ,P.IS_STATE  
       ,AVG(P.SUMVALUE) 
       ,SUM(P.SUMVALUE) 
       ,MIN(P.SUMVALUE)
       ,MAX(P.SUMVALUE)
       ,COUNT(*)
       ,MIN(PACK.PACKAGECOUNTER)
      FROM 
        APM.PERFHOURLY P
        JOIN #PCOUNTERAGGREGATE_TMP PACK ON PACK.MACHINEID = P.MACHINEID AND PACK.PCTYPEID = P.PCTYPEID
      WHERE 
        (COALESCE(P.SUMVALUE, 0) &lt;&gt; 0) 
        AND (P.UTCDATE &gt;= @INTERVALSTARTDATETIME)
        AND (P.UTCDATE &lt; @INTERVALENDDATETIME)    
      GROUP BY 
         P.PCTYPEID 
        ,P.MACHINEID
        ,P.SOURCEID
        ,P.PCPROCESSID  
        ,P.IS_STATE 
  
  QUIT:
  QUITERROR:
    RETURN @ERROR 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.RUNDAILYAGGREGATEOPERATION'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.RUNDAILYAGGREGATEOPERATION AS RETURN 1')
  END
GO
ALTER   PROCEDURE APM.RUNDAILYAGGREGATEOPERATION
   @DATASETNAME NVARCHAR(50)
  ,@DESCRIPTORS NTEXT
  ,@AGGREGATIONTARGETSTOPDATETIME DATETIME
  ,@TRACELEVEL INT 
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
    @ERROR INT
   ,@STARTDATE DATETIME
   ,@ENDDATE DATETIME
   ,@STEPCOUNT INT
   ,@MAXDAILYDATAAGEDAYS INT
   ,@MAXHOURLYDATAAGEDAYS INT
   ,@MAXDAILYHISTORYDATE DATETIME   
   ,@MAXHOURLYHISTORYDATE DATETIME
   ,@UTCOFFSETMINUTES INT
   ,@UTCDATETIME DATETIME
   ,@CHECKDATE DATETIME
   ,@HANDLER INT
   ,@ROWCOUNT INT
   ,@RESLOCK BIT
    SET @RESLOCK = 0
    EXECUTE  @ERROR = SP_GETAPPLOCK  
               @RESOURCE = N'RUNDAILYAGGREGATEOPERATION' 
              ,@LOCKMODE =  N'Exclusive'
              ,@LOCKOWNER =  N'Session'
              ,@LOCKTIMEOUT =  '0' 
    
    IF @ERROR = 0 
      SET @RESLOCK = 1  
    IF @ERROR &lt;&gt; 0 
    BEGIN
      IF @ERROR = -1 SET @ERROR = 0 
      GOTO QUIT 
    END
    SET @ERROR = 0 
  SET @UTCOFFSETMINUTES = DATEDIFF(MINUTE, GETDATE(), GETUTCDATE())
  SELECT 
    @ENDDATE   = MAX(UTCDATE) 
  FROM 
    PERFHOURLY WITH (NOLOCK)
  WHERE 
    UTCDATE &lt; @AGGREGATIONTARGETSTOPDATETIME
  SET @ENDDATE = ISNULL(@ENDDATE, '19010101')
  SET @UTCDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), @ENDDATE, 112) AS DATETIME))
  SET @ENDDATE = DATEADD(HH,DATEPART(HH, @UTCDATETIME), CAST(CONVERT(CHAR(8), @ENDDATE, 112) AS DATETIME))
  SELECT @STARTDATE = MAX(H.AGGREGATIONDATETIME)  
     FROM APM.DATASETAGGREGATIONHISTORY H
    JOIN DATASET D ON D.DATASETID = H.DATASETID AND D.DATASETNAME = @DATASETNAME
       WHERE H.DIRTYIND = 0
  IF @STARTDATE IS NULL 
  BEGIN
    SELECT @STARTDATE   = MIN(UTCDATE) 
      FROM PERFHOURLY WITH (NOLOCK)
       WHERE UTCDATE &lt; @AGGREGATIONTARGETSTOPDATETIME
  END    
  SET @STARTDATE = ISNULL(@STARTDATE, '19010101')
  SET @STARTDATE = DATEADD(DD, -1, @STARTDATE)
  SET @STEPCOUNT = ISNULL(DATEDIFF(DD, @STARTDATE, @ENDDATE), 0)
  SET @CHECKDATE = DATEADD(HH,DATEPART(HH, @UTCDATETIME), CAST(CONVERT(CHAR(8), @STARTDATE, 112) AS DATETIME)) 
  WHILE (DATEADD(DD, @STEPCOUNT + 1, @CHECKDATE) &gt; @ENDDATE) 
  BEGIN
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  SET @ENDDATE = DATEADD(DD, -1, @ENDDATE)
  
  IF (@STEPCOUNT &gt; 0)
  BEGIN
    EXEC APM.DATASETAGGREGATE
       @DATASETNAME
      ,@DESCRIPTORS
      ,@AGGREGATIONTARGETSTARTDATETIME = @ENDDATE
      ,@INTERVALSTOAGGREGATE = @STEPCOUNT
      ,@RETURN = 0      
    SET @ERROR = @@ERROR
    IF (@ERROR &lt;&gt; 0)
    GOTO QUIT
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  WHILE (@STEPCOUNT &gt; 0)
  BEGIN
    EXEC APM.DATASETAGGREGATE
       @DATASETNAME
      ,@DESCRIPTORS
      ,@AGGREGATIONTARGETSTARTDATETIME = @ENDDATE
      ,@INTERVALSTOAGGREGATE = 1
      ,@RETURN = 0      
    IF (@ERROR &lt;&gt; 0)
    GOTO QUIT     
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  
  SET @ERROR = @@ERROR
  QUIT:
    IF @RESLOCK = 1 
    BEGIN
      EXECUTE SP_RELEASEAPPLOCK 
                 @RESOURCE = N'RUNDAILYAGGREGATEOPERATION'
                ,@LOCKOWNER =  N'Session'   
    END 
    RETURN @ERROR                   
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.HourlyTableInit'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.HourlyTableInit AS RETURN 1')
  END
GO
alter procedure APM.HourlyTableInit
as 
begin
  declare 
    @DATE as datetime
   ,@ITERATOR as int
  
  set @ITERATOR = 1
  set @DATE = '19000101'
  while @ITERATOR &lt;= 24 
  begin
    insert into APM.HourlyTable Values(@DATE)
    set @DATE = dateadd(hh, 1, @DATE)  
    set @ITERATOR = @ITERATOR + 1
  end
end
GO
exec APM.HourlyTableInit
GO
drop procedure APM.HourlyTableInit
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.DISABLE_FOREIGN_KEYS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.DISABLE_FOREIGN_KEYS AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.DISABLE_FOREIGN_KEYS
    @DISABLE BIT = 1
AS
BEGIN
DECLARE
    @SQL NVARCHAR(500),
    @TABLENAME NVARCHAR(128),
    @FOREIGNKEYNAME NVARCHAR(128)
-- A LIST OF ALL OF THE FOREIGN KEYS AND THE TABLE NAMES
DECLARE FOREIGNKEYCURSOR CURSOR
    FOR
    SELECT
        REF.CONSTRAINT_NAME AS FK_NAME,
        FK.TABLE_NAME AS FK_TABLE
      FROM
        INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS REF
        INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS FK ON REF.CONSTRAINT_NAME = FK.CONSTRAINT_NAME
      ORDER BY
        FK.TABLE_NAME,
        REF.CONSTRAINT_NAME 
OPEN FOREIGNKEYCURSOR
FETCH NEXT FROM FOREIGNKEYCURSOR INTO @FOREIGNKEYNAME, @TABLENAME
WHILE ( @@FETCH_STATUS = 0 )
    BEGIN
        IF @DISABLE = 1
            SET @SQL = N'ALTER TABLE [' + @TABLENAME + N'] NOCHECK CONSTRAINT [' + @FOREIGNKEYNAME + ']'
        ELSE
            SET @SQL = N'ALTER TABLE [' + @TABLENAME + N'] CHECK CONSTRAINT [' + @FOREIGNKEYNAME + ']'
        PRINT 'EXECUTING STATEMENT - ' + @SQL
        EXECUTE(@SQL)
        FETCH NEXT FROM FOREIGNKEYCURSOR INTO @FOREIGNKEYNAME, @TABLENAME
    END
CLOSE FOREIGNKEYCURSOR
DEALLOCATE FOREIGNKEYCURSOR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SHOWMESSAGE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SHOWMESSAGE AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.SHOWMESSAGE @MESSAGE NVARCHAR(100) AS
BEGIN
  RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLGROUPS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLGROUPS AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLGROUPS                                                                 */
/* DESCRIPTION:  The procedure create resource group node only for the              */
/*               performance events. It will be called only if rowdata contains     */
/*               resource group section.                                            */   
/* INPUT PARAMETERS:                                                                */
/*      @ROWGUID     - unique identifier of the event record                        */
/*      @GROUPSDOC   - xml resource group package for processing                    */
/*                    &lt;callGroups&gt;                                                  */
/*                          &lt;callGroup name="{resource group}"                      */
/*                                   duration="{duration,ms}"                       */
/*                                   count="{call count}" /&gt;                        */
/*                          ...                                                     */
/*                          &lt;callGroup/&gt;                                            */
/*                    &lt;/callGroups&gt;                                                 */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FILLGROUPS
     @ROWGUID NVARCHAR(15)
    ,@GROUPSDOC NTEXT
    ,@TRACELEVEL INT
AS
BEGIN
  SET NOCOUNT ON
  -- temporary table. Possible it is need to reseach using temporary variable --- 
  CREATE TABLE #GROUPS (NAME NVARCHAR(255) collate database_default, CALLCOUNT INT, DURATION BIGINT)
  -- memory identifier  
  DECLARE @IDOC INT                  
  -- error code   
  DECLARE @ERR INT
  -- primary key for the @ROWGUID parameter  
  DECLARE @EVENTID BIGINT
  -- row affected records
  DECLARE @ROWAFFECTED AS INT
  -- temporary variable for row affected records 
  DECLARE @RECORDCOUNT INT
  -- error proccesing  
  DECLARE 
     @ERRORIND         bit
    ,@ERRORNUMBER      int
    ,@ERRORSEVERITY    int
    ,@ERRORSTATE       int
    ,@ERRORLINE        int
    ,@ERRORPROCEDURE   nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE    nvarchar(max) 
    ,@MESSAGE          nvarchar(max)  
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  -- get event primary key using idx_T_RowGuid
  SELECT @EVENTID = EventId FROM Event e(NOLOCK) WHERE e.rowGuid = @ROWGUID
  IF (@@ROWCOUNT = 0)
  BEGIN
      -- raise exception "{rowguid} not found"
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50006   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLGROUPS', @ROWGUID)
  END  
  -- allocate memory for xml processing  
  EXEC @ERR = SP_XML_PREPAREDOCUMENT @IDOC OUTPUT, @GROUPSDOC
  IF @ERR &lt;&gt; 0 
  BEGIN
      -- raise exception    
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLGROUPS', @ERR)
  END
  
  -- Parse xml package 
  INSERT INTO #GROUPS
  SELECT NAME, CALLCOUNT, DURATION
     FROM OPENXML(@IDOC, N'/callGroups/callGroup', 2)
  WITH (NAME NVARCHAR(255) N'@name', CALLCOUNT INT N'@count', DURATION BIGINT N'@duration')
  SELECT @ROWAFFECTED = @@ROWCOUNT
   -- free memory
  EXEC SP_XML_REMOVEDOCUMENT @IDOC
  SET @IDOC = NULL
  IF (@TRACELEVEL = 4 AND @ROWAFFECTED = 0) 
  BEGIN
    -- trace message
    SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50007
    RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;  
  END       
  -- if resource group exists 
  IF @ROWAFFECTED &gt; 0 
  BEGIN 
      -- create resource group 
      INSERT INTO APM.RESOURCEGROUP (NAME)
        SELECT DISTINCT APM.GETRESOURCETYPE(G.NAME) FROM #GROUPS G
            WHERE NOT EXISTS
            (
               SELECT * FROM RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = APM.GETRESOURCETYPE(G.NAME)
            )
      SELECT @RECORDCOUNT = @@ROWCOUNT
      IF (@TRACELEVEL = 4)
      BEGIN
        -- trace message
        SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50008
        RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;           
      END
      -- Check exitsing internal resource group. It is need to create.  
      IF NOT EXISTS(SELECT * FROM RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = N'Internal')
        INSERT INTO RESOURCEGROUP(NAME) VALUES (N'Internal')
        
      -- create resource group node for all resourtce calls 
      ;WITH RESOURCEGROUPNODESET(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS  
       (
          -- by resource group calls from package
          SELECT 
                @EVENTID EVENTID,
                SUM(G.DURATION) DURATION,
                SUM(G.CALLCOUNT) CALLCOUNT,
                RG.RESOURCEGROUPID   
          FROM
            #GROUPS G
          JOIN 
            RESOURCEGROUP RG (NOLOCK) ON RG.NAME = APM.GETRESOURCETYPE(G.NAME)
          GROUP BY
            RG.RESOURCEGROUPID      
      
          UNION ALL 
        
          -- calculate internal call group as 
          SELECT 
            EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID 
          FROM 
          (
            SELECT 
                @EVENTID EVENTID,
                -- Rule: event duration - all resource group call
                COALESCE(E.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
                NULL CALLCOUNT,
                (SELECT RESOURCEGROUPID FROM RESOURCEGROUP RG WHERE RG.NAME = N'Internal') RESOURCEGROUPID 
            FROM 
              EVENT E (NOLOCK)  
              CROSS JOIN 
              (
                SELECT 
                    SUM(G.DURATION) DURATION
                FROM
                    #GROUPS G 
                ) A    
            WHERE 
              E.EVENTID = @EVENTID 
           ) B
           WHERE B.DURATION &gt; 0
         ),
         -- grouping result by resource group
         RESOURCEGROUPNODESETUNIQ(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS 
         (
            SELECT 
                @EVENTID, SUM(DURATION), SUM(CALLCOUNT), RESOURCEGROUPID
            FROM
              RESOURCEGROUPNODESET
            GROUP BY
              RESOURCEGROUPID    
         )
         -- create resource group node
         INSERT INTO RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
            SELECT 
                EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID 
            FROM 
                RESOURCEGROUPNODESETUNIQ 
         SELECT @RECORDCOUNT = @@ROWCOUNT
         IF (@TRACELEVEL = 4)
         BEGIN
           -- trace level   
           SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50010
           RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;            
         END
  END 
  END TRY
  BEGIN CATCH   
     -- exception processing
    
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
  
     -- get context variables
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1  
  END CATCH 
   -- check memory handle
   IF @IDOC IS NOT NULL
      EXEC sp_xml_removedocument @IDOC
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FillResourceGroupNodes'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FillResourceGroupNodes AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FillResourceGroupNodes                                                     */
/* DESCRIPTION:  The procedure create resource group node for the performance nodes */
/*               This is internal stored procedure. It is used by FillResource      */
/*               stored procedure. The FillResourceGroupNodes use external          */
/*               temporary table. Existing resource group node is not check.        */
/* INPUT PARAMETERS:                                                                */
/*      @EVENTID     - primary key of the event record                              */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FillResourceGroupNodes 
    @EVENTID bigint
   ,@TRACELEVEL int
AS
BEGIN
     SET NOCOUNT ON;
     DECLARE 
       @MESSAGE nvarchar(max)
      ,@RECORDCOUNT int
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50031
       RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;    
     END 
    ;WITH ResourceGroupNodeSet(DURATION, RESOURCEGROUPID) AS 
     (
        -- grouping resources from xml resource package 
        SELECT 
            SUM(D.DUR) DURATION,
            D.RESOURCEGROUPID   
        FROM
            #DETAILS D
        GROUP BY
          D.RESOURCEGROUPID     
      
        UNION ALL 
        
        -- calculate one internal execution. Internal resource group should be create before. 
        SELECT 
           DURATION, RESOURCEGROUPID 
        FROM 
          (
            SELECT 
                -- calculation rule: event duration - all resource call group duration  
                COALESCE(A.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
                RG.RESOURCEGROUPID 
            FROM 
               RESOURCEGROUP RG (NOLOCK)
              CROSS JOIN 
              (
                -- all resource call group duration
                SELECT 
                    SUM(D.DUR) DURATION
                   ,MIN(D.EVENTDURATION) EVENTDURATION
                FROM
                    #DETAILS D 
                ) A    
            WHERE 
               RG.NAME = N'Internal'
           ) B
         WHERE B.DURATION &gt; 0
     ),
     -- grouping by resource group
     ResourceGroupNodeSetUniq(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS 
     (
        SELECT 
          @EVENTID, SUM(DURATION), NULL, RESOURCEGROUPID  
        FROM 
          ResourceGroupNodeSet
        GROUP BY 
          RESOURCEGROUPID               
     )          
     INSERT INTO RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
        SELECT 
           EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID
        FROM
           ResourceGroupNodeSetUniq
    
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace level 
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50032
       RAISERROR (@MESSAGE, 0, 1, N'FILLRESOURCEGROUPNODES', @RECORDCOUNT, N'RESOURCEGROUPNODE') WITH NOWAIT;     
     END 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLRESOURCES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLRESOURCES AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLRESOURCES                                                              */
/* DESCRIPTION:  The procedure update resource references on the performancenode,   */
/*               exceptionnode, event tables. If resource doesn't exist it          */
/*               will be create. If rowdata doesn't contain resource group call     */
/*               section resource group node will be create on the                  */
/*               resourcegroupnode table for the performance events.                */
/* INPUT PARAMETERS:                                                                */
/*      @ROWGUID     - unique identifier of the event record                        */
/*      @DETAILSDOC  - xml resource package for processing                          */
/*                   &lt;resources&gt;                                                    */
/*                      &lt;resource entryId="{entry id}" quick="{0(1)}"&gt;              */
/*                          &lt;method dur="{duration, ms}"&gt;{method name}&lt;/method&gt;     */
/*                          &lt;uriFormat&gt;{uri format}&lt;/uriFormat&gt;                     */
/*                          &lt;type&gt;{resource type}&lt;/type&gt;                            */
/*                      &lt;/resource&gt;                                                 */
/*                      ...                                                         */
/*                      &lt;resource/&gt;                                                 */
/*                   &lt;/resources&gt;                                                   */
/*                   quick attribute values:                                        */
/*                              1 quick resource call                               */
/*                              0 not quick resource call                           */
/*                   resource method format:                                        */
/*                              {namespace}${resource call}                         */
/*                   {uri format} reserved                                          */      
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE [APM].[FILLRESOURCES]
      @ROWGUID NVARCHAR(15)
     ,@DETAILSDOC NTEXT
     ,@TRACELEVEL INT
AS
BEGIN
  SET NOCOUNT ON
  -- memory identifier  
  DECLARE @IDOC INT    
            
  -- error code   
  DECLARE @ERR INT
  -- event class type
  DECLARE @EVENTCLASSTYPE NVARCHAR(255)
  -- primary key for the @ROWGUID parameter  
  DECLARE @EVENTID BIGINT
  -- row affected records
  DECLARE @ROWAFFECTED AS INT
  -- trace message 
  DECLARE @MESSAGE NVARCHAR(MAX)
  -- temporary variable for row affected records 
  DECLARE @RECORDCOUNT INT
  -- error proccesing  
  DECLARE 
     @ERRORIND        bit
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE   nvarchar(max)      
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  -- temporary table. Possible it is need to reseach using temporary variable --- 
  CREATE TABLE #DETAILS (
    ENTRYID INT
   ,METHOD nvarchar(255) collate database_default
   ,RESOURCEURI nvarchar(255) collate database_default
   ,URIFORMAT NVARCHAR(255) collate database_default
   ,TYPE NVARCHAR(255) collate database_default
   ,QUICK INT
   ,DUR decimal(35,0)
   ,RESOURCEGROUPID int
   ,SOURCEID int
   ,EVENTID bigint
   ,EVENTDURATION decimal(35,0)
  )
  -- get event primary key using idx_T_RowGuid
  SELECT @EVENTID = EventId FROM APM.Event e(NOLOCK) WHERE e.rowGuid = @ROWGUID
  IF (@@ROWCOUNT = 0)
  BEGIN
      -- raise exception "{rowguid} not found"
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50006   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLRESOURCES', @ROWGUID)
  END  
  -- allocate memory for xml processing  
  EXEC @ERR = SP_XML_PREPAREDOCUMENT @IDOC OUTPUT, @DETAILSDOC
  IF @ERR &lt;&gt; 0 
  BEGIN
      -- raise exception    
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLRESOURCES', @ERR)
  END
  -- Parse xml package 
  INSERT INTO #DETAILS
  SELECT ENTRYID, METHOD, APM.GETRESOURCE(METHOD), URIFORMAT, TYPE, QUICK, DUR, 0, 0, 0, 0 
      FROM OPENXML(@IDOC, N'/resources/resource', 2)
  WITH (
        ENTRYID INT N'@entryId', 
        METHOD NVARCHAR(255) N'method', 
        URIFORMAT NVARCHAR(255) N'uriFormat',
        TYPE NVARCHAR(255) N'type',
        QUICK INT N'@quick',
        DUR decimal(35,0) N'method/@dur'
  )
  SELECT @ROWAFFECTED = @@ROWCOUNT
  -- free memory
  EXEC SP_XML_REMOVEDOCUMENT @IDOC
  SET @IDOC = NULL
  IF @TRACELEVEL = 4 AND @ROWAFFECTED = 0 
  BEGIN
    -- resources is empty
    SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50013
    RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
  END
  -- if resources exists 
  IF @ROWAFFECTED &gt; 0 
  BEGIN
    
  -- get event class type using index idx_T_EventId 
  SELECT 
    @EVENTCLASSTYPE = EVENTCLASSTYPE
  FROM 
    APM.EVENT E (NOLOCK)
  WHERE 
    E.EVENTID = @EVENTID 
  -- create resource group 
  INSERT INTO APM.RESOURCEGROUP (NAME)
    SELECT DISTINCT APM.GETRESOURCETYPE(D.TYPE) FROM #DETAILS D
        WHERE NOT EXISTS
        (
           SELECT * FROM APM.RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = APM.GETRESOURCETYPE(D.TYPE)
        ) 
  -- updating additional fields. It is need for decrease number of join operations.
  UPDATE D
    SET 
      D.RESOURCEGROUPID = RG.RESOURCEGROUPID
     ,D.SOURCEID = E.SOURCEID
     ,D.EVENTID = E.EVENTID
     ,D.EVENTDURATION = E.EVENTDURATION 
  FROM #DETAILS D
    JOIN RESOURCEGROUP RG (NOLOCK) ON RG.NAME = APM.GETRESOURCETYPE(D.TYPE)
    CROSS JOIN (SELECT EVENTID, SOURCEID, EVENTDURATION FROM APM.EVENT E (NOLOCK) WHERE E.EVENTID = @EVENTID) E
  -- Check exitsing internal resource group. It is need to create.  
  IF NOT EXISTS(SELECT * FROM APM.RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = N'Internal')
    INSERT INTO RESOURCEGROUP(NAME) VALUES (N'Internal')
  -- create resource for all methods 
  INSERT INTO RESOURCE(
        SOURCEID, 
        RESOURCEGROUPID,
        RESOURCEURIFORMAT,
        RESOURCEURI
  )
  SELECT 
    DISTINCT D.SOURCEID, D.RESOURCEGROUPID, D.URIFORMAT, D.RESOURCEURI
  FROM 
    #DETAILS D
  WHERE 
    NOT EXISTS( 
       SELECT * 
         FROM 
            APM.RESOURCE R (NOLOCK)
         WHERE
            R.SOURCEID = D.SOURCEID
            AND R.RESOURCEGROUPID = D.RESOURCEGROUPID
            AND R.RESOURCEURI = D.RESOURCEURI
   )
   
   SELECT @RECORDCOUNT = @@ROWCOUNT
   IF @TRACELEVEL = 4 
   BEGIN
     -- send info message about resource row affected
     SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50014
     RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;    
   END 
   IF @EVENTCLASSTYPE = N'performance' AND EXISTS (SELECT * FROM #DETAILS WHERE QUICK = 0)
   BEGIN
   -- processing performance events for not quick resource calls
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace info message 
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50015
          RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;     
        END 
        -- Create resource group node if rowdata doesn't containt resource call group section or it is empty
        IF NOT EXISTS(SELECT * FROM RESOURCEGROUPNODE RN WHERE RN.EventId = @EVENTID)
           EXEC APM.FillResourceGroupNodes @EVENTID, @TRACELEVEL
       
        --Check existing performance node 
        IF NOT EXISTS(SELECT * FROM APM.PERFORMANCENODE P (NOLOCK) WHERE P.EVENTID = @EVENTID) 
        BEGIN
            -- It is need create performance node(s) for not quick resource call 
            IF @TRACELEVEL = 4 
            BEGIN
              -- trace message 
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50016
              RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;     
            END 
          
            INSERT INTO APM.PERFORMANCENODE
            (
                EVENTID,
                DESCRIPTION,
                FUNCTIONNAME,
                ENTRYID,
                DURATION,
                SELFDURATION,
                ISHEAVIESTNODE                            
            )
            SELECT 
                @EVENTID,   
                REPLACE(D.METHOD,'$',''),
                REPLACE(D.METHOD,'$',''),
                D.ENTRYID,
                D.DUR,
                D.DUR,
                1 
            FROM  
                #DETAILS D 
            WHERE 
                D.QUICK = 0
            SELECT @RECORDCOUNT = @@ROWCOUNT
            IF @TRACELEVEL = 4 
            BEGIN
              -- trace info message
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50017
              RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
            END 
        END 
        -- update resource, resource group node references and resource method for not quick resource calls 
        UPDATE P SET 
            P.RESOURCEID = R.RESOURCEID,
            P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID,
            P.RESOURCEMETHOD = REPLACE(D.METHOD, N'$', N''), -- full method name (namespace + resource function call) 
            P.SELFDURATION = D.DUR           
        FROM 
            PERFORMANCENODE P                       
             JOIN #DETAILS D ON D.ENTRYID = P.ENTRYID AND D.QUICK = 0 
             JOIN RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.RESOURCEGROUPID = D.RESOURCEGROUPID AND RGN.EVENTID = D.EVENTID
             JOIN RESOURCE R (NOLOCK) ON R.RESOURCEURI = D.RESOURCEURI AND R.SOURCEID = D.SOURCEID AND R.RESOURCEGROUPID = D.RESOURCEGROUPID 
        WHERE 
            P.EVENTID = @EVENTID 
        
        SELECT @RECORDCOUNT = @@ROWCOUNT
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace message
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50018
          RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
        END 
        -- update event resource reference. It will be reference to the most heavy resources
        UPDATE E SET
          E.RESOURCEID  = (
                             SELECT TOP 1
                                P.RESOURCEID 
                             FROM 
                                PERFORMANCENODE P (NOLOCK)
                             WHERE 
                                P.EVENTID = @EVENTID
                             ORDER BY 
                                P.SELFDURATION DESC, P.PERFORMANCENODEID DESC 
                            )
        FROM 
          APM.EVENT E 
        WHERE 
          E.EVENTID = @EVENTID  
              
        SELECT @RECORDCOUNT = @@ROWCOUNT
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace message
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50020
          RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
        END 
   END 
   IF @EVENTCLASSTYPE = N'exception' AND EXISTS(SELECT * FROM APM.EXCEPTIONNODE EX (NOLOCK) WHERE EX.EVENTID = @EVENTID) 
   BEGIN
   -- processing exception event
     -- update resource reference and resource method   
     UPDATE EX SET 
            EX.RESOURCEID = R.RESOURCEID,
            EX.RESOURCEMETHOD = REPLACE(D.METHOD, N'$', N'') -- full method name (namespace + resource function call) 
        FROM APM.EXCEPTIONNODE EX
           CROSS JOIN (SELECT METHOD, SOURCEID, RESOURCEURI,RESOURCEGROUPID FROM #DETAILS D WHERE QUICK = 0) D
           JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = D.RESOURCEURI AND R.SOURCEID = D.SOURCEID AND R.RESOURCEGROUPID = D.RESOURCEGROUPID  
        WHERE 
            EX.EVENTID = @EVENTID 
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace info message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50021
       RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;      
     END 
     -- update event resource reference. 
     UPDATE E SET
            E.RESOURCEID  = (
                             SELECT TOP 1
                                EX.RESOURCEID 
                             FROM 
                                APM.EXCEPTIONNODE EX (NOLOCK)
                             WHERE 
                                EX.EVENTID = @EVENTID
                             ORDER BY 
                                EX.RESOURCEID
                            )
      FROM 
        APM.EVENT E 
      WHERE 
        E.EVENTID = @EVENTID               
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace info message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50022
       RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;      
     END 
   END
   END
   END TRY
   BEGIN CATCH
     -- exception processing
     
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
  
     -- get context variables
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER() 
      ,@ERRORSEVERITY = ERROR_SEVERITY() 
      ,@ERRORSTATE = ERROR_STATE() 
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1
   END CATCH
   -- check memory handle
   IF @IDOC IS NOT NULL
      EXEC sp_xml_removedocument @IDOC
   --report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.UpdateEventsByInternalResource'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.UpdateEventsByInternalResource AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: UpdateEventsByInternalResource                                             */
/* DESCRIPTION:  The procedure update resource reference for events                 */
/*               This is internal stored procedure. It is used by FillResource      */
/*               stored procedure. The UpdateEventsByInternalResource use external  */
/*               temporary table.                                                   */
/* INPUT PARAMETERS:                                                                */
/*      @EVENTCLASSTYPE  - event class type                                         */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.UpdateEventsByInternalResource @EVENTCLASSTYPE nvarchar(255)
AS
BEGIN
  if (@EVENTCLASSTYPE = N'performance')
  begin
     -- processing performance events
     UPDATE E 
        SET E.RESOURCEID  = A.RESOURCEID 
     FROM   
       APM.EVENT E       
       JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = E.EVENTID 
       CROSS APPLY (
               -- using haviest resource
                SELECT TOP 1
                    P.RESOURCEID 
                FROM 
                    APM.PERFORMANCENODE P (NOLOCK)
                WHERE 
                    P.EVENTID = E.EVENTID
                ORDER BY 
                  P.SELFDURATION DESC, 
                  P.PERFORMANCENODEID       
        ) A
  end
  if @EVENTCLASSTYPE = N'exception'
  begin
     -- processing exception events
     UPDATE E 
        SET E.RESOURCEID  = A.RESOURCEID 
     FROM        
       APM.EVENT E       
       JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = E.EVENTID 
       CROSS APPLY (
                SELECT TOP 1
                    EX.RESOURCEID 
                FROM 
                    APM.EXCEPTIONNODE EX (NOLOCK)
                WHERE 
                    EX.EVENTID = E.EVENTID
                ORDER BY 
                   EX.EXCEPTIONNODEID
        ) A
  end
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.INSERTINTERNALRESOURCE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.INSERTINTERNALRESOURCE AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: INSERTINTERNALRESOURCE                                                     */
/* DESCRIPTION:  The procedure create internal execution resource.                  */
/*               This is internal stored procedure. It is used by                   */
/*               FillInternalResource stored procedure and use external temporary   */
/*               table.                                                             */
/************************************************************************************/
ALTER PROCEDURE APM.INSERTINTERNALRESOURCE
AS
BEGIN
  DECLARE @INTERNALRESOURCEGROUPID int
SELECT 
    -- get primary key for internal resource group 
    @INTERNALRESOURCEGROUPID = RESOURCEGROUPID FROM APM.RESOURCEGROUP RG WHERE RG.NAME = N'Internal'
        
    -- create internal execution resource for temporary sources 
    INSERT INTO RESOURCE (RESOURCEGROUPID, SOURCEID, RESOURCEURI, RESOURCEURIFORMAT) 
        SELECT DISTINCT
           @INTERNALRESOURCEGROUPID 
          ,F.SOURCEID 
          ,N'Internal Execution' 
          ,N'' 
        FROM 
          #FILLINTERNALRESOURCESTABLE F
        WHERE 
           NOT EXISTS(
                SELECT * 
                  FROM APM.RESOURCE R (NOLOCK) 
                WHERE 
                  R.SOURCEID = F.SOURCEID  
                  AND R.RESOURCEURI = N'Internal Execution'
            )
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLINTERNALRESOURCES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLINTERNALRESOURCES AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLINTERNALRESOURCES                                                      */
/* DESCRIPTION:  The procedure update resource references on the performancenode,   */
/*               exceptionnode, event tables which is empty. The new resource       */
/*               will be internal execution. After execution this procedure "heavy  */
/*               light" events should be performance or exception nodes. Events will*/
/*               process by block starting @STARTROWGUID and ending @ENDROWGUID     */
/*                                                                                  */
/* INPUT PARAMETERS:                                                                */
/*      @STARTROWGUID - start block unique identifier                               */
/*      @ENDBLOCK     - end block unique identifier                                 */
/*      @DATABASEID   - database identifier                                         */
/*      @RECORDCOUNT  - reserved                                                    */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FILLINTERNALRESOURCES 
     @STARTROWGUID NVARCHAR(15)
    ,@ENDROWGUID   NVARCHAR(15)
    ,@DATABASEID   INT 
    ,@RECORDCOUNT  INT
    ,@TRACELEVEL   INT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE @RECORDS      INT
  DECLARE @MESSAGE      NVARCHAR(MAX)  
  -- error proccesing  
  DECLARE 
     @ERRORIND         bit
    ,@ERRORNUMBER      int
    ,@ERRORSEVERITY    int
    ,@ERRORSTATE       int
    ,@ERRORLINE        int
    ,@ERRORPROCEDURE   nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE    nvarchar(max)      
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  DECLARE 
    -- starting primary key 
    @STARTID bigint
    -- ending primary key
   ,@ENDID bigint
    -- internal resource group
   ,@INTERNALRESOURCEGROUPID int
   
  IF NOT EXISTS(SELECT * FROM APM.RESOURCEGROUP WHERE NAME = N'Internal')   
     INSERT INTO APM.RESOURCEGROUP(NAME) VALUES (N'Internal')
  -- Get primary key internal resource group        
  SELECT
    @INTERNALRESOURCEGROUPID = RESOURCEGROUPID FROM APM.RESOURCEGROUP RG WHERE RG.NAME = N'Internal'
  -- Get event primary keys
  SELECT 
     @STARTID = CASE WHEN ROWGUID = @STARTROWGUID THEN eventId  ELSE @STARTID END
    ,@ENDID = CASE WHEN ROWGUID = @ENDROWGUID THEN eventId  ELSE @ENDID END
  FROM 
    APM.EVENT (NOLOCK) 
  WHERE 
    ROWGUID IN (@STARTROWGUID, @ENDROWGUID) 
    
  IF @STARTID IS NULL OR @ENDID IS NULL 
  BEGIN
	 DECLARE 
	   @MSG nvarchar(MAX)
       
	 SELECT @MSG = message FROM APM.MESSAGES(NOLOCK) WHERE id = 50035
	 RAISERROR(@MSG, 16, 1, @STARTROWGUID, @ENDROWGUID)   
	 RETURN 
  END   
    
  -- temporary event table. Do not use temporary table variable because table is used by internal stored procedures   
  CREATE TABLE #FILLINTERNALRESOURCESTABLE 
  (
        EVENTID INT
       ,SOURCEID INT
       ,EVENTDURATION DECIMAL(35,0)
       ,EXCEPTIONCLASS NVARCHAR(255) collate database_default
       ,DESCRIPTION NVARCHAR(255) collate database_default
  )
  
 /* Processing performance events which are not have performance nodes */
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,EVENTDURATION,SOURCEID) 
    SELECT 
      E.EVENTID, E.EVENTDURATION,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E 
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (HEAVYLIGHT IS NULL OR HEAVYLIGHT &lt;&gt; 0)
      AND NOT EXISTS(SELECT * FROM PERFORMANCENODE P (NOLOCK) WHERE P.EVENTID = E.EVENTID)
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  
  IF (@@ROWCOUNT &gt; 0)
  BEGIN
    -- Processing performance events
    -- Delete old resource group nodes
    DELETE R FROM 
        APM.RESOURCEGROUPNODE R
        JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = R.EVENTID
        
    --Insert internal resource group node
    INSERT RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
        SELECT 
            F.EVENTID, 
            -- use event duration
            COALESCE(F.EVENTDURATION, 0) / 1000 AS DURATION, 
            NULL AS CALLCOUNT, 
            @INTERNALRESOURCEGROUPID
        FROM
            #FILLINTERNALRESOURCESTABLE F
    
    -- create internal execution resource for event sources
    EXEC APM.InsertInternalResource  
    -- create performance node
    INSERT INTO APM.PERFORMANCENODE
    (
       EVENTID,
       RESOURCEID,
       RESOURCEGROUPNODEID,
       DESCRIPTION,        
       FUNCTIONNAME,
       RESOURCEMETHOD,
       DURATION,
       ENTRYID,
       SELFDURATION,
       ISHEAVIESTNODE 
    )
    SELECT 
      F.EVENTID, 
      R.RESOURCEID,
      RGN.RESOURCEGROUPNODEID,      
      R.RESOURCEURI, 
      R.RESOURCEURI,
      R.RESOURCEURI,
      -- use event duration
      F.EVENTDURATION / 1000,
      0,    
      -- use event duration
      F.EVENTDURATION / 1000,
      --These events always have only one performance node which is most heavy
      1
    FROM 
      #FILLINTERNALRESOURCESTABLE F 
      JOIN APM.RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.EVENTID = F.EVENTID 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
    SET @RECORDS = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      -- trace message
      DECLARE @PROCESSED INT
      SELECT  @PROCESSED = COUNT(*) FROM #FILLINTERNALRESOURCESTABLE
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50028
      
      RAISERROR (@MESSAGE, 0, 1, @PROCESSED, @RECORDS) WITH NOWAIT;
    END
    
    -- update event resource reference
    EXEC APM.UpdateEventsByInternalResource N'performance'
  END
 /* Processing exception events which are not have exception nodes */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID,EXCEPTIONCLASS,DESCRIPTION) 
    SELECT 
      E.EVENTID, E.SOURCEID, E.EXCEPTIONCLASS, E.DESCRIPTION
    FROM
      APM.EVENT (NOLOCK) E  
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND NOT EXISTS(SELECT * FROM EXCEPTIONNODE Ex (NOLOCK) WHERE Ex.EVENTID = E.EVENTID)
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)     
  BEGIN
    -- create internal execution resource for event sources
    EXEC APM.INSERTINTERNALRESOURCE    
     
    -- create exception node
    INSERT INTO APM.EXCEPTIONNODE
    (
       EVENTID,
       RESOURCEID,
       EXCEPTIONCLASS,
       FUNCTIONNAME,
       RESOURCEMETHOD,
       -- use event description
       DESCRIPTION                          
    )
    SELECT 
      F.EVENTID, 
      R.RESOURCEID,
      F.EXCEPTIONCLASS,      
      R.RESOURCEURI, 
      R.RESOURCEURI,
      F.DESCRIPTION
    FROM
      #FILLINTERNALRESOURCESTABLE F 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
        
    SELECT @RECORDS = @@ROWCOUNT
    
    IF @TRACELEVEL = 4 
    BEGIN
      -- trace message
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50029
      RAISERROR (@MESSAGE, 0, 1, @RECORDS) WITH NOWAIT;
    END
    
    -- update event resource reference  
    EXEC APM.UpdateEventsByInternalResource N'exception'
  END
  
 /* Processing performance nodes which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,EVENTDURATION, SOURCEID) 
    SELECT 
      E.EVENTID, E.EVENTDURATION, E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      EXISTS(
        SELECT * FROM APM.PERFORMANCENODE AS P(NOLOCK) 
            WHERE P.EVENTID = E.EVENTID AND P.RESOURCEID IS NULL
      )     
      AND E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (E.HEAVYLIGHT IS NULL OR E.HEAVYLIGHT &lt;&gt; 0)
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  
  IF @@ROWCOUNT &gt; 0
  BEGIN
     --delete not linked resource nodes
     DELETE RGN
        FROM APM.RESOURCEGROUPNODE RGN
            JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID
            WHERE NOT EXISTS(SELECT * FROM APM.PERFORMANCENODE P (NOLOCK)
                    WHERE P.EVENTID = F.EVENTID AND P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID)
     --Check existing internal group node               
     IF NOT EXISTS(
            SELECT * 
                FROM APM.RESOURCEGROUPNODE AS RGN (NOLOCK)
                JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID
            WHERE 
                RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
     ) 
     BEGIN
        --Internal resource group is missing 
        --Create new
        INSERT APM.RESOURCEGROUPNODE(EVENTID, DURATION, RESOURCEGROUPID) 
        SELECT 
            F.EVENTID,
            -- use event duration
            COALESCE(F.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
            @INTERNALRESOURCEGROUPID
        FROM 
           #FILLINTERNALRESOURCESTABLE F
               CROSS APPLY 
               (
                 SELECT 
                    SUM(DURATION) DURATION
                 FROM
                    APM.RESOURCEGROUPNODE AS RGN (NOLOCK) WHERE RGN.EVENTID = F.EVENTID
               ) A
     END
     ELSE 
     BEGIN
        ---not linked resource group node have been removed. Therefore, need recalculate internal group node 
        UPDATE RGN
            -- use event duration
            SET RGN.DURATION = COALESCE(F.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) 
        FROM
          APM.RESOURCEGROUPNODE RGN
          JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID AND RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
               CROSS APPLY 
               (
                 SELECT 
                    SUM(DURATION) DURATION
                 FROM
                    APM.RESOURCEGROUPNODE AS RGN2 (NOLOCK) 
                 WHERE 
                    RGN2.EVENTID = F.EVENTID 
                    AND RGN2.RESOURCEGROUPID &lt;&gt; @INTERNALRESOURCEGROUPID 
               ) A
     END        
     -- create internal execution resources for event sources            
     EXEC APM.INSERTINTERNALRESOURCE
     -- update resource and resource group node references for performance nodes
     UPDATE P SET 
            P.RESOURCEID = R.RESOURCEID,
            P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID,
            P.RESOURCEMETHOD = R.RESOURCEURI, 
            P.SELFDURATION = P.DURATION           
     FROM 
        APM.PERFORMANCENODE P
        JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = P.EVENTID 
        JOIN APM.RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.EVENTID = F.EVENTID AND RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
        JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID   
     WHERE P.RESOURCEID IS NULL
     -- update resource reference on performance events
     EXEC APM.UpdateEventsByInternalResource N'performance'     
  END           
 /* Processing exception nodes which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID, E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E  
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND EXISTS(SELECT * FROM EXCEPTIONNODE Ex (NOLOCK) WHERE Ex.EVENTID = E.EVENTID AND Ex.RESOURCEID IS NULL)
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)
  BEGIN
    -- create internal execution resources for event sources     
    EXEC APM.INSERTINTERNALRESOURCE
        
    -- update exception resource references
    UPDATE EX
        SET EX.RESOURCEID = R.RESOURCEID
    FROM 
      APM.EXCEPTIONNODE EX
      JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = EX.EVENTID 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
  END   
  
 /* Processing performance events which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (E.HEAVYLIGHT IS NULL OR E.HEAVYLIGHT &lt;&gt; 0)
      AND E.RESOURCEID IS NULL
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)    
 -- update resource reference on performance events 
    EXEC APM.UpdateEventsByInternalResource N'performance'
 /* Processing exception events which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND E.RESOURCEID IS NULL
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)
 -- update resource reference on exception events     
    EXEC APM.UpdateEventsByInternalResource N'exception'
  END TRY
  BEGIN CATCH
     -- exception processing
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
     -- get context variables   
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1
  END CATCH
--report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetResource'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetResource ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetResource (@METHOD nvarchar(255))
RETURNS nvarchar(255)
AS
BEGIN
  RETURN 
      LEFT(
        @METHOD, 
        CASE WHEN CHARINDEX(N'$', @METHOD) = 0 THEN LEN(@METHOD) ELSE CHARINDEX(N'$', @METHOD) - 1 END 
         ) 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetResourceType'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetResourceType ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION [APM].[GetResourceType] (@RESOURCETYPE nvarchar(255))
RETURNS nvarchar(255)
AS
BEGIN
  RETURN 
    CASE  
        WHEN @RESOURCETYPE LIKE N'Web%' OR @RESOURCETYPE LIKE N'WCF%' THEN N'WebService'
        WHEN @RESOURCETYPE LIKE N'SQL%' 
             OR @RESOURCETYPE LIKE N'OLEDB%' 
             OR @RESOURCETYPE LIKE N'IBM DB2%' 
             OR @RESOURCETYPE LIKE N'Sybase%' 
             OR @RESOURCETYPE LIKE N'Query%'
             OR @RESOURCETYPE LIKE N'ODBC%'
             OR @RESOURCETYPE LIKE N'Oracle%'
             OR @RESOURCETYPE LIKE N'ADOMD%'
            THEN N'Database'
        ELSE N'Internal' 
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ComputerResourceUtilization'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ComputerResourceUtilization AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ComputerResourceUtilization                                                */
/* USED IN: Computer resource utilization report                                    */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/*      @TOPROWCOUNT - defines number of top rows, which will be returned           */
/************************************************************************************/
ALTER PROCEDURE APM.ComputerResourceUtilization
    @DATESTART DateTime,
    @DATEEND DateTime,
    @MACHINEIDS NVARCHAR(MAX),
    @SORTORDER INT,
    @TOPROWCOUNT INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                              ASSISTING TEMP TABLES                                   */
/****************************************************************************************/
-- Filter table, which contains machine Ids 
    CREATE TABLE #COMPUTERPCOUNTERANALYSIS_FILTERTABLE
    (
        VALUEID INT
    )
-- Split @MACHINEIDS and fill table with values from it
    INSERT 
        INTO #COMPUTERPCOUNTERANALYSIS_FILTERTABLE
            SELECT 
                CAST(p.value AS int)
            FROM 
                APM.GetMultiParameters(@MACHINEIDS, N'') p
--Filter PerfHourly table for further manipulations
    CREATE TABLE #COMPUTERPCOUNTERANALYSIS_PERFHOURLY
    (
        MACHINEID INT,
        PCTYPE NVARCHAR(100) collate database_default,
        SUMVALUE FLOAT,
        MAXVALUE FLOAT,
        SAMPLECOUNT BIGINT
    )
    INSERT
        INTO #COMPUTERPCOUNTERANALYSIS_PERFHOURLY
            SELECT 
                ph.MachineId AS MachineId,
                t.type AS PCType,
                ph.SumValue AS SumValue,
                ph.MaxValue AS MaxValue,
                ph.SampleCount AS SampleCount
            FROM
                APM.PerfHourly AS ph (NOLOCK)
                JOIN APM.PCType AS t (NOLOCK) ON ph.PCTypeId = t.PCTypeId
                JOIN #COMPUTERPCOUNTERANALYSIS_FILTERTABLE f ON ph.MachineId = f.VALUEID
            WHERE 
                ph.UTCDate &gt;= @DATESTART 
                AND ph.UTCDate &lt; @DATEEND 
                AND ph.SourceId IS NULL 
                AND ph.PCProcessId IS NULL
                AND t.Type IN (
                    N'\Processor\% Processor Time', 
                    N'\Process\Private Bytes', 
                    N'\Process\IO Data Bytes/sec', 
                    N'\Apps\Monitored Requests')
 
/****************************************************************************************/
/*                                      MAIN QUERY                                      */
/****************************************************************************************/          
    ;WITH ComputerResourceUtilization AS 
    (
        SELECT
            ph.MACHINEID,
            AVG(CASE ph.PCTYPE WHEN N'\Processor\% Processor Time' THEN ph.SUMVALUE/SAMPLECOUNT END) AS ProcessorValue,
            MAX(CASE ph.PCTYPE WHEN N'\Processor\% Processor Time' THEN ph.MAXVALUE END) AS MaxProcessorValue,
            AVG(CASE ph.PCTYPE WHEN N'\Process\Private Bytes' THEN ph.SUMVALUE/SAMPLECOUNT END) AS MemoryValue,
            MAX(CASE ph.PCTYPE WHEN N'\Process\Private Bytes' THEN ph.MAXVALUE END) AS MaxMemoryValue,
            AVG(CASE ph.PCTYPE WHEN N'\Process\IO Data Bytes/sec' THEN ph.SUMVALUE/SAMPLECOUNT END) AS IOValue,
            MAX(CASE ph.PCTYPE WHEN N'\Process\IO Data Bytes/sec' THEN ph.MAXVALUE END) AS MaxIOValue,
            SUM(CASE ph.PCTYPE WHEN N'\Apps\Monitored Requests' THEN ph.SUMVALUE END) AS RequestValue  
        FROM 
            #COMPUTERPCOUNTERANALYSIS_PERFHOURLY AS ph
        GROUP BY
            ph.MACHINEID              
    ),
    OrderedDataSet AS
    (
        SELECT 
            ROW_NUMBER() OVER(ORDER BY 
                CASE @SORTORDER 
                    WHEN 1 THEN cr.ProcessorValue 
                    WHEN 2 THEN cr.MemoryValue 
                    WHEN 3 THEN cr.IOValue 
                    WHEN 4 THEN cr.RequestValue 
                END DESC
            ) AS Id,
            m.Machine,
            m.MachineId,
            COALESCE(m.CPUCount, 1) AS CPUCount,
            cr.ProcessorValue AS ProcessorValue,
            cr.MaxProcessorValue AS MaxProcessorValue,
            cr.MemoryValue/(1024*1024) AS MemoryValue,
            cr.MaxMemoryValue/(1024*1024) AS MaxMemoryValue,
            cr.IOValue/1024 AS IOValue,
            cr.MaxIOValue/1024 AS MaxIOValue,
            cr.RequestValue AS RequestValue,
            -- Flag to define if cpu count is not null,
            -- in case of  CPUDefineFlag = 0, show warning message about it in report
            COALESCE(m.CPUCount, 0) AS CPUDefineFlag
        FROM
            ComputerResourceUtilization AS cr
            JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = cr.MachineId
    )
    SELECT
        * 
    FROM
        OrderedDataSet
    WHERE
        Id &lt;= @TOPROWCOUNT
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.fn_nums'), 'IsTableFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.fn_nums() RETURNS TABLE
				AS
				RETURN
				select clmn=1')    
  END
GO
ALTER FUNCTION APM.fn_nums(@N AS INT) RETURNS TABLE
AS
RETURN
WITH
L0 AS(SELECT 1 AS c UNION ALL SELECT 1),
L1 AS(SELECT 1 AS c FROM L0 AS A, L0 AS B),
L2 AS(SELECT 1 AS c FROM L1 AS A, L1 AS B),
L3 AS(SELECT 1 AS c FROM L2 AS A, L2 AS B),
L4 AS(SELECT 1 AS c FROM L3 AS A, L3 AS B),
L5 AS(SELECT 1 AS c FROM L4 AS A, L4 AS B),
Nums AS(SELECT ROW_NUMBER() OVER(ORDER BY c) AS n FROM L5)
SELECT n FROM Nums WHERE n &lt;= @N;
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.RemoveProcessIdFromName'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.RemoveProcessIdFromName ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/************************************************************************************/
/* Object: Function                                                                 */
/* Name: RemoveProcessIdFromName                                                    */
/* Returns:  process name till # symbol.	Exp: w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp       */
/*			 or process name till _ symbol. Exp: w3wp_123 -&gt; w3wp					*/
/* Parameters:                                                                      */
/*          @PROCESSNAME - Process name, from which #N will be removed              */
/************************************************************************************/
ALTER FUNCTION APM.RemoveProcessIdFromName (@PROCESSNAME nvarchar(255))
RETURNS NVARCHAR(255)
AS
BEGIN
	DECLARE @result nvarchar(255), @pos int
	
	/* try to find w3wp#X instance formatting					*/
	SET @pos = CHARINDEX(N'#', REVERSE(@PROCESSNAME))
	SET @result = CASE	WHEN @pos &gt; 0 
					THEN LEFT(@PROCESSNAME, LEN(@PROCESSNAME) - @pos)
					ELSE @result END
										
	/* if w3wp#X instance formatting is not found we will try	*/
	/* to find w3wp_XXXX formatting								*/
	IF @pos = 0
	BEGIN
		SET @pos = PATINDEX( '%[0-9][_]%', REVERSE(@PROCESSNAME))
		SET @result = CASE	WHEN @pos &gt; 0 
						THEN LEFT(@PROCESSNAME, LEN(@PROCESSNAME) - (@pos + 1)) 
						ELSE @PROCESSNAME END
	END
    RETURN @result
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ComputerResourceUtilizationBySource'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ComputerResourceUtilizationBySource AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ComputerResourceUtilizationBySource                                        */
/* USED IN: Computer resource utilization sub report                                */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @SOURCEIDS - List of the source id, separated by comma. Exp: '1,2,3'        */
/*      @MACHINEID - Machine Id for which data should be selected                   */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/************************************************************************************/
ALTER PROCEDURE APM.ComputerResourceUtilizationBySource
    @DATESTART DATETIME,
    @DATEEND DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEID NVARCHAR(255),
    @SORTORDER INT
WITH RECOMPILE
AS
BEGIN
SET NOCOUNT ON
/************************************************************************************/
/*                  PREPARE ASSISTING TEMP TABLES                                   */
/************************************************************************************/
--Filter table, which contains source ids, transfered to SP in @SOURCEIDS parameter
CREATE TABLE #SOURCEPCOUNTERANALYSIS_FILTERTABLE(
        VALUEID INT
)
-- Split computer ids list separated by comma and fill table with it
INSERT 
    INTO #SOURCEPCOUNTERANALYSIS_FILTERTABLE
        SELECT 
            CAST(p.value AS INT)
        FROM 
            --Splits incoming string. Uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, N'') AS p
--Filter PerfHourly table to decrease records count fot further calcultaions
CREATE TABLE #PERFHOURLYBYMACHINE(
        UTCDate DATETIME,
        SOURCEID INT,
        PCPROCESSID INT,
        SUMVALUE FLOAT,
        SAMPLECOUNT BIGINT,
        PACKAGECOUNTER BIGINT,
        MAXVALUE FLOAT,
        TYPE NVARCHAR(MAX) collate database_default
)
INSERT INTO #PERFHOURLYBYMACHINE
    SELECT
        ph.UTCDate,
        ph.sourceId,
        ph.pcprocessId,
        ph.SumValue,
        ph.SampleCount,
        ph.PackageCounter,
        ph.MaxValue,
        t.Type
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        JOIN APM.PCType AS t (NOLOCK) ON t.pctypeid = ph.pctypeid
    WHERE
        ph.UTCDate &gt;= @DATESTART
        AND ph.UTCDate &lt; @DATEEND
        AND ph.MachineId = @MACHINEID
        AND t.type IN 
            (
                N'\Process\% Processor Time',
                N'\Process\IO Data Bytes/sec',
                N'\Process\Private Bytes',
                N'\Apps\Monitored Requests',
                -- 'Processor% Processor Time' counter is taken to calculate application activity,
                -- relative to hours, when machine had been sending counter
                N'\Processor\% Processor Time'
            )
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
--Insert source name with correspondent process name and extrainfo
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SOURCEID,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        #PERFHOURLYBYMACHINE AS ph
        JOIN APM.Source AS s (NOLOCK) ON ph.SOURCEID = s.sourceId
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.PCPROCESSID  
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
--Get sources name, ids list separated by comma per app pool
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        -- source names
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE as c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources,
        -- source ids
        (SELECT A.sourceid AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    CAST(c1.SOURCEID AS NVARCHAR) + N',' AS sourceid
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
            ) AS A
            FOR XML PATH ('') 
        ) AS SourceIds      
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #SOURCEPCOUNTERANALYSIS_FILTERTABLE AS f ON f.VALUEID = c.SOURCEID
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS
),
-- Filter sources for which data should be selected;
-- as info should be selected not only for transfered sources, but also for sources
-- in the same app pool
SourceFilter AS
(
--One application can be in the several app pools, so use DISTINCT
    SELECT DISTINCT 
        s2.SOURCEID
    FROM
        #PROCESSNAMEFORSOURCE AS s1
        JOIN #PROCESSNAMEFORSOURCE AS s2 ON s1.EXTRAINFO = s2.EXTRAINFO AND s1.PROCESS = s2.PROCESS
        JOIN #SOURCEPCOUNTERANALYSIS_FILTERTABLE AS f ON s1.SOURCEID = f.VALUEID
),
--Filter PerfHourly by source
PerfHourlyBySource AS
(
    SELECT
        ph.UTCDate,
        ph.PCPROCESSID,
        ph.SUMVALUE,
        ph.SAMPLECOUNT,
        ph.PACKAGECOUNTER,
        ph.MAXVALUE,
        --This field is used for 'Apps\Monitored Requests' (this counter depends on source only, not process)
        ph.SOURCEID,
        ph.TYPE
    FROM
        #PERFHOURLYBYMACHINE AS ph (NOLOCK)
        JOIN SourceFilter AS s ON s.SOURCEID = ph.SOURCEID
),
--Calculate resource utilization by process in one hour
ProcessHourlyResourceUtilization AS
(
    SELECT
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type,
        -- Select MAX value as in case of app pool, some of the application
        -- could work only part of the hour, and the value should be taken for the 
        -- application worked for the longest period 
        MAX(ph.SumValue) AS SumValue,
        MAX(ph.MaxValue) AS MaxValue,
        MAX(ph.SampleCount) AS SampleCount,
        MAX(ph.PackageCounter) AS PackageCounter 
    FROM
        PerfHourlyBySource AS ph
    WHERE
        --This condition allows to exclude Monitored Requests counter
        PCProcessId IS NOT NULL 
    GROUP BY
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type 
),
--Calculate resource utilization by application in one hour
--application means - web application = AppPool, otherwise = processname
ApplicationHourlyResourceUtilization AS
(
    SELECT
        ph.UTCDate,
        ph.Type,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        --Select process name till # symbol
        APM.RemoveProcessIdFromName(p.Process) AS ProcessName,
        COALESCE(p.ExtraInfo, N'') AS ProcessExtraInfo,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue,
        MAX(ph.MaxValue) AS MaxValue        
    FROM
        ProcessHourlyResourceUtilization AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON ph.PCProcessId = p.PCProcessId
    GROUP BY
        ph.UTCDate,
        ph.Type,
        APM.RemoveProcessIdFromName(p.Process),
        p.ExtraInfo 
),
--Calculate average application resource utilization over all specified period
ApplicationResourceUtilization AS
(
    SELECT
        ph.ProcessName,
        ph.ProcessExtraInfo,
        -- Number of hours when app was active
        COUNT(DISTINCT ph.UTCDate) AS ApplicationAvailabilityHours,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        MAX(ph.InstanceCount) AS MaxInstanceCount,
        AVG(CASE WHEN InstanceCount &lt; 1 THEN InstanceCount ELSE 1 END) AS AppActivity,
        AVG(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.AvgValue END) AS MemoryAvgValue,
        MAX(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.MaxValue END) AS CPUMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.MaxValue END) AS IOMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.MaxValue END) AS MemoryMaxValue
    FROM
        ApplicationHourlyResourceUtilization AS ph
    GROUP BY
        ph.ProcessName,
        ph.ProcessExtraInfo 
),
--Count Monitored Requests for Application
ApplicationRequestCount AS
(
    SELECT
        c.EXTRAINFO,
        c.PROCESS,
        SUM(ph.SUMVALUE) AS RequestCount
    FROM
        PerfHourlyBySource AS ph
        -- If source was running in several app pools  
        -- #PROCESSNAMEFORSOURCE would contain several rows for one sourceid.
        -- In this case request count will be counted for all app pools
        JOIN #PROCESSNAMEFORSOURCE AS c ON ph.SOURCEID = c.SOURCEID
    WHERE
        ph.type = N'\Apps\Monitored Requests'
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS
),
-- Count hours when computer sent counters.
-- This value is used to calculate application activity between hours
ComputerAvailabilityHours AS
(
    SELECT
        COUNT(DISTINCT ph.UTCDate) AS HoursCount
    FROM
        #PERFHOURLYBYMACHINE AS ph
    WHERE
        ph.SOURCEID  IS NULL
        AND ph.PCPROCESSID IS NULL
        AND ph.TYPE = N'\Processor\% Processor Time'
),
OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER (ORDER BY 
                            CASE @SORTORDER 
                                WHEN 1 THEN res.CPUAvgValue 
                                WHEN 2 THEN res.MemoryAvgValue 
                                WHEN 3 THEN res.IOAvgValue 
                                WHEN 4 THEN req.RequestCount 
                            END DESC) AS Id,
        b.ExtraInfo AS AppPoolName,
        --Remove comma from the end
        CASE b.AppPoolSources WHEN '' THEN '' ELSE LEFT(b.AppPoolSources, LEN(b.AppPoolSources)-1) END AS AppPoolSources,
        -- SourceIds string is used for drillthrought report for transfering sources to it
        b.SourceIds,
        req.RequestCount,
        -- Correct instance count and application activity with hours, when application was active
        res.InstanceCount * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount) AS InstanceCount,
        res.MaxInstanceCount,
        res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount) AS AppActivity,
        -- Calculate resource utilization
        res.CPUAvgValue/COALESCE(m.cpucount, 1) AS CPUAvgValue,
        res.IOAvgValue/1024 AS IOAvgValue,
        res.MemoryAvgValue/(1024*1024) AS MemoryAvgValue,
        res.CPUMaxValue/COALESCE(m.cpucount, 1) AS CPUMaxValue,
        res.IOMaxValue/1024 AS IOMaxValue,
        res.MemoryMaxValue/(1024*1024) AS MemoryMaxValue,
        -- This field used for chart value in subreport bottom, 
        -- and it should include application activity both for hour and for specified period (application availability),
        -- in order to be consistan with computer resources
        (CASE @SORTORDER 
                WHEN 1 THEN res.CPUAvgValue/COALESCE(m.cpucount, 1) * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 2 THEN res.MemoryAvgValue/(1024*1024) * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 3 THEN res.IOAvgValue/1024 * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 4 THEN req.RequestCount 
        END) AS OrderedValue
    FROM
        AppPoolInfo AS b
        JOIN ApplicationResourceUtilization AS res ON res.ProcessExtraInfo = b.ExtraInfo AND res.ProcessName = b.Process
        LEFT OUTER JOIN ApplicationRequestCount AS req ON req.ExtraInfo = b.ExtraInfo AND req.Process = b.Process
        JOIN APM.Machine AS m (NOLOCK) ON m.machineid = @MACHINEID
        -- This query has only one record, and this value is common for all sources,
        -- so use CROSS JOIN
        CROSS JOIN ComputerAvailabilityHours AS ca
)
SELECT
    Id,
    CASE 
        WHEN LEN(AppPoolName) &gt; 0 THEN AppPoolName + N' - '+ AppPoolSources
        ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
    END AS AppPoolName,
    SourceIds,
    RequestCount,
    InstanceCount,
    MaxInstanceCount,
    AppActivity,
    CPUAvgValue,
    CPUMaxValue,
    MemoryAvgValue,
    MemoryMaxValue,
    IOAvgValue,
    IOMaxValue,
    OrderedValue
FROM
    OrderedDataSet
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetQueryDateCount'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetQueryDateCount ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetQueryDateCount(@PERIODTYPE INT, @CURRENTDATE DATETIME) RETURNS INT
AS
BEGIN
  RETURN 
        CASE @PERIODTYPE 
            WHEN 1 THEN 1
            WHEN 2 THEN 7
            WHEN 3 THEN 31
        END 
END
GO
--------------------End Helper function for the management_application_summary_quality_analysis_report ------------------
--------------------Helper function for the management_reports_breakdown_report ------------------
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetDatePart'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetDatePart ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
alter FUNCTION APM.GetDatePart(@DATEPART nvarchar(10), @DATE dateTime) RETURNS INT
AS
BEGIN
  RETURN 
        CASE @DATEPART 
            WHEN 'Hour' THEN Datepart(hh, @DATE)
            WHEN 'WeekDay' THEN Datepart(dw, @DATE)
            WHEN 'MonthDay' THEN Datepart(d, @DATE)
        END 
END
GO
-------------------End Helper function for the management_reports_breakdown_report-------------------
--------------------Temporary table----------------------
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATES'), 'IsTable') IS NOT NULL)
  BEGIN
    DROP TABLE APM.DATES
  END
GO
CREATE TABLE APM.DATES(
    WeekDays smallint NULL,
    HourDates smallint NULL,
    MonthDays smallint NULL,
    DatesId int NULL
) 
GO
;WITH DATES_BUILD(WEEKDAYS,HOURDATES,MONTHDAYS, DatesId)  AS
(
      SELECT
       CASE WHEN N &lt;= 7 THEN N END WEEKDAYS,
         CASE WHEN N &lt;= 24 THEN N-1 END HOURDATES,
         N AS MONTHDAYS,
         N AS DatesId    
    FROM APM.FN_NUMS(31)
)
INSERT INTO APM.DATES SELECT * FROM DATES_BUILD
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationResourceUtilization'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationResourceUtilization AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationResourceUtilization                                             */
/* USED IN: Application ResourceUtilization report                                  */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/*      @TOPROWCOUNT - defines number of top rows, which will be returned           */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationResourceUtilization
    @DATESTART DATETIME,
    @DATEEND DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SORTORDER INT,
    @TOPROWCOUNT INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p
-- Filter PerfHourly table to decrease nummber of rows for further manipulations.
-- Filtering by sources could not be done as some of the filtered sources can be in app pools,
-- so they should present in calculations
CREATE TABLE #PERFHOURLYFILTERBYMACHINE
(
        UTCDate DATETIME,
        SOURCEID INT,
        MACHINEID INT,
        PCPROCESSID INT,
        SUMVALUE FLOAT,
        SAMPLECOUNT BIGINT,
        PACKAGECOUNTER BIGINT,
        MAXVALUE FLOAT,
        TYPE NVARCHAR(MAX) collate database_default
)
--Fill table #PERFHOURLYFILTERBYMACHINE
INSERT 
    INTO #PERFHOURLYFILTERBYMACHINE
        SELECT
            ph.UTCDate,
            ph.sourceId,
            ph.MachineId,
            ph.pcprocessId,
            ph.SumValue,
            ph.SampleCount,
            ph.PackageCounter,
            ph.MaxValue,
            t.Type
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            JOIN APM.PCType AS t (NOLOCK) ON t.pctypeid = ph.pctypeid
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND f.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @DATESTART
            AND ph.UTCDate &lt; @DATEEND
            AND t.type IN 
                (
                    N'\Process\% Processor Time',
                    N'\Process\IO Data Bytes/sec',
                    N'\Process\Private Bytes',
                    N'\Apps\Monitored Requests',
                    -- 'Processor% Processor Time' counter is taken to calculate application activity,
                    -- relative to hours, when machine sent counter
                    N'\Processor\% Processor Time'
                )
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    MACHINEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
-- Insert source and machine with correspondent process name and extrainfo
-- Here machine is used, as same source with same process name can run in different machines
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SOURCEID,
        ph.MACHINEID,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph
        JOIN APM.Source AS s (NOLOCK) ON ph.SOURCEID = s.sourceId
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.PCPROCESSID 
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
--Get sources name, ids list separated by comma per app pool
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID,
        -- all source names which have the same process name as passed in @SOURCEIDS
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources,
        --Select SourceIds list for application pool, this string is need to avoid drillthrought to other reports
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    CAST(c1.SOURCEID AS NVARCHAR(5)) + N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS SourceIds
        
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID
),
-- Filter sources for which data should be selected;
-- as info should be selected not only for transfered sources, but also for sources
-- in the same app pool
SourceFilter AS
(
--One application can be in the several app pools, so use DISTINCT
    SELECT DISTINCT 
        s2.SOURCEID
    FROM
        #PROCESSNAMEFORSOURCE AS s1
        JOIN #PROCESSNAMEFORSOURCE AS s2 ON s1.EXTRAINFO = s2.EXTRAINFO AND s1.PROCESS = s2.PROCESS
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND s1.SOURCEID = f.VALUEID)
),
--Filter PerfHourly by source
PerfHourlyBySource AS
(
    SELECT
        ph.UTCDate,
        ph.PCPROCESSID,
        ph.MACHINEID,
        ph.SUMVALUE,
        ph.SAMPLECOUNT,
        ph.PACKAGECOUNTER,
        ph.MAXVALUE,
        ph.SOURCEID,
        ph.TYPE
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph (NOLOCK)
        JOIN SourceFilter AS s ON s.SOURCEID = ph.SOURCEID
),
--Calculate resource utilization by processes on machines in one hour
ProcessHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type,
        -- Select MAX value as in case of app pool, some of the application
        -- could work not whole hour, and the value should be taken for the 
        -- application worked for the longest period 
        MAX(ph.SumValue) AS SumValue,
        MAX(ph.MaxValue) AS MaxValue,
        MAX(ph.SampleCount) AS SampleCount,
        MAX(ph.PackageCounter) AS PackageCounter 
    FROM
        PerfHourlyBySource AS ph
    WHERE
        --This condition allows to exclude Monitored Requests counter
        PCProcessId IS NOT NULL 
    GROUP BY
        ph.MachineId,
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type 
),
-- Calculate resource utilization by application in one hour.
-- Here "application" means - for web application = AppPool, otherwise = processname
ApplicationHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
        ph.UTCDate,
        ph.Type,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        --Select process name till # symbol
        APM.RemoveProcessIdFromName(p.Process) AS ProcessName,
        COALESCE(p.ExtraInfo, N'') AS ProcessExtraInfo,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue,
        MAX(ph.MaxValue) AS MaxValue        
    FROM
        ProcessHourlyResourceUtilization AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON ph.PCProcessId = p.PCProcessId
    GROUP BY
        ph.MachineId,
        ph.UTCDate,
        ph.Type,
        APM.RemoveProcessIdFromName(p.Process),
        p.ExtraInfo 
),
--Calculate average application resource utilization over all specified period per machine
ApplicationResourceUtilizationByMachines AS
(
    SELECT
        ph.MachineId,
        ph.ProcessName,
        ph.ProcessExtraInfo,
        -- Number of hours when application was active
        COUNT(DISTINCT ph.UTCDate) AS ApplicationAvailabilityHours,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        MAX(ph.InstanceCount) AS MaxInstanceCount,
        AVG(CASE WHEN InstanceCount &lt; 1 THEN InstanceCount ELSE 1 END) AS AppActivity,
        AVG(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.AvgValue END) AS MemoryAvgValue,
        MAX(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.MaxValue END) AS CPUMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.MaxValue END) AS IOMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.MaxValue END) AS MemoryMaxValue
    FROM
        ApplicationHourlyResourceUtilization AS ph
    GROUP BY
        ph.MachineId,
        ph.ProcessName,
        ph.ProcessExtraInfo 
),
-- Count hours when computer sent counters.
-- This value is used to calculate application activity between hours
ComputerAvailabilityHours AS
(
    SELECT
        COUNT(DISTINCT ph.UTCDate) AS HoursCount,
        ph.MACHINEID
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph
    WHERE
        ph.SOURCEID IS NULL
        AND ph.PCPROCESSID IS NULL
        AND ph.TYPE = N'\Processor\% Processor Time'
    GROUP BY
        ph.MACHINEID
),
-- Count Monitored Requests for Application on each machine
-- as source can run on different machines with same process name and app pool, but different sources set, 
-- it is important to group by machine to, to avoid calculation of requests from the other app pool
ApplicationRequestCountByMachine AS
(
    SELECT
        ph.MACHINEID,
        c.EXTRAINFO,
        c.PROCESS,
        SUM(ph.SUMVALUE) AS RequestCount
    FROM
        PerfHourlyBySource AS ph
        -- If source was running in several app pools  
        -- #PROCESSNAMEFORSOURCE would contain several rows for one sourceid.
        -- In this case request count will be counted for all app pools
        JOIN #PROCESSNAMEFORSOURCE AS c ON (ph.SOURCEID = c.SOURCEID AND ph.MACHINEID = c.MACHINEID)
    WHERE
        ph.TYPE = N'\Apps\Monitored Requests'
    GROUP BY
        ph.MACHINEID,
        c.EXTRAINFO,
        c.PROCESS
),
--Summary application resource utilization info by machines
ApplicationResourceUtilization AS
(
    SELECT 
        -- Enumerate computers within application by specified orderBy value
        ROW_NUMBER() OVER (PARTITION BY 
-- Application pool sources added to grouping as on different machines app pool with the same names
-- can contain different sources set, and app pools assumed to be same only
-- if its name and sources set are the same
                        appPool.ExtraInfo,
                        appPool.Process,
                        appPool.AppPoolSources      
                        ORDER BY 
                        CASE @SORTORDER 
                            WHEN 1 THEN ph.CPUAvgValue/COALESCE(m.CPUCount, 1)
                            WHEN 2 THEN ph.MemoryAvgValue 
                            WHEN 3 THEN ph.IOAvgValue 
                            WHEN 4 THEN r.RequestCount 
                        END DESC) AS ComputerId,
        m.machine,
        m.MachineId,
        COALESCE(m.CpuCount, 1) AS CPUCount,
        appPool.ExtraInfo,
        appPool.Process,
        -- Remove comma form the end of source list
        CASE appPool.AppPoolSources WHEN '' THEN '' ELSE LEFT(appPool.AppPoolSources, LEN(appPool.AppPoolSources)-1) END AS AppPoolSources,
        -- Use application activity during all period for instance count calculation and application activity
        InstanceCount*ph.ApplicationAvailabilityHours*1.0/mc.HoursCount AS InstanceCount,
        AppActivity*ph.ApplicationAvailabilityHours*1.0/mc.HoursCount AS AppActivity,
        MaxInstanceCount AS MaxInstanceCount,
        -- CPU load should be normalized on core count for each machine
        CPUAvgValue/COALESCE(m.CPUCount, 1) AS CPUAvgValue,
        CPUMaxValue/COALESCE(m.CPUCount, 1) AS CPUMaxValue,
        IOAvgValue AS IOAvgValue,
        IOMaxValue AS IOMaxValue,
        MemoryAvgValue AS MemoryAvgValue,
        MemoryMaxValue AS MemoryMaxValue,
        r.RequestCount AS RequestCount,
        appPool.SourceIds,
        -- Flag to define if cpu count is not null,
        -- in case of  CPUDefineFlag = 0, show warning message about it in report
        COALESCE(m.CPUCount, 0) AS CPUDefineFlag,
        -- Calculate average value for SortBy field for application over all its machines
        -- This value will be used to enumerate application by specified OrderBy Value
        AVG(CASE @SORTORDER 
                WHEN 1 THEN ph.CPUAvgValue/COALESCE(m.CPUCount, 1)
                WHEN 2 THEN ph.MemoryAvgValue 
                WHEN 3 THEN ph.IOAvgValue 
            END) 
            OVER (PARTITION BY appPool.ExtraInfo,
                        appPool.Process,
                        AppPoolSources  ) AS OrderByValue,
        -- For order by requests sum of requests should be calculated
        SUM(r.RequestCount) OVER(PARTITION BY appPool.ExtraInfo,
                        appPool.Process,
                        AppPoolSources) AS ApplicationRequestCount
    FROM
        ApplicationResourceUtilizationByMachines AS ph
        JOIN AppPoolInfo AS appPool ON (appPool.ExtraInfo = ph.ProcessExtraInfo AND 
                                appPool.Process = ph.ProcessName AND
                                appPool.MachineId = ph.MachineId)
        LEFT OUTER JOIN ApplicationRequestCountByMachine AS r ON (ph.ProcessName = r.Process 
                                                                AND ph.ProcessExtraInfo = r.ExtraInfo
                                                                AND ph.MachineId = r.MachineId)
        JOIN ComputerAvailabilityHours AS mc ON mc.MachineId = ph.MachineId
        JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = ph.MachineId
),
-- Value of Id field is duplicated for each application.
OrderedDataSet AS
(
    SELECT 
        -- DENSE_RANK function returns equal id for equal values in Over expression
        -- This allow to enumerate Application within result set by specified order by value
        DENSE_RANK() OVER(ORDER BY 
                            (CASE 
                                WHEN @SORTORDER = 4 THEN ApplicationRequestCount 
                                ELSE OrderByValue 
                            END) DESC, 
                            ExtraInfo,
                            AppPoolSources  ) AS Id,
        OrderByValue,
        ComputerId,
        machine,
        MachineId,
        CPUCount,
        CASE 
            WHEN LEN(ExtraInfo) &gt; 0 THEN ExtraInfo + N' - '+ AppPoolSources
            -- remove quotes from the start and end of the source name
            ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
        END AS AppPoolName,
        CASE 
            WHEN LEN(ExtraInfo) &gt; 0 THEN ExtraInfo  
            ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
        END AS ApplicationName,
        InstanceCount,
        MaxInstanceCount,
        AppActivity,
        CPUAvgValue,
        CPUMaxValue,
        IOAvgValue/1024 AS IOAvgValue,
        IOMaxValue/1024 AS IOMaxValue,
        MemoryAvgValue/(1024*1024) AS MemoryAvgValue,
        MemoryMaxValue/(1024*1024) AS MemoryMaxValue,
        RequestCount,
        SourceIds,
        CPUDefineFlag
    FROM
        ApplicationResourceUtilization
)
SELECT
    *
FROM
    OrderedDataSet
WHERE
    Id &lt;= @TOPROWCOUNT
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTop10MostFrequentFailureReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTop10MostFrequentFailureReport AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTop10MostFrequentFailureReport
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH ExceptionProblems AS
    (
        SELECT 
            e.description,
            e.category,
            COUNT(
                    CASE 
                        WHEN e.utceventdate &gt;= @STARTDATE AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
                    THEN e.eventid
                    END 
                  ) as EventsCount,  
            COUNT(
                    CASE 
                        WHEN e.utceventdate &gt;= @LASTPERIODSTARTDATE AND e.utceventdate &lt; @STARTDATE 
                    THEN e.eventid
                    END
                  ) AS LastEventsCount,
            MAX(e.SeViewerDBId) AS SeViewerDBId
        FROM
            APM.Event (NOLOCK) AS e
            JOIN #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.TYPEID = 1 AND e.sourceid = f1.VALUE)
            JOIN #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.TYPEID = 2 AND e.machineid = f2.VALUE)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE 
            e.EventClassType = N'Exception'
            AND (e.category LIKE @PROBLEM)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE
        GROUP BY 
            e.description, e.category
    ),
    OrderedExceptionProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY EventsCount DESC) AS Id,
            [description],
            EventsCount,
            LastEventsCount,
            category,
            db.[Address] AS SeViewer
        FROM
            ExceptionProblems AS e
            JOIN APM.SeViewerDB AS db (NOLOCK) ON e.SeViewerDBId = db.SeViewerDBId            
        WHERE 
            EventsCount &gt; 0
    ),
    GroupedExceptionProblems AS
    (
        SELECT
            Id,
            [description],
            EventsCount,
            LastEventsCount,
            category,
            SeViewer,
            SUM(CASE WHEN Id &gt; 10 THEN EventsCount ELSE 0 END) OVER () AS OtherSum,
            SUM(CASE WHEN Id &gt; 10 THEN LastEventsCount ELSE 0 END) OVER () AS OtherLastSum,
            SUM(EventsCount) OVER () AS SummaryCount
        FROM
            OrderedExceptionProblems        
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedExceptionProblems ORDER BY Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTop10MostFrequentPerformanceReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTop10MostFrequentPerformanceReport AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTop10MostFrequentPerformanceReport
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    CREATE TABLE #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    CREATE INDEX idx_parametertmp ON #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE(TYPEID) INCLUDE(VALUE)  
    ;WITH PerformanceProblems AS
    (
        SELECT 
            COUNT(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventid END) as IssuesCount,
            AVG(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS AvgDuration,
            MAX(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS MaxDuration,
            COUNT(CASE WHEN e.utceventdate &lt; @STARTDATE THEN e.eventid END) AS LastIssuesCount,
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END) AS PerfNodeDescription
        FROM
            APM.Event (NOLOCK) AS e
			JOIN #PMSTATUSFILTERTABLE AS f ON (f.VALUEID = e.PMStatus)             
            OUTER APPLY (
                SELECT TOP(1)
                    description
                FROM
                    APM.PerformanceNode (NOLOCK)
                WHERE
                    EVENTID = e.EventId  AND e.resourceid = resourceid
                ORDER BY 
                    SelfDuration DESC
            ) AS pn 
        WHERE 
            e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD 
            AND e.sourceid IN (SELECT VALUE FROM #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f1 WHERE f1.TYPEID = 1)
            AND e.machineid IN (SELECT VALUE FROM #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f2 WHERE f2.TYPEID = 2)
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
        GROUP BY 
            e.rootnodename, (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
                    END)
    ),
    OrderedPerformanceProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY IssuesCount DESC) AS Id,
            rootnodename,
            PerfNodeDescription,
            rootnodename + (CASE 
                                WHEN LEN(PerfNodeDescription) &gt; 0 
                                THEN ' slow at ' +  PerfNodeDescription 
                            ELSE N'' END) AS description,
            IssuesCount,
            AvgDuration,
            MaxDuration,
            LastIssuesCount,
            (SELECT SUM(IssuesCount) FROM PerformanceProblems) AS SummaryCount
        FROM
            PerformanceProblems
        WHERE 
            IssuesCount &gt; 0            
    ),
    GroupedPerformanceproblems AS
    (
        SELECT
            Id,
            rootnodename,
            PerfNodeDescription,
            description,
            IssuesCount,
            AvgDuration,
            MaxDuration,
            LastIssuesCount,
            SUM(CASE WHEN Id &gt; 10 THEN IssuesCount ELSE 0 END) OVER () AS OtherSum,
            SUM(CASE WHEN Id &gt; 10 THEN LastIssuesCount ELSE 0 END) OVER () AS OtherLastSum,
            SUM(IssuesCount) OVER () AS SummaryCount
        FROM
            OrderedPerformanceProblems      
    )
    SELECT 
        TOP(10) *
    FROM 
        GroupedPerformanceproblems
    ORDER BY 
        Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTOP10NewExceptionProblems'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTOP10NewExceptionProblems AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTOP10NewExceptionProblems
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
                
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH NewExceptionProblems AS
    (
        SELECT 
            e.description,
            e.category,
            COUNT(DISTINCT e.eventid) as EventsCount,
            MAX(e.SeViewerDBId) AS SeViewerDBId
        FROM
            APM.Event (NOLOCK) AS e
            JOIN #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.VALUE = e.sourceid and f1.TYPEID = 1) 
            JOIN #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.VALUE = e.machineid and f2.TYPEID = 2)
            JOIN APM.eventgroup (NOLOCK) AS eg ON e.eventGroupId = eg.EventGroupId
        WHERE 
            e.EventClassType = N'Exception'
            AND (e.category LIKE @PROBLEM)
            AND e.utceventdate &gt;= @STARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE
            AND eg.firsteventdate &gt;= @STARTDATE
            AND (e.PMStatus = 0)              
        GROUP BY 
            e.description, e.category
    ),
    OrderedExceptionProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY EventsCount DESC) AS Id,
            description,
            EventsCount,
            category,
            db.Address AS SeViewer           
        FROM
            NewExceptionProblems e
            JOIN APM.SeViewerDB AS db (NOLOCK) ON e.SeViewerDBId = db.SeViewerDBId            
    ),
    GroupedExceptionProblems AS
    (
        SELECT
            *,
            SUM(CASE WHEN Id &gt; 10 THEN EventsCount ELSE 0 END) OVER() AS OtherSum,
            SUM(EventsCount) OVER() AS EventsSum
        FROM 
            OrderedExceptionProblems
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedExceptionProblems
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTOP10NewPerformanceProblems'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTOP10NewPerformanceProblems AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTOP10NewPerformanceProblems
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH NewPerformanceProblems AS
    (
        SELECT 
            COUNT(e.eventid) as IssuesCount,
            AVG(e.eventduration / 1000000) AS AvgDuration,
            MAX(e.eventduration / 1000000) AS MaxDuration,
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END) AS PerfNodeDescription
        FROM
            APM.Event AS e
            JOIN #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.VALUE = e.sourceid and f1.TYPEID = 1) 
            JOIN #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.VALUE = e.machineid and f2.TYPEID = 2)
            JOIN APM.eventgroup (NOLOCK) AS eg ON E.EventGroupId = eg.EventGroupId
            OUTER APPLY (
                SELECT TOP(1)
                    description
                FROM
                    APM.PerformanceNode (NOLOCK)
                WHERE
                    EVENTID = e.EventId  AND e.resourceid = resourceid
                ORDER BY 
                    SelfDuration DESC
            ) AS pn 
        WHERE 
            e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD 
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @STARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
            AND eg.firsteventdate &gt;= @STARTDATE
            AND eg.firsteventdate &lt; @CURRENTPERIODENDDATE 
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
            AND (e.PMStatus = 0)              
        GROUP BY 
            e.rootnodename, (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
                    END)
    ),
    OrderedPerformanceProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY IssuesCount DESC) AS Id,
            rootnodename,
            PerfNodeDescription,
            rootnodename + (CASE 
                                WHEN LEN(PerfNodeDescription) &gt; 0 
                                THEN ' slow at ' +  PerfNodeDescription 
                            ELSE N'' END) AS description,
            IssuesCount,
            AvgDuration,
            MaxDuration
        FROM
            NewPerformanceProblems
    ),
    GroupedPerformanceProblems AS
    (
        SELECT
            *,
            SUM(CASE WHEN Id &gt; 10 THEN IssuesCount ELSE 0 END) OVER() AS OtherSum,
            SUM(IssuesCount) OVER() AS SummaryCount
        FROM
            OrderedPerformanceProblems
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedPerformanceProblems
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetAbsDateByRelative'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetAbsDateByRelative ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetAbsDateByRelative(@RELATIVEDATE INT) RETURNS DATETIME
AS
BEGIN
  RETURN 
            CASE @RELATIVEDATE 
                  WHEN 10 THEN DATEADD(d, -(DATEPART(WEEKDAY, GETDATE()) - 1), GETDATE())
                WHEN 20 THEN DATEADD(d, (7 - DATEPART(WEEKDAY, GETDATE())), GETDATE())
                WHEN 30 THEN DATEADD(WEEK, -1, DATEADD(d, -(DATEPART(WEEKDAY, GETDATE()) - 1), GETDATE()))
                  WHEN 40 THEN DATEADD(WEEK, -1, DATEADD(d, (7 - DATEPART(WEEKDAY, GETDATE())), GETDATE())) 
                WHEN 50 THEN DATEADD(DAY, -(DATEPART(DAY, GETDATE()) - 1), GETDATE())
                WHEN 60 THEN DATEADD(d, -DATEPART(DAY, DATEADD(MONTH, 1, GETDATE())), DATEADD(MONTH, 1, GETDATE()))
                WHEN 70 THEN DATEADD(MONTH, -1, DATEADD(DAY, -(DATEPART(DAY, GETDATE()) - 1), GETDATE()))
                WHEN 80 THEN DATEADD(DAY, -DATEPART(DAY, GETDATE()), GETDATE())
                WHEN 90 THEN GETDATE()
                WHEN 100 THEN DATEADD(DAY, -1, GETDATE())
                WHEN 110 THEN DATEADD(DAY, 1, GETDATE())
          END     
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('apm.Split'), 'IsTableFunction') IS NOT NULL)
  BEGIN
    DROP FUNCTION apm.Split    
  END
GO
CREATE FUNCTION apm.Split(@String NVARCHAR(MAX), @Delimiter NCHAR(1) = N',')       
RETURNS @temptable TABLE 
(
	items NVARCHAR(MAX)
)       
AS       
BEGIN       
    DECLARE @idx INT
    DECLARE @slice NVARCHAR(MAX)
      
    SELECT @idx = 1       
    IF @Delimiter IS NULL OR LEN(@Delimiter) &lt; 1 
		return;
       
    IF @String IS NULL OR LEN(@String) &lt; 1
		return;
      
    WHILE @idx!= 0       
    BEGIN       
        SET @idx = CHARINDEX(@Delimiter,@String)       
        IF @idx!=0       
            SET @slice = LEFT(@String,@idx - 1)       
        ELSE       
            SET @slice = @String       
          
        IF(LEN(@slice)&gt;0)  
            INSERT INTO @temptable(Items) VALUES(@slice)       
  
        SET @String = RIGHT(@String,LEN(@String) - @idx)       
        IF LEN(@String) = 0 BREAK       
    END   
RETURN       
END  
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetMultiParameters'), 'IsTableFunction') IS NOT NULL)
  BEGIN
    DROP FUNCTION APM.GetMultiParameters    
  END
GO
create FUNCTION APM.GetMultiParameters(@PARAMETER1 NVARCHAR(MAX), @PARAMETER2 NVARCHAR(MAX))
RETURNS @RESULT TABLE
(
    ID INT,
    TYPEID INT,
    VALUE NVARCHAR(MAX)
) 
AS 
BEGIN
    ;WITH Filters AS 
    (
        SELECT 
			1 AS typeId, items AS [Value]
        FROM
			apm.Split(@PARAMETER1, ',') 
        UNION ALL
        SELECT 
			2 AS typeId, items AS [Value]
        FROM
			apm.Split(@PARAMETER2, ',') 
    )
    INSERT INTO @RESULT 
        SELECT 
            ROW_NUMBER() OVER (ORDER BY typeId, [Value]) AS Id,
            typeId, 
            RTRIM(LTRIM([value])) AS Value
        FROM 
			Filters 
			
    RETURN
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ResourceUtilizationTrend'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ResourceUtilizationTrend AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ResourceUtilizationTrend                                                   */
/* USED IN: Day of Week Utilization, Hour of Day Utilization,                       */
/*      Utilization Trend reports                                                   */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @TIMEZONE - Time offset relative to UTC. Used in SP to calculate            */
/*              period in UTC and for conversion UTC time back                      */
/*              to user time (for showing in trend chart)                           */
/*      @GROUPBY - Specifies result gouping type. Possible values:                  */
/*              Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                  corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*              WeekDay - Group by week days. For this grouping type extra grouping */
/*                  is applied - by hours. So result data set contains 7*24 rows.   */
/*                  Date field values - 1-7, Hour fields - 0-23                 */
/*              Date - Group by date. Number of row equal to days count in specified*/
/*                  period. If extra parameter @GROUPBYHOUR = 1, then extra grouping*/
/*                  by hours applied. If @GROUPBYHOUR = 0, than date field values - */
/*                  0-(@ENDDATE-@STARTDATE) and Hour field - 0.If @GROUPBYHOUR = 1*/
/*                  than date field values - 0-(@ENDDATE-@STARTDATE)                */
/*                  and Hour field - 0-23                                           */
/*      @GROUPBYHOUR - flag to apply extra grouping by Hour. Available only for     */
/*                  grouping by Date.                                               */
/************************************************************************************/
ALTER PROCEDURE APM.ResourceUtilizationTrend 
    @SOURCEIDS NVARCHAR(MAX),
    @MACHINEIDS NVARCHAR(MAX),
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @GROUPBY NVARCHAR(10),
    @PMSTATUS NVARCHAR(50),
    @GROUPBYHOUR BIT = 0
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
/************************************************************************************************************************/
/*                              DECLARE SP VARIABLES                                                                    */    
/************************************************************************************************************************/
--Convert start date to utc format
    DECLARE @UTCSTARTDATE DATETIME
    SET @UTCSTARTDATE = DATEADD(minute, -@TIMEZONE, @STARTDATE)
--Convert end date to utc format
    DECLARE @UTCENDDATE DATETIME
    SET @UTCENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
-- Day count in specified period
    DECLARE @PERIOD INT
    SET @PERIOD = ABS(DATEDIFF(day, @STARTDATE, @ENDDATE)) + 1
-- Define if extra grouping by hours should be applied
    DECLARE @DOGROUPINGBYHOUR BIT
    SET @DOGROUPINGBYHOUR = CASE 
-- For group by WeekDay always do extra grouping by hours, for grouping by Date, only if @GROUPBYHOUR = 1 specified
                                WHEN @GROUPBY = 'WeekDay' THEN 1
                                WHEN (@GROUPBY = 'Date' AND @GROUPBYHOUR = 1) THEN 1
                                ELSE 0
                        END
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
/************************************************************************************************************/
/*                                  PREPARE ASSISTING TABLES                                                */
/************************************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    MACHINEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
-- Insert source and machine with correspondent process name and extrainfo
-- Here machine is used, as same source with same process name can run in different machines
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SourceId,
        ph.MachineId,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        (
            SELECT DISTINCT
                ph.SourceId,
                ph.pcprocessId,
                ph.MachineId
            FROM
                APM.PerfHourly AS ph (NOLOCK)
            WHERE
                ph.pcprocessId IS NOT NULL
                AND ph.UTCDate &gt;= @UTCSTARTDATE
                AND ph.UTCDate &lt; @UTCENDDATE
        ) AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.pcprocessId 
	JOIN APM.Source AS s (NOLOCK) ON s.SourceId = ph.SourceId
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MachineId = f.VALUEID)        
-- Assisting table, which contains filtered rows from Event table  
CREATE TABLE #EVENTFILTER
(
    EVENTID BIGINT,
    SOURCEID INT,
    SEVIEWERADDRESS NVARCHAR(MAX) collate database_default,
    HOUR INT,
    DATE INT
)
INSERT INTO #EVENTFILTER
    SELECT 
        e.EventId,
        E.SourceId,
        -- Select event SeViewerd address to provide link to it in report
        db.Address AS SEVIEWERADDRESS,
        -- If grouping by hour should be done, then get hour from event date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, e.utceventdate))
            ELSE 0
        END) AS HOUR,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between event date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, e.utceventdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, e.utceventdate))
        END) AS DATE
    FROM
        APM.EVENT AS e
        JOIN APM.SeViewerDB AS db ON e.seviewerdbid = db.seviewerdbid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE f1 ON e.SourceId = f1.VALUEID AND f1.TYPEID = 1
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE f2 ON e.MachineId = f2.VALUEID AND f2.TYPEID = 2
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.UTCEventDate &gt;= @UTCSTARTDATE
        AND e.UTCEventDate &lt; @UTCENDDATE
        AND (e.HeavyLight IS NULL OR e.HeavyLight  &gt; 0)
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
-- Get sources name, ids list separated by comma per app pool
-- This info should be selected for all sources, even they are in the same application pool
-- as in this report grouping by source is applied not by application pool.
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        c.SOURCEID,
        -- all source names which have the same process name as passed in @SOURCEIDS
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID,
        c.SOURCEID
),
SourceDescription AS (
    SELECT DISTINCT
        CASE 
            -- For web application add app pool name before source list (remove comma from the source list end)
            WHEN LEN(pd.ExtraInfo) &gt; 0 THEN pd.ExtraInfo + CASE pd.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(pd.AppPoolSources, LEN(pd.AppPoolSources) - 1) + ')' END
            -- For executable application remove quotes from the start and end and remove comma
            ELSE CASE pd.AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(pd.AppPoolSources, 2, LEN(pd.AppPoolSources)-3) END
            
        END AppPool,
        pd.SourceId
    FROM 
        AppPoolInfo AS pd
),
-- Forms application pool list for each source
-- Format: AppPool1 - ('Source1', 'Source2', Source3), AppPool2 - ('Source1', 'Source4')
SourceAppPools AS (
    SELECT 
        s.SourceId,
        -- Also select source name, to show it to user in report
        s.Source,
        (SELECT a.AppPool AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    sd.AppPool +  N', ' AS AppPool
                FROM 
                    SourceDescription as sd
                WHERE 
                    sd.SourceId = s.Sourceid 
            ) AS A
            FOR XML PATH ('') 
        ) AS AggAppPool
    FROM 
        #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f
        JOIN APM.Source AS s (NOLOCK) ON f.VALUEID = s.SourceId
    WHERE 
        f.TYPEID = 1
),
-- Report frame. It contains all sources, for which data sould be selected, 
-- and date values accordingly to specified period and grouping type.  
SourcesDates AS 
(
    SELECT DISTINCT
        -- Remove comma from the end
        CASE sd.AggAppPool WHEN '' THEN '' ELSE LEFT(sd.AggAppPool, LEN(sd.AggAppPool) - 1) END AS AppPool,
        sd.Source AS Source,
        sd.SourceId AS SourceId,
        -- Decrease hours to one. Result either 0-23, or 0 (if grouping by hours not specified)
        Hours.n-1 AS hours,
        D.date AS date
    FROM
        SourceAppPools AS sd
        -- If groupng by hours should be applied, select values for hours 1-24, else select only one value - 1
        CROSS JOIN APM.fn_nums(                
            (CASE
                WHEN @DOGROUPINGBYHOUR = 1 THEN 24
                ELSE 1
            END)) AS Hours
        -- Select date, depending on Group by parameter
        CROSS JOIN (SELECT
            (CASE
                -- Values 0-23
                WHEN @GROUPBY = 'Hour' THEN n-1
                -- Values 1-7
                WHEN @GROUPBY = 'WeekDay' THEN n
                -- Values 0 - (@ENDDATE - @STARTDATE)
                WHEN @GROUPBY = 'Date' THEN n - 1
            END) AS date
        FROM 
            APM.fn_nums(
                CASE
                    WHEN @GROUPBY = 'Hour' THEN 24
                    WHEN @GROUPBY = 'WeekDay' THEN 7
                    WHEN @GROUPBY = 'Date' THEN (@PERIOD)
                END     
            )           
        ) AS D
),
-- Calculate resource utilization by SOURCE in one hour.
-- Here counter values are aggregated between sources assosiated with app pool (process).
-- If source presents in several app pools, then in this step values from all of them will be aggregated 
SourceHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
-- Single source is a source for which information should be selected
-- Information about each process assosiated with single source and consolidated for it
        ph.SourceId AS SingleSourceId,
        ph.UTCDate,
        ph.PCTypeId,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
    WHERE
        ph.UTCDate &gt;= @UTCSTARTDATE
        AND ph.UTCDate &lt; @UTCENDDATE
        AND PCTypeId IN (@PROCESSORCOUNTERID, @MEMORYCOUNTERID, @IOCOUNTERID)
    GROUP BY
        ph.MachineId,
        ph.SourceId,
        ph.UTCDate,
        ph.PCTypeId
),
--Calculate average source resource utilization for each resource type
ApplicationResourceUtilizationByType AS
(
    SELECT
        ph.MachineId,
        ph.SingleSourceId,
        -- If grouping by hour should be done, then get hour from PCounter date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END) AS Hour,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between PCounter date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END) AS Date,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        AVG(CASE WHEN ph.PCTypeId = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.PCTypeId = @IOCOUNTERID THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.PCTypeId = @MEMORYCOUNTERID THEN ph.AvgValue END) AS MemoryAvgValue
    FROM
        SourceHourlyResourceUtilization AS ph
    GROUP BY
        ph.MachineId,
        ph.SingleSourceId,
        ph.utcdate
),
--Calculate average source resource utilization for specified grouping date          
ApplicationResourceUtilizationByGroupingDate AS
(
    SELECT
        ph.MachineId,
        ph.SingleSourceId,
        ph.Hour,
        ph.Date,
        AVG(InstanceCount) AS InstanceCount,
        AVG(CPUAvgValue) AS CPUAvgValue,
        AVG(IOAvgValue) AS IOAvgValue,
        AVG(MemoryAvgValue) AS MemoryAvgValue
    FROM
        ApplicationResourceUtilizationByType AS ph
    GROUP BY
        ph.MachineId,
        ph.SingleSourceId,
        ph.Hour,
        ph.Date
),
-- Calculate average source resource utilization between machines  
-- This aggregation is actual then grouping type is longer than specified period.
-- Exp: Group by week day, period - month. Then grouping between all mondays in this month should be applied         
ApplicationResourceUtilizationBetweenMachines AS
(
    SELECT
        ph.SingleSourceId,
        ph.Hour,
        ph.Date,
        AVG(InstanceCount) AS InstanceCount,
        AVG(CPUAvgValue/COALESCE(m.CPUCount, 1)) AS CPUAvgValue,
        AVG(IOAvgValue) AS IOAvgValue,
        AVG(MemoryAvgValue) AS MemoryAvgValue
    FROM
        ApplicationResourceUtilizationByGroupingDate AS ph
        JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = ph.MachineId 
    GROUP BY
        ph.SingleSourceId,
        ph.Hour,
        ph.Date
),
-- Monitored requests and request average time calculation by mechines with specified grouping
-- For this counter type perfhourly table contain one record for source, utcdate and machine, so other grouping is redundant 
RequestsBySources AS
(
    SELECT
        ph.SourceId,
        ph.MachineId,
        SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) AS ReqCount, 
        AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue/ph.SampleCount  END) AS AvgReqTime,
        -- If grouping by hour should be done, then get hour from PCounter date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END) AS Hour,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between PCounter date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END) AS Date
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
    WHERE
        ph.UTCDate &gt;= @UTCSTARTDATE
        AND ph.UTCDate &lt; @UTCENDDATE
        AND ph.PCTypeId IN (@MONITOREDREQUESTCOUNTERID, @REQUESTTIMECOUNTERID)
    GROUP BY
        ph.SourceId,
        ph.MachineId,
        -- This aggregation is actual then grouping type is longer than specified perid.
        -- Exp: Group by week day, period - month. Then grouping between all mondays in this month should be applied  
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END),
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END)
),
--Calculate request between machines
RequestsBetweenMachines AS
(
    SELECT
        SourceId,
        SUM(ReqCount) AS ReqCount, 
        AVG(AvgReqTime) AS AvgReqTime,
        Hour,
        Date
    FROM
        RequestsBySources
    GROUP BY
        SourceId,
        Hour,
        Date
),
Events AS 
(
    SELECT
        COUNT(e.EVENTID) AS EventCount,
        MAX(e.SEVIEWERADDRESS) AS SeViewerAddress,
        e.SOURCEID,
        e.HOUR,
        e.DATE
    FROM
        #EVENTFILTER AS e
    GROUP BY
        e.SOURCEID,
        e.HOUR,
        e.DATE
),
-- Check that CPU count is defined for all computers, where application run.
-- Computers set, where application run, does not depend on specified period by design, as otherwise there is performance problems
MachineCPUUndefinedFlag AS
(
    SELECT
        sf.SOURCEID,
        MIN(COALESCE(m.CPUCount, -1)) AS CPUUndefinedFlag
    FROM
        #PROCESSNAMEFORSOURCE AS sf
        JOIN APM.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MachineId
    GROUP BY
        sf.SOURCEID
)
    SELECT 
        sd.Date,
        sd.Hours,
        sd.AppPool AS ApplicationPool,
        sd.SourceId,
        sd.Source AS SingleSource,
        E.SeViewerAddress,
        COALESCE(pc.InstanceCount, 0) AS NumberOfApplicationInstances,
        COALESCE(req.ReqCount, 0) AS NumberOfRequests,
        COALESCE(req.AvgReqTime, 0) AS AverageRequestTime,
        COALESCE(pc.CPUAvgValue, 0) AS ResourceCPUUsage,
        COALESCE(pc.IOAvgValue, 0) AS ResourceIO,
        COALESCE(pc.MemoryAvgValue, 0) AS ResourceMemory,
        COALESCE(e.EventCount, 0) AS NumberOfEvents,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one PCounter row
        -- in PerfHourly table for specified period. If so, there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag
    FROM 
        SourcesDates AS sd
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON sd.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ApplicationResourceUtilizationBetweenMachines AS pc ON (sd.SourceId = pc.SingleSourceId AND pc.Hour = sd.Hours AND pc.Date = sd.Date)
        LEFT OUTER JOIN RequestsBetweenMachines AS req ON (sd.SourceId = req.SourceId AND req.Hour = sd.Hours AND req.Date = sd.Date)
        LEFT OUTER JOIN Events AS e ON (sd.SourceId = e.SourceId AND e.Hour = sd.Hours AND e.Date = sd.Date)
    ORDER BY 
        sd.SourceId,
        sd.Date, 
        sd.Hours
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Source_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Source_sync AS RETURN 1')
  END
GO
----------------------------------Sync procedures----------------------------------
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Source_sync                                                                */
/* USED IN: Synchronization source table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Source_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Source_sync', @EXECRESULT)
    END
    
    DECLARE @SOURCE TABLE (
       source           nvarchar(255)  NOT NULL
    )
    
    ----Fill table from package
    INSERT @SOURCE (
       source
    )
    SELECT
       source
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    source  nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --insert not existing
    INSERT APM.source (source)
    SELECT DISTINCT sync.source
    FROM @SOURCE sync
    WHERE NOT EXISTS (SELECT * FROM APM.source WHERE (source = sync.source))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Machine_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Machine_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Machine_sync                                                               */
/* USED IN: Synchronization machine table. Call by Intercept Reporting Services     */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Machine_sync
   @OBJECTKEYXML       ntext
  ,@TRACELEVEL         int
  ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'machine_sync', @EXECRESULT)
    END
    
    DECLARE @MACHINE TABLE (
       machinename       nvarchar(255) 
      ,windowsversion    nvarchar(50) 
      ,agentversion      nvarchar(50) 
      ,cpucount          int
    )
    
 ----Fill table from package
    INSERT @MACHINE (
       machinename
      ,windowsversion
      ,agentversion
      ,cpucount
    )
    SELECT
       machinename
      ,windowsversion   
      ,agentversion
      ,cpucount 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       machinename       nvarchar(255) 
      ,windowsversion    nvarchar(50) 
      ,agentversion      nvarchar(50) 
      ,cpucount          int    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    SET @XMLDOCHANDLE = NULL
   /*------------------ sync machine--------------------*/
    ---update existing 
    UPDATE m
    SET  machine = sync.machinename
        ,windowsversion = sync.windowsversion
        ,agentversion = COALESCE(sync.agentversion, m.agentversion)
        ,cpucount = COALESCE(sync.cpucount, m.cpucount)
    FROM APM.machine m
          JOIN @MACHINE sync ON sync.machinename = m.machine
          
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)          
    --insert not existing
    INSERT APM.machine (machine, windowsversion, agentversion, cpucount) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
    SELECT DISTINCT sync.machinename, sync.windowsversion, sync.agentversion, sync.cpucount
    FROM @MACHINE sync
    WHERE NOT EXISTS (SELECT * FROM APM.machine WHERE (machine = sync.machinename))
    
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCType_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCType_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PCType_sync                                                                */
/* USED IN: Synchronization pctype table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.PCType_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCType_sync', @EXECRESULT)
    END
    
    DECLARE @PCTYPE TABLE (
       type     nvarchar(255) collate database_default
      ,measure    nvarchar(50) collate database_default
    )
    
    ----Fill table from package
    INSERT @PCTYPE (
       type
      ,measure
    )
    SELECT
       type
      ,measure
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       type     nvarchar(255)
      ,measure    nvarchar(50) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --------------sync type---------
    UPDATE T
    SET Type = sync.type, measure = sync.measure        
    FROM APM.pctype T
          JOIN @PCTYPE sync ON sync.type = T.Type
    INSERT APM.pctype (type, measure)
    SELECT DISTINCT sync.type, sync.measure
    FROM @PCTYPE sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCType WHERE (type = sync.type))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Aspect_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Aspect_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Aspect_sync                                                                */
/* USED IN: Synchronization aspect table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Aspect_sync 
   @OBJECTKEYXML       ntext
  ,@TRACELEVEL         int
  ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Aspect_sync', @EXECRESULT)
    END
    
    DECLARE @ASPECT TABLE (
       Aspect           nvarchar(50) collate database_default  NOT NULL
      ,Description    nvarchar(255) collate database_default NULL
    )
    ----Fill table from package
    INSERT @ASPECT (
       Aspect
      ,Description
    )
    SELECT
       Aspect
      ,Description
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                     aspect         nvarchar(50) 
                    ,description  nvarchar(256) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    ---update existing 
    UPDATE asp
    SET Aspect = sync.Aspect, Description = sync.Description        
    FROM APM.Aspect asp
          JOIN @ASPECT sync ON sync.Aspect = asp.aspect
    --insert not existing
    INSERT APM.aspect (aspect, description)
    SELECT DISTINCT sync.Aspect, sync.Description
    FROM @ASPECT sync
    WHERE NOT EXISTS (SELECT * FROM APM.Aspect WHERE (aspect = sync.Aspect))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.EventGroup_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.EventGroup_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: EventGroup_sync                                                            */
/* USED IN: Synchronization eventgroup and cseventgroup tables.                     */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[EventGroup_sync]
   @OBJECTKEYXML      ntext
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@UPDATED_ROWCOUNT  int 
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE           nvarchar(max)
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'EventGroup_sync', @EXECRESULT)
    END
    
    DECLARE @EVENTGROUP TABLE (
       id                int identity(1,1)
      ,source            nvarchar(255) collate database_default
      ,firsteventdate    datetime
      ,lasteventdate     datetime
      ,eventclasstype    nvarchar(50) collate database_default  
      ,rootnodename      nvarchar(255) collate database_default
      ,aspect            nvarchar(50) collate database_default
      ,hashvalue         nvarchar(50) collate database_default
      ,client            bit
	  ,description       nvarchar(max) collate database_default     
      ,sourceid          int    
    )
    
    --Fill temporary table from package
    INSERT @EVENTGROUP (
       source
      ,firsteventdate
      ,lasteventdate
      ,eventclasstype
      ,rootnodename
      ,aspect
      ,hashvalue
      ,client
	  ,description      
    )
    SELECT DISTINCT
       source
      ,firsteventdate
      ,lasteventdate
      ,eventclasstype
      ,rootnodename
      ,aspect
      ,hashvalue
      ,CASE WHEN source LIKE '%(Client)' THEN 1 ELSE 0 END 
      ,description 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       source            nvarchar(255) 
      ,firsteventdate    datetime
      ,lasteventdate     datetime
      ,eventclasstype    nvarchar(50)   
      ,rootnodename      nvarchar(255)
      ,aspect            nvarchar(50)
      ,hashvalue         nvarchar(50)
      ,description       nvarchar(max)
	 ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    --remove duplicates by hashvalue
	Delete g1
		from @EVENTGROUP g1
			join @EVENTGROUP g2 on g1.id &gt; g2.id and g1.hashvalue = g2.hashvalue
			
			
    
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
    
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	   SELECT DISTINCT source FROM @EVENTGROUP eg
	      WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = eg.source)
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        DECLARE @ALLAPPID int
        SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
        
/*------------------sync eventgroup------------------*/
/* updating server or client event group */
    IF EXISTS(SELECT * FROM @EVENTGROUP WHERE client = 0) 
    BEGIN
        /* updating server event group records by hashavalue*/
        UPDATE G
        SET  eventclasstype = sync.eventclasstype
            ,rootnodename = sync.rootnodename
            ,aspect = sync.aspect
            ,firsteventdate = CASE WHEN sync.firsteventdate &lt; g.firsteventdate THEN sync.firsteventdate ELSE g.firsteventdate END
            ,lasteventdate = CASE WHEN sync.lasteventdate &gt; g.lasteventdate THEN sync.lasteventdate ELSE g.lasteventdate END
            ,description = sync.description
            ,sourceid = s.SourceId
        FROM APM.eventGroup g       
            JOIN @EVENTGROUP sync ON sync.hashvalue = g.hashvalue AND sync.client = 0 
            JOIN APM.Source AS s ON s.source = sync.source
        /*Permit number of affected records*/            
        SET @UPDATED_ROWCOUNT = @@ROWCOUNT
    
        /* Insert new server event group which are not found by hashvalue */
        INSERT APM.eventgroup (
             firsteventdate
            ,lasteventdate
            ,eventclasstype
            ,rootnodename
            ,aspect
            ,hashvalue
            ,description
            ,sourceid
        )
        SELECT DISTINCT 
           sync.firsteventdate
          ,sync.lasteventdate
          ,sync.eventclasstype
          ,sync.rootnodename
          ,sync.aspect
          ,sync.hashvalue
          ,sync.description
          ,s.SourceId
        FROM @EVENTGROUP sync
        JOIN APM.Source AS s ON s.source = sync.source
        WHERE 
           sync.client = 0 AND NOT EXISTS (SELECT * FROM APM.eventgroup WHERE (hashvalue = sync.hashvalue))
        SET @INSERTED_ROWCOUNT = @@ROWCOUNT
        /* Log about inserted records for verbal log mode*/
        IF @TRACELEVEL = 4 
        BEGIN
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
          RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'eventGroup') WITH NOWAIT;
        END
        /* Number of records from package */
        SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENTGROUP WHERE client = 0
        
        /* Calculate not affected packages records which are not processing */
        SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)  
        
        /* It is need clear flags because client group records can be find in the package */
        SELECT @INSERTED_ROWCOUNT = 0, @UPDATED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @EVENTGROUP WHERE client = 1) 
    BEGIN
        /* updating client event group records by hashavalue*/
        UPDATE G
        SET 
            firsteventdate = CASE WHEN sync.firsteventdate &lt; g.firsteventdate THEN sync.firsteventdate ELSE g.firsteventdate END
           ,lasteventdate = CASE WHEN sync.lasteventdate &gt; g.lasteventdate THEN sync.lasteventdate ELSE g.lasteventdate END
        FROM APM.CSEVENTGROUP g     
            JOIN @EVENTGROUP sync ON sync.hashvalue = g.hashvalue AND sync.client = 1 
            
        /*Permit number of affected records*/            
        SET @UPDATED_ROWCOUNT = @@ROWCOUNT
    
        /* Insert new server event group which are not found by hashvalue */
        INSERT APM.CSEVENTGROUP (
             firsteventdate
            ,lasteventdate
            ,hashvalue
            ,description
            ,sourceid
        )
        SELECT DISTINCT 
           sync.firsteventdate
          ,sync.lasteventdate
          ,sync.hashvalue
          ,sync.description
          ,s.SourceId
        FROM 
          @EVENTGROUP sync
          JOIN APM.Source AS s ON s.source = sync.source
        WHERE 
          sync.client = 1 AND NOT EXISTS (SELECT * FROM APM.CSEVENTGROUP WHERE (hashvalue = sync.hashvalue))
        SET @INSERTED_ROWCOUNT = @@ROWCOUNT
        /* Log about inserted records for verbal log mode */
        IF @TRACELEVEL = 4 
        BEGIN
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
          RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEVENTGROUP') WITH NOWAIT;
        END
        /* Number of records from package */
        SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENTGROUP WHERE client = 1
        
        /* Calculate not affected packages records which are not processing */
        /* It is also need to add not affected records from previos processing (server event group)*/       
        SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)    
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
                                 
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO   
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCProcess_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCProcess_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PCProcess_sync                                                             */
/* USED IN: Synchronization PCProcess table. Call by Intercept Reporting Services   */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.PCProcess_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCProcess_sync', @EXECRESULT)
    END
    
    DECLARE @PCPROCESS TABLE (
       id			int IDENTITY(1,1)
      ,process      nvarchar(255) collate database_default
      ,extratype    int
      ,extrainfo    nvarchar(255) collate database_default
      ,hashvalue    nvarchar(50)  collate database_default 
    )
    
 ----Fill table from package
    INSERT @PCPROCESS (
       process
      ,extratype
      ,extrainfo
      ,hashvalue
    )
    SELECT
       process
      ,extratype
      ,extrainfo
      ,hashvalue
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       process      nvarchar(255) 
      ,extratype    int
      ,extrainfo    nvarchar(255)
      ,hashvalue    nvarchar(50)  ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    --remove duplicates by hashvalue
	Delete pr1
		from @PCPROCESS pr1
			join @PCPROCESS pr2 on pr1.id &gt; pr2.id and pr1.hashvalue = pr2.hashvalue
    UPDATE pr
    SET  process = sync.process
        ,extratype = sync.extratype
        ,extrainfo = sync.extrainfo             
    FROM APM.PCProcess pr
          JOIN @PCPROCESS sync ON sync.hashvalue = pr.hashvalue
    INSERT APM.pcprocess (process, extratype, extrainfo, hashvalue)
    SELECT DISTINCT sync.process, sync.extratype, sync.extrainfo, sync.hashvalue
    FROM @PCPROCESS sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCProcess WHERE (hashvalue = sync.hashvalue))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCDescription_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCDescription_sync AS RETURN 1')
  END
GO
/***********************************************************************************  */
/* OBJECT: Stored Procedure                                                           */
/* NAME: PCDescription_sync                                                           */
/* USED IN: Synchronization PCDescription table. Call by Intercept Reporting Services */
/* INPUT PARAMETERS:                                                                  */
/*      @OBJECTKEYXML - xml package syncronization data                               */
/*      @TRACELEVEL - trace level. Reserved.                                          */
/* OUTPUT PARAMETERS:                                                                 */
/*      @ROWNOTAFFECTED - number of records from package which haven't been           */
/*      synchronized.Reserved.                                                        */
/* Note:                                                                              */
/* If there are records which have not been transferred that they have been already   */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a    */
/* exception at an insert                                                             */
/*************************************************************************************/
ALTER PROCEDURE APM.PCDescription_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
      
    SET @ROWNOTAFFECTED = 0  
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCDescription_sync', @EXECRESULT)
    END
    
    DECLARE @PCDESCRIPTION TABLE (
       name             nvarchar(255) collate database_default  NOT NULL
      ,description        nvarchar(max) collate database_default NULL
    )
    
----Fill table from package
    INSERT @PCDESCRIPTION (
       name
      ,description
    )
    SELECT
       Name
      ,Description
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       name         nvarchar(255) 
      ,description    nvarchar(max)  ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --------------sync description---------
    UPDATE d
    SET Name = sync.name, Description = sync.description        
    FROM APM.PCDescription d
          JOIN @PCDESCRIPTION sync ON sync.name = d.Name
    INSERT APM.pcdescription (name, description)
    SELECT DISTINCT sync.name, sync.description
    FROM @PCDESCRIPTION sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCDescription WHERE (name = sync.name))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMCREATEEVENTTRACES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMCREATEEVENTTRACES AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* PROCEDURE PMCREATEEVENTTRACES																  */
/* Description:                                                                                   */
/* It create trace and event traces.														  	  */
/* Warning: It use temporary table #RESULT(EventId int). Therefore it is need to	              */
/* create #RESULT table before call procedure													  */
/*																								  */
/* Input parameters:																			  */	
/*    @DATA - XML OBJECT VIEW																	  */
/*	  @CLIENT - 0: server events  1:client events 												  */
/**************************************************************************************************/
ALTER PROCEDURE [APM].[PMCREATEEVENTTRACES] 
     @CLIENT bit
    ,@DATA nvarchar(MAX)
AS
  SET NOCOUNT ON
  DECLARE 
     @TRACEOUTPUT TABLE (NEWTRACE int, PMSTATUS nvarchar(max))
     
	  --create trace package
	  INSERT APM.PMTRACE (PMSTATUS) 
			OUTPUT INSERTED.PMTRACEID, INSERTED.PMSTATUS INTO @TRACEOUTPUT
		SELECT DISTINCT r.PMSTATUS FROM #STATUSTABLE r
		
	  IF @@ROWCOUNT = 0
		RAISERROR(N'#STATUSTABLE is empty. Imposible created trace.', 0, 1) WITH NOWAIT	
		
	  -- update data	
	  IF @DATA IS NOT NULL
		UPDATE t 
		   SET t.DATA = @DATA
			 FROM APM.PMTRACE t
				JOIN @TRACEOUTPUT nt ON T.pmtraceId = nt.NEWTRACE  
				
	  --server trace
	  IF @CLIENT = 0
			--Fill server event trace
			--Join with Event table is need because these events can be deleted by grooming
			INSERT APM.PMSERVEREVENTTRACE(EVENTID, PMTRACEID)
			   SELECT e.EVENTID, t.NEWTRACE 
				   FROM #STATUSTABLE AS st
					  JOIN APM.EVENT (NOLOCK) AS e ON e.EVENTID = st.EVENTID	  	    
					  JOIN @TRACEOUTPUT t ON t.PMSTATUS = st.PMSTATUS
					  
	  IF @CLIENT = 1
			--Fill client event trace
			--Join with Event table is need because these events can be deleted by grooming
			INSERT APM.PMCLIENTEVENTTRACE(CSEVENTID, PMTRACEID)
			   SELECT e.CSEVENTID, t.NEWTRACE 
				   FROM #STATUSTABLE AS st
					  JOIN APM.CSEVENT (NOLOCK) AS e ON e.CSEVENTID = st.EVENTID
					  JOIN @TRACEOUTPUT t ON t.PMSTATUS = st.PMSTATUS
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ServerEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ServerEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ServerEvent_sync                                                           */
/* USED IN: Synchronization server event.                                           */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[ServerEvent_sync]
   @OBJECTKEYXML      ntext
  ,@DATABASEID        int
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@INSERTED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT   int
      ,@ERROR_MESSAGE      nvarchar(max)      
    --allocate memory for xml package
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ServerEvent_sync', @EXECRESULT)
    END
    -----temporary table variable for the keeping xml package
    DECLARE @EVENT TABLE (
       grouphash            nvarchar(50) collate database_default
      ,rootnodename         nvarchar(255) collate database_default
      ,rootfunction         nvarchar(255) collate database_default
      ,component            nvarchar(255) collate database_default
      ,source               nvarchar(255) collate database_default   
      ,eventduration        decimal(35,0)   
      ,machinename          nvarchar(255) collate database_default   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50) collate database_default    
      ,aspect               nvarchar(50) collate database_default    
      ,username             nvarchar(255) collate database_default   
      ,exceptionclass       nvarchar(255) collate database_default   
      ,description          nvarchar(255) collate database_default   
      ,category             nvarchar(255) collate database_default   
      ,rowguid              nvarchar(15) collate database_default      
      ,seviewerdbid         int
      ,sevieweregid         int
      ,heavylight           int
      ,pmstatus             tinyint
    )
    
    ---- parse and insert xml package to the temporary table variabale
    INSERT @EVENT (
       grouphash
      ,rootnodename
      ,rootfunction 
      ,component
      ,source       
      ,eventduration 
      ,machinename   
      ,utceventdate   
      ,eventclasstype  
      ,aspect          
      ,username        
      ,exceptionclass  
      ,description   
      ,category        
      ,rowguid
      ,sevieweregid  
      ,heavylight    
      ,pmstatus 
    )
    SELECT
       grouphash
      ,rootnodename 
      ,rootfunction
      ,component
      ,source       
      ,eventduration 
      ,machinename   
      ,utceventdate   
      ,eventclasstype  
      ,aspect          
      ,username        
      ,exceptionclass  
      ,description   
      ,category        
      ,rowguid
      ,sevieweregid
      ,heavylight
      ,pmstatus
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       grouphash         nvarchar(50) 
      ,rootnodename      nvarchar(255)
      ,rootfunction      nvarchar(255)      
      ,component         nvarchar(255)      
      ,source            nvarchar(255)  
      ,eventduration     decimal(35,0)  
      ,machinename       nvarchar(255)  
      ,utceventdate      datetime   
      ,eventclasstype    nvarchar(50)   
      ,aspect            nvarchar(50)   
      ,username          nvarchar(255)  
      ,exceptionclass    nvarchar(255)  
      ,description       nvarchar(255)  
      ,category          nvarchar(255)  
      ,rowguid           nvarchar(15)
      ,sevieweregid      int -------- reference to the seviewer event group ---
      ,heavylight        int
      ,pmstatus         tinyint
) xml
    --free memory of xml package
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL    
    
   ----------sync event------------
    -------- update reference to the seviewer database -------
    UPDATE @EVENT SET seviewerdbid = @DATABASEID
   -------- sync Users table--------------- 
    INSERT Users (name)
        SELECT DISTINCT sync.username FROM @EVENT sync
          WHERE NOT EXISTS(SELECT u.name FROM APM.Users u WHERE sync.username = u.name) 
                AND sync.username IS NOT NULL AND sync.username &lt;&gt; '' 
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    ----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
    INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	  SELECT DISTINCT machinename FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = e.machinename)
	     	     
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
	   
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = e.source)	   
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
                
   -------------- sync event table ------------------
   
    -- temporary table for traces. It will contains event id of the new events.
    CREATE TABLE #STATUSTABLE(EVENTID int, PMSTATUS tinyint)
   
    INSERT EVENT (
        eventgroupid    
       ,sourceid      
       ,eventduration
       ,machineid        
       ,utceventdate      
       ,eventclasstype    
       ,rootnodename 
       ,aspect            
       ,exceptionclass    
       ,description     
       ,category          
       ,rowguid
       ,seviewerdbid
       ,sevieweregid
       ,heavylight   
       ,pmstatus        
    )
    OUTPUT INSERTED.EVENTID, INSERTED.PMSTATUS
    INTO #STATUSTABLE
    SELECT 
       g.eventgroupid   
      ,s.sourceid      
      ,sync.eventduration
      ,m.MACHINEID       
      ,sync.utceventdate      
      ,sync.eventclasstype    
      ,sync.rootnodename 
      ,sync.aspect            
      ,sync.exceptionclass    
      ,sync.description     
      ,sync.category          
      ,sync.rowguid
      ,sync.seviewerdbid
      ,sync.sevieweregid    
      ,sync.heavylight
      ,pmstatus  
   FROM
     @EVENT sync
     JOIN APM.source s (NOLOCK) ON s.source = sync.source
     JOIN APM.EventGroup g (NOLOCK) ON g.hashvalue = sync.grouphash
     JOIN APM.MACHINE m (NOLOCK) ON m.machine = sync.machinename
  WHERE NOT EXISTS(SELECT * FROM event e (NOLOCK) WHERE sync.rowguid = e.rowguid) 
  --should be the same order between RowGuid and primary key of the Event table  
  ORDER BY CAST(SUBSTRING(sync.rowguid, CHARINDEX('-', rowguid) + 1, LEN(rowguid)) AS INT)  
  
  SET @INSERTED_ROWCOUNT = @@ROWCOUNT 
  
  --Create event traces for server events
  EXEC APM.PMCREATEEVENTTRACES 0, NULL 	   
  
  -----------sync event with username------------------
  UPDATE e SET 
       e.userid = u.userid
    FROM 
        APM.event e 
      JOIN @EVENT sync ON sync.rowguid = e.rowguid 
      JOIN Users u (NOLOCK) ON sync.username = u.Name   
  INSERT EVENTDETAIL
  (
        EventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.EventId
    ,'COMPONENT'
    ,sync.component
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.Event AS e (NOLOCK) ON sync.rowguid = e.rowguid
  INSERT EVENTDETAIL
  (
        EventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.EventId
    ,'ROOTFUNCTION'
    ,sync.rootfunction
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.Event AS e (NOLOCK) ON sync.rowguid = e.rowguid
        
  SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENT
  SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PerformanceNode_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PerformanceNode_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[PerformanceNode_sync]
  @OBJECTKEYXML      ntext,
  @TRACELEVEL        int, 
  @ROWNOTAFFECTED    int output               
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE       nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE                                    nvarchar(max)
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
                  SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
                  RAISERROR(@ERROR_MESSAGE, 16, 1, 'PerformanceNode_sync', @EXECRESULT)
    END
    DECLARE @PERFORMANCENODE TABLE (
       eventrowguid                 nvarchar(15) collate database_default
                  ,description     nvarchar(255) collate database_default     
                  ,functionname      nvarchar(255) collate database_default              
      ,duration          decimal(35,0)
      ,hashcode                                     nvarchar(255) collate database_default
      ,entryid                                          int
                  ,rowguid                                            nvarchar(15) collate database_default
      ,client                                              int
      ,isheaviestnode          bit
    )
                
    
    INSERT @PERFORMANCENODE (
       eventrowguid                            
      ,description    
      ,functionname     
      ,duration      
      ,hashcode                                     
      ,entryid
                  ,rowguid
                  ,client
                  ,isheaviestnode        
    )
    SELECT
       xml.eventrowguid                    
      ,xml.description    
      ,xml.functionname     
      ,xml.duration      
      ,xml.hashcode
                  ,xml.entryid                                                     
                  ,xml.rowguid
      ,xml.client 
      ,xml.isheaviestnode       
    FROM 
                  OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                                eventrowguid        nvarchar(15) 
                   ,description                                     nvarchar(255)   
                   ,functionname         nvarchar(255)          
       ,duration             decimal(35,0)
       ,hashcode                                    nvarchar(255)
                   ,entryid                                                  int
                   ,rowguid                                                nvarchar(15)
       ,client                                                  int
       ,isheaviestnode                         bit
      ) xml
    
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
   ----------sync performanceNode------------
/* updating server or client performance */
                
    IF EXISTS(SELECT * FROM @PERFORMANCENODE WHERE client = 0) 
    BEGIN
                                /* server performance */
                                INSERT APM.PerformanceNode (
                                                eventid                
                                   ,description      
                                   ,functionname                    
                                   ,duration
                                   ,hashcode
                                   ,entryid                                                             
                                   ,rowguid
                                   ,isheaviestnode        
                                )
                                SELECT 
                                   e.eventid         
                                  ,sync.description      
                                  ,sync.functionname
                                  ,sync.duration                 
                                  ,sync.hashcode               
                                  ,sync.entryid    
                                  ,sync.rowguid
                                  ,sync.isheaviestnode
                   FROM
                                 @PERFORMANCENODE sync
                                 JOIN APM.Event e (NOLOCK) ON e.rowguid = sync.eventrowguid      
                   WHERE 
          sync.client = 0 AND NOT EXISTS(SELECT * FROM APM.performanceNode (NOLOCK) WHERE rowguid = sync.rowguid)
                   SET @INSERTED_ROWCOUNT = @@ROWCOUNT
                   IF @TRACELEVEL = 4 
                   BEGIN
                                 SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
                                 RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'PerformanceNode') WITH NOWAIT;
                   END
                   SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @PERFORMANCENODE WHERE client = 0
                   SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
       SELECT @INSERTED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @PERFORMANCENODE WHERE client = 1)
    BEGIN
                                /* client performance */
                                INSERT APM.csheaviestresource (
                                    cseventid        
                                   ,name      
                                   ,duration
           ,rowguid        
                                   ,isheaviestnode        
                                )
                                SELECT 
                                   e.cseventid     
                                  ,sync.description      
                                  ,sync.duration
          ,sync.rowguid          
                                  ,sync.isheaviestnode
                   FROM
                                 @PERFORMANCENODE sync
                                 JOIN APM.CSEvent e (NOLOCK) ON e.rowguid = sync.eventrowguid 
                   WHERE 
          sync.client = 1 AND NOT EXISTS(SELECT * FROM APM.csheaviestresource (NOLOCK) WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
                   IF @TRACELEVEL = 4 
                   BEGIN
                                 SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
                                 RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csheaviestresource') WITH NOWAIT;
                   END
                   SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @PERFORMANCENODE WHERE client = 1
                   SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
    END 
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ExceptionNode_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ExceptionNode_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.ExceptionNode_sync
   @OBJECTKEYXML      ntext
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE           nvarchar(max)
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'exceptionnode_sync', @EXECRESULT)
    END
    DECLARE @EXCEPTIONNODE TABLE (
       eventrowguid      nvarchar(15) collate database_default
      ,eventAction       nvarchar(255) collate database_default   
      ,description       nvarchar(255) collate database_default  
      ,exceptionmessage  nvarchar(255) collate database_default
      ,exceptionclass    nvarchar(255) collate database_default
      ,functionname      nvarchar(255) collate database_default  
      ,modulename        nvarchar(255) collate database_default
      ,linenumber        bigint
      ,entryid           int
      ,hashcode          nvarchar(255) collate database_default
      ,rowguid           nvarchar(15) collate database_default
      ,client            int 
    )
    
    SET @ROWNOTAFFECTED = 0
    INSERT @EXCEPTIONNODE (
       eventrowguid 
       ,eventAction      
      ,description    
      ,exceptionmessage     
      ,exceptionclass      
      ,functionname          
      ,modulename
      ,linenumber
      ,entryid
      ,hashcode
      ,rowguid
      ,client        
    )
    SELECT
       eventrowguid 
      ,eventaction   
      ,description    
      ,exceptionmessage     
      ,exceptionclass      
      ,functionname          
      ,modulename
      ,linenumber
      ,entryid
      ,hashcode
      ,rowguid
      ,client        
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       eventrowguid      nvarchar(15) 
      ,eventaction       nvarchar(255)
      ,description       nvarchar(255)  
      ,exceptionmessage  nvarchar(255)
      ,exceptionclass    nvarchar(255)
      ,functionname      nvarchar(255)  
      ,modulename        nvarchar(255)
      ,linenumber        bigint
      ,entryid           int
      ,hashcode          nvarchar(255)
      ,rowguid           nvarchar(15)
      ,client            int
    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL    
   ----------sync exceptionNode------------
    IF EXISTS(SELECT * FROM @EXCEPTIONNODE WHERE client = 0) 
    BEGIN
      /* server exception */
        INSERT APM.ExceptionNode (
            eventid     
           ,exceptionmessage      
           ,exceptionclass       
           ,functionname
           ,modulename
           ,linenumber               
           ,description
           ,hashcode    
           ,entryid
           ,rowguid         
        )
        SELECT 
            e.eventid   
           ,sync.exceptionmessage      
           ,sync.exceptionclass      
           ,sync.functionname
           ,sync.modulename
           ,sync.linenumber              
           ,sync.description
           ,sync.hashcode   
           ,sync.entryid
           ,sync.rowguid            
       FROM
         @EXCEPTIONNODE sync
         JOIN APM.Event e ON e.rowguid = sync.eventrowguid  
       WHERE sync.client = 0 AND NOT EXISTS(SELECT * FROM APM.ExceptionNode WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
       IF @TRACELEVEL = 4 
       BEGIN
         SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
         RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'ExceptionNode') WITH NOWAIT;
       END
       SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EXCEPTIONNODE where client = 0
       SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
       SET @INSERTED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @EXCEPTIONNODE WHERE client = 1) 
    BEGIN
      /* client exception */
        INSERT APM.CSEXEVENT (
            cseventid   
           ,action      
           ,exmessage        
           ,extype
           ,exfunction
           ,rowguid         
        )
        SELECT 
            e.cseventid     
           ,sync.eventAction      
           ,sync.exceptionmessage
           ,sync.exceptionclass      
           ,sync.functionname
           ,sync.rowguid            
       FROM
         @EXCEPTIONNODE sync
         JOIN APM.CSEvent e ON e.rowguid = sync.eventrowguid    
       WHERE sync.client = 1 AND NOT EXISTS(SELECT * FROM APM.ExceptionNode WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
       IF @TRACELEVEL = 4 
       BEGIN
         SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
         RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEXEVENT') WITH NOWAIT;
       END
       SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EXCEPTIONNODE WHERE client = 1
       SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
     
    END 
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PerfHourly_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PerfHourly_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[PerfHourly_sync]
   @OBJECTKEYXML      ntext,
   @DATABASEID        int,
   @TRACELEVEL        int, 
   @ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@UPDATED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT  int
      ,@CURSOR_OPENED     bit
    SELECT @CHANGED_ROWCOUNT = 0, @UPDATED_ROWCOUNT = 0, @INSERTED_ROWCOUNT = 0, @CHANGED_ROWCOUNT = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PerfHourly_sync', @EXECRESULT)
    END
    DECLARE @PERFHOURLY TABLE (
       type                   nvarchar(255) collate database_default
      ,machinename              nvarchar(255) collate database_default
      ,source                   nvarchar(255) collate database_default
      ,pcprocessHash            nvarchar(50) collate database_default    
      ,is_state                 int
      ,utcdate                  datetime
      ,averagevalue             float   
      ,minvalue                 float
      ,maxvalue                 float
      ,samplecount              float
      ,sumvalue                 float
      ,packagecounter           int
      ,hashvalue                nvarchar(50) collate database_default 
      ,inserted                 bit
    )   
    
    INSERT @PERFHOURLY (
       type                   
      ,machinename              
      ,source                   
      ,pcprocessHash            
      ,is_state                 
      ,utcdate                  
      ,averagevalue             
      ,minvalue                 
      ,maxvalue                 
      ,samplecount              
      ,sumvalue                 
      ,packagecounter           
      ,hashvalue                
    )
    SELECT
       type                   
      ,machinename              
      ,source                   
      ,pcprocessHash            
      ,is_state                 
      ,utcdate                  
      ,averagevalue             
      ,minvalue                 
      ,maxvalue                 
      ,samplecount              
      ,sumvalue                 
      ,packagecounter           
      ,hashvalue                
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       type                   nvarchar(255)
      ,machinename              nvarchar(255)
      ,source                   nvarchar(255)
      ,pcprocesshash            nvarchar(50)    
      ,is_state                 int
      ,utcdate                  datetime
      ,averagevalue             float   
      ,minvalue                 float
      ,maxvalue                 float
      ,samplecount              float
      ,sumvalue                 float
      ,packagecounter           int
      ,hashvalue                nvarchar(50) 
      ) xml
    SET @CHANGED_ROWCOUNT = @@ROWCOUNT
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
	------- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
	INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
		SELECT DISTINCT machinename FROM @PERFHOURLY p
		   WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = p.machinename) AND p.machinename is NOT null
		   
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
		   
	----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
	INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
		SELECT DISTINCT source FROM @PERFHOURLY p
		   WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = p.source) AND p.source is NOT null
		   
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
    UPDATE sync
        SET sync.inserted = 1
      FROM @PERFHOURLY sync
         WHERE NOT EXISTS(SELECT * FROM APM.PerfHourly p WHERE p.hashvalue = sync.hashvalue)        
    IF EXISTS(SELECT * FROM @PERFHOURLY sync WHERE sync.inserted = 1) 
    BEGIN
      INSERT perfHourly( 
               pctypeid
              ,machineid    
              ,sourceid
              ,pcprocessId  
              ,is_state
              ,utcdate
              ,averagevalue
              ,minvalue
              ,maxvalue
              ,samplecount
              ,sumvalue
              ,packagecounter
              ,hashvalue
           )
           SELECT 
               t.pctypeid                   
              ,m.machineid              
              ,s.sourceId                   
              ,pr.pcprocessId           
              ,sync.is_state                    
              ,sync.utcdate                 
              ,sync.averagevalue                
              ,sync.minvalue                    
              ,sync.maxvalue                    
              ,sync.samplecount             
              ,sync.sumvalue                    
              ,sync.packagecounter          
              ,sync.hashvalue
         FROM
           @PERFHOURLY sync 
           JOIN APM.Machine m ON m.machine = sync.machinename
           JOIN APM.PCType t ON t.type = sync.type
           LEFT JOIN APM.Source s ON s.source = sync.source
           LEFT JOIN APM.PCProcess Pr ON PR.hashvalue = sync.pcprocessHash
         WHERE                  
           sync.inserted = 1    
         SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    END
    IF EXISTS(SELECT * FROM @PERFHOURLY sync WHERE sync.inserted is null) 
    BEGIN
      UPDATE p
         SET     
           p.minvalue = CASE WHEN sync.minvalue &lt; p.minvalue THEN sync.minvalue ELSE p.minvalue END 
          ,p.maxvalue = CASE WHEN sync.maxvalue &gt; p.maxvalue THEN sync.maxvalue ELSE p.maxvalue END 
          ,p.samplecount = p.samplecount + sync.samplecount
          ,p.sumvalue = p.sumvalue + sync.sumvalue
          ,p.packagecounter = p.packagecounter + sync.packagecounter
          ,p.averagevalue = p.sumvalue / p.samplecount
         FROM 
           APM.PerfHourly p 
            JOIN @PERFHOURLY sync ON sync.hashvalue = p.hashvalue   
            JOIN APM.Machine m ON m.machine = sync.machinename
            JOIN APM.PCType t ON t.type = sync.type
            LEFT JOIN APM.Source s ON s.source = sync.source
            LEFT JOIN APM.PCProcess Pr ON PR.hashvalue = sync.pcprocessHash
         WHERE sync.inserted IS NULL
            
         SET @UPDATED_ROWCOUNT =  @@ROWCOUNT
    END
    SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)  
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckDatabaseId'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckDatabaseId AS RETURN 1')
  END
GO
/* Procedure check database unique identificator and return error codes:  */
/* 0 : Success. Database is synhronized with SEViewer database */
/* 1 : Error. Database is not synhronized with SEViewer database */
/* 2 : Error. Database is partialy synhronized with SEViewer database */
/* 3 : Error. Database is new */
ALTER PROCEDURE APM.CheckDatabaseId
    @DBGUID uniqueidentifier
AS
BEGIN
    DECLARE @ERROR  int
  
    SET @ERROR = 0
    IF NOT EXISTS(SELECT * FROM APM.SEVIewerDB SV (NOLOCK) WHERE SV.DatabaseId = @DBGUID)
    BEGIN
      IF NOT EXISTS(SELECT * FROM APM.TASKS (NOLOCK))
      BEGIN
        SET @ERROR = 3
        GOTO QUIT
      END
      IF EXISTS(SELECT * FROM APM.TASKS t (NOLOCK) WHERE t.SEVIewerDBId IS NULL) 
      BEGIN 
        SET @ERROR = 1       
        GOTO QUIT
      END
    END 
    IF EXISTS(SELECT * FROM APM.TASKS t (NOLOCK) WHERE t.SEVIewerDBId IS NULL) 
    BEGIN
      SET @ERROR = 2       
      GOTO QUIT
    END
QUIT:
    RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckAndCreateDatabaseId'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckAndCreateDatabaseId AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* Procedure check database unique identificator and find or create internal database identifier  */
/* Procedure return error code:  */
/* 0 : Success. Database is synhronized with SEViewer database */
/* 1 : Error. Database is not synhronized with SEViewer database */
/* 2 : Error. Database is partialy synhronized with SEViewer database */
/**************************************************************************************************/
/* Parameters: */
/* @DBGUID unique identificator */
/* @SEVIEWERURL unique identificator */
/* @DBGUID unique identificator */
ALTER PROCEDURE APM.CheckAndCreateDatabaseId 
        @DBGUID uniqueidentifier
       ,@SEVIEWERURL NVARCHAR(255)
       ,@TRACELEVEL INT
       ,@DBID int OUTPUT
AS
BEGIN
  DECLARE @ERROR  int
  EXECUTE @ERROR = APM.CheckDatabaseId @DBGUID
  
  SELECT @DBID = SEVIewerDBId FROM APM.SEVIewerDB SV (NOLOCK) WHERE SV.DatabaseId = @DBGUID 
  IF @@ROWCOUNT = 0
  BEGIN
    INSERT APM.SEVIEWERDB(DatabaseId, Address) Values(@DBGUID, @SEVIEWERURL)
    SET @DBID = SCOPE_IDENTITY()
  END
  RETURN @ERROR
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Config_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Config_sync AS RETURN 1')
  END
GO
alter PROCEDURE APM.Config_sync
  @OBJECTKEYXML       ntext
 ,@TRACELEVEL         INT
 ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@UPDATED_ROWCOUNT  int
      ,@CHANGEDROWCOUNT    int 
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Config_sync', @EXECRESULT)
    END
    
    DECLARE @CONFIG TABLE (
       configname           nvarchar(50)  NOT NULL
      ,configvalue          nvarchar(max) NULL
      ,databaseid           int
    )
    
    INSERT @CONFIG (
       configname
      ,configvalue
      ,databaseid
    )
    SELECT
       configname
      ,configvalue
      ,databaseid
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       configname           nvarchar(50)  
      ,configvalue          nvarchar(max) 
      ,databaseid           int) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    UPDATE sv SET 
        Address = sync.configvalue
    FROM
      APM.SEViewerDb sv
      JOIN @CONFIG sync ON sv.seviewerdbid = sync.databaseid AND sync.configname = 'SEVIEWERADDRESS'        
    SET @UPDATED_ROWCOUNT = @@ROWCOUNT   
    SELECT @CHANGEDROWCOUNT = COUNT(*) FROM @CONFIG WHERE configname = 'SEVIEWERADDRESS'
    SET @ROWNOTAFFECTED = @CHANGEDROWCOUNT - @UPDATED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PageEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PageEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PageEvent_sync                                                             */
/* USED IN: Intercept reporting Service. Fill content information for the csm       */
/*          performance events. Internal stored procedure                           */
/* INPUT PARAMETERS:                                                                */
/*      @XMLDOCHANDLE - memory handle (from sp_xml_preparedocument)                 */
/*      @TRACELEVEL    - trace flag (4 - diagnostic message will be generated       */
/************************************************************************************/
ALTER PROCEDURE APM.PageEvent_sync
   @XMLDOCHANDLE      int
  ,@TRACELEVEL        int
AS
BEGIN
    SET NOCOUNT ON
    DECLARE 
       @INSERTED_ROWCOUNT  int
      ,@MESSAGE            nvarchar(max)
    DECLARE @PAGEEVENT TABLE (
       event_rowguid        nvarchar(15) collate database_default    
      ,networktime          decimal (35,0) 
      ,servertime           decimal (35,0)  
      ,domtime              decimal (35,0)
      ,peripheraltime       decimal (35,0)
      ,onloadtime           decimal (35,0)
      ,totaltime            decimal (35,0)
      ,totalsize            bigint
      ,latency              bigint
      ,utcdate              datetime
      ,SourceName           nvarchar (255) collate database_default     
    )
    INSERT @PAGEEVENT (
       event_rowguid        
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,SourceName                       
    )
    SELECT
       event_rowguid              
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,SourceName                       
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/pageevent') WITH (
       event_rowguid        nvarchar(15) '../@rowguid'      
      ,networktime          decimal (35,0) 
      ,servertime           decimal (35,0)  
      ,domtime              decimal (35,0)
      ,peripheraltime       decimal (35,0)
      ,onloadtime           decimal (35,0)
      ,totaltime            decimal (35,0)
      ,totalsize            bigint
      ,latency              bigint 
      ,utcdate          datetime '../@utceventdate'     
      ,sourceName           nvarchar (255) '../@source'
      ,client               int '../@client'
    ) xml
    WHERE xml.client = 2
    -- Fill CSPageEvent table--------
    INSERT APM.CSPageEvent (
       cseventid
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,sourceid
    )
    SELECT 
       e.cseventid            
      ,sync.networktime         
      ,sync.servertime          
      ,sync.domtime             
      ,sync.peripheraltime      
      ,sync.onloadtime          
      ,sync.totaltime           
      ,sync.totalsize
      ,sync.latency
      ,sync.utcdate
      ,s.SourceId           
    FROM
        @PAGEEVENT sync
        JOIN APM.csevent e ON sync.event_rowguid = e.rowguid
        JOIN APM.source s ON s.source = sync.SourceName
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSPageEvent') WITH NOWAIT;
    END
    -- Fill Periphial and Periphial Detail table--------
    DECLARE @PERIPHIAL TABLE (
       event_rowguid        nvarchar(15) collate database_default    
      ,type                 nvarchar (50) collate database_default
      ,totalsize            bigint
      ,totaltime            decimal (35,0)
      ,htmlSize             bigint
    )
    INSERT INTO @PERIPHIAL 
    (
       event_rowguid
      ,type     
      ,totalsize    
      ,totaltime    
      ,htmlSize 
    )
    SELECT
       event_rowguid              
      ,type 
      ,totalsize
      ,totaltime
      ,htmlSize 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/peripheral/row', 2) WITH (
       event_rowguid        nvarchar(15)        '../../@rowguid'     
      ,type                 nvarchar (50)   '@type' 
      ,totalsize            bigint          '@totalsize'
      ,totaltime            decimal (35,0)  '@totaltime'
      ,htmlSize             bigint              '../@htmlsize'
      ,client               int             '../../@client'     
    ) xml
    WHERE xml.client = 2 
    DECLARE @PERIPHIALDETAIL TABLE (
       event_rowguid        nvarchar(15)  collate database_default    
      ,type                 nvarchar (50) collate database_default 
      ,domain               nvarchar (255) collate database_default 
      ,path                 nvarchar (255) collate database_default 
      ,size                 bigint
      ,detail_totaltime     decimal (35,0)
    )
    INSERT INTO @PERIPHIALDETAIL 
    (
       event_rowguid
      ,type     
      ,domain       
      ,path     
      ,size     
      ,detail_totaltime
    )
    SELECT
       event_rowguid              
      ,type 
      ,domain   
      ,path 
      ,size 
      ,detail_totaltime
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/peripheral/row/row', 2) WITH (
       event_rowguid        nvarchar(15)        '../../../@rowguid'     
      ,type                 nvarchar (50)   '../@type' 
      ,domain               nvarchar (255)  '@domain' 
      ,path                 nvarchar (255)  '@path'
      ,size                 bigint              '@size'
      ,detail_totaltime     decimal (35,0)  '@totaltime'
      ,client               int             '../../../@client'  
    ) xml
    WHERE xml.client = 2 AND xml.size &gt; 0
    -- Fill summary content information 
    INSERT APM.csperipheral 
    (
         cseventid
        ,type
        ,totalsize
        ,totaltime
    )
    SELECT 
       e.cseventid
      ,sync.type
      ,sync.totalsize
      ,sync.totaltime
    FROM
      @PERIPHIAL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid 
    WHERE sync.totalsize &gt; 0 
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheral') WITH NOWAIT;
    END
    -- Fill html size
    INSERT APM.csperipheral 
    (
         cseventid
        ,type
        ,totalsize
    )
    SELECT DISTINCT
        e.cseventid
       ,N'html'
       ,sync.htmlSize
    FROM
      @PERIPHIAL sync
    JOIN
      csevent e ON sync.event_rowguid = e.rowguid
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheral {html}') WITH NOWAIT;
    END
    -- Fill detail content information
    INSERT APM.csperipheraldetail 
    (
        csperipheralid
       ,domain
       ,path
       ,size
       ,totaltime
    )
    SELECT 
       p.csperipheralid
      ,sync.domain
      ,sync.path
      ,sync.size
      ,sync.detail_totaltime
    FROM
      @PERIPHIALDETAIL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid
    JOIN
      APM.csperipheral p ON e.cseventid = p.cseventid AND sync.type = p.type
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheraldetail') WITH NOWAIT;
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.AjaxCall_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.AjaxCall_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.AjaxCall_sync
   @XMLDOCHANDLE      int
  ,@PATH              nvarchar(100)
  ,@TRACELEVEL        int
AS
BEGIN
   SET NOCOUNT ON
   DECLARE
     @MESSAGE         nvarchar(max)
    ,@RECORDCOUNT     int
--------- Fill Ajax call --------
    DECLARE @AJAXCALL TABLE (
       ajax_call_id         int identity(1,1)       
      ,event_rowguid        nvarchar(15) collate database_default 
      ,uri                  nvarchar (255) collate database_default 
      ,networktime          decimal (35,0)
      ,servertime           decimal (35,0)
      ,totaltime            decimal (35,0) 
      ,requestsize          bigint          
      ,responsesize         bigint
      ,responsetime         decimal (35,0)
      ,handlertime          decimal (35,0)  
      ,latency              bigint
      ,utcdate              datetime
      ,SourceName           nvarchar (255) collate database_default                      
    )
    INSERT INTO @AJAXCALL 
    (
       event_rowguid        
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime
      ,handlertime          
      ,latency
      ,utcdate
      ,SourceName                   
    )
    SELECT
       event_rowguid        
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime
      ,handlertime
      ,latency
      ,utcdate
      ,SourceName               
     FROM OPENXML(@XMLDOCHANDLE, @PATH) WITH (
       event_rowguid        nvarchar(15)            '../../@rowguid'    
      ,uri                  nvarchar (255) 
      ,networktime          decimal (35,0)
      ,servertime           decimal (35,0)
      ,totaltime            decimal (35,0) 
      ,requestsize          bigint 
      ,responsesize         bigint                  
      ,responsetime         decimal (35,0)      
      ,handlertime          decimal (35,0)      '../@handlertime' 
      ,latency              bigint
      ,utcdate          datetime '../../@utceventdate'     
      ,sourceName           nvarchar (255) '../../@source'                      
    ) xml
    INSERT APM.csajax 
    (
       cseventid    
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime         
      ,synchronous
      ,latency
      ,utcdate
      ,sourceid
      ,IsHeaviestNode                   
    )
    SELECT 
       e.cseventid
      ,sync.uri                 
      ,sync.networktime         
      ,sync.servertime          
      ,sync.totaltime           
      ,sync.requestsize         
      ,sync.responsesize            
      ,sync.responsetime
      ,CASE WHEN handlertime IS NULL THEN 1 ELSE 0 END  
      ,sync.latency
      ,sync.utcdate
      ,s.SourceId
      ,CASE 
            WHEN sync.ajax_call_id = (SELECT TOP(1) ajax_call_id FROM @AJAXCALL AS a WHERE sync.event_rowguid = a.event_rowguid ORDER BY TotalTime DESC, ajax_call_id)
            THEN 1
            ELSE 0
        END
    FROM
      @AJAXCALL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid
      JOIN APM.source s ON s.source = sync.SourceName
    SELECT @RECORDCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, 'csajax') WITH NOWAIT;
    END
    ---Find Async ajax call-----------
    IF EXISTS(SELECT * FROM  @AJAXCALL WHERE handlertime IS NOT NULL)
    BEGIN
      INSERT APM.csasyncajax
      (
         cseventid
        ,totaltime
        ,handlertime
      ) 
      SELECT 
         e.cseventid
        ,sync.totaltime 
        ,sync.handlertime
      FROM
        @AJAXCALL sync
      JOIN
        APM.csevent e ON sync.event_rowguid = e.rowguid
      WHERE 
        sync.handlertime IS NOT NULL
      SELECT @RECORDCOUNT = @@ROWCOUNT
      IF @TRACELEVEL = 4 
      BEGIN
        SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
        RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, 'csasyncajax') WITH NOWAIT;
      END
    END 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.JScriptEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.JScriptEvent_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.JScriptEvent_sync
   @XMLDOCHANDLE    int
  ,@TRACELEVEL      int
AS
BEGIN
  SET NOCOUNT ON
    DECLARE 
       @INSERTED_ROWCOUNT  int
      ,@MESSAGE            nvarchar(max)
    DECLARE @SCRIPTEVENT TABLE (
       event_rowguid        nvarchar(15)  collate database_default    
      ,action               nvarchar(255)  collate database_default
      ,totaltime            nvarchar(255)  collate database_default
      ,utcdate              datetime
      ,SourceName           nvarchar (255)  collate database_default        
    )
    INSERT @SCRIPTEVENT (
       event_rowguid        
      ,action           
      ,totaltime
      ,utcdate
      ,SourceName                   
    )
    SELECT
       event_rowguid              
      ,action           
      ,totaltime
      ,utcdate
      ,SourceName                   
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/jscript') WITH (
       event_rowguid        nvarchar(15) '../@rowguid'      
      ,action               nvarchar(255)
      ,totaltime            decimal (35,0)
      ,utcdate              datetime '../@utceventdate'     
      ,sourceName           nvarchar (255) '../@source'   
    ) xml
    -- Fill CSJSCRIPTEVENT table--------
    INSERT APM.csjscriptevent (
       cseventid
      ,action                   
      ,totaltime
      ,utcdate
      ,sourceid         
    )
    SELECT 
       e.cseventid            
      ,sync.action          
      ,sync.totaltime
      ,sync.utcdate
      ,s.SourceId                   
    FROM
        @SCRIPTEVENT sync
        JOIN APM.csevent e ON sync.event_rowguid = e.rowguid
        JOIN APM.source s ON s.source = sync.SourceName 
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csjscriptevent') WITH NOWAIT;
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ClientEvent_sync                                                           */
/* USED IN: Synchronization client event.                                           */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[ClientEvent_sync]
   @OBJECTKEYXML      ntext
  ,@DATABASEID        int
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE
     @MESSAGE         nvarchar(max)
    ,@RECORDCOUNT     int
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@INSERTED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT   int
      ,@ERROR_MESSAGE      nvarchar(max)      
    --allocate memory for xml package
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ClientEvent_sync', @EXECRESULT)
    END
 -----temporary table variable for the keeping xml package
    DECLARE @EVENT TABLE (
       grouphash            nvarchar(50) collate database_default
      ,source               nvarchar(255) collate database_default   
      ,machinename          nvarchar(255) collate database_default   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50) collate database_default
      ,eventclass           nvarchar(50) collate database_default    
      ,description          nvarchar(255) collate database_default
      ,ip                   nvarchar(50) collate database_default
      ,subnetc              nvarchar(50) collate database_default
      ,pageuri              nvarchar(255) collate database_default
      ,browser              nvarchar(255) collate database_default
      ,userName             nvarchar(255) collate database_default   
      ,rowguid              nvarchar(15) collate database_default      
      ,seviewerdbid         int
      ,sevieweregid         int
      ,client               int 
      ,pmstatus             tinyint 
      ,category            nvarchar(50) collate database_default 
      ,rootnodename         nvarchar(255) collate database_default             
      ,rootfunction         nvarchar(255) collate database_default   
    )
    
 ---- parse and insert xml package to the temporary table variabale
    INSERT @EVENT (
       grouphash
      ,source   
      ,machinename
      ,utceventdate
      ,eventclasstype
      ,eventclass
      ,description  
      ,ip           
      ,subnetc      
      ,pageuri
      ,browser
      ,userName         
      ,rowguid
      ,sevieweregid
      ,client
      ,pmstatus     
      ,category
      ,rootnodename
      ,rootfunction
    )
    SELECT
       grouphash
      ,source   
      ,machinename
      ,utceventdate
      ,eventclasstype
      ,eventclass
      ,description  
      ,ip           
      ,subnetc      
      ,pageuri  
      ,browser
      ,username 
      ,rowguid
      ,sevieweregid         
      ,client   
      ,pmstatus
      ,category
      ,rootnodename
      ,rootfunction
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row') WITH (
       grouphash            nvarchar(50) 
      ,source               nvarchar(255)   
      ,machinename          nvarchar(255)   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50)    
      ,eventclass           nvarchar(50)    
      ,description          nvarchar(255)
      ,ip                   nvarchar(50)
      ,subnetc              nvarchar(50)
      ,pageuri              nvarchar(255)
      ,browser              nvarchar(255)
      ,username             nvarchar(255)   
      ,rowguid              nvarchar(15)  
      ,sevieweregid         int
      ,client               int
      ,pmstatus             tinyint    
      ,category             nvarchar(50) 
      ,rootnodename         nvarchar(255)             
      ,rootfunction         nvarchar(255)
    ) xml
    
    SELECT @RECORDCOUNT = @@ROWCOUNT
    --- Trace about package size
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, '@EVENT') WITH NOWAIT;
    END
    UPDATE @EVENT SET seviewerdbid = @DATABASEID
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
  ----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
    INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	  SELECT DISTINCT machinename FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = e.machinename)
	     
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
	     
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
	   
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @EVENT e 
	     WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = e.source)
    
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
   -------- sync Users table--------------- 
    INSERT Users (name)
        SELECT DISTINCT sync.userName FROM @EVENT sync
          WHERE NOT EXISTS(SELECT u.name FROM APM.Users u WHERE sync.userName = u.name)
                AND sync.userName IS NOT NULL AND sync.userName &lt;&gt; '' 
   -- Fill Ip table--------
   INSERT APM.ip (ip, subnetc) 
    SELECT DISTINCT 
        sync.ip
       ,sync.subnetc
    FROM 
        @EVENT sync 
    WHERE 
        sync.ip IS NOT NULL AND sync.ip &lt;&gt; '' AND NOT EXISTS(SELECT * FROM APM.ip ip WHERE ip.ip = sync.ip)
        
     -- temporary table for traces. It will contains event id of the new events.    
    CREATE TABLE #STATUSTABLE(EVENTID int, PMSTATUS tinyint)
   -- Fill CSEvent table--------
    INSERT APM.CSEVENT (
       cseventgroupid
      ,sourceid 
      ,machineid
      ,utcdate
      ,classtype
      ,eventclass   
      ,description  
      ,ipid         
      ,pageuri
      ,browser      
      ,rowguid
      ,seviewerdbid
      ,sevieweregid
      ,pmstatus 
    )
    OUTPUT INSERTED.csEventId, INSERTED.pmstatus 
    INTO #STATUSTABLE
    SELECT 
       g.cseventgroupid     
      ,s.sourceid      
      ,m.MACHINEID       
      ,sync.utceventdate      
      ,sync.eventclasstype 
      ,sync.eventclass   
      ,sync.description
      ,ip.ipid       
      ,sync.pageuri 
      ,sync.browser 
      ,sync.rowguid
      ,sync.seviewerdbid
      ,sync.sevieweregid    -------- reference to the seviewer event group ---       
      ,sync.pmstatus
   FROM
     @EVENT sync
     JOIN APM.source s ON s.source = sync.source
     JOIN APM.CSEventGroup g ON g.hashvalue = sync.grouphash
     JOIN APM.MACHINE m ON m.machine = sync.machinename
     LEFT JOIN APM.ip ip ON sync.ip = ip.ip
  WHERE NOT EXISTS(SELECT * FROM APM.csevent e WHERE sync.rowguid = e.rowguid) 
  SET @INSERTED_ROWCOUNT = @@ROWCOUNT  
 
  --Create event traces for client events
  EXEC APM.PMCREATEEVENTTRACES 1, NULL 
  INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'CATEGORY'
    ,sync.category
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid
     
  INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'ROOTNODENAME'
    ,sync.rootnodename
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid  
 
   INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'ROOTFUNCTION'
    ,sync.rootfunction
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid
     
  --------- trace about number of inserted records into csevent table -----------
  IF @TRACELEVEL = 4 
  BEGIN
    SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
    RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEvent') WITH NOWAIT;
  END
  SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENT
  SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
  -----------sync csevent with username------------------
  UPDATE e SET 
       e.userid = u.userid
    FROM 
        APM.csevent e 
      JOIN @EVENT sync ON sync.rowguid = e.rowguid 
      JOIN APM.Users u ON sync.userName = u.Name   
  IF EXISTS(SELECT * FROM @EVENT WHERE client = 2) 
  BEGIN
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50025
      RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
    END
    ----exists pageevents--------    
    EXECUTE APM.PageEvent_sync @XMLDOCHANDLE, @TRACELEVEL
  END
  ------ Fill ajax calls--------------
  EXEC APM.AjaxCall_sync @XMLDOCHANDLE, N'rows/row/ajaxcalls/row', @TRACELEVEL
    
  --------Check Ajax events and script events
  IF EXISTS(SELECT * FROM @EVENT WHERE client = 1) 
  BEGIN
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50026
      RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
    END
    ----Find and sync script events --------
    EXEC APM.AjaxCall_sync @XMLDOCHANDLE, N'rows/row/jscript/row', @TRACELEVEL
    EXECUTE APM.JScriptEvent_sync @XMLDOCHANDLE, @TRACELEVEL
  END
 -- Update  CSEvent table with totaltime, total size and latency values
   UPDATE e SET 
       e.TotalTime = COALESCE(p.TotalTime, COALESCE(js.TotalTime, a.TotalTime)),
       e.TotalSize = COALESCE(P.TotalSize, 0) + COALESCE(a.TotalSize, 0),
       e.Latency = COALESCE(p.Latency, a.Latency)
    FROM 
        APM.csevent e 
        JOIN @EVENT sync ON sync.rowguid = e.rowguid
        LEFT OUTER JOIN APM.CSPAGEEVENT AS p ON p.CSEventId = e.CSEventId
        LEFT OUTER JOIN APM.CSJSCRIPTEVENT AS js ON js.CSEventId = e.CSEventId
        OUTER APPLY
        (
            SELECT
                SUM(a.TotalTime) AS TotalTime,
                SUM(a.ResponseSize + a.REQUESTSIZE) AS TotalSize,
                AVG(a.Latency) AS Latency
            FROM
                APM.CSAJAX AS a 
            WHERE
                A.CSEventId = e.CSEventId
        ) AS a
 --free memory of xml package
  EXEC sp_xml_removedocument @XMLDOCHANDLE
    
  SET @XMLDOCHANDLE = NULL  
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckConfiguration'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckConfiguration AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[CheckConfiguration]
	@VERSION		nvarchar(15)
   ,@SCHEMAVERSION	nvarchar(15)
   ,@TRACELEVEL		INT
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE 
	@ERROR INT
  SET @ERROR = 0
  IF NOT EXISTS(SELECT * FROM APM.Config WHERE ConfigName = N'DATABASE_VERSION' 
					AND CAST(ConfigValue AS nvarchar(15)) = @VERSION)
  BEGIN
	SET @ERROR = 1
	GOTO QUIT
  END
-- Check that schema is valid
  IF NOT EXISTS(SELECT * FROM APM.Config WHERE ConfigName = N'SCHEMA_VERSION' 
					AND CAST(ConfigValue AS nvarchar(15)) = @SCHEMAVERSION)
  BEGIN
	SET @ERROR = 1
	GOTO QUIT
  END
QUIT:
	RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CreateOrUpdateTaskStatus'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CreateOrUpdateTaskStatus AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.CreateOrUpdateTaskStatus 
     @DATABASEID      int
    ,@TASK            nvarchar(50)
    ,@OPERATION       int
    ,@STATUS          nvarchar(50)
    ,@STARTED         bit    
    ,@DATE            dateTime
    ,@LASTTIMESTAMP   bigint
    ,@TRACELEVEL      int
    ,@OPERATIONINDEX  bigint OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE
        @RECORDCOUNT int
    SELECT 
        @OPERATIONINDEX = t.LastTimeStamp 
    FROM 
        APM.Tasks t
    WHERE 
      t.TableName = @TASK 
      AND t.SEViewerDbId = @DATABASEID
    SELECT @RECORDCOUNT = @@ROWCOUNT  
    
    IF @RECORDCOUNT = 1 
    BEGIN        
      UPDATE 
        APM.Tasks  
      SET Status = @STATUS  
         ,StartDate = CASE WHEN @STARTED = 1 THEN @DATE ELSE StartDate END
         ,EndDate = CASE WHEN @STARTED = 0 THEN @DATE ELSE EndDate END
         ,LastTimeStamp = CASE WHEN @STARTED = 0 THEN @LASTTIMESTAMP ELSE LastTimeStamp END
         ,OperationId = @OPERATION
      WHERE
        TableName = @TASK 
        AND SEViewerDbId = @DATABASEID
      IF @STARTED = 0
        Set @OPERATIONINDEX = @LASTTIMESTAMP
    END
    IF @RECORDCOUNT = 0 
    BEGIN
        INSERT 
          APM.Tasks (TableName, StartDate, OperationId, LastTimeStamp, Status, SEViewerDbId)   
        VALUES (
          @TASK    
         ,@DATE  
         ,@OPERATION
         ,0
         ,@STATUS
         ,@DATABASEID
        )
       SET @OPERATIONINDEX = 0
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SelectAbsDateORRelative'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.SelectAbsDateORRelative ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.SelectAbsDateORRelative(
    @RELATIVEDATE INT,
    @ABSDATE DATETIME,
--@ISENDDATE parameter defines how to return relative date
--if @ISENDDATE = 1, then appropriate date returned with 23:59 hours, otherwise it would be rounded to 00:00
    @ISENDDATE BIT,
--Offset field is used to return time value in client timezone, it can be different from SQL server
    @OFFSET INT) RETURNS DATETIME
AS
BEGIN
    DECLARE @RESULTDATE DATETIME
    -- Current time in user timezone
    DECLARE @CURRENTUSERDATE DATETIME
    SELECT @CURRENTUSERDATE = DATEADD(minute, @OFFSET, GETUTCDATE())
    IF @RELATIVEDATE &lt;&gt; 0
    BEGIN
        SELECT @RESULTDATE = 
            CASE @RELATIVEDATE 
                -- This Week: First Day
                WHEN 10 THEN DATEADD(d, -(DATEPART(WEEKDAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE)
                -- This Week: Last Day
                WHEN 20 THEN DATEADD(d, (7 - DATEPART(WEEKDAY, @CURRENTUSERDATE)), @CURRENTUSERDATE)
                -- Previous Week: First Day
                WHEN 30 THEN DATEADD(WEEK, -1, DATEADD(d, -(DATEPART(WEEKDAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE))
                -- Previous Week: Last Day
                WHEN 40 THEN DATEADD(WEEK, -1, DATEADD(d, (7 - DATEPART(WEEKDAY, @CURRENTUSERDATE)), @CURRENTUSERDATE)) 
                -- This Month: First Day
                WHEN 50 THEN DATEADD(DAY, -(DATEPART(DAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE)
                -- This Month: Last Day
                WHEN 60 THEN DATEADD(d, -DATEPART(DAY, DATEADD(MONTH, 1, @CURRENTUSERDATE)), DATEADD(MONTH, 1, @CURRENTUSERDATE))
                -- Previous Month: First Day
                WHEN 70 THEN DATEADD(MONTH, -1, DATEADD(DAY, -(DATEPART(DAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE))
                -- Previous Month: Last Day
                WHEN 80 THEN DATEADD(DAY, -DATEPART(DAY, @CURRENTUSERDATE), @CURRENTUSERDATE)
                -- Today
                WHEN 90 THEN @CURRENTUSERDATE
                -- Yesterday
                WHEN 100 THEN DATEADD(DAY, -1, @CURRENTUSERDATE)
                -- Tomorrow
                WHEN 110 THEN DATEADD(DAY, 1, @CURRENTUSERDATE)
          END  
--Round datetime to date, without hours
        SELECT @RESULTDATE = CONVERT(NVARCHAR, @RESULTDATE, 112)
        
        IF @ISENDDATE &gt; 0
        BEGIN
--If IsEndDate parameter specified, take all day (time value equal to 23:59:59)
            SELECT @RESULTDATE = DATEADD(second, -1, DATEADD(d, 1, @RESULTDATE))
            IF @RESULTDATE &gt; @CURRENTUSERDATE
                SELECT @RESULTDATE = DATEADD(HOUR, DATEPART(HOUR,@CURRENTUSERDATE)+1, CONVERT(NVARCHAR, @CURRENTUSERDATE, 112))
        END
    END
    ELSE
        SELECT @RESULTDATE =@ABSDATE
    RETURN @RESULTDATE
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.EventDetail_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.EventDetail_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.EventDetail_sync
  @OBJECTKEYXML       ntext
 ,@TRACELEVEL         INT
 ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@ERROR_MESSAGE      nvarchar(max)      
      ,@INSERTED_ROWCOUNT  int
      ,@UPDATED_ROWCOUNT   int
      ,@CHANGEDROWCOUNT    int 
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'EventDetail_sync', @EXECRESULT)
    END
    
    DECLARE @EVENTDETAIL TABLE (
       eventrowguid         nvarchar(15) collate database_default 
      ,name                 nvarchar(50) collate database_default  
      ,val1                 nvarchar(255) collate database_default 
      ,val2                 nvarchar(255) collate database_default
      ,client               bit
    )
    
    INSERT @EVENTDETAIL (
       eventrowguid
      ,name
      ,val1
      ,val2
      ,client
    )
    SELECT
       eventrowguid
      ,name
      ,val1
      ,val2
      ,client
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       eventrowguid         nvarchar(15)    
      ,name                 nvarchar(50)  
      ,val1                 nvarchar(255) 
      ,val2                 nvarchar(255)
      ,client               bit
    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
   -- Fill Ip table--------
   INSERT APM.ip (ip, subnetc) 
    SELECT DISTINCT 
        sync.val1
       ,sync.val2
    FROM 
        @EVENTDETAIL sync 
    WHERE 
        sync.name = 'IPADDRESS' AND
        sync.val1 IS NOT NULL AND sync.val1 &lt;&gt; '' AND NOT EXISTS(SELECT * FROM APM.ip ip WHERE ip.ip = sync.val1)
    UPDATE e
        SET e.ipid = ip.ipid
    FROM 
        APM.Event e
        JOIN @EVENTDETAIL sync ON e.rowguid = sync.eventrowguid AND sync.name = 'IPADDRESS' and sync.client = 0
        JOIN APM.Ip ip ON sync.val1 = ip.ip
         
    SET @UPDATED_ROWCOUNT = @@ROWCOUNT   
    SELECT @CHANGEDROWCOUNT = COUNT(*) FROM @EVENTDETAIL WHERE name = 'IPADDRESS' AND client = 0
    SET @ROWNOTAFFECTED = @CHANGEDROWCOUNT - @UPDATED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetDependentComputersList'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetDependentComputersList AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetDependentComputersList 
        @SOURCE NVARCHAR(MAX)
       ,@COMPUTERS NVARCHAR(MAX)
       ,@STARTDATE DateTime
       ,@ENDDATE DateTime
AS
BEGIN
    CREATE TABLE #SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #SOURCEMACHINEMULTIVALUE
            SELECT 
                p.typeid,
                CAST(p.value AS Int)
            FROM 
                APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
--Select machine for server events
    SELECT DISTINCT m.machine, m.machineid
    FROM 
        APM.Machine AS m (NOLOCK) 
        JOIN #SOURCEMACHINEMULTIVALUE AS f2 ON (f2.TYPEID = 2 and f2.VALUE = M.machineid)
    UNION
    --Computer parameter have to contain at leat one value, or an exception occures in reports
    select N'', -1
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusSummaryStatistics'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusSummaryStatistics AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationStatusSummaryStatistics                                         */
/* USED IN: Application Status  Report                                              */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEIDS - List of the source id, separated by comma. Exp: '1,2,3'        */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @ENDDATE     - End date of the period                                       */
/*      @PERIOD      - Period type(Day, Week or Month).                             */
/*                   - Use for the Start Date calculate of the period               */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values   */
/*                          be calculated. Possible values: 1(1 month), 2(2 month), */
/*                          3(3 month), 6(6 month), 17 (7 day)                      */
/*      @TRESHOLD    - Event duration treshold                                      */
/*      @PROBLEM     - Event problem type (all, critical)                           */
/*      @TIMEZONE    - correlate parameter (timezone by min)                        */
/*                   - for the End Date calculate                                   */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationStatusSummaryStatistics 
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)   
WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON;
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    --Calculate End Date in view of timezone
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = APM.GetQueryDateCount(@PERIOD, @ENDDATE)
    --Calculate Start Date in view of period type
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @ENDDATE)
    --Calculate previos period Start Date
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @STARTDATE)
    --Calculate average period Start Date 
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
    /************************************************************************************/
    /*                          ASSISTING TEMP TABLES                                   */
    /************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    /************************************************************************************/
    /*                          Filtered events for further manipulations               */
    /************************************************************************************/
    ;WITH GetSummaryStatistics_EventsFiltered AS
    (
        SELECT
            e.SourceId,
            e.EventId,
            e.UtcEventDate AS Date,
            ABS(DATEDIFF(d, DATEADD(minute, @TIMEZONE, e.UtcEventDate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId
        FROM
            APM.Event AS e
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE
            (e.EventClassType = N'exception' OR (e.EventClassType = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD))
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    /************************************************************************************/
    /*                          Resource Utilizayion Queries                            */
    /************************************************************************************/
-- Calculate resource utilization by Source in one hour.
-- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId AS [Type],    
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,   
            
            ABS(DATEDIFF(day, DATEADD(minute, @TIMEZONE, ph.utcdate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId     
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeId = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
            --Join with #SOURCEMACHINEFILTERTABLE with typeId = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeId IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId
    ),
    --Calculate average application resource utilization over all specified period per machine
    --and for specified grouping period         
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilization AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId
    ),
    -- Count Monitored Requests and Avg. Request Timefor Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)  
            END AS LastMonRequest,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) 
            END AS CurMonRequest,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END) 
            END AS AvgReqTime,
            ABS(DATEDIFF(day, DATEADD(minute, @TIMEZONE, ph.utcdate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId     
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate
    ),
--Calculate average request time  and  sum request count for specified grouping period 
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByMachinePrepare ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId
    ),
--Union .NET counters and process counters for period Id.   
--PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
    ActivePreparePCounters AS (
        SELECT 
            pc.machineId,
            pc.SourceId,            
            
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurInstanceCount) AS CurInstanceCount, 
            MAX(pc.LastInstanceCount) AS LastInstanceCount,
            AVG(pc.AvgInstanceCount) AS AvgInstanceCount,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM 
            ApplicationResourceUtilizationByMachines AS pc
            LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId
       GROUP BY
            pc.machineId,
            pc.SourceId  
    ),
--Group PC between machines
    PCounters AS 
    (
        SELECT
            pc.SourceId AS SourceId,
            SUM(pc.CurReqCount) AS CurReqCount, 
            SUM(pc.LastReqCount) AS LastReqCount,
            SUM(pc.AvgReqCount) AS AvgReqCount,
            AVG(pc.CurAvgReqTime) AS CurAvgReqTime, 
            AVG(pc.LastAvgReqTime) AS LastAvgReqTime,
            AVG(pc.AvgReqTime) AS AvgReqTime,
            AVG(pc.CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(pc.LastCPUSum / COALESCE(m.CPUCount, 1)) AS LastCPUSum,
            AVG(pc.AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(pc.CurMemSum) AS CurMemSum, 
            AVG(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            AVG(pc.CurIOSum) AS CurIOSum, 
            AVG(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum,
            AVG(pc.CurInstanceCount) AS CurInstanceCount, 
            AVG(pc.LastInstanceCount) AS LastInstanceCount,
            AVG(pc.AvgInstanceCount) AS AvgInstanceCount
        FROM
            ActivePreparePCounters AS pc
            JOIN APM.Machine AS m ON m.MachineId = pc.MachineId
        GROUP BY 
            pc.SourceId
    ),
    PrepareEvents AS
    (
        SELECT
            e.SourceId,
            e.PeriodId,
            COUNT(CASE WHEN e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE THEN e.eventid END) AS CurEventCount,
            COUNT(CASE WHEN e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE THEN e.eventid END) AS LastEventCount,
            COUNT(CASE WHEN e.date &lt; @STARTDATE THEN e.eventid END) AS AverageEventCount
        FROM
            GetSummaryStatistics_EventsFiltered AS e
        GROUP BY 
            e.SourceId,
            e.PeriodId      
    ),
--Aggregate average event count. As PeriodId differs only for avg value, it doesn't matter which aggregation function is taken for other values
    Events AS
    (
        SELECT
            e.SourceId,
            MAX(e.CurEventCount) AS CurEventCount,
            MAX(e.LastEventCount) AS LastEventCount,
            --Average counting should not include current period
            AVG(CASE WHEN PeriodID &gt; 0 THEN e.AverageEventCount END) AS AverageEventCount
        FROM
            PrepareEvents AS e
        GROUP BY 
            e.SourceId      
    ),
    --  this query separated from GetSummaryStatistics_EventsFiltered as it has smaller period
    GetSummaryStatistics_EventsProblemsFiltered AS
    (
        SELECT
            e.SourceId,
            e.EventId,
            e.EventClassType,
            e.Description,
            e.RootNodeName,
            --Forms description for perfNode this way to avoid duration in event description
            COALESCE(RIGHT(pn.Description, LEN(pn.Description) - CHARINDEX(':', pn.Description)), N'') AS PerfNode,
            e.UtcEventDate AS Date,
            eg.FirstEventDate
        FROM
            APM.Event AS e
            JOIN APM.EventGroup AS eg ON e.eventgroupId = eg.EventGroupId
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
            OUTER APPLY (
                SELECT TOP(1)
                    pn.description
                FROM
                    APM.PerformanceNode AS pn
                WHERE
                    pn.eventid = e.eventid AND e.resourceid = pn.resourceid
                ORDER BY
                    pn.selfduration DESC
            ) AS pn
        WHERE
            (e.EventClassType = N'exception' OR (e.EventClassType = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD))
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
