<ManagementPack xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="2.0"><Manifest><Identity><ID>Microsoft.SystemCenter.DataWarehouse.ApmReports.Library</ID><Version>10.19.10050.0</Version></Identity><Name>Reports</Name><References><Reference Alias="System"><ID>System.Library</ID><Version>7.5.8500.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference></References></Manifest><Presentation><StringResources><StringResource ID="Microsoft.SystemCenter.DataWarehouse.DataSet.APM.DefaultConfiguration" /></StringResources></Presentation><Reporting><DataWarehouseDataSets><DataWarehouseDataSet ID="Microsoft.SystemCenter.DataWarehouse.DataSet.APM" Accessibility="Internal"><Configuration /><Install>IF (OBJECTPROPERTY(OBJECT_ID('APM.PMTRACE'), 'IsTable') IS NULL) 
BEGIN
	CREATE TABLE APM.PMTRACE (
	   PMTRACEID             INT                  IDENTITY(1,1) NOT NULL,
	   UTCDATE               DATETIME             NOT NULL,
	   DATA					 NVARCHAR(MAX)		  NULL,
	   PMSTATUS				 tinyint	          NULL 
	   CONSTRAINT PK_PMTRACE PRIMARY KEY (PMTRACEID)
	)
END	
GO
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
		WHERE TABLE_NAME = 'PMTRACE' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'UTCDATE' AND COLUMN_DEFAULT IS NOT NULL)
BEGIN		
	ALTER TABLE APM.PMTRACE ADD CONSTRAINT DF_PMTRACE_UTCDATE DEFAULT GETUTCDATE() FOR UTCDATE;
END	
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMSERVEREVENTTRACE'), 'IsTable') IS NULL) 
BEGIN
	/* server event trace table */
	CREATE TABLE APM.PMSERVEREVENTTRACE (
	   EVENTID              BIGINT                  NOT NULL,
	   PMTRACEID            INT                  NOT NULL
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PMSERVEREVENTTRACE]') AND name = N'IDX_EVENTID'
)
BEGIN
	CREATE INDEX IDX_EVENTID ON APM.PMSERVEREVENTTRACE
	(
		EVENTID
	) 
	INCLUDE(PMTRACEID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PMSERVEREVENTTRACE]') AND name = N'IX_PMSERVEREVENTTRACE_PMTRACEID'
)
BEGIN
	CREATE INDEX IX_PMSERVEREVENTTRACE_PMTRACEID ON APM.PMSERVEREVENTTRACE 
		(PMTRACEID)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PMSERVEREVENTTRACE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ADT_PMSERVEREVENTTRACE'), 'IsTrigger') IS NULL)
BEGIN
	exec(
		'CREATE TRIGGER APM.ADT_PMSERVEREVENTTRACE ON APM.PMSERVEREVENTTRACE	AFTER DELETE
		AS
		BEGIN
			RETURN;
		END')
END		
GO
ALTER TRIGGER APM.ADT_PMSERVEREVENTTRACE ON APM.PMSERVEREVENTTRACE	AFTER DELETE
	AS
BEGIN
	SET NOCOUNT ON
	DELETE a FROM
		APM.PMTRACE a JOIN deleted b ON a.PMTRACEID=b.PMTRACEID
		WHERE NOT EXISTS (SELECT 1 FROM APM.PMSERVEREVENTTRACE WHERE PMTRACEID=a.PMTRACEID)
END
GO		
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMCLIENTEVENTTRACE'), 'IsTable') IS NULL) 
BEGIN
	/* client event trace table */
	CREATE TABLE APM.PMCLIENTEVENTTRACE (
	   CSEVENTID            INT                  NOT NULL,
	   PMTRACEID            INT                  NOT NULL
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PMCLIENTEVENTTRACE]') AND name = N'IDX_EVENTID'
)
BEGIN
	CREATE INDEX IDX_EVENTID ON APM.PMCLIENTEVENTTRACE
	(CSEVENTID) 
	INCLUDE(PMTRACEID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PMCLIENTEVENTTRACE]') AND name = N'IX_PMCLIENTEVENTTRACE_PMTRACEID'
)
BEGIN
	CREATE INDEX IX_PMCLIENTEVENTTRACE_PMTRACEID ON APM.PMCLIENTEVENTTRACE 
		(PMTRACEID)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PMCLIENTEVENTTRACE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ADT_PMCLIENTEVENTTRACE'), 'IsTrigger') IS NULL)
BEGIN
	EXEC('
		CREATE TRIGGER APM.ADT_PMCLIENTEVENTTRACE ON APM.PMCLIENTEVENTTRACE
		AFTER DELETE
		AS
		BEGIN
		  RETURN;
		END')
END		
GO
ALTER TRIGGER APM.ADT_PMCLIENTEVENTTRACE ON APM.PMCLIENTEVENTTRACE
	AFTER DELETE
AS
BEGIN
  SET NOCOUNT ON
  
  DELETE a FROM
	APM.PMTRACE a JOIN deleted b ON a.PMTRACEID=b.PMTRACEID
	WHERE NOT EXISTS (SELECT 1 FROM APM.PMCLIENTEVENTTRACE WHERE PMTRACEID=a.PMTRACEID)
END
go
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMENTITYMAPPING'), 'IsTable') IS NULL) 
BEGIN
	/*==============================================================*/
	/* Table: PMENTITYMAPPING                                       */
	/*==============================================================*/
	CREATE TABLE APM.PMENTITYMAPPING (
	   PMENTITYMAPPINGID    INT                  IDENTITY,
	   ALIAS                NVARCHAR(50)         NOT NULL,
	   ENTITY               NVARCHAR(50)         NOT NULL,
	   FIELD                NVARCHAR(50)         NULL,
	   FIELDTYPE            NVARCHAR(50)         NULL,
	   ISPROCEDURE          BIT                  NOT NULL,
	   ISCLIENT             BIT                  NOT NULL,
	   CONSTRAINT PK_PMENTITYMAPPING PRIMARY KEY (PMENTITYMAPPINGID)
	)
	
	------------------ SERVER EVENT MAPING ------------------------
	INSERT APM.PMENTITYMAPPING
			( 
			  ALIAS,
			  ENTITY,
			  FIELD,
			  FIELDTYPE ,
			  ISPROCEDURE,
			  ISCLIENT
			)
	SELECT N'EVENT.EVENTCLASSTYPE',N'V_PM_EVENT',N'EVENTCLASSTYPE',N'nvarchar(50)',0,0  
	UNION ALL
	SELECT N'EVENT.SOURCE',N'V_PM_EVENT',N'SOURCE',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.MACHINENAME',N'V_PM_EVENT',N'MACHINENAME',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.ROOTNODENAME',N'V_PM_EVENT',N'ROOTNODENAME',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.DESCRIPTION',N'V_PM_EVENT',N'DESCRIPTION',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.USERNAME',N'V_PM_EVENT',N'USERNAME',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.EXCEPTIONCLASS',N'V_PM_EVENT',N'EXCEPTIONCLASS',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.EVENTDURATION',N'V_PM_EVENT',N'EVENTDURATION',N'decimal(35,0)',0,0 
	UNION ALL
	SELECT N'EVENT.EVENTGROUPID',N'V_PM_EVENT',N'SEVIEWEREGID',N'int',0,0 
	UNION ALL
	SELECT N'EVENT.HEAVYLIGHT',N'V_PM_EVENT',N'HEAVYLIGHT',N'int',0,0 
	UNION ALL
	SELECT N'EVENT.ASPECT',N'V_PM_EVENT',N'ASPECT',N'nvarchar(50)',0,0 
	UNION ALL
	SELECT N'EVENT.PMSTATUS',N'EVENT',N'PMSTATUS',N'tinyint',0,0 
	UNION ALL
	SELECT N'EVENT.HEAVIESTEXTERNALRESOURCE',N'V_PM_RESOURCE',N'RESOURCEMETHOD',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.COMPONENT',N'V_PM_EVENTDETAIL',N'VALUE',N'COMPONENT',0,0
	UNION ALL
	SELECT N'EVENT.EVENTID',N'EVENT',N'EVENTID',N'int',0,0 
	UNION ALL
	SELECT N'EVENT.CATEGORY',N'V_PM_EVENT',N'CATEGORY',N'nvarchar(50)',0,0 
	UNION ALL
	SELECT N'EVENT.HEAVIESTNODE',N'V_PM_HEAVIESTNODE',N'VAL',N'nvarchar(255)',0,0 
	UNION ALL
	SELECT N'EVENT.ROOTFUNCTION',N'V_PM_EVENTDETAIL',N'VALUE',N'ROOTFUNCTION',0,0
	UNION ALL
	SELECT N'EVENT.SLOWCALLDURATION',N'V_PM_HEAVIESTNODE',N'SELFDURATION',N'decimal(35,0)',0,0 
	------------------ CLIENT EVENT MAPING ------------------------
	INSERT APM.PMENTITYMAPPING
			( 
			  ALIAS,
			  ENTITY,
			  FIELD,
			  FIELDTYPE ,
			  ISPROCEDURE,
			  ISCLIENT
			)
	SELECT N'EVENT.EVENTCLASSTYPE',N'V_PM_CSEVENT',N'EVENTCLASSTYPE',N'nvarchar(50)',0,1  
	UNION ALL
	SELECT N'EVENT.SOURCE',N'V_PM_CSEVENT',N'SOURCE',N'nvarchar(255)',0,1 
	UNION ALL
	SELECT N'EVENT.MACHINENAME',N'V_PM_CSEVENT',N'MACHINENAME',N'nvarchar(255)',0,1
	UNION ALL
	SELECT N'EVENT.ROOTNODENAME',N'V_PM_CSEVENTDETAIL',N'VALUE',N'ROOTNODENAME',0,1 
	UNION ALL
	SELECT N'EVENT.DESCRIPTION',N'V_PM_CSEVENT',N'DESCRIPTION',N'nvarchar(255)',0,1 
	UNION ALL
	SELECT N'EVENT.USERNAME',N'V_PM_CSEVENT',N'USERNAME',N'nvarchar(255)',0,1 
	UNION ALL
	SELECT N'EVENT.EXCEPTIONCLASS',N'V_PM_CSEVENT',N'EXCEPTIONCLASS',N'nvarchar(255)',0,1
	UNION ALL
	SELECT N'EVENT.EVENTDURATION',N'V_PM_CSEVENT',N'EVENTDURATION',N'decimal(35,0)',0,1 
	UNION ALL
	SELECT N'EVENT.EVENTGROUPID',N'V_PM_CSEVENT',N'SEVIEWEREGID',N'int',0,1
	UNION ALL
	SELECT N'EVENT.HEAVYLIGHT',N'V_PM_CSEVENT',N'HEAVYLIGHT',N'int',0,1 
	UNION ALL
	SELECT N'EVENT.ASPECT',N'V_PM_CSEVENT',N'ASPECT',N'nvarchar(50)',0,1 
	UNION ALL
	SELECT N'EVENT.PMSTATUS',N'V_PM_CSEVENTSTATUS',N'PMSTATUS',N'tinyint',0,1 
	UNION ALL
	SELECT N'EVENT.HEAVIESTEXTERNALRESOURCE',N'V_PM_EMPTY',N'VAL',N'nvarchar(255)',0,1
	UNION ALL
	SELECT N'EVENT.COMPONENT',N'V_PM_CSEVENT',N'COMPONENT',N'nvarchar(50)',0,1
	UNION ALL
	SELECT N'EVENT.EVENTID',N'V_PM_CSEVENTSTATUS',N'EVENTID',N'int',0,1 
	UNION ALL
	SELECT N'EVENT.CATEGORY',N'V_PM_CSEVENTDETAIL',N'VALUE',N'CATEGORY',0,1
	UNION ALL
	SELECT N'EVENT.HEAVIESTNODE',N'V_PM_CSHEAVIESTNODE',N'VAL',N'nvarchar(255)',0,1 
	UNION ALL
	SELECT N'EVENT.ROOTFUNCTION',N'V_PM_CSEVENTDETAIL',N'VALUE',N'ROOTFUNCTION',0,1
	UNION ALL
	SELECT N'EVENT.SLOWCALLDURATION',N'V_PM_CSHEAVIESTNODE',N'SELFDURATION',N'decimal(35,0)',0,1 
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'PMENTITYMAPPING' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'PMENTITYMAPPING_UNIQUE'
)        
BEGIN
	ALTER TABLE APM.PMENTITYMAPPING ADD CONSTRAINT PMENTITYMAPPING_UNIQUE 
		UNIQUE(ALIAS, ISCLIENT) 
END    
GO
/*==============================================================*/
/* Table: PMEVENTSTATUS                                       */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMEVENTSTATUS'), 'IsTable') IS NULL) 
BEGIN
	CREATE TABLE APM.PMEVENTSTATUS (
	   PMSTATUSID	int                  not null,
	   PMSTATUSNAME nvarchar(50)         not null,
	   ISDEFAULT	bit                  not null
	)
	
	INSERT INTO [APM].[PMEVENTSTATUS] ([PMSTATUSID], [PMSTATUSNAME], [ISDEFAULT])
		SELECT 0, N'New',		1
		UNION
		SELECT 1, N'Reviewed',	1
		UNION
		SELECT 2, N'Deleted',	0
		UNION
		SELECT 3, N'By Design', 0	
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'PMEVENTSTATUS' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'ISDEFAULT' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE APM.PMEVENTSTATUS ADD CONSTRAINT DF_PMEVENTSTATUS_ISDEFAULT DEFAULT 0 FOR ISDEFAULT	
END	
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.HourlyTable'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.HourlyTable (value datetime)
END	
GO
/*==============================================================*/
/* Table: AGGREGATIONTYPE                                       */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.AGGREGATIONTYPE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.AGGREGATIONTYPE (
	   AGGREGATIONTYPEID    int                  not null,
	   AGGREGATIONTYPEDEFAULTNAME nvarchar(50)         not null,
	   AGGREGATIONINTERVALDURATIONMINUTES int                  not null,
	   AGGREGATIONSTARTDELAYMINUTES int                  not null,
	   constraint PK_AGGREGATIONTYPE primary key (AGGREGATIONTYPEID)
	)
	
	INSERT INTO APM.AGGREGATIONTYPE (
		AGGREGATIONTYPEID,
		AGGREGATIONTYPEDEFAULTNAME,
		AGGREGATIONINTERVALDURATIONMINUTES,
		AGGREGATIONSTARTDELAYMINUTES
	)
	values(
		20,
		'Hourly',
		60,
		5
	)
	
	INSERT INTO APM.AGGREGATIONTYPE (
		AGGREGATIONTYPEID,
		AGGREGATIONTYPEDEFAULTNAME,
		AGGREGATIONINTERVALDURATIONMINUTES,
		AGGREGATIONSTARTDELAYMINUTES
	)
	VALUES(
		30,
		'Daily',
		1440,
		20
	)
END
GO
/*==============================================================*/
/* Table: APPLICATION                                           */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.APPLICATION'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.APPLICATION (
	   APPLICATIONID        int                  identity,
	   APPLICATION          nvarchar(255)        null,
	   TYPE                 int                  not null,
	   constraint PK_APPLICATION primary key (APPLICATIONID)
	)
END
GO
/*==============================================================*/
/* Index: IX_APPLICATION                                        */
/*==============================================================*/  
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[APPLICATION]') AND name = N'IX_APPLICATION'
)
BEGIN
	create unique index IX_APPLICATION on APM.APPLICATION (
		APPLICATION ASC
	)
END
GO
/*==============================================================*/
/* Table: APPLICATIONSOURCEMACHINE                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.APPLICATIONSOURCEMACHINE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.APPLICATIONSOURCEMACHINE (
	   APPLICATIONSOURCEID  int                  identity,
	   APPLICATIONID        int                  null,
	   SOURCEID             int                  null,
	   MACHINEID            int                  null,
	   constraint PK_APPLICATIONSOURCEMACHINE primary key (APPLICATIONSOURCEID)
	)
END
GO
/*==============================================================*/
/* Index: FK_SOURCE                                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[APPLICATIONSOURCEMACHINE]') AND name = N'FK_SOURCE'
)
BEGIN
	create index FK_SOURCE on APM.APPLICATIONSOURCEMACHINE 
	(
		SOURCEID ASC 
	)
	INCLUDE ( [APPLICATIONID]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
/*==============================================================*/
/* Index: FK_APPLICATION                                        */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[APPLICATIONSOURCEMACHINE]') AND name = N'FK_APPLICATION'
)
BEGIN
	create index FK_APPLICATION on APM.APPLICATIONSOURCEMACHINE (
		APPLICATIONID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_MACHINE                                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[APPLICATIONSOURCEMACHINE]') AND name = N'FK_MACHINE'
)
BEGIN
	create index FK_MACHINE on APM.APPLICATIONSOURCEMACHINE (
		MACHINEID ASC 
	)
	INCLUDE ([APPLICATIONID])
END
GO
/*==============================================================*/
/* Table: ASPECT                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.ASPECT'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.ASPECT (
	   ASPECT               nvarchar(50)         null,
	   DESCRIPTION          nvarchar(255)        null,
	   ASPECTID             int                  identity,
	   constraint PK_ASPECT primary key (ASPECTID)
	)
END
GO
/*==============================================================*/
/* Index: IX_ASPECT                                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[ASPECT]') AND name = N'IX_ASPECT'
)
BEGIN
	create unique index IX_ASPECT on APM.ASPECT (
		ASPECT ASC
	)
END
GO
/*==============================================================*/
/* Table: CONFIG                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CONFIG'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.CONFIG (
	   CONFIGID             int                  identity,
	   CONFIGNAME           nvarchar(50)         not null,
	   CONFIGVALUE          ntext                null,
	   constraint PK_CONFIG primary key (CONFIGID)
	)
	
	INSERT INTO APM.CONFIG (configname, configvalue) VALUES ('SECURITYMODE', '0')
	INSERT INTO APM.CONFIG (CONFIGNAME, CONFIGVALUE) VALUES ('DATABASE_VERSION', '5.7')
	INSERT INTO APM.CONFIG (CONFIGNAME, CONFIGVALUE) VALUES ('DATABASE_NAME', 'Reporting')
	INSERT INTO APM.CONFIG (CONFIGNAME, CONFIGVALUE) VALUES ('SCHEMA_VERSION', '1')	
	
	/*Lifetime for events with "Deleted" status (hours)*/
	INSERT INTO APM.CONFIG (CONFIGNAME, CONFIGVALUE) VALUES (N'PMLifeTimeInHoursForDeletedEvents', '24')
          
	/*Lifetime for events with "By Design" status (hours)*/
	INSERT INTO APM.CONFIG (CONFIGNAME, CONFIGVALUE) VALUES (N'PMLifeTimeInHoursForByDesignEvents', '72')
END
GO
/*==============================================================*/
/* Index: IX_CONFIGNAME                                         */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CONFIG]') AND name = N'IX_CONFIGNAME'
)
BEGIN
	CREATE UNIQUE INDEX IX_CONFIGNAME on APM.CONFIG (
		CONFIGNAME ASC
	)
END
GO
/*==============================================================*/
/* Table: CSAJAX                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSAJAX'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSAJAX (
	   CSAJAXID             int                  identity,
	   CSEVENTID            int                  not null,
	   URI                  nvarchar(255)        not null,
	   NETWORKTIME          decimal(35)          null,
	   SERVERTIME           decimal(35)          null,
	   TOTALTIME            decimal(35)          null,
	   REQUESTSIZE          bigint               null,
	   RESPONSESIZE         bigint               null,
	   RESPONSETIME         decimal(35)          null,
	   SYNCHRONOUS          bit                  not null,
	   LATENCY              bigint               null,
	   UTCDATE              datetime             null,
	   SOURCEID             int                  null,
	   ISHEAVIESTNODE       bit                  not null,
	   constraint PK_CSAJAX primary key (CSAJAXID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSAJAX]') AND name = N'idx_W_EventURI'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_EventURI] ON [APM].[CSAJAX] 
	(
		[CSEVENTID] ASC,
		[URI] ASC
	)
	INCLUDE ( [TOTALTIME],
	[SYNCHRONOUS]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSAJAX]') AND name = N'FK_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_CSEVENTID] ON [APM].[CSAJAX]
	(
		[CSEVENTID] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSAJAX]') AND name = N'idx_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventId] ON [APM].[CSAJAX] 
	(
		[CSEVENTID] ASC
	)
	INCLUDE ( [TOTALTIME],
	[RESPONSESIZE],
	[LATENCY],
	[SYNCHRONOUS],
	[URI],
	[NETWORKTIME],
	[SERVERTIME],
	[REQUESTSIZE]
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSAJAX]') AND name = N'idx_EventIdTotalTime1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdTotalTime1] ON APM.CSAJAX 
	(
		[CSEVENTID] ASC,
		[TOTALTIME] DESC
	)
	INCLUDE ( [URI],
	[NETWORKTIME],
	[SERVERTIME],
	[RESPONSETIME],
	[RESPONSESIZE],
	[REQUESTSIZE],
	[LATENCY]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSAJAX'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSASYNCAJAX                                           */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSASYNCAJAX'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.CSASYNCAJAX (
	   CSASYNCAJAXID        int                  identity,
	   CSEVENTID            int                  not null,
	   HANDLERTIME          decimal(35)          null,
	   TOTALTIME            decimal(35)          null,
	   constraint PK_CSASYNCAJAX primary key (CSASYNCAJAXID)
	)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSASYNCAJAX]') AND name = N'idx_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventId] ON APM.CSASYNCAJAX
	(
		[CSEVENTID] ASC
	)
	INCLUDE ([HANDLERTIME]) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSASYNCAJAX'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSEVENT                                               */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSEVENT'), 'IsTable') IS NULL)
BEGIN
 	CREATE TABLE APM.CSEVENT (
	   CSEVENTID            int                  identity,
	   CSEVENTGROUPID       int                  not null,
	   SOURCEID             int                  not null,
	   MACHINEID            int                  not null,
	   IPID                 int                  null,
	   CLASSTYPE            nvarchar(50)         not null,
	   EVENTCLASS           nvarchar(50)         null,
	   PAGEURI              nvarchar(255)        null,
	   DESCRIPTION          nvarchar(255)        not null,
	   BROWSER              nvarchar(255)        null,
	   UTCDATE              datetime             not null,
	   ROWGUID              nvarchar(15)         null,
	   SEVIEWERDBID         int                  not null,
	   SEVIEWEREGID         int                  not null,
	   USERID               int                  null,
	   PMSTATUS             tinyint              not null,
	   TOTALTIME            decimal(35)          null,
	   TOTALSIZE            bigint               null,
	   LATENCY              bigint               null,
	   constraint PK_CSEVENT primary key (CSEVENTID)
	)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'FK_USERS'
)
BEGIN
	CREATE NONCLUSTERED INDEX FK_USERS ON APM.CSEVENT
		(USERID)
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'CSEVENT' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'PMSTATUS' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE [APM].[CSEVENT] ADD  CONSTRAINT [DF_CSEVENT_PMSTATUS]  DEFAULT ((0)) FOR [PMSTATUS]	
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_DateSourceClassTypeMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSourceClassTypeMachine] ON [APM].[CSEVENT] 
	(
		[UTCDATE] ASC,
		[SOURCEID] ASC,
		[CLASSTYPE] ASC,
		[MACHINEID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_ClassTypeDateMachineSource'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_ClassTypeDateMachineSource] ON [APM].[CSEVENT] 
	(
		[CLASSTYPE] ASC,
		[UTCDATE] ASC,
		[MACHINEID] ASC,
		[SOURCEID] ASC
	) 
	INCLUDE([CSEVENTID],
	PAGEURI) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceClassTypeDateMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceClassTypeDateMachine] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC,
		[CLASSTYPE] ASC,
		[UTCDATE] ASC,
		[MACHINEID] ASC
	) 
	INCLUDE([CSEVENTID],
	PAGEURI) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceMachineClassTypeDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceMachineClassTypeDate] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[CLASSTYPE] ASC,
		[UTCDATE] ASC
	)
	INCLUDE ( [CSEVENTID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_DateSourceClassTypeMachineIpId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSourceClassTypeMachineIpId] ON [APM].[CSEVENT] 
	(
		[UTCDATE] ASC,
		[SOURCEID] ASC,
		[CLASSTYPE] ASC,
		[MACHINEID] ASC,
		[IPID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[CSEVENTGROUPID],
	[EVENTCLASS],
	[PAGEURI],
	[BROWSER],
	[DESCRIPTION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceMachineEventClassDateIpId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceMachineEventClassDateIpId] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[EVENTCLASS] ASC,
		[UTCDATE] ASC,
		[IPID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[CSEVENTGROUPID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_DateSourceMachineEventClassIpId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSourceMachineEventClassIpId] ON [APM].[CSEVENT] 
	(
		[UTCDATE] ASC,
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[EVENTCLASS] ASC,
		[IPID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[CSEVENTGROUPID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'FK_IPID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_IPID] ON [APM].[CSEVENT]
	(
		[IPID] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'FK_SOURCEID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_SOURCEID] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceEventClassDateMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceEventClassDateMachine] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC,
		[EVENTCLASS] ASC,
		[UTCDATE] ASC,
		[MACHINEID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_DateSourceEventClassMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSourceEventClassMachine] ON [APM].[CSEVENT] 
	(
		[UTCDATE] ASC,
		[SOURCEID] ASC,
		[EVENTCLASS] ASC,
		[MACHINEID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[PAGEURI]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_ClassTypeSourceMachineDateIpId2'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_ClassTypeSourceMachineDateIpId2] ON [APM].[CSEVENT] 
	(
		[CLASSTYPE] ASC,
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[UTCDATE] ASC,
		[IPID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[CSEVENTGROUPID],
	[BROWSER],
	[DESCRIPTION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_W_PageSourceDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_PageSourceDate] ON [APM].[CSEVENT] 
	(
		[PAGEURI] ASC,
		[SOURCEID] ASC,
		[UTCDATE] ASC
	)
	INCLUDE ( [CLASSTYPE],
	[DESCRIPTION],
	[ROWGUID],
	[SEVIEWEREGID],
	[MACHINEID],
	[SEVIEWERDBID],
	[IPID]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceMachineClassTypeDateIpId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceMachineClassTypeDateIpId] ON [APM].[CSEVENT] 
	(
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[CLASSTYPE] ASC,
		[UTCDATE] ASC,
		[IPID] ASC
	)
	INCLUDE ( [CSEVENTID],
	[CSEVENTGROUPID],
	[EVENTCLASS],
	[PAGEURI],
	[BROWSER],
	[DESCRIPTION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_W_IpIdSourcePageDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_IpIdSourcePageDate]  ON [APM].[CSEVENT] 
	(
		[IPID] ASC,
		[SOURCEID] ASC,
		[PAGEURI] ASC,
		[UTCDATE] ASC
	)
	INCLUDE ( [CLASSTYPE],
	[DESCRIPTION],
	[ROWGUID],
	[SEVIEWEREGID],
	[MACHINEID],
	[SEVIEWERDBID]
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------------ Summary User Analysis Indexes ------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_DateSource1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSource1] ON [APM].[CSEVENT] 
		(
			[UTCDATE] ASC,
			[SOURCEID] ASC
		)
		INCLUDE ( [CSEVENTID],
		[CSEVENTGROUPID],
		[PAGEURI],
		[USERID],
		[CLASSTYPE],
		[EVENTCLASS],
		[MACHINEID],
		[BROWSER],
		[DESCRIPTION],
		[IPID],
		[TOTALTIME]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SourceDate1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceDate1] ON [APM].[CSEVENT] 
		(
			[SOURCEID] ASC,
			[UTCDATE] ASC
		)
		INCLUDE ( [CSEVENTID],
		[CSEVENTGROUPID],
		[PAGEURI],
		[USERID],
		[CLASSTYPE],
		[EVENTCLASS],
		[MACHINEID],
		[BROWSER],
		[DESCRIPTION],
		[IPID],
		[TOTALTIME]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
------------------------------ Transfer indexes--------------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_T_RowGuid'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_RowGuid] ON [APM].[CSEVENT] 
	(
		[ROWGUID] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_T_RowGuid2'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_RowGuid2] ON APM.CSEVENT
	(
		[ROWGUID] ASC
	)INCLUDE (UserId) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_T_UtcDate'
)
BEGIN
	CREATE INDEX idx_T_UtcDate ON APM.CSEVENT
		(UTCDATE) 
		INCLUDE(SEVIEWERDBID) WITH (SORT_IN_TEMPDB = ON) 
END
GO
---------------- delete old sources/computers wizard indexes --------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[csevent]') AND name = N'idx_MachineDate'
)
BEGIN
	CREATE INDEX idx_MachineDate ON APM.csevent (MACHINEID, UTCDATE DESC)  
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENT]') AND name = N'idx_SM_PMStatusDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SM_PMStatusDate] ON [APM].[CSEVENT] 
	(
		[PMSTATUS] ASC,
		[UTCDATE] ASC
	)
	INCLUDE ( [SEVIEWERDBID],
	[CSEVENTID])
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSEVENT'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSEVENTGROUP                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSEVENTGROUP'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSEVENTGROUP (
	   CSEVENTGROUPID       int                  identity,
	   FIRSTEVENTDATE       datetime             not null,
	   LASTEVENTDATE        datetime             not null,
	   HASHVALUE            nvarchar(50)         null,
	   DESCRIPTION          nvarchar(255)        null,
	   SOURCEID             int                  null,
	   constraint PK_CSEVENTGROUP primary key (CSEVENTGROUPID)
	)
END
GO
------------------ Transfer indexes -----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEventGroup]') AND name = N'idx_T_hashvalue'
)
BEGIN
	CREATE INDEX idx_T_hashvalue on APM.CSEventGroup(hashvalue) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENTGROUP]') AND name = N'idx_T_hashvalue2'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_hashvalue2] ON APM.CSEVENTGROUP
	(
		[HASHVALUE] ASC
	) include (firsteventdate, lasteventdate, sourceid) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSEVENTGROUP'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSEXEVENT                                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSEXEVENT'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.CSEXEVENT (
	   CSEXEVENTID          int                  identity,
	   CSEVENTID            int                  not null,
	   ACTION               nvarchar(255)        not null,
	   EXMESSAGE            nvarchar(255)        not null,
	   EXTYPE               nvarchar(255)        not null,
	   EXFUNCTION           nvarchar(255)        not null,
	   ROWGUID              nvarchar(15)         null,
	   constraint PK_CSEXEVENT primary key (CSEXEVENTID)
	)
END	
GO
/*==============================================================*/
/* Table: CSHEAVIESTRESOURCE                                    */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSHEAVIESTRESOURCE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSHEAVIESTRESOURCE (
	   CSHEAVIESTRESOURCEID int                  identity,
	   CSEVENTID            int                  not null,
	   NAME                 nvarchar(255)        not null,
	   DURATION             decimal(35)          not null,
	   ROWGUID              nvarchar(15)         null,
	   ISHEAVIESTNODE          bit                               not null,
	   constraint PK_CSHEAVIESTRESOURCE primary key (CSHEAVIESTRESOURCEID)
	)
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'CSHEAVIESTRESOURCE' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'IsHeaviestNode' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE APM.CSHEAVIESTRESOURCE ADD CONSTRAINT DF_CSHEAVIESTRESOURCE_ISHAVIESTNODE DEFAULT 0 FOR IsHeaviestNode	
END	
GO
---------------------Transfer indexes---------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSHEAVIESTRESOURCE]') AND name = N'idx_T_RowGuid'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_RowGuid] ON APM.CSHEAVIESTRESOURCE
	(
		[ROWGUID] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSHEAVIESTRESOURCE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSJSCRIPTEVENT                                        */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSJSCRIPTEVENT'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSJSCRIPTEVENT (
	   CSJSCRIPTEVENTID     int                  identity,
	   CSEVENTID            int                  not null,
	   ACTION               nvarchar(255)        not null,
	   TOTALTIME            decimal(35)          null,
	   UTCDATE              datetime             null,
	   SOURCEID             int                  null,
	   constraint PK_CSJSCRIPTEVENT primary key (CSJSCRIPTEVENTID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSJSCRIPTEVENT]') AND name = N'idx_W_ActionEvent'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_ActionEvent] ON [APM].[CSJSCRIPTEVENT] 
	(
		 [ACTION] ASC,
		 [CSEVENTID] ASC
	    
	) INCLUDE([TOTALTIME])
	 WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSJSCRIPTEVENT]') AND name = N'idx_W_EventAction'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_EventAction] ON [APM].[CSJSCRIPTEVENT] 
	(
		 [CSEVENTID] ASC,
		 [ACTION] ASC    
	    
	) INCLUDE([TOTALTIME])
	 WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSJSCRIPTEVENT]') AND name = N'FK_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_CSEVENTID] ON [APM].[CSJSCRIPTEVENT]
	(
		[CSEVENTID] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSJSCRIPTEVENT]') AND name = N'idx_CSEvent1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_CSEvent1] ON APM.CSJSCRIPTEVENT
	(
		[CSEVENTID] ASC
	)
	INCLUDE ( 
	[TOTALTIME], 
	[ACTION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSJSCRIPTEVENT'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSPAGEEVENT                                           */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSPAGEEVENT'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSPAGEEVENT (
	   CSPAGEEVENTID        int                  identity,
	   CSEVENTID            int                  not null,
	   NETWORKTIME          decimal(35)          null,
	   SERVERTIME           decimal(35)          null,
	   DOMTIME              decimal(35)          null,
	   PERIPHERALTIME       decimal(35)          null,
	   ONLOADTIME           decimal(35)          null,
	   TOTALTIME            decimal(35)          null,
	   TOTALSIZE            bigint               null,
	   LATENCY              bigint               null,
	   UTCDATE              datetime             null,
	   SOURCEID             int                  null,
	   constraint PK_CSPAGEEVENT primary key (CSPAGEEVENTID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPAGEEVENT]') AND name = N'FK_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_CSEVENTID] ON [APM].[CSPAGEEVENT]
	(
		[CSEVENTID] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPAGEEVENT]') AND name = N'idx_EventId1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventId1] ON [APM].[CSPAGEEVENT] 
	(
		[CSEVENTID] ASC
	)
	INCLUDE ( [TOTALTIME],
		[TOTALSIZE],
		[NETWORKTIME],
		[SERVERTIME],
		[DOMTIME],
		[PERIPHERALTIME],
		[ONLOADTIME],
		[LATENCY]
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSPAGEEVENT'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSPERIPHERAL                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSPERIPHERAL'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSPERIPHERAL (
	   CSPERIPHERALID       int                  identity,
	   CSEVENTID            int                  not null,
	   TYPE                 nvarchar(50)         not null,
	   TOTALSIZE            bigint               null,
	   TOTALTIME            decimal(35)          null,
	   constraint PK_CSPERIPHERAL primary key (CSPERIPHERALID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPERIPHERAL]') AND name = N'FK_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_CSEVENTID] ON [APM].[CSPERIPHERAL]
	(
		[CSEVENTID] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPERIPHERAL]') AND name = N'idx_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventId] ON [APM].[CSPERIPHERAL] 
	(
		[CSEVENTID] ASC
	)
	INCLUDE ( [TYPE],
	[TOTALSIZE]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPERIPHERAL]') AND name = N'idx_EventPeripheral'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventPeripheral] ON [APM].[CSPERIPHERAL] 
	(
		[CSEVENTID] ASC,
		[CSPERIPHERALID] ASC
	)
	INCLUDE ( [TYPE],
	[TOTALSIZE]) WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------------ Transfer indexes -------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSPERIPHERAL]') AND name = N'idx_T_EventIdType'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_EventIdType] ON APM.CSPERIPHERAL
	(
		[CSEVENTID] ASC,	
		[TYPE] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSPERIPHERAL'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSPERIPHERALDETAIL                                    */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSPERIPHERALDETAIL'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.CSPERIPHERALDETAIL (
	   CSPERIPHERALDETAILID int                  identity,
	   CSPERIPHERALID       int                  not null,
	   DOMAIN               nvarchar(255)        not null,
	   PATH                 nvarchar(255)        not null,
	   SIZE                 bigint               null,
	   TOTALTIME            decimal(35)          null,
	   constraint PK_CSPERIPHERALDETAIL primary key (CSPERIPHERALDETAILID)
	)
END
GO
/*==============================================================*/
/* Table: DATASET                                               */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATASET'), 'IsTable') IS NULL)
BEGIN
	-- Create table
	CREATE TABLE APM.DATASET (
	   DATASETID            int                  identity,
	   AGGREGATIONTYPEID    int                  null,
	   DATASETNAME          nvarchar(50)         not null,
	   DEFAULTAGGREGATIONINTERVALCOUNT tinyint              not null,
	   MAXDATAAGEDAYS       int                  null,
	   AGGREGATIONMETHODNAME nvarchar(50)         null,
	   constraint PK_DATASET primary key (DATASETID)
	)
	
	--Insert default values
	INSERT into APM.dataset (
		DATASETNAME
	   ,DEFAULTAGGREGATIONINTERVALCOUNT
	   ,AGGREGATIONTYPEID
	   ,AGGREGATIONMETHODNAME
	   ,MAXDATAAGEDAYS
	)
	values (
		N'perfHourly',
		40,
		30,
		N'PCounterAggregate',
		91
	)	
END
GO
/*==============================================================*/
/* Table: DATASETAGGREGATIONHISTORY                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATASETAGGREGATIONHISTORY'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.DATASETAGGREGATIONHISTORY (
	   DATASETAGGREGATIONHISTORYID int                  identity,
	   DATASETID            int                  not null,
	   AGGREGATIONDATETIME  datetime             not null,
	   DIRTYIND             bit                  not null,
	   constraint PK_DATASETAGGREGATIONHISTORY primary key (DATASETAGGREGATIONHISTORYID)
	)
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'DatasetAggregationHistory' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'DirtyInd' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE APM.DatasetAggregationHistory ADD CONSTRAINT DatasetAggregationHistoryID_Default DEFAULT 1 FOR DirtyInd	
END	
GO
--------------------------------------- Transfer indexes ----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[DATASETAGGREGATIONHISTORY]') AND name = N'idx_T_DIRTYIND_datasetid_date'
)
BEGIN
	CREATE INDEX idx_T_DIRTYIND_datasetid_date ON APM.DATASETAGGREGATIONHISTORY
	(
		DIRTYIND, datasetid, AGGREGATIONDATETIME
	)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'DATASETAGGREGATIONHISTORY'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: EVENT                                                 */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.EVENT'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.EVENT (
	   EVENTID              bigint               identity,
	   EVENTGROUPID         int                  null,
	   RESOURCEID           int                  null,
	   SOURCEID             int                  null,
	   EVENTDURATION        decimal(35)          null,
	   MACHINEID            int                  not null,
	   UTCEVENTDATE         datetime             not null,
	   EVENTCLASSTYPE       nvarchar(50)         null,
	   ROOTNODENAME         nvarchar(255)        null,
	   ASPECT               nvarchar(50)         null,
	   EXCEPTIONCLASS       nvarchar(255)        null,
	   DESCRIPTION          nvarchar(255)        null,
	   CATEGORY             nvarchar(50)         null,
	   HEAVYLIGHT           int                  null,
	   ROWGUID              nvarchar(15)         null,
	   SEVIEWERDBID         int                  null,
	   SEVIEWEREGID         int                  not null,
	   IPID                 int                  null,
	   USERID               int                  null,
	   PMSTATUS             tinyint              not null
	)
	
	ALTER TABLE APM.Event 
		ADD CONSTRAINT PK_EVENT PRIMARY KEY NONCLUSTERED (EVENTID)	
END
GO
/*==============================================================*/
/* Index: IX_CDATE                                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[Event]') AND name = N'IX_CDATE'
)
BEGIN
	CREATE CLUSTERED INDEX IX_CDATE ON APM.Event
	(
		UTCEVENTDATE ASC
	) 
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'EVENT' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'PMSTATUS' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE [APM].[EVENT] ADD  CONSTRAINT [DF_EVENT_PMSTATUS]  DEFAULT ((0)) FOR [PMSTATUS]	
END	
GO
--------------------- Change foreign key index--------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_EVENTGROUP'
)
BEGIN
	CREATE NONCLUSTERED INDEX [FK_EVENTGROUP] ON [APM].[EVENT] 
	(
		[EVENTGROUPID] ASC
	)
	INCLUDE ( [EVENTDURATION],
	[MACHINEID],
	[UTCEVENTDATE],
	[EVENTID],
	[SOURCEID],
	[EVENTCLASSTYPE],
	[rootnodename],
	[DESCRIPTION],
	[CATEGORY]) WITH (SORT_IN_TEMPDB = ON)
END
GO
-----------------End Change foreign key index---------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_DateSourceMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateSourceMachine] ON [APM].[EVENT] 
	(
		[UTCEVENTDATE] ASC,
		[SOURCEID] ASC,
		[MACHINEID] ASC
	)
	INCLUDE ( [EVENTGROUPID],
	[EVENTDURATION],
	[CATEGORY],
	[HEAVYLIGHT],
	[ASPECT],
	[RESOURCEID],
	[EVENTCLASSTYPE],
	[USERID],
	[EVENTID],
	[DESCRIPTION],
	[SEVIEWERDBID],
	[ROOTNODENAME]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_MachineDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX idx_MachineDate ON APM.EVENT
	(
		MACHINEID
	   ,UTCEVENTDATE 
	)
	INCLUDE
	(
		 SOURCEID
		,EVENTGROUPID
		,EVENTDURATION
		,CATEGORY
		,HEAVYLIGHT
		,ASPECT
		,RESOURCEID
		,EVENTCLASSTYPE
		,USERID
		,EVENTID
		,DESCRIPTION
		,SEVIEWERDBID
		,ROOTNODENAME
		,[PMSTATUS]
	)
	WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
--------------------------------- Transfer indexes --------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_T_RowGuid'
)
BEGIN
	CREATE NONCLUSTERED INDEX idx_T_RowGuid ON APM.EVENT
	(
		 ROWGUID 
	)
	INCLUDE
	(
		HEAVYLIGHT
		,IPID
		,EVENTID 
		,USERID
	)
	WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_T_ResourceIdEventClassTypeDB'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_ResourceIdEventClassTypeDB] ON [APM].[EVENT] 
	(
		  [RESOURCEID] ASC,
		  [EVENTCLASSTYPE] ASC,
		  [SEVIEWERDBID] ASC
	)
	INCLUDE ( [HEAVYLIGHT],
	[ROWGUID],
	[EVENTID],
	[SOURCEID],
	[MACHINEID],
	[EVENTDURATION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_T_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_EventId] ON [APM].[EVENT] 
	(
		[EVENTID] ASC
	)
	INCLUDE ( [SEVIEWERDBID],
	[HEAVYLIGHT],
	[ROWGUID],
	[EXCEPTIONCLASS],
	[DESCRIPTION],
	[EVENTDURATION],
	[SOURCEID],
	[EVENTCLASSTYPE],
	[RESOURCEID]) WITH (SORT_IN_TEMPDB = ON) ON [PRIMARY]
END
GO
----------------------- Event Window Indexes ----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[Event]') AND name = N'idx_W_ResourceDate'
)
BEGIN
	CREATE INDEX idx_W_ResourceDate ON APM.Event 
		(ResourceId, UtcEventDate) 
	INCLUDE(
	  [SourceId],
	  [EventId],
	  [EventDuration],
	  [MACHINEID], 
	  [EVENTCLASSTYPE],
	  [RootNodeName], 
	  [DESCRIPTION], 
	  [CATEGORY], 
	  [ROWGUID], 
	  [Aspect],
	  [HeavyLight],
	  [SEVIEWERDBID], 
	  [SEVIEWEREGID],
	  [USERID],
	  [EVENTGROUPID]
	  ) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[Event]') AND name = N'idx_W_SourceDate'
)
BEGIN
	CREATE INDEX idx_W_SourceDate ON APM.Event 
		(SourceId, UtcEventDate) 
	INCLUDE(
		  [RESOURCEID],
		  [EventId],
		  [EventDuration],
		  [MACHINEID], 
		  [EVENTCLASSTYPE],
		  [RootNodeName],   
		  [DESCRIPTION], 
		  [CATEGORY], 
		  [ROWGUID], 
		  [Aspect],
		  [HeavyLight],
		  [SEVIEWERDBID], 
		  [SEVIEWEREGID],
		  [EVENTGROUPID],
		  [USERID]
	  ) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[Event]') AND name = N'idx_W_RootDate'
)
BEGIN
	CREATE INDEX idx_W_RootDate ON APM.Event 
		(RootNodeName, UTCEVENTDATE) 
	INCLUDE(
	  [SourceId],
	  [MachineId],
	  [RESOURCEID],
	  [EVENTID],
	  [EVENTDURATION], 
	  [EVENTCLASSTYPE], 
	  [DESCRIPTION], 
	  [CATEGORY], 
	  [ROWGUID], 
	  [Aspect], 
	  [Heavylight],
	  [SEVIEWERDBID], 
	  [SEVIEWEREGID],
	  [EVENTGROUPID],
	  [USERID]
	  ) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_W_DescriptionDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_W_DescriptionDate] ON [APM].[EVENT] 
	(
		  [DESCRIPTION] ASC,
		  [UTCEVENTDATE] ASC
	)
		INCLUDE ( [SOURCEID],
		[MACHINEID],
		[RESOURCEID],
		[ROOTNODENAME],
		[CATEGORY],
		[EVENTID],
		[EVENTCLASSTYPE],
		[ROWGUID],
		[ASPECT],
		[HEAVYLIGHT],
		[SEVIEWERDBID],
		[SEVIEWEREGID],
		[USERID]) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_EVENTRESOURCEID                                    */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_EVENTRESOURCEID'
)
BEGIN
	CREATE INDEX FK_EVENTRESOURCEID on APM.EVENT (
		RESOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_EVENTMACHINEID                                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_EVENTMACHINEID'
)
BEGIN
	CREATE INDEX FK_EVENTMACHINEID on APM.EVENT (
		MACHINEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_EVENTSOURCEID                                      */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_EVENTSOURCEID'
)
BEGIN
	CREATE INDEX FK_EVENTSOURCEID on APM.EVENT (
		SOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_IPID                                               */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_IPID'
)
BEGIN
	CREATE INDEX FK_IPID on APM.EVENT (
		IPID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_SEVIEWERDBID                                       */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_SEVIEWERDBID'
)
BEGIN
	CREATE INDEX FK_SEVIEWERDBID on APM.EVENT (
		SEVIEWERDBID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_USERS                                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'FK_USERS'
)
BEGIN
	CREATE INDEX FK_USERS on APM.EVENT (
		USERID ASC
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENT]') AND name = N'idx_SM_PMStatusDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SM_PMStatusDate] ON [APM].[EVENT] 
	(
		[PMSTATUS] ASC,
		[UTCEVENTDATE] ASC
	)
	INCLUDE ( [SEVIEWERDBID],
	[EVENTID])		
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EVENT'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: EVENTGROUP                                            */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.EVENTGROUP'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.EVENTGROUP (
	   EVENTGROUPID         int                  identity,
	   FIRSTEVENTDATE       datetime             null,
	   LASTEVENTDATE        datetime             null,
	   EVENTCLASSTYPE       nvarchar(50)         null,
	   ROOTNODENAME         nvarchar(255)        null,
	   ASPECT               nvarchar(50)         null,
	   HASHVALUE            nvarchar(50)         null,
	   DESCRIPTION          nvarchar(255)        null,
	   SOURCEID             int                  null,
	   constraint PK_EVENTGROUP primary key (EVENTGROUPID)
	)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTGROUP]') AND name = N'idx_EventGroupIdFirstEventDateSource'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventGroupIdFirstEventDateSource] ON [APM].[EVENTGROUP] 
	(
		[EVENTGROUPID] ASC,
		[FIRSTEVENTDATE] ASC,
		[SOURCEID] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
-----------------------Transfer indexed----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTGROUP]') AND name = N'idx_EVENTGROUP_LASTEVENTDATE'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EVENTGROUP_LASTEVENTDATE] ON APM.EVENTGROUP
	(
		[LASTEVENTDATE]
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENTGROUP]') AND name = N'idx_CSEVENTGROUP_LASTEVENTDATE'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_CSEVENTGROUP_LASTEVENTDATE] ON APM.CSEVENTGROUP
	(
		[LASTEVENTDATE]
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTGROUP]') AND name = N'idx_T_hashvalue'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_hashvalue] ON [APM].[EVENTGROUP] 
	(
		[HASHVALUE] ASC
	) INCLUDE (firsteventdate, lasteventdate, sourceid) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTGROUP]') AND name = N'ix_T_hashvalue2'
)
BEGIN
	CREATE NONCLUSTERED INDEX [ix_T_hashvalue2] ON [APM].[EVENTGROUP] 
	(
		[HASHVALUE] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTGROUP]') AND name = N'idx_EventGroupIdFirstEventDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventGroupIdFirstEventDate] ON APM.EVENTGROUP
	(
		[EVENTGROUPID] ASC,
		[FIRSTEVENTDATE] ASC
	)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EVENTGROUP'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: EXCEPTIONNODE                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.EXCEPTIONNODE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.EXCEPTIONNODE (
	   EXCEPTIONNODEID      bigint               identity,
	   EVENTID              bigint               not null,
	   RESOURCEID           int                  null,
	   EXCEPTIONMESSAGE     nvarchar(255)        null,
	   EXCEPTIONCLASS       nvarchar(255)        null,
	   FUNCTIONNAME         nvarchar(255)        null,
	   RESOURCEMETHOD       nvarchar(255)        null,
	   MODULENAME           nvarchar(255)        null,
	   LINENUMBER           bigint               null,
	   DESCRIPTION          nvarchar(255)        null,
	   HASHCODE             nvarchar(255)        null,
	   ENTRYID              int                  null,
	   ROWGUID              nvarchar(15)         null,
	   constraint PK_EXCEPTIONNODE primary key (EXCEPTIONNODEID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_EVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EVENTID] ON [APM].[EXCEPTIONNODE] 
	(
		[EVENTID] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_ResourceExceptionEvent'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_ResourceExceptionEvent] ON [APM].[EXCEPTIONNODE] 
	(
		[RESOURCEID] ASC,
		[EXCEPTIONNODEID] ASC,
		[EVENTID] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_EventIdResource2'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResource2] ON [APM].[EXCEPTIONNODE] 
	(
		[EVENTID] ASC,
		[ResourceId] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON) 
END
GO
----------------------Summary User Analysis Report -------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[ExceptionNode]') AND name = N'idx_EventIdResource'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResource] ON [APM].[ExceptionNode] 
	(
		[EVENTID] ASC,
		[RESOURCEID] ASC
	)
	INCLUDE ( [DESCRIPTION]) WITH (SORT_IN_TEMPDB = ON) 
END
GO
----------------------Transfer indexes ------------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_T_eventIdResourceId'
)
BEGIN
	CREATE INDEX idx_T_eventIdResourceId on APM.exceptionnode(eventid, resourceid) WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_T_rowguid'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_rowguid] ON [APM].[EXCEPTIONNODE] 
	(
		[ROWGUID] ASC
	) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'idx_T_eventId'
)
BEGIN
	CREATE INDEX idx_T_eventId on APM.EXCEPTIONNODE(eventid) 
	INCLUDE(resourceid) WITH (SORT_IN_TEMPDB = ON)
END
GO
----------------------- Event Window indexes ---------------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[ExceptionNode]') AND name = N'idx_W_ResourceMethod'
)
BEGIN
	CREATE INDEX idx_W_ResourceMethod on APM.ExceptionNode (RESOURCEMETHOD) INCLUDE(Eventid) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: IX_XDATA_HASHCODE                                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'IX_XDATA_HASHCODE'
)
BEGIN
	create index IX_XDATA_HASHCODE on APM.EXCEPTIONNODE (
		HASHCODE ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_EXCEPTIONNODERESOURCEID                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'FK_EXCEPTIONNODERESOURCEID'
)
BEGIN
	create index FK_EXCEPTIONNODERESOURCEID on APM.EXCEPTIONNODE (
	RESOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_EXCEPTIONNODEEVENTID                               */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'FK_EXCEPTIONNODEEVENTID'
)
BEGIN
	create index FK_EXCEPTIONNODEEVENTID on APM.EXCEPTIONNODE (
		EVENTID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_EXCEPTIONNODEEVENTIDRESOURCEID                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EXCEPTIONNODE]') AND name = N'FK_EXCEPTIONNODEEVENTIDRESOURCEID'
)
BEGIN
	create index FK_EXCEPTIONNODEEVENTIDRESOURCEID on APM.EXCEPTIONNODE (
	EVENTID ASC,
	RESOURCEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EXCEPTIONNODE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: IP                                                    */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.IP'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.IP (
	   IPID                 int                  identity,
	   IP                   nvarchar(50)         not null,
	   SUBNETC              nvarchar(50)         not null,
	   constraint PK_IP primary key (IPID)
	)
END	
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'IP' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'uniq_ip'
)
BEGIN
	ALTER TABLE APM.ip ADD CONSTRAINT uniq_ip UNIQUE (ip)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[IP]') AND name = N'idx_IP'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_IP] ON [APM].[IP] 
	(
		[IPID] ASC
	)
	INCLUDE ([SUBNETC]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[IP]') AND name = N'idx_IPSubnetC'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_IPSubnetC] ON [APM].[IP] 
	(
		[IPID] ASC,
		[SUBNETC] ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'IP'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: MACHINE                                               */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.MACHINE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.MACHINE (
	   MACHINEID            int                  identity,
	   MACHINE              nvarchar(255)        NOT NULL,
	   WINDOWSVERSION       nvarchar(50)         NULL,
	   AGENTVERSION         nvarchar(50)         NULL,
	   CPUCOUNT             int                  NULL,
	   CONSTRAINT PK_MACHINE primary key (MACHINEID),
	   CONSTRAINT UC_MACHINE_MACHINE UNIQUE (MACHINE)
	)
END	
GO
/*==============================================================*/
/* Index: IX_MACHINE                                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[MACHINE]') AND name = N'IX_MACHINE'
)
BEGIN
	create unique index IX_MACHINE on APM.MACHINE (
		MACHINE ASC
	)
END
GO
/*==============================================================*/
/* Table: MEMBER                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.MEMBER'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.MEMBER (
	   MEMBERID             int                  not null,
	   LOGINNAME            nvarchar(50)         not null,
	   MEMBERPASSWORD       nvarchar(255)        null,
	   FIRSTNAME            nvarchar(50)         null,
	   LASTNAME             nvarchar(50)         null,
	   EMAIL                nvarchar(255)        null,
	   USERDATA             ntext                null,
	   USERTYPE             char(1)              null,
	   constraint PK_MEMBER primary key nonclustered (MEMBERID)
	)
END
GO
/*==============================================================*/
/* Index: IX_LOGINNAME                                          */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[MEMBER]') AND name = N'IX_LOGINNAME'
)
BEGIN
	create unique index IX_LOGINNAME on APM.MEMBER (
		LOGINNAME ASC
	)
END
GO
/*==============================================================*/
/* Table: MEMBERAPPLICATION                                     */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.MEMBERAPPLICATION'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.MEMBERAPPLICATION (
	   MEMBERAPPLICATIONID  int                  not null,
	   APPLICATIONID        int                  null,
	   MEMBERID             int                  null,
	   constraint PK_MEMBERAPPLICATION primary key nonclustered (MEMBERAPPLICATIONID)
	)
END
GO
/*==============================================================*/
/* Index: FK_FK_APPLICATION                                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[MEMBERAPPLICATION]') AND name = N'FK_FK_APPLICATION'
)
BEGIN
	create index FK_FK_APPLICATION on APM.MEMBERAPPLICATION (
		APPLICATIONID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_FK_USER                                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[MEMBERAPPLICATION]') AND name = N'FK_FK_USER'
)
BEGIN
	create index FK_FK_USER on APM.MEMBERAPPLICATION (
		MEMBERID ASC
	)
END
GO
/*==============================================================*/
/* Table: MESSAGES                                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.MESSAGES'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.MESSAGES (
	   ID                   int                  not null,
	   MESSAGE              nvarchar(max)        not null,
	   constraint PK_MESSAGES primary key (ID)
	)
	insert APM.messages values(50002, N'stored procedure %s: sp_xml_preparedocument has returned error code %d ')
	insert APM.messages values(50004, N'There was an error %d. Severity level: %d  Error state: %d Procedure: %s Line: %d Message: %s ')
	INSERT APM.MESSAGES VALUES(50006, N'stored procedure %s: Event with RowGuid %s was not found.')
	INSERT APM.MESSAGES VALUES(50007, N'FillGroups: document is empty.')
	INSERT APM.MESSAGES VALUES(50008, N'FillGroups: Inserted %d resource group.')
	INSERT APM.MESSAGES VALUES(50010, N'FillGroups: Inserted %d resource group node.')
	INSERT APM.MESSAGES VALUES(50011, N'FILLINTERNALRESOURCES: performance events exist without performance nodes.')
	INSERT APM.MESSAGES VALUES(50012, N'FILLINTERNALRESOURCES: exception events exist without exception nodes.')
	INSERT APM.MESSAGES VALUES(50013, N'FILLRESOURCES: #DETAILS is empty.')
	INSERT APM.MESSAGES VALUES(50014, N'FILLRESOURCES: INSERTED INTO RESOURCE %d record(s).')
	INSERT APM.MESSAGES VALUES(50015, N'FILLRESOURCES: heaviest nodes exist.')
	INSERT APM.MESSAGES VALUES(50016, N'FILLRESOURCES: Performance node is missing for the heaviest resource.')
	INSERT APM.MESSAGES VALUES(50017, N'FILLRESOURCES: Created %d performancenode record(s) for missing heaviest nodes.')
	INSERT APM.MESSAGES VALUES(50018, N'FILLRESOURCES: Updated %d performancenode record(s) for resources that contain references to the resource group node.')
	INSERT APM.MESSAGES VALUES(50019, N'FILLRESOURCES: Updated %d performancenode record(s) for resources that do not contains references to the resource group node.')
	INSERT APM.MESSAGES VALUES(50020, N'FILLRESOURCES: Updated %d event record(s). Save references to the top heaviest resource.')
	INSERT APM.MESSAGES VALUES(50021, N'FILLRESOURCES: Updated %d exceptionnode record(s). Save references to the exception method.')
	INSERT APM.MESSAGES VALUES(50022, N'FILLRESOURCES: Updated %d event record(s). Save references to the exception method.')
	INSERT APM.MESSAGES VALUES(50023, N'GROOMINGWORKTABLES: Deleted %d record(s) from %s table.')
	INSERT APM.MESSAGES VALUES(50024, N'CLIENTEVENT_SYNC: Inserted %d record(s) into %s table.')
	INSERT APM.MESSAGES VALUES(50025, N'CLIENTEVENT_SYNC: performance events exist.')
	INSERT APM.MESSAGES VALUES(50026, N'CLIENTEVENT_SYNC: AJAX events exist.')
	INSERT APM.MESSAGES VALUES(50027, N'FILLINTERNALRESOURCES: Resource group nodes were not found.')
	INSERT APM.MESSAGES VALUES(50028, N'FILLINTERNALRESOURCES: Processed %d record(s). Inserted %d record(s) into the performance node table.')
	INSERT APM.MESSAGES VALUES(50029, N'FILLINTERNALRESOURCES: Inserted %d record(s) into the exception node table.')
	INSERT APM.MESSAGES VALUES(50030, N'stored procedure %s: Event with RowGuid %s was not found.')
	INSERT APM.MESSAGES VALUES(50031, N'FILLRESOURCEGROUPNODES: Resource group node is missing.')
	INSERT APM.MESSAGES VALUES(50032, N'%s: Inserted %d record(s) into %s table.')
	INSERT APM.MESSAGES VALUES(50033, N'GroomingWorkTables: package size %d, period(days) %d, reporting grooming date %s.') 
	INSERT APM.MESSAGES VALUES(50034, N'GROOMINGWORKTABLES: pmstatus - %d  lifetime - %d (hours) last keep date - %s.')
	INSERT APM.MESSAGES VALUES(50035, N'FILLINTERNALRESOURCES: rowguid(s) "%s" or "%s" have not been found.')
END
GO
/*==============================================================*/
/* Table: OPERATION                                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.OPERATION'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.OPERATION (
	   OPERATIONID          int                  not null,
	   OPERATIONNAME        nvarchar(50)         not null,
	   REPEATCOUNTONFAILED  int                  not null,
	   constraint PK_OPERATION primary key (OPERATIONID)
	)
	
	insert into APM.operation values(1, 'extraction', 0)
	insert into APM.operation values(2, 'transform', 0)
	insert into APM.operation values(3, 'insert', 0)
	insert into APM.operation values(4, 'update', 0)
	insert into APM.operation values(5, 'aggregate', 0)
	insert into APM.operation values(6, 'grooming', 0)
	insert into APM.operation values(7, 'constraints', 0)
	insert into APM.operation values(8, 'resource', 0)	
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[OPERATION]') AND name = N'OperationName_IX'
)
BEGIN
	CREATE UNIQUE INDEX OperationName_IX ON APM.OPERATION (OperationName)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'OPERATION'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: PCDESCRIPTION                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCDESCRIPTION'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.PCDESCRIPTION (
	   PCDESCRIPTIONID      int                  identity,
	   NAME                 nvarchar(255)        not null,
	   DESCRIPTION          ntext                null,
	   constraint PK_PCDESCRIPTION primary key (PCDESCRIPTIONID)
	)
END
GO
/*==============================================================*/
/* Index: IX_NAME                                               */
/*==============================================================*/
IF NOT EXISTS
(
	SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PCDESCRIPTION]') AND name = N'IX_NAME'
)
BEGIN
	create unique index IX_NAME on APM.PCDESCRIPTION (
	NAME ASC
	)
END
GO
/*==============================================================*/
/* Table: PCPROCESS                                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCPROCESS'), 'IsTable') IS NULL)
  BEGIN
	CREATE TABLE APM.PCPROCESS (
	   PCPROCESSID          int                  identity,
	   PROCESS              nvarchar(255)        NULL,
	   EXTRATYPE            int                  NULL,
	   EXTRAINFO            nvarchar(255)        NULL,
	   HASHVALUE            nvarchar(50)         NULL,
	   CONSTRAINT PK_PCPROCESS primary key (PCPROCESSID),
	   CONSTRAINT UC_PCPROCESS_HASHVALUE UNIQUE (HASHVALUE)
	)
  END
GO
------------------------------ Transfer indexes -------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[pcprocess]') AND name = N'idx_T_hashvalue'
)
BEGIN
	CREATE index idx_T_hashvalue on APM.pcprocess(hashvalue) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PCPROCESS]') AND name = N'idx_PCProcessId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_PCProcessId] ON [APM].[PCPROCESS] 
	(
		[PCPROCESSID]
	)
	INCLUDE
	(
		[EXTRAINFO],
		[PROCESS]
	) 
	WITH (SORT_IN_TEMPDB = OFF)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PCPROCESS'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: PCTYPE                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCTYPE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.PCTYPE (
	   PCTYPEID             int                  identity,
	   TYPE                 nvarchar(255)        NOT NULL,
	   MEASURE              nvarchar(50)         NULL,
	   INSTANCEFUNCTION     nvarchar(50)         NULL,
	   DATEFUNCTION         nvarchar(50)         NULL,
	   CONSTRAINT PK_PCTYPE primary key (PCTYPEID),
	   CONSTRAINT UC_PCTYPE_TYPE UNIQUE (TYPE)
	)
END	
GO
/*==============================================================*/
/* Index: IX_TYPE                                               */
/*==============================================================*/
IF NOT EXISTS
(
	SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PCTYPE]') AND name = N'IX_TYPE'
)
BEGIN
	create unique index IX_TYPE on APM.PCTYPE (
		TYPE ASC
	)
END	
GO
/*==============================================================*/
/* Table: PERFDAILY                                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PERFDAILY'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.PERFDAILY (
	   PERFDAILYID          bigint               identity,
	   PCTYPEID             int                  not null,
	   MACHINEID            int                  not null,
	   SOURCEID             int                  null,
	   PCPROCESSID          int                  null,
	   IS_STATE             int                  null,
	   UTCDATE              datetime             not null,
	   SUMVALUE             decimal(18,4)        not null,
	   AVERAGEVALUE         decimal(18,4)        not null,
	   SAMPLECOUNT          int                  not null,
	   MINVALUE             decimal(18,4)        not null,
	   MAXVALUE             decimal(18,4)        not null,
	   PACKAGECOUNTER       int                  not null
	)
END
GO
/*==============================================================*/
/* Index: IX_CDATE                                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PerfDaily]') AND name = N'IX_CDATE'
)
BEGIN
	CREATE CLUSTERED INDEX IX_CDATE ON APM.PerfDaily
	(
		UTCDATE ASC
	) 
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'PERFDAILY' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'PK_PERFDAILY'
)        
BEGIN
	ALTER TABLE APM.PERFDAILY  ADD CONSTRAINT PK_PERFDAILY PRIMARY KEY (PERFDAILYID)
END    
GO
/*==============================================================*/
/* Index: FK_PERFDAILYMACHINEID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFDAILY]') AND name = N'FK_PERFDAILYMACHINEID'
)
BEGIN
	create index FK_PERFDAILYMACHINEID on APM.PERFDAILY (
	MACHINEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFDAILYSOURCEID                                  */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFDAILY]') AND name = N'FK_PERFDAILYSOURCEID'
)
BEGIN
	create index FK_PERFDAILYSOURCEID on APM.PERFDAILY (
	SOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFDAILYPROCESSID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFDAILY]') AND name = N'FK_PERFDAILYPROCESSID'
)
BEGIN
	create index FK_PERFDAILYPROCESSID on APM.PERFDAILY (
		PCPROCESSID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFDAILYTYPEID                                    */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFDAILY]') AND name = N'FK_PERFDAILYTYPEID'
)
BEGIN
	create index FK_PERFDAILYTYPEID on APM.PERFDAILY (
	PCTYPEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PERFDAILY'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: PERFHOURLY                                            */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PERFHOURLY'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.PERFHOURLY (
	   PERFHOURLYID         bigint               identity,
	   PCTYPEID             int                  not null,
	   MACHINEID            int                  not null,
	   SOURCEID             int                  null,
	   PCPROCESSID          int                  null,
	   IS_STATE             int                  null,
	   UTCDATE              datetime             not null,
	   AVERAGEVALUE         float(53)            not null,
	   MINVALUE             float(53)            not null,
	   MAXVALUE             float(53)            not null,
	   SAMPLECOUNT          bigint               not null,
	   SUMVALUE             float(53)            not null,
	   PACKAGECOUNTER       bigint               not null,
	   HASHVALUE            nvarchar(50)         null
	)
END	
GO
/*==============================================================*/
/* Index: IX_CDATE                                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'IX_CDATE'
)
BEGIN
	CREATE CLUSTERED INDEX IX_CDATE ON APM.PERFHOURLY
	(
		UTCDATE ASC
	) 
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'PERFHOURLY' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'PK_PERFHOURLY'
)        
BEGIN
	ALTER TABLE APM.PERFHOURLY  ADD CONSTRAINT PK_PERFHOURLY PRIMARY KEY (PERFHOURLYID) 
END    
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'IX_AGGREGATE'
)
BEGIN
	CREATE NONCLUSTERED INDEX IX_AGGREGATE ON APM.PERFHOURLY 
	(
		[PCTYPEID] ASC,
		[MACHINEID] ASC,
		[SOURCEID] ASC,
		[PCPROCESSID] ASC,
		[IS_STATE] ASC,
		[UTCDATE] ASC,
		[SUMVALUE] ASC
	)
END
GO
--------------------- Summary Performance &amp; Summary Failure &amp; Problem Distribution ----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_TypeSourceMachineDate'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_TypeSourceMachineDate] ON [APM].[PERFHOURLY] 
	(
		  [PCTYPEID] ASC,
		  [SOURCEID] ASC,
		  [MACHINEID] ASC,
		  [UTCDATE] ASC
	)
	INCLUDE ([SUMVALUE], [MAXVALUE], [SAMPLECOUNT], [PACKAGECOUNTER], [PCPROCESSID]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_DateTypeSourceMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_DateTypeSourceMachine] ON [APM].[PERFHOURLY] 
	(
		  [UTCDATE] ASC,
		  [PCTYPEID] ASC,
		  [SOURCEID] ASC,
		  [MACHINEID] ASC
	)
	INCLUDE ([SUMVALUE], [MAXVALUE], [SAMPLECOUNT], [PACKAGECOUNTER], [PCPROCESSID]) 
	WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_MachineSourceDateType'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_MachineSourceDateType] ON [APM].[PERFHOURLY] 
	(
		[MACHINEID] ASC,
		[SOURCEID] ASC,
		[UTCDATE] ASC,
		[PCTYPEID] ASC
	)
	INCLUDE ( [SAMPLECOUNT],
	[SUMVALUE],
	[MAXVALUE],
	[PACKAGECOUNTER], 
	[PCPROCESSID]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_SourceMachineDateType'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceMachineDateType] ON [APM].[PERFHOURLY] 
	(
		[SOURCEID] ASC,
		[MACHINEID] ASC,
		[UTCDATE] ASC,
		[PCTYPEID] ASC
	)
	INCLUDE ( [SAMPLECOUNT],
	[SUMVALUE],
	[MAXVALUE],
	[PACKAGECOUNTER],
	[PCPROCESSID]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_TypeDateSourceMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_TypeDateSourceMachine] ON [APM].[PERFHOURLY] 
	(
		[PCTYPEID] ASC,
		[UTCDATE] ASC,
		[SOURCEID] ASC,
		[MACHINEID] ASC
	)
	INCLUDE ( [SAMPLECOUNT],
	[SUMVALUE],
	[MAXVALUE],
	[PACKAGECOUNTER], 
	[PCPROCESSID]) 
	WITH (SORT_IN_TEMPDB = ON)
END
GO
--------------------- Application Status -------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_SourceId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceId] ON [APM].[PERFHOURLY] 
	(
		[SOURCEID] ASC
	)
	INCLUDE ([PCPROCESSID]) 
	WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_ProcessId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_ProcessId] ON [APM].[PERFHOURLY] 
	(
		[PCPROCESSID]ASC
	)
	INCLUDE ([SOURCEID]) 
	WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_SourceProcessMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_SourceProcessMachine] ON [APM].[PERFHOURLY] 
	(
		[SOURCEID] ASC,
		[PCPROCESSID] ASC,
		[MACHINEID] ASC
	)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_ProcessSourceMachine'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_ProcessSourceMachine] ON [APM].[PERFHOURLY] 
	(
		[PCPROCESSID] ASC,
		[SOURCEID] ASC,
		[MACHINEID] ASC
	)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_MachineProcessSource'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_MachineProcessSource] ON [APM].[PERFHOURLY] 
	(
		[MACHINEID] ASC,
		[PCPROCESSID] ASC,
		[SOURCEID] ASC
	)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
--------------------- Transfer indexes -----------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'idx_T_hashvalue'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_hashvalue] ON [APM].[PERFHOURLY] 
	(
		[HASHVALUE] ASC
	)
	INCLUDE ( 
	[MINVALUE],
	[MAXVALUE],
	[SAMPLECOUNT],
	[SUMVALUE],
	[PACKAGECOUNTER]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYMACHINEID                                */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYMACHINEID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYMACHINEID on APM.PERFHOURLY (
		MACHINEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYSOURCEID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYSOURCEID'
)
BEGIN
	create index FK_PERFHOURLYSOURCEID on APM.PERFHOURLY (
	SOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYPCTYPEID                                 */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYPCTYPEID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYPCTYPEID on APM.PERFHOURLY (
		PCTYPEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFHOURLYPCPROCESSID                              */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFHOURLY]') AND name = N'FK_PERFHOURLYPCPROCESSID'
)
BEGIN
	CREATE INDEX FK_PERFHOURLYPCPROCESSID on APM.PERFHOURLY (
		PCPROCESSID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PERFHOURLY'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: PERFORMANCENODE                                       */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.PERFORMANCENODE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.PERFORMANCENODE (
	   PERFORMANCENODEID    bigint               identity,
	   EVENTID              bigint               not null,
	   RESOURCEID           int                  null,
	   RESOURCEGROUPNODEID  int                  null,
	   DESCRIPTION          nvarchar(255)        null,
	   FUNCTIONNAME         nvarchar(255)        null,
	   RESOURCEMETHOD       nvarchar(255)        null,
	   DURATION             decimal(35)          not null,
	   HASHCODE             nvarchar(255)        null,
	   ENTRYID              int                  not null,
	   SELFDURATION         decimal(35)          null,
	   ROWGUID              nvarchar(15)         null,
	   ISHEAVIESTNODE       bit              not null,
	   constraint PK_PERFORMANCENODE primary key (PERFORMANCENODEID)
	)
END
GO
IF NOT EXISTS (
	SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'PERFORMANCENODE' AND TABLE_SCHEMA = N'apm' AND COLUMN_NAME = 'IsHeaviestNode' AND COLUMN_DEFAULT IS NOT NULL
)
BEGIN		
	ALTER TABLE APM.PERFORMANCENODE ADD CONSTRAINT DF_PERFORMANCENODE_ISHAVIESTNODE DEFAULT 0 FOR IsHeaviestNode
END	
GO
------------------------ Application Performance index-----------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_EventIdResourceIdSelfDuration1'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceIdSelfDuration1] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID] ASC,
		[RESOURCEID] ASC,
		[SELFDURATION] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_EventIdResourceIdDuration'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceIdDuration] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID] ASC,
		[RESOURCEID] ASC,
		[DURATION] ASC
	)
	INCLUDE ( [RESOURCEMETHOD]) WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Transfer indexes ------------------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performancenode]') AND name = N'idx_T_eventIdResourceId'
)
BEGIN
	CREATE INDEX idx_T_eventIdResourceId on APM.performancenode(eventid, resourceid)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performanceNode]') AND name = N'idx_T_EventIdEntryId'
)
BEGIN
	CREATE INDEX idx_T_EventIdEntryId on APM.performanceNode(EventId, EntryId) WITH (SORT_IN_TEMPDB = ON)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_T_EventId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_T_EventId] ON [APM].[PERFORMANCENODE] 
	(
		[EVENTID]
	)
	INCLUDE ( [PerformanceNodeId],[RESOURCEMETHOD], ResourceGroupNodeId, [EntryId], [RESOURCEID], [SELFDURATION]) 
	WITH (SORT_IN_TEMPDB = ON) 
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[performancenode]') AND name = N'idx_T_RowGuid'
)
BEGIN
	CREATE INDEX idx_T_RowGuid on APM.performancenode(rowguid)  
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'idx_T_ResourceIdEventId'
)
BEGIN
	CREATE INDEX idx_T_ResourceIdEventId ON APM.PERFORMANCENODE 
	(
		 RESOURCEID,
		 EVENTID
	) WITH (SORT_IN_TEMPDB = ON) 
END
GO
----------------------- Event Window Indexes ----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PerformanceNode]') AND name = N'idx_W_EventIdResourceIdSelfDuration2'
)
BEGIN
	CREATE INDEX idx_W_EventIdResourceIdSelfDuration2 on APM.PerformanceNode
	( 
		EventId, ResourceId, SelfDuration Desc
	)
	INCLUDE(
	  [Description],
	  [DURATION],
	  [ENTRYID]
	 ) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODERESOURCEID                          */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODERESOURCEID'
)
BEGIN
	create index FK_PERFORMANCENODERESOURCEID on APM.PERFORMANCENODE (
		RESOURCEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODERESOURCEGROUPID                     */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODERESOURCEGROUPID'
)
BEGIN
	create index FK_PERFORMANCENODERESOURCEGROUPID on APM.PERFORMANCENODE (
		RESOURCEGROUPNODEID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODEEVENTID                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODEEVENTID'
)
BEGIN
	create index FK_PERFORMANCENODEEVENTID on APM.PERFORMANCENODE (
		EVENTID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_PERFORMANCENODEVENTIDRESOURCEID                    */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[PERFORMANCENODE]') AND name = N'FK_PERFORMANCENODEVENTIDRESOURCEID'
)
BEGIN
	CREATE INDEX FK_PERFORMANCENODEVENTIDRESOURCEID on APM.PERFORMANCENODE (
		EVENTID ASC,
		RESOURCEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PERFORMANCENODE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: RELATIVEDATES                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RELATIVEDATES'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RELATIVEDATES (
	   ID                   int                  not null,
	   NAME                 nvarchar(255)        not null,
	   ORDERBY              int                  not null
	)
	INSERT INTO APM.RELATIVEDATES VALUES(0, '', 0)
	INSERT INTO APM.RelativeDates([Id], [Name], [OrderBy])
	SELECT 10, 'This Week: First Day', 6 
		UNION ALL
	SELECT 20, 'This Week: Last Day', 7
		UNION ALL
	SELECT 30, 'Previous Week: First Day', 10
		UNION ALL
	SELECT 40, 'Previous Week: Last Day', 11
		UNION ALL
	SELECT 50, 'This Month: First Day', 4
		UNION ALL
	SELECT 60, 'This Month: Last Day', 5
		UNION ALL
	SELECT 70, 'Previous Month: First Day', 8
		UNION ALL
	SELECT 80, 'Previous Month: Last Day', 9
		UNION ALL
	SELECT 90, 'Today', 1
		UNION ALL
	SELECT 100, 'Yesterday', 2
END	
GO
 
/*==============================================================*/
/* Table: RESOURCE                                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.RESOURCE (
	   RESOURCEID           int                  identity,
	   RESOURCEGROUPID      int                  not null,
	   SOURCEID             int                  not null,
	   RESOURCEURIFORMAT    nvarchar(255)        not null,
	   RESOURCEURI          nvarchar(255)        not null,
	   constraint PK_RESOURCE primary key (RESOURCEID)
	)
END	
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_GroupResourceUri'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_GroupResourceUri] ON [APM].[RESOURCE] 
	(
		[RESOURCEGROUPID] ASC,
		[RESOURCEID] ASC,
		[RESOURCEURI] ASC
	)WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Transfer indexes -----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_T_SourceResourceUri'
)
BEGIN
	CREATE INDEX idx_T_SourceResourceUri ON APM.RESOURCE(sourceId, resourceUri) 
	include(resourceid, resourcegroupid) WITH (SORT_IN_TEMPDB = ON)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_T_ResGroupUri'
)
BEGIN
	CREATE INDEX idx_T_ResGroupUri ON APM.RESOURCE(ResourceGroupId, ResourceUri) include (sourceId, resourceid)
	WITH (SORT_IN_TEMPDB = ON)
END
GO
------------------------ Event WINDOW indexes -----------------------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'idx_W_ResourceUri'
)
BEGIN
	CREATE INDEX idx_W_ResourceUri ON APM.RESOURCE (ResourceUri) INCLUDE(ResourceGroupId) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCERESOURCEGROUPID                            */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'FK_RESOURCERESOURCEGROUPID'
)
BEGIN
	create index FK_RESOURCERESOURCEGROUPID on APM.RESOURCE (
		RESOURCEGROUPID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCESOURCEID                                   */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCE]') AND name = N'FK_RESOURCESOURCEID'
)
BEGIN
	CREATE INDEX FK_RESOURCESOURCEID on APM.RESOURCE (
		SOURCEID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'RESOURCE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: RESOURCEGROUP                                         */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCEGROUP'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RESOURCEGROUP (
	   RESOURCEGROUPID      int                  identity,
	   NAME                 nvarchar(255)        not null,
	   constraint PK_RESOURCEGROUP primary key (RESOURCEGROUPID)
	)
END
GO
/*==============================================================*/
/* Table: RESOURCEGROUPNODE                                     */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.RESOURCEGROUPNODE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.RESOURCEGROUPNODE (
	   RESOURCEGROUPNODEID  int                  identity,
	   EVENTID              bigint               not null,
	   RESOURCEGROUPID      int                  not null,
	   DURATION             bigint               not null,
	   CALLCOUNT            int                  null,
	   constraint PK_RESOURCEGROUPNODE primary key (RESOURCEGROUPNODEID)
	)
END
GO
---------------------- Application Performance index-----------
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'idx_EventIdResourceGroupNodeIdResourceGroupId'
)
BEGIN
	CREATE NONCLUSTERED INDEX [idx_EventIdResourceGroupNodeIdResourceGroupId] ON [APM].[RESOURCEGROUPNODE] 
	(
		[EVENTID] ASC,
		[RESOURCEGROUPNODEID] ASC,
		[RESOURCEGROUPID] ASC
	)
	INCLUDE ( [DURATION]) WITH (SORT_IN_TEMPDB = ON)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCEGROUPNODERESOURCEGROUPID                   */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'FK_RESOURCEGROUPNODERESOURCEGROUPID'
)
BEGIN
	CREATE INDEX FK_RESOURCEGROUPNODERESOURCEGROUPID on APM.RESOURCEGROUPNODE (
		RESOURCEGROUPID ASC
	)
END
GO
/*==============================================================*/
/* Index: FK_RESOURCEGROUPNODEEVENTID                           */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[RESOURCEGROUPNODE]') AND name = N'FK_RESOURCEGROUPNODEEVENTID'
)
BEGIN
	CREATE INDEX FK_RESOURCEGROUPNODEEVENTID on APM.RESOURCEGROUPNODE (
		EVENTID ASC
	)
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'RESOURCEGROUPNODE'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: SEVIEWERDB                                            */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.SEVIEWERDB'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.SEVIEWERDB (
	   SEVIEWERDBID         int                  identity,
	   DATABASEID           uniqueidentifier     not null,
	   ADDRESS              nvarchar(max)        null,
	   constraint PK_SEVIEWERDB primary key (SEVIEWERDBID)
	)
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'SEVIEWERDB' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'database_id_uniq'
)
BEGIN
	ALTER TABLE APM.SEVIEWERDB add constraint database_id_uniq unique(databaseId)
END	
GO
/*==============================================================*/
/* Table: SOURCE                                                */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.SOURCE'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.SOURCE (
	   SOURCEID             int                  identity,
	   SOURCE               nvarchar(255)        NOT NULL,
	   CONSTRAINT PK_SOURCE primary key (SOURCEID),
	   CONSTRAINT UC_SOURCE_SOURCE UNIQUE (SOURCE)
	)
END
GO
/*==============================================================*/
/* Index: IX_SOURCE                                             */
/*==============================================================*/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[SOURCE]') AND name = N'IX_SOURCE'
)
BEGIN
	create unique index IX_SOURCE on APM.SOURCE (
		SOURCE ASC
	)
END
GO
/*==============================================================*/
/* Table: TASKS                                                 */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.TASKS'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.TASKS (
	   TASKID               int                  identity,
	   TABLENAME            nvarchar(50)         not null,
	   STARTDATE            datetime             null,
	   ENDDATE              datetime             null,
	   OPERATIONID          int                  not null,
	   LASTTIMESTAMP        bigint               null,
	   STATUS               nvarchar(50)         null,
	   SEVIEWERDBID         int                  null,
	   constraint PK_TASKS primary key (TASKID)
	)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[TASKS]') AND name = N'idx_T_TableNameDatabase'
)
BEGIN
	CREATE INDEX idx_T_TableNameDatabase ON APM.TASKS
		(tablename, seviewerdbid) INCLUDE(lasttimestamp) 
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'TASKS'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: TIMEZONE                                              */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.TIMEZONE'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE APM.TIMEZONE (
	   NAME                 nvarchar(255)        null,
	   OFFSET               int                  null
	)
	
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-12:00', -720)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-11:00', -660)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-10:00', -600)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-9:00', -540)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-8:00', -480)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-7:00', -420)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-6:00', -360)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-5:00', -300)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-4:00', -240)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-3:30', -210)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-3:00', -180)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-2:00', -120)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-1:00', -60)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-0:00', 0)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+1:00', 60)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+2:00', 120)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+3:00', 180)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+3:30', 210)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+4:00', 240)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+4:30', 270)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:00', 300)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:30', 330)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+5:45', 345)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:00', 360)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:30', 390)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+7:00', 420)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+8:00', 480)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+9:00', 540)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+9:30', 570)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+10:00', 600)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+11:00', 660)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+12:00', 720)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+13:00', 780)
	/* Daylight Saving time zones*/
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT-2:30', -150)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+6:45', 405)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+10:30', 630)
	INSERT INTO APM.TIMEZONE (NAME, OFFSET) VALUES ('GMT+14:00', 840)
END
GO
/*==============================================================*/
/* Table: USERS                                                 */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.USERS'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE APM.USERS (
	   USERID               int                  identity,
	   NAME                 nvarchar(255)        not null,
	   constraint PK_USERS primary key (USERID)
	)
END
GO
IF NOT EXISTS
(
	SELECT * FROM INFORMATION_SCHEMA.table_constraints WHERE TABLE_NAME = N'Users' AND TABLE_SCHEMA = N'apm' AND CONSTRAINT_NAME=N'Name_Unique'
)
BEGIN
	ALTER TABLE [APM].[Users] ADD  CONSTRAINT Name_Unique UNIQUE  (NAME) 
END	
GO
/*==============================================================*/
/* Table: EVENTDETAIL                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.EVENTDETAIL'), 'IsTable') IS NULL)
BEGIN
	CREATE TABLE [APM].[EVENTDETAIL](
		[EVENTDETAILID] [int] IDENTITY(1,1) NOT NULL,
		[EVENTID] [bigint] NULL,
		[NAME] [nvarchar](50) NULL,
		[VALUE] [nvarchar](255) NULL,
		[VALUETYPE] [nvarchar](50) NULL
	 CONSTRAINT [PK_EVENTDETAIL] PRIMARY KEY CLUSTERED 
	(
		[EVENTDETAILID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
END
GO
/****** Object:  Index [IX_EVENTID]    ******/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[EVENTDETAIL]') AND name = N'IX_EVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [IX_EVENTID] ON [APM].[EVENTDETAIL] 
	(
		  [EVENTID] ASC
	)WITH (MAXDOP = 1, SORT_IN_TEMPDB = ON, ONLINE = OFF) ON [PRIMARY]
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EVENTDETAIL'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* Table: CSEVENTDETAIL                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.CSEVENTDETAIL'), 'IsTable') IS NULL)
BEGIN
	 CREATE TABLE [APM].[CSEVENTDETAIL](
		[CSEVENTDETAILID] [int] IDENTITY(1,1) NOT NULL,
		[CSEVENTID] [int] NULL,
		[NAME] [nvarchar](50) NULL,
		[VALUE] [nvarchar](255) NULL,
		[VALUETYPE] [nvarchar](50) NULL
	 CONSTRAINT [PK_CSEVENTDETAIL] PRIMARY KEY CLUSTERED 
	(
		[CSEVENTDETAILID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
END
GO
/****** Object:  Index [[IX_CSEVENTID]]    ******/
IF NOT EXISTS 
(
    SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[apm].[CSEVENTDETAIL]') AND name = N'IX_CSEVENTID'
)
BEGIN
	CREATE NONCLUSTERED INDEX [IX_CSEVENTID] ON [APM].[CSEVENTDETAIL] 
	(
		  [CSEVENTID] ASC
	)WITH (MAXDOP = 1, SORT_IN_TEMPDB = ON, ONLINE = OFF) ON [PRIMARY]
END
GO
EXEC DomainTableRegisterIndexOptimization
       @TableName = 'CSEVENTDETAIL'
      ,@SchemaName = 'APM'
      ,@DatasetId = '$Config/DatasetId$'
GO
/*==============================================================*/
/* View: V_APPLICATIONSOURCEMACHINE                             */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_APPLICATIONSOURCEMACHINE'), 'IsView') IS NULL) 
BEGIN
    EXECUTE('CREATE VIEW APM.V_APPLICATIONSOURCEMACHINE
				AS				
				select clmn=1')
END
GO
ALTER VIEW APM.V_APPLICATIONSOURCEMACHINE as
SELECT A.APPLICATIONID, B.SOURCEID, M.MACHINEID, A.APPLICATION, B.SOURCE, M.MACHINE AS MACHINENAME
FROM APM.APPLICATION A 
    INNER JOIN APM.APPLICATIONSOURCEMACHINE C ON A.APPLICATIONID = C.APPLICATIONID
    LEFT JOIN APM.SOURCE B ON B.SOURCEID = C.SOURCEID 
    LEFT JOIN APM.MACHINE M ON M.MACHINEID = C.MACHINEID
GO
/*==============================================================*/
/* View: V_EVENTWINDOW                                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_EVENTWINDOW'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_EVENTWINDOW
				AS				
				select clmn=1')
END
GO
ALTER VIEW APM.V_EVENTWINDOW as
SELECT E.EVENTID, E.EVENTGROUPID, E.CATEGORY, E.DESCRIPTION, E.EVENTDURATION, E.ROOTNODENAME,
    E.UTCEVENTDATE, E.EVENTCLASSTYPE, E.ASPECT,E.EXCEPTIONCLASS, E.RESOURCEID, E.ROWGUID, E.HEAVYLIGHT,E.SEVIEWEREGID,
    S.SOURCE, S.SOURCEID, M.MACHINE, M.MACHINEID, SDB.ADDRESS AS PATH,
    E.USERID,USR.NAME AS USERNAME, E.PMSTATUS
FROM APM.EVENT (NOLOCK) AS E  INNER JOIN APM.SOURCE AS S ON S.SOURCEID=E.SOURCEID
    INNER JOIN APM.MACHINE (NOLOCK) AS M ON M.MACHINEID=E.MACHINEID
    INNER JOIN APM.SEVIEWERDB (NOLOCK) AS SDB ON SDB.SEVIEWERDBID=E.SEVIEWERDBID
    LEFT JOIN APM.USERS (NOLOCK) AS USR ON E.USERID=USR.USERID
GO
/* foreign key to trace */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMSERVEREVENTTRACE_PMTRACE')
BEGIN
	ALTER TABLE APM.PMSERVEREVENTTRACE ADD CONSTRAINT FK_PMSERVEREVENTTRACE_PMTRACE FOREIGN KEY (PMTRACEID) REFERENCES APM.PMTRACE(PMTRACEID)
END 
GO
/* foreign key to event delete cascade */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMSERVEREVENTTRACE_PMEVENT')
BEGIN
	ALTER TABLE APM.PMSERVEREVENTTRACE ADD CONSTRAINT FK_PMSERVEREVENTTRACE_PMEVENT FOREIGN KEY (EVENTID) REFERENCES APM.EVENT(EVENTID) ON DELETE CASCADE
END 
GO
GO
/* foreign key to trace */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMCLIENTEVENTTRACE_PMTRACE')
BEGIN
	ALTER TABLE APM.PMCLIENTEVENTTRACE ADD CONSTRAINT FK_PMCLIENTEVENTTRACE_PMTRACE FOREIGN KEY (PMTRACEID) REFERENCES APM.PMTRACE(PMTRACEID)
END 
GO
/* foreign key to csevent delete cascade */
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PMCLIENTEVENTTRACE_PMEVENT')
BEGIN
	ALTER TABLE APM.PMCLIENTEVENTTRACE ADD CONSTRAINT FK_PMCLIENTEVENTTRACE_PMEVENT FOREIGN KEY (CSEVENTID) REFERENCES APM.CSEVENT(CSEVENTID) ON DELETE CASCADE
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENTDET_REFERENCE_EVENT')
BEGIN
	ALTER TABLE [APM].[EVENTDETAIL]  WITH CHECK ADD  CONSTRAINT [FK_EVENTDET_REFERENCE_EVENT] FOREIGN KEY([EVENTID])
	REFERENCES [APM].[EVENT] ([EVENTID])
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENTDET_REFERENCE_CSEVENT')
BEGIN
	ALTER TABLE [APM].[CSEVENTDETAIL]  WITH CHECK ADD  CONSTRAINT [FK_CSEVENTDET_REFERENCE_CSEVENT] FOREIGN KEY([CSEVENTID])
	REFERENCES [APM].[CSEVENT] ([CSEVENTID])
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_APPLIC_APPLICAT')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_APPLIC_APPLICAT foreign key (APPLICATIONID)
		  references APM.APPLICATION (APPLICATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_MACHIN_MACHINE')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_MACHIN_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_APPLICAT_FK_SOURCE_SOURCE')
BEGIN
	alter table APM.APPLICATIONSOURCEMACHINE
	   add constraint FK_APPLICAT_FK_SOURCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSAJAX_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSAJAX
	   add constraint FK_CSAJAX_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSASYNCA_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSASYNCAJAX
	   add constraint FK_CSASYNCA_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_MACHINE')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_SOURCE')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_CSEVENTG')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_CSEVENTG foreign key (CSEVENTGROUPID)
		  references APM.CSEVENTGROUP (CSEVENTGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSEVENT_REFERENCE_IP')
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_REFERENCE_IP foreign key (IPID)
		  references APM.IP (IPID)
END 
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSEVENT_USERS'
)
BEGIN
	alter table APM.CSEVENT
	   add constraint FK_CSEVENT_USERS foreign key (USERID)
		  references APM.USERS (USERID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSEXEVEN_REFERENCE_CSEVENT'
)
BEGIN
	alter table APM.CSEXEVENT
	   add constraint FK_CSEXEVEN_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END
GO
IF NOT EXISTS 
(
    SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = N'FK_CSHEAVIE_REFERENCE_CSEVENT'
)
BEGIN
	alter table APM.CSHEAVIESTRESOURCE
	   add constraint FK_CSHEAVIE_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSJSCRIP_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSJSCRIPTEVENT
	   add constraint FK_CSJSCRIP_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPAGEEV_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSPAGEEVENT
	   add constraint FK_CSPAGEEV_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPERIPH_REFERENCE_CSEVENT')
BEGIN
	alter table APM.CSPERIPHERAL
	   add constraint FK_CSPERIPH_REFERENCE_CSEVENT foreign key (CSEVENTID)
		  references APM.CSEVENT (CSEVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_CSPERIPH_REFERENCE_CSPERIPH')
BEGIN
	alter table APM.CSPERIPHERALDETAIL
	   add constraint FK_CSPERIPH_REFERENCE_CSPERIPH foreign key (CSPERIPHERALID)
		  references APM.CSPERIPHERAL (CSPERIPHERALID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_DATASET_AGGREGATION')
BEGIN
	alter table APM.DATASET
	   add constraint FK_DATASET_AGGREGATION foreign key (AGGREGATIONTYPEID)
		  references APM.AGGREGATIONTYPE (AGGREGATIONTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_DATASET_HISTORY')
BEGIN
	alter table APM.DATASETAGGREGATIONHISTORY
	   add constraint FK_DATASET_HISTORY foreign key (DATASETID)
		  references APM.DATASET (DATASETID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENTG_EVENTGRO')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENTG_EVENTGRO foreign key (EVENTGROUPID)
		  references APM.EVENTGROUP (EVENTGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENT__IP')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENT__IP foreign key (IPID)
		  references APM.IP (IPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_EVENT__SEVIEWER')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_EVENT__SEVIEWER foreign key (SEVIEWERDBID)
		  references APM.SEVIEWERDB (SEVIEWERDBID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_FK_SOURCE_SOURCE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_FK_SOURCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_REFERENCE_MACHINE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_REFERENCE_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_REFERENCE_RESOURCE')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EVENT_USERS')
BEGIN
	alter table APM.EVENT
	   add constraint FK_EVENT_USERS foreign key (USERID)
		  references APM.USERS (USERID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EXCEPTIO_FK_EXCEPT_EVENT')
BEGIN
	alter table APM.EXCEPTIONNODE
	   add constraint FK_EXCEPTIO_FK_EXCEPT_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_EXCEPTIO_REFERENCE_RESOURCE')
BEGIN
	alter table APM.EXCEPTIONNODE
	   add constraint FK_EXCEPTIO_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_MEMBERAP_FK_APPLIC_APPLICAT')
BEGIN
	alter table APM.MEMBERAPPLICATION
	   add constraint FK_MEMBERAP_FK_APPLIC_APPLICAT foreign key (APPLICATIONID)
		  references APM.APPLICATION (APPLICATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_MEMBERAP_FK_USER_MEMBER')
BEGIN
	alter table APM.MEMBERAPPLICATION
	   add constraint FK_MEMBERAP_FK_USER_MEMBER foreign key (MEMBERID)
		  references APM.MEMBER (MEMBERID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_TYPE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_TYPE foreign key (PCTYPEID)
		  references APM.PCTYPE (PCTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_MACHINE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAYLY_SOURCE')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAYLY_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFDAIL_REFERENCE_PCPROCES')
BEGIN
	alter table APM.PERFDAILY
	   add constraint FK_PERFDAIL_REFERENCE_PCPROCES foreign key (PCPROCESSID)
		  references APM.PCPROCESS (PCPROCESSID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_PCTYPE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_PCTYPE foreign key (PCTYPEID)
		  references APM.PCTYPE (PCTYPEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_MACHINE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_MACHINE foreign key (MACHINEID)
		  references APM.MACHINE (MACHINEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOURLY_SOURCE')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOURLY_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFHOUR_REFERENCE_PCPROCES')
BEGIN
	alter table APM.PERFHOURLY
	   add constraint FK_PERFHOUR_REFERENCE_PCPROCES foreign key (PCPROCESSID)
		  references APM.PCPROCESS (PCPROCESSID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMANCENODE_EVENT')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMANCENODE_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMA_REFERENCE_RESOURCEGROUP')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMA_REFERENCE_RESOURCEGROUP foreign key (RESOURCEGROUPNODEID)
		  references APM.RESOURCEGROUPNODE (RESOURCEGROUPNODEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_PERFORMA_REFERENCE_RESOURCE')
BEGIN
	alter table APM.PERFORMANCENODE
	   add constraint FK_PERFORMA_REFERENCE_RESOURCE foreign key (RESOURCEID)
		  references APM.RESOURCE (RESOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_RESOURCE')
BEGIN
	alter table APM.RESOURCE
	   add constraint FK_RESOURCE_REFERENCE_RESOURCE foreign key (RESOURCEGROUPID)
		  references APM.RESOURCEGROUP (RESOURCEGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_SOURCE')
BEGIN
	alter table APM.RESOURCE
	   add constraint FK_RESOURCE_REFERENCE_SOURCE foreign key (SOURCEID)
		  references APM.SOURCE (SOURCEID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_RESOURCENODE')
BEGIN
	alter table APM.RESOURCEGROUPNODE
	   add constraint FK_RESOURCE_REFERENCE_RESOURCENODE foreign key (RESOURCEGROUPID)
		  references APM.RESOURCEGROUP (RESOURCEGROUPID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_RESOURCE_REFERENCE_EVENT')
BEGIN
	alter table APM.RESOURCEGROUPNODE
	   add constraint FK_RESOURCE_REFERENCE_EVENT foreign key (EVENTID)
		  references APM.EVENT (EVENTID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_TASKS_TaskMode')
BEGIN
	alter table APM.TASKS
	   add constraint FK_TASKS_TaskMode foreign key (OPERATIONID)
		  references APM.OPERATION (OPERATIONID)
END 
GO
if NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = 'FK_TASKS_REFERENCE_SEVIEWER')
BEGIN
	alter table APM.TASKS
	   add constraint FK_TASKS_REFERENCE_SEVIEWER foreign key (SEVIEWERDBID)
		  references APM.SEVIEWERDB (SEVIEWERDBID)
END 
GO
/*==============================================================*/
/* Common security reporting functions                          */
/*==============================================================*/
IF (OBJECTPROPERTY(OBJECT_ID('APM.FN_ADMINUSER'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.FN_ADMINUSER ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/*==============================================================*/
/* Function: FN_ADMINUSER                                       */
/*==============================================================*/
ALTER FUNCTION APM.FN_ADMINUSER(@USERNAME NVARCHAR(100))  
RETURNS INT AS  
BEGIN  
  DECLARE @A INT 
  SET @A = (SELECT MEMBERID FROM APM.MEMBER WHERE LOGINNAME = @USERNAME AND USERTYPE='a')
  RETURN @A
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FN_ISSECURE'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.FN_ISSECURE ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/*==============================================================*/
/* Function: FN_ISSECURE                                        */
/*==============================================================*/
ALTER FUNCTION APM.FN_ISSECURE ()  
RETURNS INT AS  
BEGIN  
    DECLARE @A INT
    SELECT @A = CAST(CAST(CONFIGVALUE AS NCHAR)  AS INT) FROM APM.CONFIG WHERE CONFIGNAME = 'SECURITYMODE'
    RETURN @A
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATASETAGGREGATE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.DATASETAGGREGATE AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.DATASETAGGREGATE
   @DATASETNAME NVARCHAR(50)
  ,@DESCRIPTORS NTEXT
  ,@AGGREGATIONTARGETSTARTDATETIME DATETIME = NULL
  ,@INTERVALSTOAGGREGATE INT = NULL
  ,@RETURN BIT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE
     @DATASETID INT
    ,@AGGREGATIONINTERVALCOUNT INT
    ,@LASTMIDNIGHTDATETIME DATETIME
    ,@CURRENTAGGREGATIONSTARTDELAYMINUTES INT
    ,@CURRENTAGGREGATIONTYPEID TINYINT
    ,@CURRENTAGGREGATIONINTERVALDURATIONMINUTES INT
    ,@INTERVALSTARTDATETIME DATETIME
    ,@INTERVALENDDATETIME DATETIME
    ,@DATASETAGGREGATIONHISTORYID INT
    ,@I INT
    ,@AGGREGATIONSTARTDATETIME DATETIME
    ,@STATEMENT NVARCHAR(255)
    ,@UTCOFFSETMINUTES INT
    ,@MAXDATAAGEDAYS INT    
    ,@MAXHISTORYDATE DATETIME
  DECLARE
     @ERROR INT
  SET @UTCOFFSETMINUTES = DATEDIFF(MINUTE, GETDATE(), GETUTCDATE())
    
  SELECT
    @DATASETID                = DATASETID, 
    @AGGREGATIONINTERVALCOUNT = ISNULL(@INTERVALSTOAGGREGATE, DEFAULTAGGREGATIONINTERVALCOUNT),
    @CURRENTAGGREGATIONTYPEID = AGTYPE.AGGREGATIONTYPEID,
    @CURRENTAGGREGATIONINTERVALDURATIONMINUTES = AGTYPE.AGGREGATIONINTERVALDURATIONMINUTES,
    @CURRENTAGGREGATIONSTARTDELAYMINUTES = AGTYPE.AGGREGATIONSTARTDELAYMINUTES,
    @STATEMENT = AGGREGATIONMETHODNAME
  FROM APM.DATASET DATASET
    JOIN APM.AGGREGATIONTYPE AGTYPE ON AGTYPE.AGGREGATIONTYPEID = DATASET.AGGREGATIONTYPEID
  WHERE DATASET.DATASETNAME = @DATASETNAME
   SET @ERROR = 0
              
    IF (@AGGREGATIONINTERVALCOUNT &lt; 1)
      SET @AGGREGATIONINTERVALCOUNT = 1
      
    IF (@AGGREGATIONTARGETSTARTDATETIME IS NULL)
      SET @AGGREGATIONTARGETSTARTDATETIME = GETUTCDATE()
      
    -- FIND THE LAST AGGREGATION INTERVAL WHICH ENDED BEFORE
    -- THE AGGREGATION START DATE TIME
    IF (@CURRENTAGGREGATIONTYPEID &lt; 30)
    BEGIN
      --HOURLY AGGREGATION
      SET @LASTMIDNIGHTDATETIME = CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME)
      SET @INTERVALSTARTDATETIME = DATEADD(
             MINUTE
            ,ABS(DATEDIFF(MINUTE, @LASTMIDNIGHTDATETIME, @AGGREGATIONTARGETSTARTDATETIME)) / @CURRENTAGGREGATIONINTERVALDURATIONMINUTES * @CURRENTAGGREGATIONINTERVALDURATIONMINUTES - @CURRENTAGGREGATIONINTERVALDURATIONMINUTES
            ,CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME))
    END
    ELSE IF (@CURRENTAGGREGATIONTYPEID = 30)
    BEGIN
      --DAILY AGGREGATION
--      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), GETDATE(), 112) AS DATETIME))
      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), @AGGREGATIONTARGETSTARTDATETIME, 112) AS DATETIME))
    END
    SET @I = @AGGREGATIONINTERVALCOUNT
    DECLARE @AGGREGATION TABLE
    (
      AGGREGATIONDATETIME  DATETIME  NOT NULL,
      AGGREGATIONTYPEID BIT NOT NULL
    )     
    WHILE (@I &gt; 0)
    BEGIN
      INSERT @AGGREGATION(AGGREGATIONDATETIME, AGGREGATIONTYPEID)
        VALUES (@INTERVALSTARTDATETIME, @CURRENTAGGREGATIONTYPEID)
      
      SET @I = @I - 1
      SET @INTERVALSTARTDATETIME = DATEADD(MINUTE, -@CURRENTAGGREGATIONINTERVALDURATIONMINUTES, @INTERVALSTARTDATETIME)
    END
        
    -- GROOM AGGREGATION HISTORY
    SELECT @MAXDATAAGEDAYS = ISNULL(MAXDATAAGEDAYS, 30) 
    FROM DATASET WHERE DATASETID = @DATASETID 
    SELECT @MAXHISTORYDATE = DATEADD(DD, -@MAXDATAAGEDAYS, ISNULL(MAX(AGGREGATIONDATETIME), GETUTCDATE())) 
    FROM DATASETAGGREGATIONHISTORY WHERE DIRTYIND = 0 AND DATASETID = @DATASETID
    
    DELETE DATASETAGGREGATIONHISTORY       
      WHERE (AGGREGATIONDATETIME &lt; @MAXHISTORYDATE) AND (DIRTYIND = 0)
    
    INSERT APM.DATASETAGGREGATIONHISTORY (
       DATASETID
      ,AGGREGATIONDATETIME
    )
    SELECT
       @DATASETID
      ,A.AGGREGATIONDATETIME
    FROM @AGGREGATION A
    WHERE NOT EXISTS (SELECT * FROM APM.DATASETAGGREGATIONHISTORY
                      WHERE (DATASETID = @DATASETID)
                        AND (AGGREGATIONDATETIME = A.AGGREGATIONDATETIME)
                     )
    
    
    -- SELECT AGGREGATION PERIOD TO WORK ON
    -- FIRST SELECT OLDEST NEVER AGGREGATED INTERVAL
    -- IF NONE EXIST SELECT OLDEST DIRTY INTERVAL
    SELECT TOP 1
       @DATASETAGGREGATIONHISTORYID = DATASETAGGREGATIONHISTORYID
      ,@INTERVALSTARTDATETIME = AH.AGGREGATIONDATETIME
      ,@INTERVALENDDATETIME = DATEADD(MINUTE, @CURRENTAGGREGATIONINTERVALDURATIONMINUTES, AH.AGGREGATIONDATETIME)
    FROM APM.DATASETAGGREGATIONHISTORY AH
    WHERE (AH.DATASETID = @DATASETID)
      AND (DATEADD(MINUTE, @CURRENTAGGREGATIONINTERVALDURATIONMINUTES + @CURRENTAGGREGATIONSTARTDELAYMINUTES, AH.AGGREGATIONDATETIME) &lt; GETUTCDATE()) -- AGGREGATION INTERVAL + SLIGHT DELAY IS IN THE PAST
      AND (DIRTYIND = 1)
    ORDER BY AH.AGGREGATIONDATETIME ASC
            
    IF (@RETURN = 1) 
    BEGIN
      CREATE TABLE #DATASETAGGREGATETABLE 
      (
        UTCDATE      DATETIME
       ,PCTYPEID     INT
       ,MACHINEID    INT
       ,SOURCEID     INT
       ,PCPROCESSID  INT 
       ,IS_STATE     INT 
       ,AVERAGEVALUE DECIMAL(18, 4)
       ,SUMVALUE     DECIMAL(18, 4)
       ,MINVALUE     DECIMAL(18, 4)
       ,MAXVALUE     DECIMAL(18, 4)
       ,SAMPLECOUNT  INT
       ,PACKAGECOUNTER INT      
      )
      SET @ERROR = @@ERROR
    
      IF (@ERROR &lt;&gt; 0) 
    GOTO ERRORQUIT
    END
 
    IF (@DATASETAGGREGATIONHISTORYID IS NOT NULL)
    BEGIN
      DECLARE @SQL NVARCHAR(1000)
      SET @SQL = 
        N'EXEC APM.' + QUOTENAME(@STATEMENT) + 
        '
          @DESCRIPTORS 
         ,@INTERVALSTARTDATETIME
         ,@INTERVALENDDATETIME                      
        '
      IF (@RETURN = 1)
        SET @SQL = N'INSERT INTO #DATASETAGGREGATETABLE ' + @SQL
        
      EXECUTE SP_EXECUTESQL @SQL, N'@DESCRIPTORS ntext, @INTERVALSTARTDATETIME datetime, @INTERVALENDDATETIME datetime',
         @DESCRIPTORS,
         @INTERVALSTARTDATETIME,
         @INTERVALENDDATETIME
      SET @ERROR = @@ERROR
      IF (@ERROR = 0)
      BEGIN      
        -- UPDATE AGGREGATION HISTORY
        UPDATE DATASETAGGREGATIONHISTORY
        SET DIRTYIND = 0
        WHERE (DATASETID = @DATASETID)
          AND (AGGREGATIONDATETIME = @INTERVALSTARTDATETIME)
      END
    END
    IF (@RETURN = 1)
      SELECT * FROM #DATASETAGGREGATETABLE
   ERRORQUIT:
     RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCOUNTERAGGREGATE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCOUNTERAGGREGATE AS RETURN 1')
  END
GO
alter PROCEDURE APM.PCOUNTERAGGREGATE
   @DESCRIPTORS NTEXT 
  ,@INTERVALSTARTDATETIME DATETIME
  ,@INTERVALENDDATETIME DATETIME
AS
BEGIN
  SET NOCOUNT ON
  DECLARE @ERROR INT
  SET @ERROR = 0
  CREATE TABLE #PCOUNTERAGGREGATE_TMP (PCTYPEID INT, MACHINEID INT, PACKAGECOUNTER INT) 
  INSERT INTO  #PCOUNTERAGGREGATE_TMP(PCTYPEID, MACHINEID, PACKAGECOUNTER)  
    SELECT 
        P.PCTYPEID,
        P.MACHINEID,
        COUNT(DISTINCT P.UTCDATE) PACKAGE_COUNT
    FROM 
        PERFHOURLY P WITH (NOLOCK)      
        JOIN PCTYPE T WITH (NOLOCK) ON T.PCTYPEID = P.PCTYPEID AND
                T.TYPE IN (
                    N'\Processor\% Processor Time', 
                    N'\PROCESS\PRIVATE BYTES', 
                    N'\PROCESS\IO DATA BYTES/SEC'
                    )
    WHERE 
        (COALESCE(P.SUMVALUE, 0) &lt;&gt; 0) 
        AND (P.UTCDATE &gt;= @INTERVALSTARTDATETIME)
        AND (P.UTCDATE &lt; @INTERVALENDDATETIME)    
    GROUP BY
        P.PCTYPEID, 
        P.MACHINEID
   INSERT PERFDAILY (
       UTCDATE
      ,PCTYPEID
      ,MACHINEID
      ,SOURCEID
      ,PCPROCESSID 
      ,IS_STATE
      ,AVERAGEVALUE
      ,SUMVALUE
      ,MINVALUE
      ,MAXVALUE
      ,SAMPLECOUNT
      ,PACKAGECOUNTER
      )
      SELECT
       @INTERVALSTARTDATETIME 
       ,P.PCTYPEID
       ,P.MACHINEID
       ,P.SOURCEID
       ,P.PCPROCESSID  
       ,P.IS_STATE  
       ,AVG(P.SUMVALUE) 
       ,SUM(P.SUMVALUE) 
       ,MIN(P.SUMVALUE)
       ,MAX(P.SUMVALUE)
       ,COUNT(*)
       ,MIN(PACK.PACKAGECOUNTER)
      FROM 
        APM.PERFHOURLY P
        JOIN #PCOUNTERAGGREGATE_TMP PACK ON PACK.MACHINEID = P.MACHINEID AND PACK.PCTYPEID = P.PCTYPEID
      WHERE 
        (COALESCE(P.SUMVALUE, 0) &lt;&gt; 0) 
        AND (P.UTCDATE &gt;= @INTERVALSTARTDATETIME)
        AND (P.UTCDATE &lt; @INTERVALENDDATETIME)    
      GROUP BY 
         P.PCTYPEID 
        ,P.MACHINEID
        ,P.SOURCEID
        ,P.PCPROCESSID  
        ,P.IS_STATE 
  
  QUIT:
  QUITERROR:
    RETURN @ERROR 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.RUNDAILYAGGREGATEOPERATION'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.RUNDAILYAGGREGATEOPERATION AS RETURN 1')
  END
GO
ALTER   PROCEDURE APM.RUNDAILYAGGREGATEOPERATION
   @DATASETNAME NVARCHAR(50)
  ,@DESCRIPTORS NTEXT
  ,@AGGREGATIONTARGETSTOPDATETIME DATETIME
  ,@TRACELEVEL INT 
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
    @ERROR INT
   ,@STARTDATE DATETIME
   ,@ENDDATE DATETIME
   ,@STEPCOUNT INT
   ,@MAXDAILYDATAAGEDAYS INT
   ,@MAXHOURLYDATAAGEDAYS INT
   ,@MAXDAILYHISTORYDATE DATETIME   
   ,@MAXHOURLYHISTORYDATE DATETIME
   ,@UTCOFFSETMINUTES INT
   ,@UTCDATETIME DATETIME
   ,@CHECKDATE DATETIME
   ,@HANDLER INT
   ,@ROWCOUNT INT
   ,@RESLOCK BIT
    SET @RESLOCK = 0
    EXECUTE  @ERROR = SP_GETAPPLOCK  
               @RESOURCE = N'RUNDAILYAGGREGATEOPERATION' 
              ,@LOCKMODE =  N'Exclusive'
              ,@LOCKOWNER =  N'Session'
              ,@LOCKTIMEOUT =  '0' 
    
    IF @ERROR = 0 
      SET @RESLOCK = 1  
    IF @ERROR &lt;&gt; 0 
    BEGIN
      IF @ERROR = -1 SET @ERROR = 0 
      GOTO QUIT 
    END
    SET @ERROR = 0 
  SET @UTCOFFSETMINUTES = DATEDIFF(MINUTE, GETDATE(), GETUTCDATE())
  SELECT 
    @ENDDATE   = MAX(UTCDATE) 
  FROM 
    PERFHOURLY WITH (NOLOCK)
  WHERE 
    UTCDATE &lt; @AGGREGATIONTARGETSTOPDATETIME
  SET @ENDDATE = ISNULL(@ENDDATE, '19010101')
  SET @UTCDATETIME = DATEADD(MINUTE, @UTCOFFSETMINUTES, CAST(CONVERT(CHAR(8), @ENDDATE, 112) AS DATETIME))
  SET @ENDDATE = DATEADD(HH,DATEPART(HH, @UTCDATETIME), CAST(CONVERT(CHAR(8), @ENDDATE, 112) AS DATETIME))
  SELECT @STARTDATE = MAX(H.AGGREGATIONDATETIME)  
     FROM APM.DATASETAGGREGATIONHISTORY H
    JOIN DATASET D ON D.DATASETID = H.DATASETID AND D.DATASETNAME = @DATASETNAME
       WHERE H.DIRTYIND = 0
  IF @STARTDATE IS NULL 
  BEGIN
    SELECT @STARTDATE   = MIN(UTCDATE) 
      FROM PERFHOURLY WITH (NOLOCK)
       WHERE UTCDATE &lt; @AGGREGATIONTARGETSTOPDATETIME
  END    
  SET @STARTDATE = ISNULL(@STARTDATE, '19010101')
  SET @STARTDATE = DATEADD(DD, -1, @STARTDATE)
  SET @STEPCOUNT = ISNULL(DATEDIFF(DD, @STARTDATE, @ENDDATE), 0)
  SET @CHECKDATE = DATEADD(HH,DATEPART(HH, @UTCDATETIME), CAST(CONVERT(CHAR(8), @STARTDATE, 112) AS DATETIME)) 
  WHILE (DATEADD(DD, @STEPCOUNT + 1, @CHECKDATE) &gt; @ENDDATE) 
  BEGIN
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  SET @ENDDATE = DATEADD(DD, -1, @ENDDATE)
  
  IF (@STEPCOUNT &gt; 0)
  BEGIN
    EXEC APM.DATASETAGGREGATE
       @DATASETNAME
      ,@DESCRIPTORS
      ,@AGGREGATIONTARGETSTARTDATETIME = @ENDDATE
      ,@INTERVALSTOAGGREGATE = @STEPCOUNT
      ,@RETURN = 0      
    SET @ERROR = @@ERROR
    IF (@ERROR &lt;&gt; 0)
    GOTO QUIT
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  WHILE (@STEPCOUNT &gt; 0)
  BEGIN
    EXEC APM.DATASETAGGREGATE
       @DATASETNAME
      ,@DESCRIPTORS
      ,@AGGREGATIONTARGETSTARTDATETIME = @ENDDATE
      ,@INTERVALSTOAGGREGATE = 1
      ,@RETURN = 0      
    IF (@ERROR &lt;&gt; 0)
    GOTO QUIT     
    SET @STEPCOUNT = @STEPCOUNT - 1
  END
  
  SET @ERROR = @@ERROR
  QUIT:
    IF @RESLOCK = 1 
    BEGIN
      EXECUTE SP_RELEASEAPPLOCK 
                 @RESOURCE = N'RUNDAILYAGGREGATEOPERATION'
                ,@LOCKOWNER =  N'Session'   
    END 
    RETURN @ERROR                   
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.HourlyTableInit'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.HourlyTableInit AS RETURN 1')
  END
GO
alter procedure APM.HourlyTableInit
as 
begin
  declare 
    @DATE as datetime
   ,@ITERATOR as int
  
  set @ITERATOR = 1
  set @DATE = '19000101'
  while @ITERATOR &lt;= 24 
  begin
    insert into APM.HourlyTable Values(@DATE)
    set @DATE = dateadd(hh, 1, @DATE)  
    set @ITERATOR = @ITERATOR + 1
  end
end
GO
exec APM.HourlyTableInit
GO
drop procedure APM.HourlyTableInit
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.DISABLE_FOREIGN_KEYS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.DISABLE_FOREIGN_KEYS AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.DISABLE_FOREIGN_KEYS
    @DISABLE BIT = 1
AS
BEGIN
DECLARE
    @SQL NVARCHAR(500),
    @TABLENAME NVARCHAR(128),
    @FOREIGNKEYNAME NVARCHAR(128)
-- A LIST OF ALL OF THE FOREIGN KEYS AND THE TABLE NAMES
DECLARE FOREIGNKEYCURSOR CURSOR
    FOR
    SELECT
        REF.CONSTRAINT_NAME AS FK_NAME,
        FK.TABLE_NAME AS FK_TABLE
      FROM
        INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS REF
        INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS FK ON REF.CONSTRAINT_NAME = FK.CONSTRAINT_NAME
      ORDER BY
        FK.TABLE_NAME,
        REF.CONSTRAINT_NAME 
OPEN FOREIGNKEYCURSOR
FETCH NEXT FROM FOREIGNKEYCURSOR INTO @FOREIGNKEYNAME, @TABLENAME
WHILE ( @@FETCH_STATUS = 0 )
    BEGIN
        IF @DISABLE = 1
            SET @SQL = N'ALTER TABLE [' + @TABLENAME + N'] NOCHECK CONSTRAINT [' + @FOREIGNKEYNAME + ']'
        ELSE
            SET @SQL = N'ALTER TABLE [' + @TABLENAME + N'] CHECK CONSTRAINT [' + @FOREIGNKEYNAME + ']'
        PRINT 'EXECUTING STATEMENT - ' + @SQL
        EXECUTE(@SQL)
        FETCH NEXT FROM FOREIGNKEYCURSOR INTO @FOREIGNKEYNAME, @TABLENAME
    END
CLOSE FOREIGNKEYCURSOR
DEALLOCATE FOREIGNKEYCURSOR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SHOWMESSAGE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SHOWMESSAGE AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.SHOWMESSAGE @MESSAGE NVARCHAR(100) AS
BEGIN
  RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLGROUPS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLGROUPS AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLGROUPS                                                                 */
/* DESCRIPTION:  The procedure create resource group node only for the              */
/*               performance events. It will be called only if rowdata contains     */
/*               resource group section.                                            */   
/* INPUT PARAMETERS:                                                                */
/*      @ROWGUID     - unique identifier of the event record                        */
/*      @GROUPSDOC   - xml resource group package for processing                    */
/*                    &lt;callGroups&gt;                                                  */
/*                          &lt;callGroup name="{resource group}"                      */
/*                                   duration="{duration,ms}"                       */
/*                                   count="{call count}" /&gt;                        */
/*                          ...                                                     */
/*                          &lt;callGroup/&gt;                                            */
/*                    &lt;/callGroups&gt;                                                 */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FILLGROUPS
     @ROWGUID NVARCHAR(15)
    ,@GROUPSDOC NTEXT
    ,@TRACELEVEL INT
AS
BEGIN
  SET NOCOUNT ON
  -- temporary table. Possible it is need to reseach using temporary variable --- 
  CREATE TABLE #GROUPS (NAME NVARCHAR(255) collate database_default, CALLCOUNT INT, DURATION BIGINT)
  -- memory identifier  
  DECLARE @IDOC INT                  
  -- error code   
  DECLARE @ERR INT
  -- primary key for the @ROWGUID parameter  
  DECLARE @EVENTID BIGINT
  -- row affected records
  DECLARE @ROWAFFECTED AS INT
  -- temporary variable for row affected records 
  DECLARE @RECORDCOUNT INT
  -- error proccesing  
  DECLARE 
     @ERRORIND         bit
    ,@ERRORNUMBER      int
    ,@ERRORSEVERITY    int
    ,@ERRORSTATE       int
    ,@ERRORLINE        int
    ,@ERRORPROCEDURE   nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE    nvarchar(max) 
    ,@MESSAGE          nvarchar(max)  
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  -- get event primary key using idx_T_RowGuid
  SELECT @EVENTID = EventId FROM Event e(NOLOCK) WHERE e.rowGuid = @ROWGUID
  IF (@@ROWCOUNT = 0)
  BEGIN
      -- raise exception "{rowguid} not found"
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50006   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLGROUPS', @ROWGUID)
  END  
  -- allocate memory for xml processing  
  EXEC @ERR = SP_XML_PREPAREDOCUMENT @IDOC OUTPUT, @GROUPSDOC
  IF @ERR &lt;&gt; 0 
  BEGIN
      -- raise exception    
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLGROUPS', @ERR)
  END
  
  -- Parse xml package 
  INSERT INTO #GROUPS
  SELECT NAME, CALLCOUNT, DURATION
     FROM OPENXML(@IDOC, N'/callGroups/callGroup', 2)
  WITH (NAME NVARCHAR(255) N'@name', CALLCOUNT INT N'@count', DURATION BIGINT N'@duration')
  SELECT @ROWAFFECTED = @@ROWCOUNT
   -- free memory
  EXEC SP_XML_REMOVEDOCUMENT @IDOC
  SET @IDOC = NULL
  IF (@TRACELEVEL = 4 AND @ROWAFFECTED = 0) 
  BEGIN
    -- trace message
    SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50007
    RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;  
  END       
  -- if resource group exists 
  IF @ROWAFFECTED &gt; 0 
  BEGIN 
      -- create resource group 
      INSERT INTO APM.RESOURCEGROUP (NAME)
        SELECT DISTINCT APM.GETRESOURCETYPE(G.NAME) FROM #GROUPS G
            WHERE NOT EXISTS
            (
               SELECT * FROM RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = APM.GETRESOURCETYPE(G.NAME)
            )
      SELECT @RECORDCOUNT = @@ROWCOUNT
      IF (@TRACELEVEL = 4)
      BEGIN
        -- trace message
        SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50008
        RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;           
      END
      -- Check exitsing internal resource group. It is need to create.  
      IF NOT EXISTS(SELECT * FROM RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = N'Internal')
        INSERT INTO RESOURCEGROUP(NAME) VALUES (N'Internal')
        
      -- create resource group node for all resourtce calls 
      ;WITH RESOURCEGROUPNODESET(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS  
       (
          -- by resource group calls from package
          SELECT 
                @EVENTID EVENTID,
                SUM(G.DURATION) DURATION,
                SUM(G.CALLCOUNT) CALLCOUNT,
                RG.RESOURCEGROUPID   
          FROM
            #GROUPS G
          JOIN 
            RESOURCEGROUP RG (NOLOCK) ON RG.NAME = APM.GETRESOURCETYPE(G.NAME)
          GROUP BY
            RG.RESOURCEGROUPID      
      
          UNION ALL 
        
          -- calculate internal call group as 
          SELECT 
            EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID 
          FROM 
          (
            SELECT 
                @EVENTID EVENTID,
                -- Rule: event duration - all resource group call
                COALESCE(E.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
                NULL CALLCOUNT,
                (SELECT RESOURCEGROUPID FROM RESOURCEGROUP RG WHERE RG.NAME = N'Internal') RESOURCEGROUPID 
            FROM 
              EVENT E (NOLOCK)  
              CROSS JOIN 
              (
                SELECT 
                    SUM(G.DURATION) DURATION
                FROM
                    #GROUPS G 
                ) A    
            WHERE 
              E.EVENTID = @EVENTID 
           ) B
           WHERE B.DURATION &gt; 0
         ),
         -- grouping result by resource group
         RESOURCEGROUPNODESETUNIQ(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS 
         (
            SELECT 
                @EVENTID, SUM(DURATION), SUM(CALLCOUNT), RESOURCEGROUPID
            FROM
              RESOURCEGROUPNODESET
            GROUP BY
              RESOURCEGROUPID    
         )
         -- create resource group node
         INSERT INTO RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
            SELECT 
                EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID 
            FROM 
                RESOURCEGROUPNODESETUNIQ 
         SELECT @RECORDCOUNT = @@ROWCOUNT
         IF (@TRACELEVEL = 4)
         BEGIN
           -- trace level   
           SELECT @MESSAGE = message FROM APM.Messages WHERE ID = 50010
           RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;            
         END
  END 
  END TRY
  BEGIN CATCH   
     -- exception processing
    
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
  
     -- get context variables
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1  
  END CATCH 
   -- check memory handle
   IF @IDOC IS NOT NULL
      EXEC sp_xml_removedocument @IDOC
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FillResourceGroupNodes'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FillResourceGroupNodes AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FillResourceGroupNodes                                                     */
/* DESCRIPTION:  The procedure create resource group node for the performance nodes */
/*               This is internal stored procedure. It is used by FillResource      */
/*               stored procedure. The FillResourceGroupNodes use external          */
/*               temporary table. Existing resource group node is not check.        */
/* INPUT PARAMETERS:                                                                */
/*      @EVENTID     - primary key of the event record                              */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FillResourceGroupNodes 
    @EVENTID bigint
   ,@TRACELEVEL int
AS
BEGIN
     SET NOCOUNT ON;
     DECLARE 
       @MESSAGE nvarchar(max)
      ,@RECORDCOUNT int
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50031
       RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;    
     END 
    ;WITH ResourceGroupNodeSet(DURATION, RESOURCEGROUPID) AS 
     (
        -- grouping resources from xml resource package 
        SELECT 
            SUM(D.DUR) DURATION,
            D.RESOURCEGROUPID   
        FROM
            #DETAILS D
        GROUP BY
          D.RESOURCEGROUPID     
      
        UNION ALL 
        
        -- calculate one internal execution. Internal resource group should be create before. 
        SELECT 
           DURATION, RESOURCEGROUPID 
        FROM 
          (
            SELECT 
                -- calculation rule: event duration - all resource call group duration  
                COALESCE(A.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
                RG.RESOURCEGROUPID 
            FROM 
               RESOURCEGROUP RG (NOLOCK)
              CROSS JOIN 
              (
                -- all resource call group duration
                SELECT 
                    SUM(D.DUR) DURATION
                   ,MIN(D.EVENTDURATION) EVENTDURATION
                FROM
                    #DETAILS D 
                ) A    
            WHERE 
               RG.NAME = N'Internal'
           ) B
         WHERE B.DURATION &gt; 0
     ),
     -- grouping by resource group
     ResourceGroupNodeSetUniq(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) AS 
     (
        SELECT 
          @EVENTID, SUM(DURATION), NULL, RESOURCEGROUPID  
        FROM 
          ResourceGroupNodeSet
        GROUP BY 
          RESOURCEGROUPID               
     )          
     INSERT INTO RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
        SELECT 
           EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID
        FROM
           ResourceGroupNodeSetUniq
    
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace level 
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50032
       RAISERROR (@MESSAGE, 0, 1, N'FILLRESOURCEGROUPNODES', @RECORDCOUNT, N'RESOURCEGROUPNODE') WITH NOWAIT;     
     END 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLRESOURCES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLRESOURCES AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLRESOURCES                                                              */
/* DESCRIPTION:  The procedure update resource references on the performancenode,   */
/*               exceptionnode, event tables. If resource doesn't exist it          */
/*               will be create. If rowdata doesn't contain resource group call     */
/*               section resource group node will be create on the                  */
/*               resourcegroupnode table for the performance events.                */
/* INPUT PARAMETERS:                                                                */
/*      @ROWGUID     - unique identifier of the event record                        */
/*      @DETAILSDOC  - xml resource package for processing                          */
/*                   &lt;resources&gt;                                                    */
/*                      &lt;resource entryId="{entry id}" quick="{0(1)}"&gt;              */
/*                          &lt;method dur="{duration, ms}"&gt;{method name}&lt;/method&gt;     */
/*                          &lt;uriFormat&gt;{uri format}&lt;/uriFormat&gt;                     */
/*                          &lt;type&gt;{resource type}&lt;/type&gt;                            */
/*                      &lt;/resource&gt;                                                 */
/*                      ...                                                         */
/*                      &lt;resource/&gt;                                                 */
/*                   &lt;/resources&gt;                                                   */
/*                   quick attribute values:                                        */
/*                              1 quick resource call                               */
/*                              0 not quick resource call                           */
/*                   resource method format:                                        */
/*                              {namespace}${resource call}                         */
/*                   {uri format} reserved                                          */      
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE [APM].[FILLRESOURCES]
      @ROWGUID NVARCHAR(15)
     ,@DETAILSDOC NTEXT
     ,@TRACELEVEL INT
AS
BEGIN
  SET NOCOUNT ON
  -- memory identifier  
  DECLARE @IDOC INT    
            
  -- error code   
  DECLARE @ERR INT
  -- event class type
  DECLARE @EVENTCLASSTYPE NVARCHAR(255)
  -- primary key for the @ROWGUID parameter  
  DECLARE @EVENTID BIGINT
  -- row affected records
  DECLARE @ROWAFFECTED AS INT
  -- trace message 
  DECLARE @MESSAGE NVARCHAR(MAX)
  -- temporary variable for row affected records 
  DECLARE @RECORDCOUNT INT
  -- error proccesing  
  DECLARE 
     @ERRORIND        bit
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE   nvarchar(max)      
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  -- temporary table. Possible it is need to reseach using temporary variable --- 
  CREATE TABLE #DETAILS (
    ENTRYID INT
   ,METHOD nvarchar(255) collate database_default
   ,RESOURCEURI nvarchar(255) collate database_default
   ,URIFORMAT NVARCHAR(255) collate database_default
   ,TYPE NVARCHAR(255) collate database_default
   ,QUICK INT
   ,DUR decimal(35,0)
   ,RESOURCEGROUPID int
   ,SOURCEID int
   ,EVENTID bigint
   ,EVENTDURATION decimal(35,0)
  )
  -- get event primary key using idx_T_RowGuid
  SELECT @EVENTID = EventId FROM APM.Event e(NOLOCK) WHERE e.rowGuid = @ROWGUID
  IF (@@ROWCOUNT = 0)
  BEGIN
      -- raise exception "{rowguid} not found"
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50006   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLRESOURCES', @ROWGUID)
  END  
  -- allocate memory for xml processing  
  EXEC @ERR = SP_XML_PREPAREDOCUMENT @IDOC OUTPUT, @DETAILSDOC
  IF @ERR &lt;&gt; 0 
  BEGIN
      -- raise exception    
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'FILLRESOURCES', @ERR)
  END
  -- Parse xml package 
  INSERT INTO #DETAILS
  SELECT ENTRYID, METHOD, APM.GETRESOURCE(METHOD), URIFORMAT, TYPE, QUICK, DUR, 0, 0, 0, 0 
      FROM OPENXML(@IDOC, N'/resources/resource', 2)
  WITH (
        ENTRYID INT N'@entryId', 
        METHOD NVARCHAR(255) N'method', 
        URIFORMAT NVARCHAR(255) N'uriFormat',
        TYPE NVARCHAR(255) N'type',
        QUICK INT N'@quick',
        DUR decimal(35,0) N'method/@dur'
  )
  SELECT @ROWAFFECTED = @@ROWCOUNT
  -- free memory
  EXEC SP_XML_REMOVEDOCUMENT @IDOC
  SET @IDOC = NULL
  IF @TRACELEVEL = 4 AND @ROWAFFECTED = 0 
  BEGIN
    -- resources is empty
    SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50013
    RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
  END
  -- if resources exists 
  IF @ROWAFFECTED &gt; 0 
  BEGIN
    
  -- get event class type using index idx_T_EventId 
  SELECT 
    @EVENTCLASSTYPE = EVENTCLASSTYPE
  FROM 
    APM.EVENT E (NOLOCK)
  WHERE 
    E.EVENTID = @EVENTID 
  -- create resource group 
  INSERT INTO APM.RESOURCEGROUP (NAME)
    SELECT DISTINCT APM.GETRESOURCETYPE(D.TYPE) FROM #DETAILS D
        WHERE NOT EXISTS
        (
           SELECT * FROM APM.RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = APM.GETRESOURCETYPE(D.TYPE)
        ) 
  -- updating additional fields. It is need for decrease number of join operations.
  UPDATE D
    SET 
      D.RESOURCEGROUPID = RG.RESOURCEGROUPID
     ,D.SOURCEID = E.SOURCEID
     ,D.EVENTID = E.EVENTID
     ,D.EVENTDURATION = E.EVENTDURATION 
  FROM #DETAILS D
    JOIN RESOURCEGROUP RG (NOLOCK) ON RG.NAME = APM.GETRESOURCETYPE(D.TYPE)
    CROSS JOIN (SELECT EVENTID, SOURCEID, EVENTDURATION FROM APM.EVENT E (NOLOCK) WHERE E.EVENTID = @EVENTID) E
  -- Check exitsing internal resource group. It is need to create.  
  IF NOT EXISTS(SELECT * FROM APM.RESOURCEGROUP RG (NOLOCK) WHERE RG.NAME = N'Internal')
    INSERT INTO RESOURCEGROUP(NAME) VALUES (N'Internal')
  -- create resource for all methods 
  INSERT INTO RESOURCE(
        SOURCEID, 
        RESOURCEGROUPID,
        RESOURCEURIFORMAT,
        RESOURCEURI
  )
  SELECT 
    DISTINCT D.SOURCEID, D.RESOURCEGROUPID, D.URIFORMAT, D.RESOURCEURI
  FROM 
    #DETAILS D
  WHERE 
    NOT EXISTS( 
       SELECT * 
         FROM 
            APM.RESOURCE R (NOLOCK)
         WHERE
            R.SOURCEID = D.SOURCEID
            AND R.RESOURCEGROUPID = D.RESOURCEGROUPID
            AND R.RESOURCEURI = D.RESOURCEURI
   )
   
   SELECT @RECORDCOUNT = @@ROWCOUNT
   IF @TRACELEVEL = 4 
   BEGIN
     -- send info message about resource row affected
     SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50014
     RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;    
   END 
   IF @EVENTCLASSTYPE = N'performance' AND EXISTS (SELECT * FROM #DETAILS WHERE QUICK = 0)
   BEGIN
   -- processing performance events for not quick resource calls
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace info message 
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50015
          RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;     
        END 
        -- Create resource group node if rowdata doesn't containt resource call group section or it is empty
        IF NOT EXISTS(SELECT * FROM RESOURCEGROUPNODE RN WHERE RN.EventId = @EVENTID)
           EXEC APM.FillResourceGroupNodes @EVENTID, @TRACELEVEL
       
        --Check existing performance node 
        IF NOT EXISTS(SELECT * FROM APM.PERFORMANCENODE P (NOLOCK) WHERE P.EVENTID = @EVENTID) 
        BEGIN
            -- It is need create performance node(s) for not quick resource call 
            IF @TRACELEVEL = 4 
            BEGIN
              -- trace message 
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50016
              RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;     
            END 
          
            INSERT INTO APM.PERFORMANCENODE
            (
                EVENTID,
                DESCRIPTION,
                FUNCTIONNAME,
                ENTRYID,
                DURATION,
                SELFDURATION,
                ISHEAVIESTNODE                            
            )
            SELECT 
                @EVENTID,   
                REPLACE(D.METHOD,'$',''),
                REPLACE(D.METHOD,'$',''),
                D.ENTRYID,
                D.DUR,
                D.DUR,
                1 
            FROM  
                #DETAILS D 
            WHERE 
                D.QUICK = 0
            SELECT @RECORDCOUNT = @@ROWCOUNT
            IF @TRACELEVEL = 4 
            BEGIN
              -- trace info message
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50017
              RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
            END 
        END 
        -- update resource, resource group node references and resource method for not quick resource calls 
        UPDATE P SET 
            P.RESOURCEID = R.RESOURCEID,
            P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID,
            P.RESOURCEMETHOD = REPLACE(D.METHOD, N'$', N''), -- full method name (namespace + resource function call) 
            P.SELFDURATION = D.DUR           
        FROM 
            PERFORMANCENODE P                       
             JOIN #DETAILS D ON D.ENTRYID = P.ENTRYID AND D.QUICK = 0 
             JOIN RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.RESOURCEGROUPID = D.RESOURCEGROUPID AND RGN.EVENTID = D.EVENTID
             JOIN RESOURCE R (NOLOCK) ON R.RESOURCEURI = D.RESOURCEURI AND R.SOURCEID = D.SOURCEID AND R.RESOURCEGROUPID = D.RESOURCEGROUPID 
        WHERE 
            P.EVENTID = @EVENTID 
        
        SELECT @RECORDCOUNT = @@ROWCOUNT
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace message
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50018
          RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
        END 
        -- update event resource reference. It will be reference to the most heavy resources
        UPDATE E SET
          E.RESOURCEID  = (
                             SELECT TOP 1
                                P.RESOURCEID 
                             FROM 
                                PERFORMANCENODE P (NOLOCK)
                             WHERE 
                                P.EVENTID = @EVENTID
                             ORDER BY 
                                P.SELFDURATION DESC, P.PERFORMANCENODEID DESC 
                            )
        FROM 
          APM.EVENT E 
        WHERE 
          E.EVENTID = @EVENTID  
              
        SELECT @RECORDCOUNT = @@ROWCOUNT
        IF @TRACELEVEL = 4 
        BEGIN
          -- trace message
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50020
          RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;   
        END 
   END 
   IF @EVENTCLASSTYPE = N'exception' AND EXISTS(SELECT * FROM APM.EXCEPTIONNODE EX (NOLOCK) WHERE EX.EVENTID = @EVENTID) 
   BEGIN
   -- processing exception event
     -- update resource reference and resource method   
     UPDATE EX SET 
            EX.RESOURCEID = R.RESOURCEID,
            EX.RESOURCEMETHOD = REPLACE(D.METHOD, N'$', N'') -- full method name (namespace + resource function call) 
        FROM APM.EXCEPTIONNODE EX
           CROSS JOIN (SELECT METHOD, SOURCEID, RESOURCEURI,RESOURCEGROUPID FROM #DETAILS D WHERE QUICK = 0) D
           JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = D.RESOURCEURI AND R.SOURCEID = D.SOURCEID AND R.RESOURCEGROUPID = D.RESOURCEGROUPID  
        WHERE 
            EX.EVENTID = @EVENTID 
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace info message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50021
       RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;      
     END 
     -- update event resource reference. 
     UPDATE E SET
            E.RESOURCEID  = (
                             SELECT TOP 1
                                EX.RESOURCEID 
                             FROM 
                                APM.EXCEPTIONNODE EX (NOLOCK)
                             WHERE 
                                EX.EVENTID = @EVENTID
                             ORDER BY 
                                EX.RESOURCEID
                            )
      FROM 
        APM.EVENT E 
      WHERE 
        E.EVENTID = @EVENTID               
     SELECT @RECORDCOUNT = @@ROWCOUNT
     IF @TRACELEVEL = 4 
     BEGIN
       -- trace info message
       SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50022
       RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT) WITH NOWAIT;      
     END 
   END
   END
   END TRY
   BEGIN CATCH
     -- exception processing
     
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
  
     -- get context variables
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER() 
      ,@ERRORSEVERITY = ERROR_SEVERITY() 
      ,@ERRORSTATE = ERROR_STATE() 
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1
   END CATCH
   -- check memory handle
   IF @IDOC IS NOT NULL
      EXEC sp_xml_removedocument @IDOC
   --report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.UpdateEventsByInternalResource'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.UpdateEventsByInternalResource AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: UpdateEventsByInternalResource                                             */
/* DESCRIPTION:  The procedure update resource reference for events                 */
/*               This is internal stored procedure. It is used by FillResource      */
/*               stored procedure. The UpdateEventsByInternalResource use external  */
/*               temporary table.                                                   */
/* INPUT PARAMETERS:                                                                */
/*      @EVENTCLASSTYPE  - event class type                                         */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.UpdateEventsByInternalResource @EVENTCLASSTYPE nvarchar(255)
AS
BEGIN
  if (@EVENTCLASSTYPE = N'performance')
  begin
     -- processing performance events
     UPDATE E 
        SET E.RESOURCEID  = A.RESOURCEID 
     FROM   
       APM.EVENT E       
       JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = E.EVENTID 
       CROSS APPLY (
               -- using haviest resource
                SELECT TOP 1
                    P.RESOURCEID 
                FROM 
                    APM.PERFORMANCENODE P (NOLOCK)
                WHERE 
                    P.EVENTID = E.EVENTID
                ORDER BY 
                  P.SELFDURATION DESC, 
                  P.PERFORMANCENODEID       
        ) A
  end
  if @EVENTCLASSTYPE = N'exception'
  begin
     -- processing exception events
     UPDATE E 
        SET E.RESOURCEID  = A.RESOURCEID 
     FROM        
       APM.EVENT E       
       JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = E.EVENTID 
       CROSS APPLY (
                SELECT TOP 1
                    EX.RESOURCEID 
                FROM 
                    APM.EXCEPTIONNODE EX (NOLOCK)
                WHERE 
                    EX.EVENTID = E.EVENTID
                ORDER BY 
                   EX.EXCEPTIONNODEID
        ) A
  end
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.INSERTINTERNALRESOURCE'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.INSERTINTERNALRESOURCE AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: INSERTINTERNALRESOURCE                                                     */
/* DESCRIPTION:  The procedure create internal execution resource.                  */
/*               This is internal stored procedure. It is used by                   */
/*               FillInternalResource stored procedure and use external temporary   */
/*               table.                                                             */
/************************************************************************************/
ALTER PROCEDURE APM.INSERTINTERNALRESOURCE
AS
BEGIN
  DECLARE @INTERNALRESOURCEGROUPID int
SELECT 
    -- get primary key for internal resource group 
    @INTERNALRESOURCEGROUPID = RESOURCEGROUPID FROM APM.RESOURCEGROUP RG WHERE RG.NAME = N'Internal'
        
    -- create internal execution resource for temporary sources 
    INSERT INTO RESOURCE (RESOURCEGROUPID, SOURCEID, RESOURCEURI, RESOURCEURIFORMAT) 
        SELECT DISTINCT
           @INTERNALRESOURCEGROUPID 
          ,F.SOURCEID 
          ,N'Internal Execution' 
          ,N'' 
        FROM 
          #FILLINTERNALRESOURCESTABLE F
        WHERE 
           NOT EXISTS(
                SELECT * 
                  FROM APM.RESOURCE R (NOLOCK) 
                WHERE 
                  R.SOURCEID = F.SOURCEID  
                  AND R.RESOURCEURI = N'Internal Execution'
            )
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.FILLINTERNALRESOURCES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.FILLINTERNALRESOURCES AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: FILLINTERNALRESOURCES                                                      */
/* DESCRIPTION:  The procedure update resource references on the performancenode,   */
/*               exceptionnode, event tables which is empty. The new resource       */
/*               will be internal execution. After execution this procedure "heavy  */
/*               light" events should be performance or exception nodes. Events will*/
/*               process by block starting @STARTROWGUID and ending @ENDROWGUID     */
/*                                                                                  */
/* INPUT PARAMETERS:                                                                */
/*      @STARTROWGUID - start block unique identifier                               */
/*      @ENDBLOCK     - end block unique identifier                                 */
/*      @DATABASEID   - database identifier                                         */
/*      @RECORDCOUNT  - reserved                                                    */
/*      @TRACELEVEL  - trace level                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.FILLINTERNALRESOURCES 
     @STARTROWGUID NVARCHAR(15)
    ,@ENDROWGUID   NVARCHAR(15)
    ,@DATABASEID   INT 
    ,@RECORDCOUNT  INT
    ,@TRACELEVEL   INT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE @RECORDS      INT
  DECLARE @MESSAGE      NVARCHAR(MAX)  
  -- error proccesing  
  DECLARE 
     @ERRORIND         bit
    ,@ERRORNUMBER      int
    ,@ERRORSEVERITY    int
    ,@ERRORSTATE       int
    ,@ERRORLINE        int
    ,@ERRORPROCEDURE   nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
    ,@ERROR_MESSAGE    nvarchar(max)      
  -- reset error flag 
  SET @ERRORIND = 0
  BEGIN TRY
  DECLARE 
    -- starting primary key 
    @STARTID bigint
    -- ending primary key
   ,@ENDID bigint
    -- internal resource group
   ,@INTERNALRESOURCEGROUPID int
   
  IF NOT EXISTS(SELECT * FROM APM.RESOURCEGROUP WHERE NAME = N'Internal')   
     INSERT INTO APM.RESOURCEGROUP(NAME) VALUES (N'Internal')
  -- Get primary key internal resource group        
  SELECT
    @INTERNALRESOURCEGROUPID = RESOURCEGROUPID FROM APM.RESOURCEGROUP RG WHERE RG.NAME = N'Internal'
  -- Get event primary keys
  SELECT 
     @STARTID = CASE WHEN ROWGUID = @STARTROWGUID THEN eventId  ELSE @STARTID END
    ,@ENDID = CASE WHEN ROWGUID = @ENDROWGUID THEN eventId  ELSE @ENDID END
  FROM 
    APM.EVENT (NOLOCK) 
  WHERE 
    ROWGUID IN (@STARTROWGUID, @ENDROWGUID) 
    
  IF @STARTID IS NULL OR @ENDID IS NULL 
  BEGIN
	 DECLARE 
	   @MSG nvarchar(MAX)
       
	 SELECT @MSG = message FROM APM.MESSAGES(NOLOCK) WHERE id = 50035
	 RAISERROR(@MSG, 16, 1, @STARTROWGUID, @ENDROWGUID)   
	 RETURN 
  END   
    
  -- temporary event table. Do not use temporary table variable because table is used by internal stored procedures   
  CREATE TABLE #FILLINTERNALRESOURCESTABLE 
  (
        EVENTID INT
       ,SOURCEID INT
       ,EVENTDURATION DECIMAL(35,0)
       ,EXCEPTIONCLASS NVARCHAR(255) collate database_default
       ,DESCRIPTION NVARCHAR(255) collate database_default
  )
  
 /* Processing performance events which are not have performance nodes */
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,EVENTDURATION,SOURCEID) 
    SELECT 
      E.EVENTID, E.EVENTDURATION,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E 
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (HEAVYLIGHT IS NULL OR HEAVYLIGHT &lt;&gt; 0)
      AND NOT EXISTS(SELECT * FROM PERFORMANCENODE P (NOLOCK) WHERE P.EVENTID = E.EVENTID)
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  
  IF (@@ROWCOUNT &gt; 0)
  BEGIN
    -- Processing performance events
    -- Delete old resource group nodes
    DELETE R FROM 
        APM.RESOURCEGROUPNODE R
        JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = R.EVENTID
        
    --Insert internal resource group node
    INSERT RESOURCEGROUPNODE(EVENTID, DURATION, CALLCOUNT, RESOURCEGROUPID) 
        SELECT 
            F.EVENTID, 
            -- use event duration
            COALESCE(F.EVENTDURATION, 0) / 1000 AS DURATION, 
            NULL AS CALLCOUNT, 
            @INTERNALRESOURCEGROUPID
        FROM
            #FILLINTERNALRESOURCESTABLE F
    
    -- create internal execution resource for event sources
    EXEC APM.InsertInternalResource  
    -- create performance node
    INSERT INTO APM.PERFORMANCENODE
    (
       EVENTID,
       RESOURCEID,
       RESOURCEGROUPNODEID,
       DESCRIPTION,        
       FUNCTIONNAME,
       RESOURCEMETHOD,
       DURATION,
       ENTRYID,
       SELFDURATION,
       ISHEAVIESTNODE 
    )
    SELECT 
      F.EVENTID, 
      R.RESOURCEID,
      RGN.RESOURCEGROUPNODEID,      
      R.RESOURCEURI, 
      R.RESOURCEURI,
      R.RESOURCEURI,
      -- use event duration
      F.EVENTDURATION / 1000,
      0,    
      -- use event duration
      F.EVENTDURATION / 1000,
      --These events always have only one performance node which is most heavy
      1
    FROM 
      #FILLINTERNALRESOURCESTABLE F 
      JOIN APM.RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.EVENTID = F.EVENTID 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
    SET @RECORDS = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      -- trace message
      DECLARE @PROCESSED INT
      SELECT  @PROCESSED = COUNT(*) FROM #FILLINTERNALRESOURCESTABLE
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50028
      
      RAISERROR (@MESSAGE, 0, 1, @PROCESSED, @RECORDS) WITH NOWAIT;
    END
    
    -- update event resource reference
    EXEC APM.UpdateEventsByInternalResource N'performance'
  END
 /* Processing exception events which are not have exception nodes */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID,EXCEPTIONCLASS,DESCRIPTION) 
    SELECT 
      E.EVENTID, E.SOURCEID, E.EXCEPTIONCLASS, E.DESCRIPTION
    FROM
      APM.EVENT (NOLOCK) E  
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND NOT EXISTS(SELECT * FROM EXCEPTIONNODE Ex (NOLOCK) WHERE Ex.EVENTID = E.EVENTID)
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)     
  BEGIN
    -- create internal execution resource for event sources
    EXEC APM.INSERTINTERNALRESOURCE    
     
    -- create exception node
    INSERT INTO APM.EXCEPTIONNODE
    (
       EVENTID,
       RESOURCEID,
       EXCEPTIONCLASS,
       FUNCTIONNAME,
       RESOURCEMETHOD,
       -- use event description
       DESCRIPTION                          
    )
    SELECT 
      F.EVENTID, 
      R.RESOURCEID,
      F.EXCEPTIONCLASS,      
      R.RESOURCEURI, 
      R.RESOURCEURI,
      F.DESCRIPTION
    FROM
      #FILLINTERNALRESOURCESTABLE F 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
        
    SELECT @RECORDS = @@ROWCOUNT
    
    IF @TRACELEVEL = 4 
    BEGIN
      -- trace message
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50029
      RAISERROR (@MESSAGE, 0, 1, @RECORDS) WITH NOWAIT;
    END
    
    -- update event resource reference  
    EXEC APM.UpdateEventsByInternalResource N'exception'
  END
  
 /* Processing performance nodes which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,EVENTDURATION, SOURCEID) 
    SELECT 
      E.EVENTID, E.EVENTDURATION, E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      EXISTS(
        SELECT * FROM APM.PERFORMANCENODE AS P(NOLOCK) 
            WHERE P.EVENTID = E.EVENTID AND P.RESOURCEID IS NULL
      )     
      AND E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (E.HEAVYLIGHT IS NULL OR E.HEAVYLIGHT &lt;&gt; 0)
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  
  IF @@ROWCOUNT &gt; 0
  BEGIN
     --delete not linked resource nodes
     DELETE RGN
        FROM APM.RESOURCEGROUPNODE RGN
            JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID
            WHERE NOT EXISTS(SELECT * FROM APM.PERFORMANCENODE P (NOLOCK)
                    WHERE P.EVENTID = F.EVENTID AND P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID)
     --Check existing internal group node               
     IF NOT EXISTS(
            SELECT * 
                FROM APM.RESOURCEGROUPNODE AS RGN (NOLOCK)
                JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID
            WHERE 
                RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
     ) 
     BEGIN
        --Internal resource group is missing 
        --Create new
        INSERT APM.RESOURCEGROUPNODE(EVENTID, DURATION, RESOURCEGROUPID) 
        SELECT 
            F.EVENTID,
            -- use event duration
            COALESCE(F.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) DURATION,
            @INTERNALRESOURCEGROUPID
        FROM 
           #FILLINTERNALRESOURCESTABLE F
               CROSS APPLY 
               (
                 SELECT 
                    SUM(DURATION) DURATION
                 FROM
                    APM.RESOURCEGROUPNODE AS RGN (NOLOCK) WHERE RGN.EVENTID = F.EVENTID
               ) A
     END
     ELSE 
     BEGIN
        ---not linked resource group node have been removed. Therefore, need recalculate internal group node 
        UPDATE RGN
            -- use event duration
            SET RGN.DURATION = COALESCE(F.EVENTDURATION, 0) / 1000 -  COALESCE(A.DURATION, 0) 
        FROM
          APM.RESOURCEGROUPNODE RGN
          JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = RGN.EVENTID AND RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
               CROSS APPLY 
               (
                 SELECT 
                    SUM(DURATION) DURATION
                 FROM
                    APM.RESOURCEGROUPNODE AS RGN2 (NOLOCK) 
                 WHERE 
                    RGN2.EVENTID = F.EVENTID 
                    AND RGN2.RESOURCEGROUPID &lt;&gt; @INTERNALRESOURCEGROUPID 
               ) A
     END        
     -- create internal execution resources for event sources            
     EXEC APM.INSERTINTERNALRESOURCE
     -- update resource and resource group node references for performance nodes
     UPDATE P SET 
            P.RESOURCEID = R.RESOURCEID,
            P.RESOURCEGROUPNODEID = RGN.RESOURCEGROUPNODEID,
            P.RESOURCEMETHOD = R.RESOURCEURI, 
            P.SELFDURATION = P.DURATION           
     FROM 
        APM.PERFORMANCENODE P
        JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = P.EVENTID 
        JOIN APM.RESOURCEGROUPNODE RGN (NOLOCK) ON RGN.EVENTID = F.EVENTID AND RGN.RESOURCEGROUPID = @INTERNALRESOURCEGROUPID
        JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID   
     WHERE P.RESOURCEID IS NULL
     -- update resource reference on performance events
     EXEC APM.UpdateEventsByInternalResource N'performance'     
  END           
 /* Processing exception nodes which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID, E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E  
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND EXISTS(SELECT * FROM EXCEPTIONNODE Ex (NOLOCK) WHERE Ex.EVENTID = E.EVENTID AND Ex.RESOURCEID IS NULL)
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)
  BEGIN
    -- create internal execution resources for event sources     
    EXEC APM.INSERTINTERNALRESOURCE
        
    -- update exception resource references
    UPDATE EX
        SET EX.RESOURCEID = R.RESOURCEID
    FROM 
      APM.EXCEPTIONNODE EX
      JOIN #FILLINTERNALRESOURCESTABLE F ON F.EVENTID = EX.EVENTID 
      JOIN APM.RESOURCE R (NOLOCK) ON R.RESOURCEURI = N'Internal Execution' AND R.SOURCEID = F.SOURCEID
  END   
  
 /* Processing performance events which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND (E.HEAVYLIGHT IS NULL OR E.HEAVYLIGHT &lt;&gt; 0)
      AND E.RESOURCEID IS NULL
      AND E.EVENTCLASSTYPE = N'performance' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)    
 -- update resource reference on performance events 
    EXEC APM.UpdateEventsByInternalResource N'performance'
 /* Processing exception events which are not have resources */
  TRUNCATE TABLE #FILLINTERNALRESOURCESTABLE
  INSERT INTO #FILLINTERNALRESOURCESTABLE(EVENTID,SOURCEID) 
    SELECT 
      E.EVENTID,E.SOURCEID
    FROM
      APM.EVENT (NOLOCK) E     
    WHERE
      E.SEVIEWERDBID = @DATABASEID 
      AND E.EVENTID &gt;= @STARTID AND E.EVENTID &lt;= @ENDID 
      AND E.RESOURCEID IS NULL
      AND E.EVENTCLASSTYPE = N'exception' OPTION(RECOMPILE)
  IF (@@ROWCOUNT &gt; 0)
 -- update resource reference on exception events     
    EXEC APM.UpdateEventsByInternalResource N'exception'
  END TRY
  BEGIN CATCH
     -- exception processing
     -- check active transactions
     IF (@@TRANCOUNT &gt; 0)
       ROLLBACK TRAN
     -- get context variables   
     SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
     -- switch error flag
     SET @ERRORIND = 1
  END CATCH
--report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetResource'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetResource ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetResource (@METHOD nvarchar(255))
RETURNS nvarchar(255)
AS
BEGIN
  RETURN 
      LEFT(
        @METHOD, 
        CASE WHEN CHARINDEX(N'$', @METHOD) = 0 THEN LEN(@METHOD) ELSE CHARINDEX(N'$', @METHOD) - 1 END 
         ) 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetResourceType'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetResourceType ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION [APM].[GetResourceType] (@RESOURCETYPE nvarchar(255))
RETURNS nvarchar(255)
AS
BEGIN
  RETURN 
    CASE  
        WHEN @RESOURCETYPE LIKE N'Web%' OR @RESOURCETYPE LIKE N'WCF%' THEN N'WebService'
        WHEN @RESOURCETYPE LIKE N'SQL%' 
             OR @RESOURCETYPE LIKE N'OLEDB%' 
             OR @RESOURCETYPE LIKE N'IBM DB2%' 
             OR @RESOURCETYPE LIKE N'Sybase%' 
             OR @RESOURCETYPE LIKE N'Query%'
             OR @RESOURCETYPE LIKE N'ODBC%'
             OR @RESOURCETYPE LIKE N'Oracle%'
             OR @RESOURCETYPE LIKE N'ADOMD%'
            THEN N'Database'
        ELSE N'Internal' 
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ComputerResourceUtilization'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ComputerResourceUtilization AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ComputerResourceUtilization                                                */
/* USED IN: Computer resource utilization report                                    */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/*      @TOPROWCOUNT - defines number of top rows, which will be returned           */
/************************************************************************************/
ALTER PROCEDURE APM.ComputerResourceUtilization
    @DATESTART DateTime,
    @DATEEND DateTime,
    @MACHINEIDS NVARCHAR(MAX),
    @SORTORDER INT,
    @TOPROWCOUNT INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                              ASSISTING TEMP TABLES                                   */
/****************************************************************************************/
-- Filter table, which contains machine Ids 
    CREATE TABLE #COMPUTERPCOUNTERANALYSIS_FILTERTABLE
    (
        VALUEID INT
    )
-- Split @MACHINEIDS and fill table with values from it
    INSERT 
        INTO #COMPUTERPCOUNTERANALYSIS_FILTERTABLE
            SELECT 
                CAST(p.value AS int)
            FROM 
                APM.GetMultiParameters(@MACHINEIDS, N'') p
--Filter PerfHourly table for further manipulations
    CREATE TABLE #COMPUTERPCOUNTERANALYSIS_PERFHOURLY
    (
        MACHINEID INT,
        PCTYPE NVARCHAR(100) collate database_default,
        SUMVALUE FLOAT,
        MAXVALUE FLOAT,
        SAMPLECOUNT BIGINT
    )
    INSERT
        INTO #COMPUTERPCOUNTERANALYSIS_PERFHOURLY
            SELECT 
                ph.MachineId AS MachineId,
                t.type AS PCType,
                ph.SumValue AS SumValue,
                ph.MaxValue AS MaxValue,
                ph.SampleCount AS SampleCount
            FROM
                APM.PerfHourly AS ph (NOLOCK)
                JOIN APM.PCType AS t (NOLOCK) ON ph.PCTypeId = t.PCTypeId
                JOIN #COMPUTERPCOUNTERANALYSIS_FILTERTABLE f ON ph.MachineId = f.VALUEID
            WHERE 
                ph.UTCDate &gt;= @DATESTART 
                AND ph.UTCDate &lt; @DATEEND 
                AND ph.SourceId IS NULL 
                AND ph.PCProcessId IS NULL
                AND t.Type IN (
                    N'\Processor\% Processor Time', 
                    N'\Process\Private Bytes', 
                    N'\Process\IO Data Bytes/sec', 
                    N'\Apps\Monitored Requests')
 
/****************************************************************************************/
/*                                      MAIN QUERY                                      */
/****************************************************************************************/          
    ;WITH ComputerResourceUtilization AS 
    (
        SELECT
            ph.MACHINEID,
            AVG(CASE ph.PCTYPE WHEN N'\Processor\% Processor Time' THEN ph.SUMVALUE/SAMPLECOUNT END) AS ProcessorValue,
            MAX(CASE ph.PCTYPE WHEN N'\Processor\% Processor Time' THEN ph.MAXVALUE END) AS MaxProcessorValue,
            AVG(CASE ph.PCTYPE WHEN N'\Process\Private Bytes' THEN ph.SUMVALUE/SAMPLECOUNT END) AS MemoryValue,
            MAX(CASE ph.PCTYPE WHEN N'\Process\Private Bytes' THEN ph.MAXVALUE END) AS MaxMemoryValue,
            AVG(CASE ph.PCTYPE WHEN N'\Process\IO Data Bytes/sec' THEN ph.SUMVALUE/SAMPLECOUNT END) AS IOValue,
            MAX(CASE ph.PCTYPE WHEN N'\Process\IO Data Bytes/sec' THEN ph.MAXVALUE END) AS MaxIOValue,
            SUM(CASE ph.PCTYPE WHEN N'\Apps\Monitored Requests' THEN ph.SUMVALUE END) AS RequestValue  
        FROM 
            #COMPUTERPCOUNTERANALYSIS_PERFHOURLY AS ph
        GROUP BY
            ph.MACHINEID              
    ),
    OrderedDataSet AS
    (
        SELECT 
            ROW_NUMBER() OVER(ORDER BY 
                CASE @SORTORDER 
                    WHEN 1 THEN cr.ProcessorValue 
                    WHEN 2 THEN cr.MemoryValue 
                    WHEN 3 THEN cr.IOValue 
                    WHEN 4 THEN cr.RequestValue 
                END DESC
            ) AS Id,
            m.Machine,
            m.MachineId,
            COALESCE(m.CPUCount, 1) AS CPUCount,
            cr.ProcessorValue AS ProcessorValue,
            cr.MaxProcessorValue AS MaxProcessorValue,
            cr.MemoryValue/(1024*1024) AS MemoryValue,
            cr.MaxMemoryValue/(1024*1024) AS MaxMemoryValue,
            cr.IOValue/1024 AS IOValue,
            cr.MaxIOValue/1024 AS MaxIOValue,
            cr.RequestValue AS RequestValue,
            -- Flag to define if cpu count is not null,
            -- in case of  CPUDefineFlag = 0, show warning message about it in report
            COALESCE(m.CPUCount, 0) AS CPUDefineFlag
        FROM
            ComputerResourceUtilization AS cr
            JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = cr.MachineId
    )
    SELECT
        * 
    FROM
        OrderedDataSet
    WHERE
        Id &lt;= @TOPROWCOUNT
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.fn_nums'), 'IsTableFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.fn_nums() RETURNS TABLE
				AS
				RETURN
				select clmn=1')    
  END
GO
ALTER FUNCTION APM.fn_nums(@N AS INT) RETURNS TABLE
AS
RETURN
WITH
L0 AS(SELECT 1 AS c UNION ALL SELECT 1),
L1 AS(SELECT 1 AS c FROM L0 AS A, L0 AS B),
L2 AS(SELECT 1 AS c FROM L1 AS A, L1 AS B),
L3 AS(SELECT 1 AS c FROM L2 AS A, L2 AS B),
L4 AS(SELECT 1 AS c FROM L3 AS A, L3 AS B),
L5 AS(SELECT 1 AS c FROM L4 AS A, L4 AS B),
Nums AS(SELECT ROW_NUMBER() OVER(ORDER BY c) AS n FROM L5)
SELECT n FROM Nums WHERE n &lt;= @N;
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.RemoveProcessIdFromName'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.RemoveProcessIdFromName ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
/************************************************************************************/
/* Object: Function                                                                 */
/* Name: RemoveProcessIdFromName                                                    */
/* Returns:  process name till # symbol.	Exp: w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp       */
/*			 or process name till _ symbol. Exp: w3wp_123 -&gt; w3wp					*/
/* Parameters:                                                                      */
/*          @PROCESSNAME - Process name, from which #N will be removed              */
/************************************************************************************/
ALTER FUNCTION APM.RemoveProcessIdFromName (@PROCESSNAME nvarchar(255))
RETURNS NVARCHAR(255)
AS
BEGIN
	DECLARE @result nvarchar(255), @pos int
	
	/* try to find w3wp#X instance formatting					*/
	SET @pos = CHARINDEX(N'#', REVERSE(@PROCESSNAME))
	SET @result = CASE	WHEN @pos &gt; 0 
					THEN LEFT(@PROCESSNAME, LEN(@PROCESSNAME) - @pos)
					ELSE @result END
										
	/* if w3wp#X instance formatting is not found we will try	*/
	/* to find w3wp_XXXX formatting								*/
	IF @pos = 0
	BEGIN
		SET @pos = PATINDEX( '%[0-9][_]%', REVERSE(@PROCESSNAME))
		SET @result = CASE	WHEN @pos &gt; 0 
						THEN LEFT(@PROCESSNAME, LEN(@PROCESSNAME) - (@pos + 1)) 
						ELSE @PROCESSNAME END
	END
    RETURN @result
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ComputerResourceUtilizationBySource'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ComputerResourceUtilizationBySource AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ComputerResourceUtilizationBySource                                        */
/* USED IN: Computer resource utilization sub report                                */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @SOURCEIDS - List of the source id, separated by comma. Exp: '1,2,3'        */
/*      @MACHINEID - Machine Id for which data should be selected                   */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/************************************************************************************/
ALTER PROCEDURE APM.ComputerResourceUtilizationBySource
    @DATESTART DATETIME,
    @DATEEND DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEID NVARCHAR(255),
    @SORTORDER INT
WITH RECOMPILE
AS
BEGIN
SET NOCOUNT ON
/************************************************************************************/
/*                  PREPARE ASSISTING TEMP TABLES                                   */
/************************************************************************************/
--Filter table, which contains source ids, transfered to SP in @SOURCEIDS parameter
CREATE TABLE #SOURCEPCOUNTERANALYSIS_FILTERTABLE(
        VALUEID INT
)
-- Split computer ids list separated by comma and fill table with it
INSERT 
    INTO #SOURCEPCOUNTERANALYSIS_FILTERTABLE
        SELECT 
            CAST(p.value AS INT)
        FROM 
            --Splits incoming string. Uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, N'') AS p
--Filter PerfHourly table to decrease records count fot further calcultaions
CREATE TABLE #PERFHOURLYBYMACHINE(
        UTCDate DATETIME,
        SOURCEID INT,
        PCPROCESSID INT,
        SUMVALUE FLOAT,
        SAMPLECOUNT BIGINT,
        PACKAGECOUNTER BIGINT,
        MAXVALUE FLOAT,
        TYPE NVARCHAR(MAX) collate database_default
)
INSERT INTO #PERFHOURLYBYMACHINE
    SELECT
        ph.UTCDate,
        ph.sourceId,
        ph.pcprocessId,
        ph.SumValue,
        ph.SampleCount,
        ph.PackageCounter,
        ph.MaxValue,
        t.Type
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        JOIN APM.PCType AS t (NOLOCK) ON t.pctypeid = ph.pctypeid
    WHERE
        ph.UTCDate &gt;= @DATESTART
        AND ph.UTCDate &lt; @DATEEND
        AND ph.MachineId = @MACHINEID
        AND t.type IN 
            (
                N'\Process\% Processor Time',
                N'\Process\IO Data Bytes/sec',
                N'\Process\Private Bytes',
                N'\Apps\Monitored Requests',
                -- 'Processor% Processor Time' counter is taken to calculate application activity,
                -- relative to hours, when machine had been sending counter
                N'\Processor\% Processor Time'
            )
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
--Insert source name with correspondent process name and extrainfo
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SOURCEID,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        #PERFHOURLYBYMACHINE AS ph
        JOIN APM.Source AS s (NOLOCK) ON ph.SOURCEID = s.sourceId
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.PCPROCESSID  
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
--Get sources name, ids list separated by comma per app pool
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        -- source names
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE as c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources,
        -- source ids
        (SELECT A.sourceid AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    CAST(c1.SOURCEID AS NVARCHAR) + N',' AS sourceid
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
            ) AS A
            FOR XML PATH ('') 
        ) AS SourceIds      
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #SOURCEPCOUNTERANALYSIS_FILTERTABLE AS f ON f.VALUEID = c.SOURCEID
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS
),
-- Filter sources for which data should be selected;
-- as info should be selected not only for transfered sources, but also for sources
-- in the same app pool
SourceFilter AS
(
--One application can be in the several app pools, so use DISTINCT
    SELECT DISTINCT 
        s2.SOURCEID
    FROM
        #PROCESSNAMEFORSOURCE AS s1
        JOIN #PROCESSNAMEFORSOURCE AS s2 ON s1.EXTRAINFO = s2.EXTRAINFO AND s1.PROCESS = s2.PROCESS
        JOIN #SOURCEPCOUNTERANALYSIS_FILTERTABLE AS f ON s1.SOURCEID = f.VALUEID
),
--Filter PerfHourly by source
PerfHourlyBySource AS
(
    SELECT
        ph.UTCDate,
        ph.PCPROCESSID,
        ph.SUMVALUE,
        ph.SAMPLECOUNT,
        ph.PACKAGECOUNTER,
        ph.MAXVALUE,
        --This field is used for 'Apps\Monitored Requests' (this counter depends on source only, not process)
        ph.SOURCEID,
        ph.TYPE
    FROM
        #PERFHOURLYBYMACHINE AS ph (NOLOCK)
        JOIN SourceFilter AS s ON s.SOURCEID = ph.SOURCEID
),
--Calculate resource utilization by process in one hour
ProcessHourlyResourceUtilization AS
(
    SELECT
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type,
        -- Select MAX value as in case of app pool, some of the application
        -- could work only part of the hour, and the value should be taken for the 
        -- application worked for the longest period 
        MAX(ph.SumValue) AS SumValue,
        MAX(ph.MaxValue) AS MaxValue,
        MAX(ph.SampleCount) AS SampleCount,
        MAX(ph.PackageCounter) AS PackageCounter 
    FROM
        PerfHourlyBySource AS ph
    WHERE
        --This condition allows to exclude Monitored Requests counter
        PCProcessId IS NOT NULL 
    GROUP BY
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type 
),
--Calculate resource utilization by application in one hour
--application means - web application = AppPool, otherwise = processname
ApplicationHourlyResourceUtilization AS
(
    SELECT
        ph.UTCDate,
        ph.Type,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        --Select process name till # symbol
        APM.RemoveProcessIdFromName(p.Process) AS ProcessName,
        COALESCE(p.ExtraInfo, N'') AS ProcessExtraInfo,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue,
        MAX(ph.MaxValue) AS MaxValue        
    FROM
        ProcessHourlyResourceUtilization AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON ph.PCProcessId = p.PCProcessId
    GROUP BY
        ph.UTCDate,
        ph.Type,
        APM.RemoveProcessIdFromName(p.Process),
        p.ExtraInfo 
),
--Calculate average application resource utilization over all specified period
ApplicationResourceUtilization AS
(
    SELECT
        ph.ProcessName,
        ph.ProcessExtraInfo,
        -- Number of hours when app was active
        COUNT(DISTINCT ph.UTCDate) AS ApplicationAvailabilityHours,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        MAX(ph.InstanceCount) AS MaxInstanceCount,
        AVG(CASE WHEN InstanceCount &lt; 1 THEN InstanceCount ELSE 1 END) AS AppActivity,
        AVG(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.AvgValue END) AS MemoryAvgValue,
        MAX(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.MaxValue END) AS CPUMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.MaxValue END) AS IOMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.MaxValue END) AS MemoryMaxValue
    FROM
        ApplicationHourlyResourceUtilization AS ph
    GROUP BY
        ph.ProcessName,
        ph.ProcessExtraInfo 
),
--Count Monitored Requests for Application
ApplicationRequestCount AS
(
    SELECT
        c.EXTRAINFO,
        c.PROCESS,
        SUM(ph.SUMVALUE) AS RequestCount
    FROM
        PerfHourlyBySource AS ph
        -- If source was running in several app pools  
        -- #PROCESSNAMEFORSOURCE would contain several rows for one sourceid.
        -- In this case request count will be counted for all app pools
        JOIN #PROCESSNAMEFORSOURCE AS c ON ph.SOURCEID = c.SOURCEID
    WHERE
        ph.type = N'\Apps\Monitored Requests'
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS
),
-- Count hours when computer sent counters.
-- This value is used to calculate application activity between hours
ComputerAvailabilityHours AS
(
    SELECT
        COUNT(DISTINCT ph.UTCDate) AS HoursCount
    FROM
        #PERFHOURLYBYMACHINE AS ph
    WHERE
        ph.SOURCEID  IS NULL
        AND ph.PCPROCESSID IS NULL
        AND ph.TYPE = N'\Processor\% Processor Time'
),
OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER (ORDER BY 
                            CASE @SORTORDER 
                                WHEN 1 THEN res.CPUAvgValue 
                                WHEN 2 THEN res.MemoryAvgValue 
                                WHEN 3 THEN res.IOAvgValue 
                                WHEN 4 THEN req.RequestCount 
                            END DESC) AS Id,
        b.ExtraInfo AS AppPoolName,
        --Remove comma from the end
        CASE b.AppPoolSources WHEN '' THEN '' ELSE LEFT(b.AppPoolSources, LEN(b.AppPoolSources)-1) END AS AppPoolSources,
        -- SourceIds string is used for drillthrought report for transfering sources to it
        b.SourceIds,
        req.RequestCount,
        -- Correct instance count and application activity with hours, when application was active
        res.InstanceCount * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount) AS InstanceCount,
        res.MaxInstanceCount,
        res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount) AS AppActivity,
        -- Calculate resource utilization
        res.CPUAvgValue/COALESCE(m.cpucount, 1) AS CPUAvgValue,
        res.IOAvgValue/1024 AS IOAvgValue,
        res.MemoryAvgValue/(1024*1024) AS MemoryAvgValue,
        res.CPUMaxValue/COALESCE(m.cpucount, 1) AS CPUMaxValue,
        res.IOMaxValue/1024 AS IOMaxValue,
        res.MemoryMaxValue/(1024*1024) AS MemoryMaxValue,
        -- This field used for chart value in subreport bottom, 
        -- and it should include application activity both for hour and for specified period (application availability),
        -- in order to be consistan with computer resources
        (CASE @SORTORDER 
                WHEN 1 THEN res.CPUAvgValue/COALESCE(m.cpucount, 1) * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 2 THEN res.MemoryAvgValue/(1024*1024) * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 3 THEN res.IOAvgValue/1024 * res.AppActivity * (res.ApplicationAvailabilityHours*1.0/ca.HoursCount)
                WHEN 4 THEN req.RequestCount 
        END) AS OrderedValue
    FROM
        AppPoolInfo AS b
        JOIN ApplicationResourceUtilization AS res ON res.ProcessExtraInfo = b.ExtraInfo AND res.ProcessName = b.Process
        LEFT OUTER JOIN ApplicationRequestCount AS req ON req.ExtraInfo = b.ExtraInfo AND req.Process = b.Process
        JOIN APM.Machine AS m (NOLOCK) ON m.machineid = @MACHINEID
        -- This query has only one record, and this value is common for all sources,
        -- so use CROSS JOIN
        CROSS JOIN ComputerAvailabilityHours AS ca
)
SELECT
    Id,
    CASE 
        WHEN LEN(AppPoolName) &gt; 0 THEN AppPoolName + N' - '+ AppPoolSources
        ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
    END AS AppPoolName,
    SourceIds,
    RequestCount,
    InstanceCount,
    MaxInstanceCount,
    AppActivity,
    CPUAvgValue,
    CPUMaxValue,
    MemoryAvgValue,
    MemoryMaxValue,
    IOAvgValue,
    IOMaxValue,
    OrderedValue
FROM
    OrderedDataSet
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetQueryDateCount'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetQueryDateCount ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetQueryDateCount(@PERIODTYPE INT, @CURRENTDATE DATETIME) RETURNS INT
AS
BEGIN
  RETURN 
        CASE @PERIODTYPE 
            WHEN 1 THEN 1
            WHEN 2 THEN 7
            WHEN 3 THEN 31
        END 
END
GO
--------------------End Helper function for the management_application_summary_quality_analysis_report ------------------
--------------------Helper function for the management_reports_breakdown_report ------------------
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetDatePart'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetDatePart ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
alter FUNCTION APM.GetDatePart(@DATEPART nvarchar(10), @DATE dateTime) RETURNS INT
AS
BEGIN
  RETURN 
        CASE @DATEPART 
            WHEN 'Hour' THEN Datepart(hh, @DATE)
            WHEN 'WeekDay' THEN Datepart(dw, @DATE)
            WHEN 'MonthDay' THEN Datepart(d, @DATE)
        END 
END
GO
-------------------End Helper function for the management_reports_breakdown_report-------------------
--------------------Temporary table----------------------
IF (OBJECTPROPERTY(OBJECT_ID('APM.DATES'), 'IsTable') IS NOT NULL)
  BEGIN
    DROP TABLE APM.DATES
  END
GO
CREATE TABLE APM.DATES(
    WeekDays smallint NULL,
    HourDates smallint NULL,
    MonthDays smallint NULL,
    DatesId int NULL
) 
GO
;WITH DATES_BUILD(WEEKDAYS,HOURDATES,MONTHDAYS, DatesId)  AS
(
      SELECT
       CASE WHEN N &lt;= 7 THEN N END WEEKDAYS,
         CASE WHEN N &lt;= 24 THEN N-1 END HOURDATES,
         N AS MONTHDAYS,
         N AS DatesId    
    FROM APM.FN_NUMS(31)
)
INSERT INTO APM.DATES SELECT * FROM DATES_BUILD
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationResourceUtilization'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationResourceUtilization AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationResourceUtilization                                             */
/* USED IN: Application ResourceUtilization report                                  */
/* INPUT PARAMETERS:                                                                */
/*      @DATESTART - Start date of the priod                                        */
/*      @DATEEND - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SORTORDER - Specifies field to which sorting should be applayed            */
/*                  1. CPU value                                                    */
/*                  2. Memory value                                                 */
/*                  3. I/O value                                                    */
/*                  4. Request count                                                */
/*      @TOPROWCOUNT - defines number of top rows, which will be returned           */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationResourceUtilization
    @DATESTART DATETIME,
    @DATEEND DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SORTORDER INT,
    @TOPROWCOUNT INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p
-- Filter PerfHourly table to decrease nummber of rows for further manipulations.
-- Filtering by sources could not be done as some of the filtered sources can be in app pools,
-- so they should present in calculations
CREATE TABLE #PERFHOURLYFILTERBYMACHINE
(
        UTCDate DATETIME,
        SOURCEID INT,
        MACHINEID INT,
        PCPROCESSID INT,
        SUMVALUE FLOAT,
        SAMPLECOUNT BIGINT,
        PACKAGECOUNTER BIGINT,
        MAXVALUE FLOAT,
        TYPE NVARCHAR(MAX) collate database_default
)
--Fill table #PERFHOURLYFILTERBYMACHINE
INSERT 
    INTO #PERFHOURLYFILTERBYMACHINE
        SELECT
            ph.UTCDate,
            ph.sourceId,
            ph.MachineId,
            ph.pcprocessId,
            ph.SumValue,
            ph.SampleCount,
            ph.PackageCounter,
            ph.MaxValue,
            t.Type
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            JOIN APM.PCType AS t (NOLOCK) ON t.pctypeid = ph.pctypeid
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND f.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @DATESTART
            AND ph.UTCDate &lt; @DATEEND
            AND t.type IN 
                (
                    N'\Process\% Processor Time',
                    N'\Process\IO Data Bytes/sec',
                    N'\Process\Private Bytes',
                    N'\Apps\Monitored Requests',
                    -- 'Processor% Processor Time' counter is taken to calculate application activity,
                    -- relative to hours, when machine sent counter
                    N'\Processor\% Processor Time'
                )
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    MACHINEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
-- Insert source and machine with correspondent process name and extrainfo
-- Here machine is used, as same source with same process name can run in different machines
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SOURCEID,
        ph.MACHINEID,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph
        JOIN APM.Source AS s (NOLOCK) ON ph.SOURCEID = s.sourceId
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.PCPROCESSID 
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
--Get sources name, ids list separated by comma per app pool
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID,
        -- all source names which have the same process name as passed in @SOURCEIDS
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources,
        --Select SourceIds list for application pool, this string is need to avoid drillthrought to other reports
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    CAST(c1.SOURCEID AS NVARCHAR(5)) + N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS SourceIds
        
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID
),
-- Filter sources for which data should be selected;
-- as info should be selected not only for transfered sources, but also for sources
-- in the same app pool
SourceFilter AS
(
--One application can be in the several app pools, so use DISTINCT
    SELECT DISTINCT 
        s2.SOURCEID
    FROM
        #PROCESSNAMEFORSOURCE AS s1
        JOIN #PROCESSNAMEFORSOURCE AS s2 ON s1.EXTRAINFO = s2.EXTRAINFO AND s1.PROCESS = s2.PROCESS
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND s1.SOURCEID = f.VALUEID)
),
--Filter PerfHourly by source
PerfHourlyBySource AS
(
    SELECT
        ph.UTCDate,
        ph.PCPROCESSID,
        ph.MACHINEID,
        ph.SUMVALUE,
        ph.SAMPLECOUNT,
        ph.PACKAGECOUNTER,
        ph.MAXVALUE,
        ph.SOURCEID,
        ph.TYPE
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph (NOLOCK)
        JOIN SourceFilter AS s ON s.SOURCEID = ph.SOURCEID
),
--Calculate resource utilization by processes on machines in one hour
ProcessHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type,
        -- Select MAX value as in case of app pool, some of the application
        -- could work not whole hour, and the value should be taken for the 
        -- application worked for the longest period 
        MAX(ph.SumValue) AS SumValue,
        MAX(ph.MaxValue) AS MaxValue,
        MAX(ph.SampleCount) AS SampleCount,
        MAX(ph.PackageCounter) AS PackageCounter 
    FROM
        PerfHourlyBySource AS ph
    WHERE
        --This condition allows to exclude Monitored Requests counter
        PCProcessId IS NOT NULL 
    GROUP BY
        ph.MachineId,
        ph.UTCDate,
        ph.pcprocessId,
        ph.Type 
),
-- Calculate resource utilization by application in one hour.
-- Here "application" means - for web application = AppPool, otherwise = processname
ApplicationHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
        ph.UTCDate,
        ph.Type,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        --Select process name till # symbol
        APM.RemoveProcessIdFromName(p.Process) AS ProcessName,
        COALESCE(p.ExtraInfo, N'') AS ProcessExtraInfo,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue,
        MAX(ph.MaxValue) AS MaxValue        
    FROM
        ProcessHourlyResourceUtilization AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON ph.PCProcessId = p.PCProcessId
    GROUP BY
        ph.MachineId,
        ph.UTCDate,
        ph.Type,
        APM.RemoveProcessIdFromName(p.Process),
        p.ExtraInfo 
),
--Calculate average application resource utilization over all specified period per machine
ApplicationResourceUtilizationByMachines AS
(
    SELECT
        ph.MachineId,
        ph.ProcessName,
        ph.ProcessExtraInfo,
        -- Number of hours when application was active
        COUNT(DISTINCT ph.UTCDate) AS ApplicationAvailabilityHours,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        MAX(ph.InstanceCount) AS MaxInstanceCount,
        AVG(CASE WHEN InstanceCount &lt; 1 THEN InstanceCount ELSE 1 END) AS AppActivity,
        AVG(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.AvgValue END) AS MemoryAvgValue,
        MAX(CASE WHEN ph.type = N'\Process\% Processor Time' THEN ph.MaxValue END) AS CPUMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\IO Data Bytes/sec' THEN ph.MaxValue END) AS IOMaxValue,
        MAX(CASE WHEN ph.type = N'\Process\Private Bytes' THEN ph.MaxValue END) AS MemoryMaxValue
    FROM
        ApplicationHourlyResourceUtilization AS ph
    GROUP BY
        ph.MachineId,
        ph.ProcessName,
        ph.ProcessExtraInfo 
),
-- Count hours when computer sent counters.
-- This value is used to calculate application activity between hours
ComputerAvailabilityHours AS
(
    SELECT
        COUNT(DISTINCT ph.UTCDate) AS HoursCount,
        ph.MACHINEID
    FROM
        #PERFHOURLYFILTERBYMACHINE AS ph
    WHERE
        ph.SOURCEID IS NULL
        AND ph.PCPROCESSID IS NULL
        AND ph.TYPE = N'\Processor\% Processor Time'
    GROUP BY
        ph.MACHINEID
),
-- Count Monitored Requests for Application on each machine
-- as source can run on different machines with same process name and app pool, but different sources set, 
-- it is important to group by machine to, to avoid calculation of requests from the other app pool
ApplicationRequestCountByMachine AS
(
    SELECT
        ph.MACHINEID,
        c.EXTRAINFO,
        c.PROCESS,
        SUM(ph.SUMVALUE) AS RequestCount
    FROM
        PerfHourlyBySource AS ph
        -- If source was running in several app pools  
        -- #PROCESSNAMEFORSOURCE would contain several rows for one sourceid.
        -- In this case request count will be counted for all app pools
        JOIN #PROCESSNAMEFORSOURCE AS c ON (ph.SOURCEID = c.SOURCEID AND ph.MACHINEID = c.MACHINEID)
    WHERE
        ph.TYPE = N'\Apps\Monitored Requests'
    GROUP BY
        ph.MACHINEID,
        c.EXTRAINFO,
        c.PROCESS
),
--Summary application resource utilization info by machines
ApplicationResourceUtilization AS
(
    SELECT 
        -- Enumerate computers within application by specified orderBy value
        ROW_NUMBER() OVER (PARTITION BY 
-- Application pool sources added to grouping as on different machines app pool with the same names
-- can contain different sources set, and app pools assumed to be same only
-- if its name and sources set are the same
                        appPool.ExtraInfo,
                        appPool.Process,
                        appPool.AppPoolSources      
                        ORDER BY 
                        CASE @SORTORDER 
                            WHEN 1 THEN ph.CPUAvgValue/COALESCE(m.CPUCount, 1)
                            WHEN 2 THEN ph.MemoryAvgValue 
                            WHEN 3 THEN ph.IOAvgValue 
                            WHEN 4 THEN r.RequestCount 
                        END DESC) AS ComputerId,
        m.machine,
        m.MachineId,
        COALESCE(m.CpuCount, 1) AS CPUCount,
        appPool.ExtraInfo,
        appPool.Process,
        -- Remove comma form the end of source list
        CASE appPool.AppPoolSources WHEN '' THEN '' ELSE LEFT(appPool.AppPoolSources, LEN(appPool.AppPoolSources)-1) END AS AppPoolSources,
        -- Use application activity during all period for instance count calculation and application activity
        InstanceCount*ph.ApplicationAvailabilityHours*1.0/mc.HoursCount AS InstanceCount,
        AppActivity*ph.ApplicationAvailabilityHours*1.0/mc.HoursCount AS AppActivity,
        MaxInstanceCount AS MaxInstanceCount,
        -- CPU load should be normalized on core count for each machine
        CPUAvgValue/COALESCE(m.CPUCount, 1) AS CPUAvgValue,
        CPUMaxValue/COALESCE(m.CPUCount, 1) AS CPUMaxValue,
        IOAvgValue AS IOAvgValue,
        IOMaxValue AS IOMaxValue,
        MemoryAvgValue AS MemoryAvgValue,
        MemoryMaxValue AS MemoryMaxValue,
        r.RequestCount AS RequestCount,
        appPool.SourceIds,
        -- Flag to define if cpu count is not null,
        -- in case of  CPUDefineFlag = 0, show warning message about it in report
        COALESCE(m.CPUCount, 0) AS CPUDefineFlag,
        -- Calculate average value for SortBy field for application over all its machines
        -- This value will be used to enumerate application by specified OrderBy Value
        AVG(CASE @SORTORDER 
                WHEN 1 THEN ph.CPUAvgValue/COALESCE(m.CPUCount, 1)
                WHEN 2 THEN ph.MemoryAvgValue 
                WHEN 3 THEN ph.IOAvgValue 
            END) 
            OVER (PARTITION BY appPool.ExtraInfo,
                        appPool.Process,
                        AppPoolSources  ) AS OrderByValue,
        -- For order by requests sum of requests should be calculated
        SUM(r.RequestCount) OVER(PARTITION BY appPool.ExtraInfo,
                        appPool.Process,
                        AppPoolSources) AS ApplicationRequestCount
    FROM
        ApplicationResourceUtilizationByMachines AS ph
        JOIN AppPoolInfo AS appPool ON (appPool.ExtraInfo = ph.ProcessExtraInfo AND 
                                appPool.Process = ph.ProcessName AND
                                appPool.MachineId = ph.MachineId)
        LEFT OUTER JOIN ApplicationRequestCountByMachine AS r ON (ph.ProcessName = r.Process 
                                                                AND ph.ProcessExtraInfo = r.ExtraInfo
                                                                AND ph.MachineId = r.MachineId)
        JOIN ComputerAvailabilityHours AS mc ON mc.MachineId = ph.MachineId
        JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = ph.MachineId
),
-- Value of Id field is duplicated for each application.
OrderedDataSet AS
(
    SELECT 
        -- DENSE_RANK function returns equal id for equal values in Over expression
        -- This allow to enumerate Application within result set by specified order by value
        DENSE_RANK() OVER(ORDER BY 
                            (CASE 
                                WHEN @SORTORDER = 4 THEN ApplicationRequestCount 
                                ELSE OrderByValue 
                            END) DESC, 
                            ExtraInfo,
                            AppPoolSources  ) AS Id,
        OrderByValue,
        ComputerId,
        machine,
        MachineId,
        CPUCount,
        CASE 
            WHEN LEN(ExtraInfo) &gt; 0 THEN ExtraInfo + N' - '+ AppPoolSources
            -- remove quotes from the start and end of the source name
            ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
        END AS AppPoolName,
        CASE 
            WHEN LEN(ExtraInfo) &gt; 0 THEN ExtraInfo  
            ELSE CASE AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(AppPoolSources, 2, LEN(AppPoolSources)-2) END
        END AS ApplicationName,
        InstanceCount,
        MaxInstanceCount,
        AppActivity,
        CPUAvgValue,
        CPUMaxValue,
        IOAvgValue/1024 AS IOAvgValue,
        IOMaxValue/1024 AS IOMaxValue,
        MemoryAvgValue/(1024*1024) AS MemoryAvgValue,
        MemoryMaxValue/(1024*1024) AS MemoryMaxValue,
        RequestCount,
        SourceIds,
        CPUDefineFlag
    FROM
        ApplicationResourceUtilization
)
SELECT
    *
FROM
    OrderedDataSet
WHERE
    Id &lt;= @TOPROWCOUNT
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTop10MostFrequentFailureReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTop10MostFrequentFailureReport AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTop10MostFrequentFailureReport
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH ExceptionProblems AS
    (
        SELECT 
            e.description,
            e.category,
            COUNT(
                    CASE 
                        WHEN e.utceventdate &gt;= @STARTDATE AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
                    THEN e.eventid
                    END 
                  ) as EventsCount,  
            COUNT(
                    CASE 
                        WHEN e.utceventdate &gt;= @LASTPERIODSTARTDATE AND e.utceventdate &lt; @STARTDATE 
                    THEN e.eventid
                    END
                  ) AS LastEventsCount,
            MAX(e.SeViewerDBId) AS SeViewerDBId
        FROM
            APM.Event (NOLOCK) AS e
            JOIN #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.TYPEID = 1 AND e.sourceid = f1.VALUE)
            JOIN #GETTOP10MOSTFREQUENTFAILURE_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.TYPEID = 2 AND e.machineid = f2.VALUE)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE 
            e.EventClassType = N'Exception'
            AND (e.category LIKE @PROBLEM)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE
        GROUP BY 
            e.description, e.category
    ),
    OrderedExceptionProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY EventsCount DESC) AS Id,
            [description],
            EventsCount,
            LastEventsCount,
            category,
            db.[Address] AS SeViewer
        FROM
            ExceptionProblems AS e
            JOIN APM.SeViewerDB AS db (NOLOCK) ON e.SeViewerDBId = db.SeViewerDBId            
        WHERE 
            EventsCount &gt; 0
    ),
    GroupedExceptionProblems AS
    (
        SELECT
            Id,
            [description],
            EventsCount,
            LastEventsCount,
            category,
            SeViewer,
            SUM(CASE WHEN Id &gt; 10 THEN EventsCount ELSE 0 END) OVER () AS OtherSum,
            SUM(CASE WHEN Id &gt; 10 THEN LastEventsCount ELSE 0 END) OVER () AS OtherLastSum,
            SUM(EventsCount) OVER () AS SummaryCount
        FROM
            OrderedExceptionProblems        
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedExceptionProblems ORDER BY Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTop10MostFrequentPerformanceReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTop10MostFrequentPerformanceReport AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTop10MostFrequentPerformanceReport
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    CREATE TABLE #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    CREATE INDEX idx_parametertmp ON #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE(TYPEID) INCLUDE(VALUE)  
    ;WITH PerformanceProblems AS
    (
        SELECT 
            COUNT(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventid END) as IssuesCount,
            AVG(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS AvgDuration,
            MAX(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS MaxDuration,
            COUNT(CASE WHEN e.utceventdate &lt; @STARTDATE THEN e.eventid END) AS LastIssuesCount,
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END) AS PerfNodeDescription
        FROM
            APM.Event (NOLOCK) AS e
			JOIN #PMSTATUSFILTERTABLE AS f ON (f.VALUEID = e.PMStatus)             
            OUTER APPLY (
                SELECT TOP(1)
                    description
                FROM
                    APM.PerformanceNode (NOLOCK)
                WHERE
                    EVENTID = e.EventId  AND e.resourceid = resourceid
                ORDER BY 
                    SelfDuration DESC
            ) AS pn 
        WHERE 
            e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD 
            AND e.sourceid IN (SELECT VALUE FROM #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f1 WHERE f1.TYPEID = 1)
            AND e.machineid IN (SELECT VALUE FROM #GETTOP10MOSTFREQUENTPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f2 WHERE f2.TYPEID = 2)
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
        GROUP BY 
            e.rootnodename, (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
                    END)
    ),
    OrderedPerformanceProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY IssuesCount DESC) AS Id,
            rootnodename,
            PerfNodeDescription,
            rootnodename + (CASE 
                                WHEN LEN(PerfNodeDescription) &gt; 0 
                                THEN ' slow at ' +  PerfNodeDescription 
                            ELSE N'' END) AS description,
            IssuesCount,
            AvgDuration,
            MaxDuration,
            LastIssuesCount,
            (SELECT SUM(IssuesCount) FROM PerformanceProblems) AS SummaryCount
        FROM
            PerformanceProblems
        WHERE 
            IssuesCount &gt; 0            
    ),
    GroupedPerformanceproblems AS
    (
        SELECT
            Id,
            rootnodename,
            PerfNodeDescription,
            description,
            IssuesCount,
            AvgDuration,
            MaxDuration,
            LastIssuesCount,
            SUM(CASE WHEN Id &gt; 10 THEN IssuesCount ELSE 0 END) OVER () AS OtherSum,
            SUM(CASE WHEN Id &gt; 10 THEN LastIssuesCount ELSE 0 END) OVER () AS OtherLastSum,
            SUM(IssuesCount) OVER () AS SummaryCount
        FROM
            OrderedPerformanceProblems      
    )
    SELECT 
        TOP(10) *
    FROM 
        GroupedPerformanceproblems
    ORDER BY 
        Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTOP10NewExceptionProblems'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTOP10NewExceptionProblems AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTOP10NewExceptionProblems
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
                
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH NewExceptionProblems AS
    (
        SELECT 
            e.description,
            e.category,
            COUNT(DISTINCT e.eventid) as EventsCount,
            MAX(e.SeViewerDBId) AS SeViewerDBId
        FROM
            APM.Event (NOLOCK) AS e
            JOIN #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.VALUE = e.sourceid and f1.TYPEID = 1) 
            JOIN #GETTOP10NEWEXCEPTION_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.VALUE = e.machineid and f2.TYPEID = 2)
            JOIN APM.eventgroup (NOLOCK) AS eg ON e.eventGroupId = eg.EventGroupId
        WHERE 
            e.EventClassType = N'Exception'
            AND (e.category LIKE @PROBLEM)
            AND e.utceventdate &gt;= @STARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE
            AND eg.firsteventdate &gt;= @STARTDATE
            AND (e.PMStatus = 0)              
        GROUP BY 
            e.description, e.category
    ),
    OrderedExceptionProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY EventsCount DESC) AS Id,
            description,
            EventsCount,
            category,
            db.Address AS SeViewer           
        FROM
            NewExceptionProblems e
            JOIN APM.SeViewerDB AS db (NOLOCK) ON e.SeViewerDBId = db.SeViewerDBId            
    ),
    GroupedExceptionProblems AS
    (
        SELECT
            *,
            SUM(CASE WHEN Id &gt; 10 THEN EventsCount ELSE 0 END) OVER() AS OtherSum,
            SUM(EventsCount) OVER() AS EventsSum
        FROM 
            OrderedExceptionProblems
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedExceptionProblems
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetTOP10NewPerformanceProblems'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetTOP10NewPerformanceProblems AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetTOP10NewPerformanceProblems
    @SOURCE NVARCHAR(MAX),
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE
            SELECT 
                    p.typeid,
                    cast(p.value AS Int)
                FROM APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH NewPerformanceProblems AS
    (
        SELECT 
            COUNT(e.eventid) as IssuesCount,
            AVG(e.eventduration / 1000000) AS AvgDuration,
            MAX(e.eventduration / 1000000) AS MaxDuration,
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END) AS PerfNodeDescription
        FROM
            APM.Event AS e
            JOIN #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f1 ON (f1.VALUE = e.sourceid and f1.TYPEID = 1) 
            JOIN #GETTOP10NEWPERFORMANCE_SOURCEMACHINEMULTIVALUE AS f2 ON (f2.VALUE = e.machineid and f2.TYPEID = 2)
            JOIN APM.eventgroup (NOLOCK) AS eg ON E.EventGroupId = eg.EventGroupId
            OUTER APPLY (
                SELECT TOP(1)
                    description
                FROM
                    APM.PerformanceNode (NOLOCK)
                WHERE
                    EVENTID = e.EventId  AND e.resourceid = resourceid
                ORDER BY 
                    SelfDuration DESC
            ) AS pn 
        WHERE 
            e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD 
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @STARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
            AND eg.firsteventdate &gt;= @STARTDATE
            AND eg.firsteventdate &lt; @CURRENTPERIODENDDATE 
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
            AND (e.PMStatus = 0)              
        GROUP BY 
            e.rootnodename, (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
                    END)
    ),
    OrderedPerformanceProblems AS
    (
        SELECT
            ROW_NUMBER() OVER (ORDER BY IssuesCount DESC) AS Id,
            rootnodename,
            PerfNodeDescription,
            rootnodename + (CASE 
                                WHEN LEN(PerfNodeDescription) &gt; 0 
                                THEN ' slow at ' +  PerfNodeDescription 
                            ELSE N'' END) AS description,
            IssuesCount,
            AvgDuration,
            MaxDuration
        FROM
            NewPerformanceProblems
    ),
    GroupedPerformanceProblems AS
    (
        SELECT
            *,
            SUM(CASE WHEN Id &gt; 10 THEN IssuesCount ELSE 0 END) OVER() AS OtherSum,
            SUM(IssuesCount) OVER() AS SummaryCount
        FROM
            OrderedPerformanceProblems
    )
    SELECT 
        TOP 10 *
    FROM 
        GroupedPerformanceProblems
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetAbsDateByRelative'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.GetAbsDateByRelative ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.GetAbsDateByRelative(@RELATIVEDATE INT) RETURNS DATETIME
AS
BEGIN
  RETURN 
            CASE @RELATIVEDATE 
                  WHEN 10 THEN DATEADD(d, -(DATEPART(WEEKDAY, GETDATE()) - 1), GETDATE())
                WHEN 20 THEN DATEADD(d, (7 - DATEPART(WEEKDAY, GETDATE())), GETDATE())
                WHEN 30 THEN DATEADD(WEEK, -1, DATEADD(d, -(DATEPART(WEEKDAY, GETDATE()) - 1), GETDATE()))
                  WHEN 40 THEN DATEADD(WEEK, -1, DATEADD(d, (7 - DATEPART(WEEKDAY, GETDATE())), GETDATE())) 
                WHEN 50 THEN DATEADD(DAY, -(DATEPART(DAY, GETDATE()) - 1), GETDATE())
                WHEN 60 THEN DATEADD(d, -DATEPART(DAY, DATEADD(MONTH, 1, GETDATE())), DATEADD(MONTH, 1, GETDATE()))
                WHEN 70 THEN DATEADD(MONTH, -1, DATEADD(DAY, -(DATEPART(DAY, GETDATE()) - 1), GETDATE()))
                WHEN 80 THEN DATEADD(DAY, -DATEPART(DAY, GETDATE()), GETDATE())
                WHEN 90 THEN GETDATE()
                WHEN 100 THEN DATEADD(DAY, -1, GETDATE())
                WHEN 110 THEN DATEADD(DAY, 1, GETDATE())
          END     
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('apm.Split'), 'IsTableFunction') IS NOT NULL)
  BEGIN
    DROP FUNCTION apm.Split    
  END
GO
CREATE FUNCTION apm.Split(@String NVARCHAR(MAX), @Delimiter NCHAR(1) = N',')       
RETURNS @temptable TABLE 
(
	items NVARCHAR(MAX)
)       
AS       
BEGIN       
    DECLARE @idx INT
    DECLARE @slice NVARCHAR(MAX)
      
    SELECT @idx = 1       
    IF @Delimiter IS NULL OR LEN(@Delimiter) &lt; 1 
		return;
       
    IF @String IS NULL OR LEN(@String) &lt; 1
		return;
      
    WHILE @idx!= 0       
    BEGIN       
        SET @idx = CHARINDEX(@Delimiter,@String)       
        IF @idx!=0       
            SET @slice = LEFT(@String,@idx - 1)       
        ELSE       
            SET @slice = @String       
          
        IF(LEN(@slice)&gt;0)  
            INSERT INTO @temptable(Items) VALUES(@slice)       
  
        SET @String = RIGHT(@String,LEN(@String) - @idx)       
        IF LEN(@String) = 0 BREAK       
    END   
RETURN       
END  
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetMultiParameters'), 'IsTableFunction') IS NOT NULL)
  BEGIN
    DROP FUNCTION APM.GetMultiParameters    
  END
GO
create FUNCTION APM.GetMultiParameters(@PARAMETER1 NVARCHAR(MAX), @PARAMETER2 NVARCHAR(MAX))
RETURNS @RESULT TABLE
(
    ID INT,
    TYPEID INT,
    VALUE NVARCHAR(MAX)
) 
AS 
BEGIN
    ;WITH Filters AS 
    (
        SELECT 
			1 AS typeId, items AS [Value]
        FROM
			apm.Split(@PARAMETER1, ',') 
        UNION ALL
        SELECT 
			2 AS typeId, items AS [Value]
        FROM
			apm.Split(@PARAMETER2, ',') 
    )
    INSERT INTO @RESULT 
        SELECT 
            ROW_NUMBER() OVER (ORDER BY typeId, [Value]) AS Id,
            typeId, 
            RTRIM(LTRIM([value])) AS Value
        FROM 
			Filters 
			
    RETURN
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ResourceUtilizationTrend'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ResourceUtilizationTrend AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ResourceUtilizationTrend                                                   */
/* USED IN: Day of Week Utilization, Hour of Day Utilization,                       */
/*      Utilization Trend reports                                                   */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @TIMEZONE - Time offset relative to UTC. Used in SP to calculate            */
/*              period in UTC and for conversion UTC time back                      */
/*              to user time (for showing in trend chart)                           */
/*      @GROUPBY - Specifies result gouping type. Possible values:                  */
/*              Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                  corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*              WeekDay - Group by week days. For this grouping type extra grouping */
/*                  is applied - by hours. So result data set contains 7*24 rows.   */
/*                  Date field values - 1-7, Hour fields - 0-23                 */
/*              Date - Group by date. Number of row equal to days count in specified*/
/*                  period. If extra parameter @GROUPBYHOUR = 1, then extra grouping*/
/*                  by hours applied. If @GROUPBYHOUR = 0, than date field values - */
/*                  0-(@ENDDATE-@STARTDATE) and Hour field - 0.If @GROUPBYHOUR = 1*/
/*                  than date field values - 0-(@ENDDATE-@STARTDATE)                */
/*                  and Hour field - 0-23                                           */
/*      @GROUPBYHOUR - flag to apply extra grouping by Hour. Available only for     */
/*                  grouping by Date.                                               */
/************************************************************************************/
ALTER PROCEDURE APM.ResourceUtilizationTrend 
    @SOURCEIDS NVARCHAR(MAX),
    @MACHINEIDS NVARCHAR(MAX),
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @GROUPBY NVARCHAR(10),
    @PMSTATUS NVARCHAR(50),
    @GROUPBYHOUR BIT = 0
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
/************************************************************************************************************************/
/*                              DECLARE SP VARIABLES                                                                    */    
/************************************************************************************************************************/
--Convert start date to utc format
    DECLARE @UTCSTARTDATE DATETIME
    SET @UTCSTARTDATE = DATEADD(minute, -@TIMEZONE, @STARTDATE)
--Convert end date to utc format
    DECLARE @UTCENDDATE DATETIME
    SET @UTCENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
-- Day count in specified period
    DECLARE @PERIOD INT
    SET @PERIOD = ABS(DATEDIFF(day, @STARTDATE, @ENDDATE)) + 1
-- Define if extra grouping by hours should be applied
    DECLARE @DOGROUPINGBYHOUR BIT
    SET @DOGROUPINGBYHOUR = CASE 
-- For group by WeekDay always do extra grouping by hours, for grouping by Date, only if @GROUPBYHOUR = 1 specified
                                WHEN @GROUPBY = 'WeekDay' THEN 1
                                WHEN (@GROUPBY = 'Date' AND @GROUPBYHOUR = 1) THEN 1
                                ELSE 0
                        END
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
/************************************************************************************************************/
/*                                  PREPARE ASSISTING TABLES                                                */
/************************************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
--Assisting table for application pool forming
CREATE TABLE #PROCESSNAMEFORSOURCE(
    SOURCE NVARCHAR(255) collate database_default,
    SOURCEID INT,
    MACHINEID INT,
    EXTRAINFO NVARCHAR(MAX) collate database_default,
    PROCESS NVARCHAR(255) collate database_default
)
-- Insert source and machine with correspondent process name and extrainfo
-- Here machine is used, as same source with same process name can run in different machines
INSERT INTO #PROCESSNAMEFORSOURCE
    SELECT DISTINCT
        S.Source,
        ph.SourceId,
        ph.MachineId,
        COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
        --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
        APM.RemoveProcessIdFromName(p.Process) AS Process
    FROM
        (
            SELECT DISTINCT
                ph.SourceId,
                ph.pcprocessId,
                ph.MachineId
            FROM
                APM.PerfHourly AS ph (NOLOCK)
            WHERE
                ph.pcprocessId IS NOT NULL
                AND ph.UTCDate &gt;= @UTCSTARTDATE
                AND ph.UTCDate &lt; @UTCENDDATE
        ) AS ph
        JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.pcprocessId 
	JOIN APM.Source AS s (NOLOCK) ON s.SourceId = ph.SourceId
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MachineId = f.VALUEID)        
-- Assisting table, which contains filtered rows from Event table  
CREATE TABLE #EVENTFILTER
(
    EVENTID BIGINT,
    SOURCEID INT,
    SEVIEWERADDRESS NVARCHAR(MAX) collate database_default,
    HOUR INT,
    DATE INT
)
INSERT INTO #EVENTFILTER
    SELECT 
        e.EventId,
        E.SourceId,
        -- Select event SeViewerd address to provide link to it in report
        db.Address AS SEVIEWERADDRESS,
        -- If grouping by hour should be done, then get hour from event date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, e.utceventdate))
            ELSE 0
        END) AS HOUR,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between event date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, e.utceventdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, e.utceventdate))
        END) AS DATE
    FROM
        APM.EVENT AS e
        JOIN APM.SeViewerDB AS db ON e.seviewerdbid = db.seviewerdbid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE f1 ON e.SourceId = f1.VALUEID AND f1.TYPEID = 1
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE f2 ON e.MachineId = f2.VALUEID AND f2.TYPEID = 2
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.UTCEventDate &gt;= @UTCSTARTDATE
        AND e.UTCEventDate &lt; @UTCENDDATE
        AND (e.HeavyLight IS NULL OR e.HeavyLight  &gt; 0)
/********************************************************************************/
/*                                  MAIN QUERY                                  */
/********************************************************************************/
-- Get sources name, ids list separated by comma per app pool
-- This info should be selected for all sources, even they are in the same application pool
-- as in this report grouping by source is applied not by application pool.
;WITH AppPoolInfo AS 
(
    SELECT 
        c.EXTRAINFO,
        c.PROCESS,
        c.SOURCEID,
        -- all source names which have the same process name as passed in @SOURCEIDS
        (SELECT A.source AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    N'''' + c1.SOURCE + N'''' +  N',' AS source
                FROM 
                    #PROCESSNAMEFORSOURCE AS c1
                WHERE 
                    c1.EXTRAINFO = c.EXTRAINFO 
                    AND c1.PROCESS = c.PROCESS
                    AND c1.MACHINEID = c.MACHINEID
            ) AS A
            FOR XML PATH ('') 
        ) AS AppPoolSources
    FROM
        #PROCESSNAMEFORSOURCE AS c
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
    GROUP BY
        c.EXTRAINFO,
        c.PROCESS,
        c.MACHINEID,
        c.SOURCEID
),
SourceDescription AS (
    SELECT DISTINCT
        CASE 
            -- For web application add app pool name before source list (remove comma from the source list end)
            WHEN LEN(pd.ExtraInfo) &gt; 0 THEN pd.ExtraInfo + CASE pd.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(pd.AppPoolSources, LEN(pd.AppPoolSources) - 1) + ')' END
            -- For executable application remove quotes from the start and end and remove comma
            ELSE CASE pd.AppPoolSources WHEN '' THEN '' ELSE SUBSTRING(pd.AppPoolSources, 2, LEN(pd.AppPoolSources)-3) END
            
        END AppPool,
        pd.SourceId
    FROM 
        AppPoolInfo AS pd
),
-- Forms application pool list for each source
-- Format: AppPool1 - ('Source1', 'Source2', Source3), AppPool2 - ('Source1', 'Source4')
SourceAppPools AS (
    SELECT 
        s.SourceId,
        -- Also select source name, to show it to user in report
        s.Source,
        (SELECT a.AppPool AS [data()]
            FROM 
            (
                SELECT DISTINCT 
                    sd.AppPool +  N', ' AS AppPool
                FROM 
                    SourceDescription as sd
                WHERE 
                    sd.SourceId = s.Sourceid 
            ) AS A
            FOR XML PATH ('') 
        ) AS AggAppPool
    FROM 
        #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f
        JOIN APM.Source AS s (NOLOCK) ON f.VALUEID = s.SourceId
    WHERE 
        f.TYPEID = 1
),
-- Report frame. It contains all sources, for which data sould be selected, 
-- and date values accordingly to specified period and grouping type.  
SourcesDates AS 
(
    SELECT DISTINCT
        -- Remove comma from the end
        CASE sd.AggAppPool WHEN '' THEN '' ELSE LEFT(sd.AggAppPool, LEN(sd.AggAppPool) - 1) END AS AppPool,
        sd.Source AS Source,
        sd.SourceId AS SourceId,
        -- Decrease hours to one. Result either 0-23, or 0 (if grouping by hours not specified)
        Hours.n-1 AS hours,
        D.date AS date
    FROM
        SourceAppPools AS sd
        -- If groupng by hours should be applied, select values for hours 1-24, else select only one value - 1
        CROSS JOIN APM.fn_nums(                
            (CASE
                WHEN @DOGROUPINGBYHOUR = 1 THEN 24
                ELSE 1
            END)) AS Hours
        -- Select date, depending on Group by parameter
        CROSS JOIN (SELECT
            (CASE
                -- Values 0-23
                WHEN @GROUPBY = 'Hour' THEN n-1
                -- Values 1-7
                WHEN @GROUPBY = 'WeekDay' THEN n
                -- Values 0 - (@ENDDATE - @STARTDATE)
                WHEN @GROUPBY = 'Date' THEN n - 1
            END) AS date
        FROM 
            APM.fn_nums(
                CASE
                    WHEN @GROUPBY = 'Hour' THEN 24
                    WHEN @GROUPBY = 'WeekDay' THEN 7
                    WHEN @GROUPBY = 'Date' THEN (@PERIOD)
                END     
            )           
        ) AS D
),
-- Calculate resource utilization by SOURCE in one hour.
-- Here counter values are aggregated between sources assosiated with app pool (process).
-- If source presents in several app pools, then in this step values from all of them will be aggregated 
SourceHourlyResourceUtilization AS
(
    SELECT
        ph.MachineId,
-- Single source is a source for which information should be selected
-- Information about each process assosiated with single source and consolidated for it
        ph.SourceId AS SingleSourceId,
        ph.UTCDate,
        ph.PCTypeId,
        SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter) AS InstanceCount,
        SUM(SumValue)/SUM(SampleCount) AS AvgValue
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
    WHERE
        ph.UTCDate &gt;= @UTCSTARTDATE
        AND ph.UTCDate &lt; @UTCENDDATE
        AND PCTypeId IN (@PROCESSORCOUNTERID, @MEMORYCOUNTERID, @IOCOUNTERID)
    GROUP BY
        ph.MachineId,
        ph.SourceId,
        ph.UTCDate,
        ph.PCTypeId
),
--Calculate average source resource utilization for each resource type
ApplicationResourceUtilizationByType AS
(
    SELECT
        ph.MachineId,
        ph.SingleSourceId,
        -- If grouping by hour should be done, then get hour from PCounter date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END) AS Hour,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between PCounter date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END) AS Date,
        -- Instance count should be same for different resource types in one hour for one process
        -- and averaging them won't make any difference but allow to avoid one aggregation step  
        AVG(ph.InstanceCount) AS InstanceCount,
        AVG(CASE WHEN ph.PCTypeId = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS CPUAvgValue,
        AVG(CASE WHEN ph.PCTypeId = @IOCOUNTERID THEN ph.AvgValue END) AS IOAvgValue,
        AVG(CASE WHEN ph.PCTypeId = @MEMORYCOUNTERID THEN ph.AvgValue END) AS MemoryAvgValue
    FROM
        SourceHourlyResourceUtilization AS ph
    GROUP BY
        ph.MachineId,
        ph.SingleSourceId,
        ph.utcdate
),
--Calculate average source resource utilization for specified grouping date          
ApplicationResourceUtilizationByGroupingDate AS
(
    SELECT
        ph.MachineId,
        ph.SingleSourceId,
        ph.Hour,
        ph.Date,
        AVG(InstanceCount) AS InstanceCount,
        AVG(CPUAvgValue) AS CPUAvgValue,
        AVG(IOAvgValue) AS IOAvgValue,
        AVG(MemoryAvgValue) AS MemoryAvgValue
    FROM
        ApplicationResourceUtilizationByType AS ph
    GROUP BY
        ph.MachineId,
        ph.SingleSourceId,
        ph.Hour,
        ph.Date
),
-- Calculate average source resource utilization between machines  
-- This aggregation is actual then grouping type is longer than specified period.
-- Exp: Group by week day, period - month. Then grouping between all mondays in this month should be applied         
ApplicationResourceUtilizationBetweenMachines AS
(
    SELECT
        ph.SingleSourceId,
        ph.Hour,
        ph.Date,
        AVG(InstanceCount) AS InstanceCount,
        AVG(CPUAvgValue/COALESCE(m.CPUCount, 1)) AS CPUAvgValue,
        AVG(IOAvgValue) AS IOAvgValue,
        AVG(MemoryAvgValue) AS MemoryAvgValue
    FROM
        ApplicationResourceUtilizationByGroupingDate AS ph
        JOIN APM.Machine AS m (NOLOCK) ON m.MachineId = ph.MachineId 
    GROUP BY
        ph.SingleSourceId,
        ph.Hour,
        ph.Date
),
-- Monitored requests and request average time calculation by mechines with specified grouping
-- For this counter type perfhourly table contain one record for source, utcdate and machine, so other grouping is redundant 
RequestsBySources AS
(
    SELECT
        ph.SourceId,
        ph.MachineId,
        SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) AS ReqCount, 
        AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue/ph.SampleCount  END) AS AvgReqTime,
        -- If grouping by hour should be done, then get hour from PCounter date, else - 0
        -- Hour will be in user time, not in UTC
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END) AS Hour,
        -- Get grouping date (for week day - week day number1-7, for hour day hour 0-23,
        -- for date - number of days between PCounter date and specified period start day 0-(@ENDDATE-@STARTDATE))
        -- This information is in user time
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END) AS Date
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
        --Join with #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
        JOIN #RESOURCEUTILIZATIONTREND_SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
    WHERE
        ph.UTCDate &gt;= @UTCSTARTDATE
        AND ph.UTCDate &lt; @UTCENDDATE
        AND ph.PCTypeId IN (@MONITOREDREQUESTCOUNTERID, @REQUESTTIMECOUNTERID)
    GROUP BY
        ph.SourceId,
        ph.MachineId,
        -- This aggregation is actual then grouping type is longer than specified perid.
        -- Exp: Group by week day, period - month. Then grouping between all mondays in this month should be applied  
        (CASE 
            WHEN @DOGROUPINGBYHOUR = 1
                THEN DATEPART(hour, DATEADD(mi, @TIMEZONE, ph.utcdate))
            ELSE 0
        END),
        (CASE 
            WHEN @GROUPBY = 'Date'
                THEN ABS(DATEDIFF(d, @STARTDATE, DATEADD(minute, @TIMEZONE, ph.utcdate))) 
            ELSE APM.GetDatePart(@GROUPBY, DATEADD(mi, @TIMEZONE, ph.utcdate))
        END)
),
--Calculate request between machines
RequestsBetweenMachines AS
(
    SELECT
        SourceId,
        SUM(ReqCount) AS ReqCount, 
        AVG(AvgReqTime) AS AvgReqTime,
        Hour,
        Date
    FROM
        RequestsBySources
    GROUP BY
        SourceId,
        Hour,
        Date
),
Events AS 
(
    SELECT
        COUNT(e.EVENTID) AS EventCount,
        MAX(e.SEVIEWERADDRESS) AS SeViewerAddress,
        e.SOURCEID,
        e.HOUR,
        e.DATE
    FROM
        #EVENTFILTER AS e
    GROUP BY
        e.SOURCEID,
        e.HOUR,
        e.DATE
),
-- Check that CPU count is defined for all computers, where application run.
-- Computers set, where application run, does not depend on specified period by design, as otherwise there is performance problems
MachineCPUUndefinedFlag AS
(
    SELECT
        sf.SOURCEID,
        MIN(COALESCE(m.CPUCount, -1)) AS CPUUndefinedFlag
    FROM
        #PROCESSNAMEFORSOURCE AS sf
        JOIN APM.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MachineId
    GROUP BY
        sf.SOURCEID
)
    SELECT 
        sd.Date,
        sd.Hours,
        sd.AppPool AS ApplicationPool,
        sd.SourceId,
        sd.Source AS SingleSource,
        E.SeViewerAddress,
        COALESCE(pc.InstanceCount, 0) AS NumberOfApplicationInstances,
        COALESCE(req.ReqCount, 0) AS NumberOfRequests,
        COALESCE(req.AvgReqTime, 0) AS AverageRequestTime,
        COALESCE(pc.CPUAvgValue, 0) AS ResourceCPUUsage,
        COALESCE(pc.IOAvgValue, 0) AS ResourceIO,
        COALESCE(pc.MemoryAvgValue, 0) AS ResourceMemory,
        COALESCE(e.EventCount, 0) AS NumberOfEvents,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one PCounter row
        -- in PerfHourly table for specified period. If so, there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag
    FROM 
        SourcesDates AS sd
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON sd.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ApplicationResourceUtilizationBetweenMachines AS pc ON (sd.SourceId = pc.SingleSourceId AND pc.Hour = sd.Hours AND pc.Date = sd.Date)
        LEFT OUTER JOIN RequestsBetweenMachines AS req ON (sd.SourceId = req.SourceId AND req.Hour = sd.Hours AND req.Date = sd.Date)
        LEFT OUTER JOIN Events AS e ON (sd.SourceId = e.SourceId AND e.Hour = sd.Hours AND e.Date = sd.Date)
    ORDER BY 
        sd.SourceId,
        sd.Date, 
        sd.Hours
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Source_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Source_sync AS RETURN 1')
  END
GO
----------------------------------Sync procedures----------------------------------
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Source_sync                                                                */
/* USED IN: Synchronization source table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Source_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Source_sync', @EXECRESULT)
    END
    
    DECLARE @SOURCE TABLE (
       source           nvarchar(255)  NOT NULL
    )
    
    ----Fill table from package
    INSERT @SOURCE (
       source
    )
    SELECT
       source
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    source  nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --insert not existing
    INSERT APM.source (source)
    SELECT DISTINCT sync.source
    FROM @SOURCE sync
    WHERE NOT EXISTS (SELECT * FROM APM.source WHERE (source = sync.source))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Machine_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Machine_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Machine_sync                                                               */
/* USED IN: Synchronization machine table. Call by Intercept Reporting Services     */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Machine_sync
   @OBJECTKEYXML       ntext
  ,@TRACELEVEL         int
  ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'machine_sync', @EXECRESULT)
    END
    
    DECLARE @MACHINE TABLE (
       machinename       nvarchar(255) 
      ,windowsversion    nvarchar(50) 
      ,agentversion      nvarchar(50) 
      ,cpucount          int
    )
    
 ----Fill table from package
    INSERT @MACHINE (
       machinename
      ,windowsversion
      ,agentversion
      ,cpucount
    )
    SELECT
       machinename
      ,windowsversion   
      ,agentversion
      ,cpucount 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       machinename       nvarchar(255) 
      ,windowsversion    nvarchar(50) 
      ,agentversion      nvarchar(50) 
      ,cpucount          int    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    SET @XMLDOCHANDLE = NULL
   /*------------------ sync machine--------------------*/
    ---update existing 
    UPDATE m
    SET  machine = sync.machinename
        ,windowsversion = sync.windowsversion
        ,agentversion = COALESCE(sync.agentversion, m.agentversion)
        ,cpucount = COALESCE(sync.cpucount, m.cpucount)
    FROM APM.machine m
          JOIN @MACHINE sync ON sync.machinename = m.machine
          
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)          
    --insert not existing
    INSERT APM.machine (machine, windowsversion, agentversion, cpucount) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
    SELECT DISTINCT sync.machinename, sync.windowsversion, sync.agentversion, sync.cpucount
    FROM @MACHINE sync
    WHERE NOT EXISTS (SELECT * FROM APM.machine WHERE (machine = sync.machinename))
    
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCType_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCType_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PCType_sync                                                                */
/* USED IN: Synchronization pctype table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.PCType_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCType_sync', @EXECRESULT)
    END
    
    DECLARE @PCTYPE TABLE (
       type     nvarchar(255) collate database_default
      ,measure    nvarchar(50) collate database_default
    )
    
    ----Fill table from package
    INSERT @PCTYPE (
       type
      ,measure
    )
    SELECT
       type
      ,measure
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       type     nvarchar(255)
      ,measure    nvarchar(50) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --------------sync type---------
    UPDATE T
    SET Type = sync.type, measure = sync.measure        
    FROM APM.pctype T
          JOIN @PCTYPE sync ON sync.type = T.Type
    INSERT APM.pctype (type, measure)
    SELECT DISTINCT sync.type, sync.measure
    FROM @PCTYPE sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCType WHERE (type = sync.type))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Aspect_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Aspect_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Aspect_sync                                                                */
/* USED IN: Synchronization aspect table. Call by Intercept Reporting Services      */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Aspect_sync 
   @OBJECTKEYXML       ntext
  ,@TRACELEVEL         int
  ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Aspect_sync', @EXECRESULT)
    END
    
    DECLARE @ASPECT TABLE (
       Aspect           nvarchar(50) collate database_default  NOT NULL
      ,Description    nvarchar(255) collate database_default NULL
    )
    ----Fill table from package
    INSERT @ASPECT (
       Aspect
      ,Description
    )
    SELECT
       Aspect
      ,Description
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                     aspect         nvarchar(50) 
                    ,description  nvarchar(256) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    ---update existing 
    UPDATE asp
    SET Aspect = sync.Aspect, Description = sync.Description        
    FROM APM.Aspect asp
          JOIN @ASPECT sync ON sync.Aspect = asp.aspect
    --insert not existing
    INSERT APM.aspect (aspect, description)
    SELECT DISTINCT sync.Aspect, sync.Description
    FROM @ASPECT sync
    WHERE NOT EXISTS (SELECT * FROM APM.Aspect WHERE (aspect = sync.Aspect))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.EventGroup_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.EventGroup_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: EventGroup_sync                                                            */
/* USED IN: Synchronization eventgroup and cseventgroup tables.                     */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[EventGroup_sync]
   @OBJECTKEYXML      ntext
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@UPDATED_ROWCOUNT  int 
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE           nvarchar(max)
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'EventGroup_sync', @EXECRESULT)
    END
    
    DECLARE @EVENTGROUP TABLE (
       id                int identity(1,1)
      ,source            nvarchar(255) collate database_default
      ,firsteventdate    datetime
      ,lasteventdate     datetime
      ,eventclasstype    nvarchar(50) collate database_default  
      ,rootnodename      nvarchar(255) collate database_default
      ,aspect            nvarchar(50) collate database_default
      ,hashvalue         nvarchar(50) collate database_default
      ,client            bit
	  ,description       nvarchar(max) collate database_default     
      ,sourceid          int    
    )
    
    --Fill temporary table from package
    INSERT @EVENTGROUP (
       source
      ,firsteventdate
      ,lasteventdate
      ,eventclasstype
      ,rootnodename
      ,aspect
      ,hashvalue
      ,client
	  ,description      
    )
    SELECT DISTINCT
       source
      ,firsteventdate
      ,lasteventdate
      ,eventclasstype
      ,rootnodename
      ,aspect
      ,hashvalue
      ,CASE WHEN source LIKE '%(Client)' THEN 1 ELSE 0 END 
      ,description 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       source            nvarchar(255) 
      ,firsteventdate    datetime
      ,lasteventdate     datetime
      ,eventclasstype    nvarchar(50)   
      ,rootnodename      nvarchar(255)
      ,aspect            nvarchar(50)
      ,hashvalue         nvarchar(50)
      ,description       nvarchar(max)
	 ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    --remove duplicates by hashvalue
	Delete g1
		from @EVENTGROUP g1
			join @EVENTGROUP g2 on g1.id &gt; g2.id and g1.hashvalue = g2.hashvalue
			
			
    
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
    
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	   SELECT DISTINCT source FROM @EVENTGROUP eg
	      WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = eg.source)
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        DECLARE @ALLAPPID int
        SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
        
/*------------------sync eventgroup------------------*/
/* updating server or client event group */
    IF EXISTS(SELECT * FROM @EVENTGROUP WHERE client = 0) 
    BEGIN
        /* updating server event group records by hashavalue*/
        UPDATE G
        SET  eventclasstype = sync.eventclasstype
            ,rootnodename = sync.rootnodename
            ,aspect = sync.aspect
            ,firsteventdate = CASE WHEN sync.firsteventdate &lt; g.firsteventdate THEN sync.firsteventdate ELSE g.firsteventdate END
            ,lasteventdate = CASE WHEN sync.lasteventdate &gt; g.lasteventdate THEN sync.lasteventdate ELSE g.lasteventdate END
            ,description = sync.description
            ,sourceid = s.SourceId
        FROM APM.eventGroup g       
            JOIN @EVENTGROUP sync ON sync.hashvalue = g.hashvalue AND sync.client = 0 
            JOIN APM.Source AS s ON s.source = sync.source
        /*Permit number of affected records*/            
        SET @UPDATED_ROWCOUNT = @@ROWCOUNT
    
        /* Insert new server event group which are not found by hashvalue */
        INSERT APM.eventgroup (
             firsteventdate
            ,lasteventdate
            ,eventclasstype
            ,rootnodename
            ,aspect
            ,hashvalue
            ,description
            ,sourceid
        )
        SELECT DISTINCT 
           sync.firsteventdate
          ,sync.lasteventdate
          ,sync.eventclasstype
          ,sync.rootnodename
          ,sync.aspect
          ,sync.hashvalue
          ,sync.description
          ,s.SourceId
        FROM @EVENTGROUP sync
        JOIN APM.Source AS s ON s.source = sync.source
        WHERE 
           sync.client = 0 AND NOT EXISTS (SELECT * FROM APM.eventgroup WHERE (hashvalue = sync.hashvalue))
        SET @INSERTED_ROWCOUNT = @@ROWCOUNT
        /* Log about inserted records for verbal log mode*/
        IF @TRACELEVEL = 4 
        BEGIN
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
          RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'eventGroup') WITH NOWAIT;
        END
        /* Number of records from package */
        SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENTGROUP WHERE client = 0
        
        /* Calculate not affected packages records which are not processing */
        SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)  
        
        /* It is need clear flags because client group records can be find in the package */
        SELECT @INSERTED_ROWCOUNT = 0, @UPDATED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @EVENTGROUP WHERE client = 1) 
    BEGIN
        /* updating client event group records by hashavalue*/
        UPDATE G
        SET 
            firsteventdate = CASE WHEN sync.firsteventdate &lt; g.firsteventdate THEN sync.firsteventdate ELSE g.firsteventdate END
           ,lasteventdate = CASE WHEN sync.lasteventdate &gt; g.lasteventdate THEN sync.lasteventdate ELSE g.lasteventdate END
        FROM APM.CSEVENTGROUP g     
            JOIN @EVENTGROUP sync ON sync.hashvalue = g.hashvalue AND sync.client = 1 
            
        /*Permit number of affected records*/            
        SET @UPDATED_ROWCOUNT = @@ROWCOUNT
    
        /* Insert new server event group which are not found by hashvalue */
        INSERT APM.CSEVENTGROUP (
             firsteventdate
            ,lasteventdate
            ,hashvalue
            ,description
            ,sourceid
        )
        SELECT DISTINCT 
           sync.firsteventdate
          ,sync.lasteventdate
          ,sync.hashvalue
          ,sync.description
          ,s.SourceId
        FROM 
          @EVENTGROUP sync
          JOIN APM.Source AS s ON s.source = sync.source
        WHERE 
          sync.client = 1 AND NOT EXISTS (SELECT * FROM APM.CSEVENTGROUP WHERE (hashvalue = sync.hashvalue))
        SET @INSERTED_ROWCOUNT = @@ROWCOUNT
        /* Log about inserted records for verbal log mode */
        IF @TRACELEVEL = 4 
        BEGIN
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
          RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEVENTGROUP') WITH NOWAIT;
        END
        /* Number of records from package */
        SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENTGROUP WHERE client = 1
        
        /* Calculate not affected packages records which are not processing */
        /* It is also need to add not affected records from previos processing (server event group)*/       
        SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)    
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
                                 
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO   
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCProcess_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCProcess_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PCProcess_sync                                                             */
/* USED IN: Synchronization PCProcess table. Call by Intercept Reporting Services   */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.PCProcess_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCProcess_sync', @EXECRESULT)
    END
    
    DECLARE @PCPROCESS TABLE (
       id			int IDENTITY(1,1)
      ,process      nvarchar(255) collate database_default
      ,extratype    int
      ,extrainfo    nvarchar(255) collate database_default
      ,hashvalue    nvarchar(50)  collate database_default 
    )
    
 ----Fill table from package
    INSERT @PCPROCESS (
       process
      ,extratype
      ,extrainfo
      ,hashvalue
    )
    SELECT
       process
      ,extratype
      ,extrainfo
      ,hashvalue
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       process      nvarchar(255) 
      ,extratype    int
      ,extrainfo    nvarchar(255)
      ,hashvalue    nvarchar(50)  ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    --remove duplicates by hashvalue
	Delete pr1
		from @PCPROCESS pr1
			join @PCPROCESS pr2 on pr1.id &gt; pr2.id and pr1.hashvalue = pr2.hashvalue
    UPDATE pr
    SET  process = sync.process
        ,extratype = sync.extratype
        ,extrainfo = sync.extrainfo             
    FROM APM.PCProcess pr
          JOIN @PCPROCESS sync ON sync.hashvalue = pr.hashvalue
    INSERT APM.pcprocess (process, extratype, extrainfo, hashvalue)
    SELECT DISTINCT sync.process, sync.extratype, sync.extrainfo, sync.hashvalue
    FROM @PCPROCESS sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCProcess WHERE (hashvalue = sync.hashvalue))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCDescription_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCDescription_sync AS RETURN 1')
  END
GO
/***********************************************************************************  */
/* OBJECT: Stored Procedure                                                           */
/* NAME: PCDescription_sync                                                           */
/* USED IN: Synchronization PCDescription table. Call by Intercept Reporting Services */
/* INPUT PARAMETERS:                                                                  */
/*      @OBJECTKEYXML - xml package syncronization data                               */
/*      @TRACELEVEL - trace level. Reserved.                                          */
/* OUTPUT PARAMETERS:                                                                 */
/*      @ROWNOTAFFECTED - number of records from package which haven't been           */
/*      synchronized.Reserved.                                                        */
/* Note:                                                                              */
/* If there are records which have not been transferred that they have been already   */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a    */
/* exception at an insert                                                             */
/*************************************************************************************/
ALTER PROCEDURE APM.PCDescription_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
      
    SET @ROWNOTAFFECTED = 0  
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PCDescription_sync', @EXECRESULT)
    END
    
    DECLARE @PCDESCRIPTION TABLE (
       name             nvarchar(255) collate database_default  NOT NULL
      ,description        nvarchar(max) collate database_default NULL
    )
    
----Fill table from package
    INSERT @PCDESCRIPTION (
       name
      ,description
    )
    SELECT
       Name
      ,Description
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       name         nvarchar(255) 
      ,description    nvarchar(max)  ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --------------sync description---------
    UPDATE d
    SET Name = sync.name, Description = sync.description        
    FROM APM.PCDescription d
          JOIN @PCDESCRIPTION sync ON sync.name = d.Name
    INSERT APM.pcdescription (name, description)
    SELECT DISTINCT sync.name, sync.description
    FROM @PCDESCRIPTION sync
    WHERE NOT EXISTS (SELECT * FROM APM.PCDescription WHERE (name = sync.name))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMCREATEEVENTTRACES'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMCREATEEVENTTRACES AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* PROCEDURE PMCREATEEVENTTRACES																  */
/* Description:                                                                                   */
/* It create trace and event traces.														  	  */
/* Warning: It use temporary table #RESULT(EventId int). Therefore it is need to	              */
/* create #RESULT table before call procedure													  */
/*																								  */
/* Input parameters:																			  */	
/*    @DATA - XML OBJECT VIEW																	  */
/*	  @CLIENT - 0: server events  1:client events 												  */
/**************************************************************************************************/
ALTER PROCEDURE [APM].[PMCREATEEVENTTRACES] 
     @CLIENT bit
    ,@DATA nvarchar(MAX)
AS
  SET NOCOUNT ON
  DECLARE 
     @TRACEOUTPUT TABLE (NEWTRACE int, PMSTATUS nvarchar(max))
     
	  --create trace package
	  INSERT APM.PMTRACE (PMSTATUS) 
			OUTPUT INSERTED.PMTRACEID, INSERTED.PMSTATUS INTO @TRACEOUTPUT
		SELECT DISTINCT r.PMSTATUS FROM #STATUSTABLE r
		
	  IF @@ROWCOUNT = 0
		RAISERROR(N'#STATUSTABLE is empty. Imposible created trace.', 0, 1) WITH NOWAIT	
		
	  -- update data	
	  IF @DATA IS NOT NULL
		UPDATE t 
		   SET t.DATA = @DATA
			 FROM APM.PMTRACE t
				JOIN @TRACEOUTPUT nt ON T.pmtraceId = nt.NEWTRACE  
				
	  --server trace
	  IF @CLIENT = 0
			--Fill server event trace
			--Join with Event table is need because these events can be deleted by grooming
			INSERT APM.PMSERVEREVENTTRACE(EVENTID, PMTRACEID)
			   SELECT e.EVENTID, t.NEWTRACE 
				   FROM #STATUSTABLE AS st
					  JOIN APM.EVENT (NOLOCK) AS e ON e.EVENTID = st.EVENTID	  	    
					  JOIN @TRACEOUTPUT t ON t.PMSTATUS = st.PMSTATUS
					  
	  IF @CLIENT = 1
			--Fill client event trace
			--Join with Event table is need because these events can be deleted by grooming
			INSERT APM.PMCLIENTEVENTTRACE(CSEVENTID, PMTRACEID)
			   SELECT e.CSEVENTID, t.NEWTRACE 
				   FROM #STATUSTABLE AS st
					  JOIN APM.CSEVENT (NOLOCK) AS e ON e.CSEVENTID = st.EVENTID
					  JOIN @TRACEOUTPUT t ON t.PMSTATUS = st.PMSTATUS
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ServerEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ServerEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ServerEvent_sync                                                           */
/* USED IN: Synchronization server event.                                           */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[ServerEvent_sync]
   @OBJECTKEYXML      ntext
  ,@DATABASEID        int
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
  
    SET @ROWNOTAFFECTED = 0
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@INSERTED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT   int
      ,@ERROR_MESSAGE      nvarchar(max)      
    --allocate memory for xml package
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ServerEvent_sync', @EXECRESULT)
    END
    -----temporary table variable for the keeping xml package
    DECLARE @EVENT TABLE (
       grouphash            nvarchar(50) collate database_default
      ,rootnodename         nvarchar(255) collate database_default
      ,rootfunction         nvarchar(255) collate database_default
      ,component            nvarchar(255) collate database_default
      ,source               nvarchar(255) collate database_default   
      ,eventduration        decimal(35,0)   
      ,machinename          nvarchar(255) collate database_default   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50) collate database_default    
      ,aspect               nvarchar(50) collate database_default    
      ,username             nvarchar(255) collate database_default   
      ,exceptionclass       nvarchar(255) collate database_default   
      ,description          nvarchar(255) collate database_default   
      ,category             nvarchar(255) collate database_default   
      ,rowguid              nvarchar(15) collate database_default      
      ,seviewerdbid         int
      ,sevieweregid         int
      ,heavylight           int
      ,pmstatus             tinyint
    )
    
    ---- parse and insert xml package to the temporary table variabale
    INSERT @EVENT (
       grouphash
      ,rootnodename
      ,rootfunction 
      ,component
      ,source       
      ,eventduration 
      ,machinename   
      ,utceventdate   
      ,eventclasstype  
      ,aspect          
      ,username        
      ,exceptionclass  
      ,description   
      ,category        
      ,rowguid
      ,sevieweregid  
      ,heavylight    
      ,pmstatus 
    )
    SELECT
       grouphash
      ,rootnodename 
      ,rootfunction
      ,component
      ,source       
      ,eventduration 
      ,machinename   
      ,utceventdate   
      ,eventclasstype  
      ,aspect          
      ,username        
      ,exceptionclass  
      ,description   
      ,category        
      ,rowguid
      ,sevieweregid
      ,heavylight
      ,pmstatus
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       grouphash         nvarchar(50) 
      ,rootnodename      nvarchar(255)
      ,rootfunction      nvarchar(255)      
      ,component         nvarchar(255)      
      ,source            nvarchar(255)  
      ,eventduration     decimal(35,0)  
      ,machinename       nvarchar(255)  
      ,utceventdate      datetime   
      ,eventclasstype    nvarchar(50)   
      ,aspect            nvarchar(50)   
      ,username          nvarchar(255)  
      ,exceptionclass    nvarchar(255)  
      ,description       nvarchar(255)  
      ,category          nvarchar(255)  
      ,rowguid           nvarchar(15)
      ,sevieweregid      int -------- reference to the seviewer event group ---
      ,heavylight        int
      ,pmstatus         tinyint
) xml
    --free memory of xml package
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL    
    
   ----------sync event------------
    -------- update reference to the seviewer database -------
    UPDATE @EVENT SET seviewerdbid = @DATABASEID
   -------- sync Users table--------------- 
    INSERT Users (name)
        SELECT DISTINCT sync.username FROM @EVENT sync
          WHERE NOT EXISTS(SELECT u.name FROM APM.Users u WHERE sync.username = u.name) 
                AND sync.username IS NOT NULL AND sync.username &lt;&gt; '' 
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    ----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
    INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	  SELECT DISTINCT machinename FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = e.machinename)
	     	     
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
	   
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = e.source)	   
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
                
   -------------- sync event table ------------------
   
    -- temporary table for traces. It will contains event id of the new events.
    CREATE TABLE #STATUSTABLE(EVENTID int, PMSTATUS tinyint)
   
    INSERT EVENT (
        eventgroupid    
       ,sourceid      
       ,eventduration
       ,machineid        
       ,utceventdate      
       ,eventclasstype    
       ,rootnodename 
       ,aspect            
       ,exceptionclass    
       ,description     
       ,category          
       ,rowguid
       ,seviewerdbid
       ,sevieweregid
       ,heavylight   
       ,pmstatus        
    )
    OUTPUT INSERTED.EVENTID, INSERTED.PMSTATUS
    INTO #STATUSTABLE
    SELECT 
       g.eventgroupid   
      ,s.sourceid      
      ,sync.eventduration
      ,m.MACHINEID       
      ,sync.utceventdate      
      ,sync.eventclasstype    
      ,sync.rootnodename 
      ,sync.aspect            
      ,sync.exceptionclass    
      ,sync.description     
      ,sync.category          
      ,sync.rowguid
      ,sync.seviewerdbid
      ,sync.sevieweregid    
      ,sync.heavylight
      ,pmstatus  
   FROM
     @EVENT sync
     JOIN APM.source s (NOLOCK) ON s.source = sync.source
     JOIN APM.EventGroup g (NOLOCK) ON g.hashvalue = sync.grouphash
     JOIN APM.MACHINE m (NOLOCK) ON m.machine = sync.machinename
  WHERE NOT EXISTS(SELECT * FROM event e (NOLOCK) WHERE sync.rowguid = e.rowguid) 
  --should be the same order between RowGuid and primary key of the Event table  
  ORDER BY CAST(SUBSTRING(sync.rowguid, CHARINDEX('-', rowguid) + 1, LEN(rowguid)) AS INT)  
  
  SET @INSERTED_ROWCOUNT = @@ROWCOUNT 
  
  --Create event traces for server events
  EXEC APM.PMCREATEEVENTTRACES 0, NULL 	   
  
  -----------sync event with username------------------
  UPDATE e SET 
       e.userid = u.userid
    FROM 
        APM.event e 
      JOIN @EVENT sync ON sync.rowguid = e.rowguid 
      JOIN Users u (NOLOCK) ON sync.username = u.Name   
  INSERT EVENTDETAIL
  (
        EventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.EventId
    ,'COMPONENT'
    ,sync.component
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.Event AS e (NOLOCK) ON sync.rowguid = e.rowguid
  INSERT EVENTDETAIL
  (
        EventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.EventId
    ,'ROOTFUNCTION'
    ,sync.rootfunction
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.Event AS e (NOLOCK) ON sync.rowguid = e.rowguid
        
  SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENT
  SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PerformanceNode_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PerformanceNode_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[PerformanceNode_sync]
  @OBJECTKEYXML      ntext,
  @TRACELEVEL        int, 
  @ROWNOTAFFECTED    int output               
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE       nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE                                    nvarchar(max)
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
                  SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
                  RAISERROR(@ERROR_MESSAGE, 16, 1, 'PerformanceNode_sync', @EXECRESULT)
    END
    DECLARE @PERFORMANCENODE TABLE (
       eventrowguid                 nvarchar(15) collate database_default
                  ,description     nvarchar(255) collate database_default     
                  ,functionname      nvarchar(255) collate database_default              
      ,duration          decimal(35,0)
      ,hashcode                                     nvarchar(255) collate database_default
      ,entryid                                          int
                  ,rowguid                                            nvarchar(15) collate database_default
      ,client                                              int
      ,isheaviestnode          bit
    )
                
    
    INSERT @PERFORMANCENODE (
       eventrowguid                            
      ,description    
      ,functionname     
      ,duration      
      ,hashcode                                     
      ,entryid
                  ,rowguid
                  ,client
                  ,isheaviestnode        
    )
    SELECT
       xml.eventrowguid                    
      ,xml.description    
      ,xml.functionname     
      ,xml.duration      
      ,xml.hashcode
                  ,xml.entryid                                                     
                  ,xml.rowguid
      ,xml.client 
      ,xml.isheaviestnode       
    FROM 
                  OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                                eventrowguid        nvarchar(15) 
                   ,description                                     nvarchar(255)   
                   ,functionname         nvarchar(255)          
       ,duration             decimal(35,0)
       ,hashcode                                    nvarchar(255)
                   ,entryid                                                  int
                   ,rowguid                                                nvarchar(15)
       ,client                                                  int
       ,isheaviestnode                         bit
      ) xml
    
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
   ----------sync performanceNode------------
/* updating server or client performance */
                
    IF EXISTS(SELECT * FROM @PERFORMANCENODE WHERE client = 0) 
    BEGIN
                                /* server performance */
                                INSERT APM.PerformanceNode (
                                                eventid                
                                   ,description      
                                   ,functionname                    
                                   ,duration
                                   ,hashcode
                                   ,entryid                                                             
                                   ,rowguid
                                   ,isheaviestnode        
                                )
                                SELECT 
                                   e.eventid         
                                  ,sync.description      
                                  ,sync.functionname
                                  ,sync.duration                 
                                  ,sync.hashcode               
                                  ,sync.entryid    
                                  ,sync.rowguid
                                  ,sync.isheaviestnode
                   FROM
                                 @PERFORMANCENODE sync
                                 JOIN APM.Event e (NOLOCK) ON e.rowguid = sync.eventrowguid      
                   WHERE 
          sync.client = 0 AND NOT EXISTS(SELECT * FROM APM.performanceNode (NOLOCK) WHERE rowguid = sync.rowguid)
                   SET @INSERTED_ROWCOUNT = @@ROWCOUNT
                   IF @TRACELEVEL = 4 
                   BEGIN
                                 SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
