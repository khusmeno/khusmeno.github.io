                                 RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'PerformanceNode') WITH NOWAIT;
                   END
                   SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @PERFORMANCENODE WHERE client = 0
                   SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
       SELECT @INSERTED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @PERFORMANCENODE WHERE client = 1)
    BEGIN
                                /* client performance */
                                INSERT APM.csheaviestresource (
                                    cseventid        
                                   ,name      
                                   ,duration
           ,rowguid        
                                   ,isheaviestnode        
                                )
                                SELECT 
                                   e.cseventid     
                                  ,sync.description      
                                  ,sync.duration
          ,sync.rowguid          
                                  ,sync.isheaviestnode
                   FROM
                                 @PERFORMANCENODE sync
                                 JOIN APM.CSEvent e (NOLOCK) ON e.rowguid = sync.eventrowguid 
                   WHERE 
          sync.client = 1 AND NOT EXISTS(SELECT * FROM APM.csheaviestresource (NOLOCK) WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
                   IF @TRACELEVEL = 4 
                   BEGIN
                                 SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
                                 RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csheaviestresource') WITH NOWAIT;
                   END
                   SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @PERFORMANCENODE WHERE client = 1
                   SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
    END 
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ExceptionNode_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ExceptionNode_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.ExceptionNode_sync
   @OBJECTKEYXML      ntext
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@CHANGED_ROWCOUNT  int
      ,@MESSAGE           nvarchar(max)
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'exceptionnode_sync', @EXECRESULT)
    END
    DECLARE @EXCEPTIONNODE TABLE (
       eventrowguid      nvarchar(15) collate database_default
      ,eventAction       nvarchar(255) collate database_default   
      ,description       nvarchar(255) collate database_default  
      ,exceptionmessage  nvarchar(255) collate database_default
      ,exceptionclass    nvarchar(255) collate database_default
      ,functionname      nvarchar(255) collate database_default  
      ,modulename        nvarchar(255) collate database_default
      ,linenumber        bigint
      ,entryid           int
      ,hashcode          nvarchar(255) collate database_default
      ,rowguid           nvarchar(15) collate database_default
      ,client            int 
    )
    
    SET @ROWNOTAFFECTED = 0
    INSERT @EXCEPTIONNODE (
       eventrowguid 
       ,eventAction      
      ,description    
      ,exceptionmessage     
      ,exceptionclass      
      ,functionname          
      ,modulename
      ,linenumber
      ,entryid
      ,hashcode
      ,rowguid
      ,client        
    )
    SELECT
       eventrowguid 
      ,eventaction   
      ,description    
      ,exceptionmessage     
      ,exceptionclass      
      ,functionname          
      ,modulename
      ,linenumber
      ,entryid
      ,hashcode
      ,rowguid
      ,client        
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       eventrowguid      nvarchar(15) 
      ,eventaction       nvarchar(255)
      ,description       nvarchar(255)  
      ,exceptionmessage  nvarchar(255)
      ,exceptionclass    nvarchar(255)
      ,functionname      nvarchar(255)  
      ,modulename        nvarchar(255)
      ,linenumber        bigint
      ,entryid           int
      ,hashcode          nvarchar(255)
      ,rowguid           nvarchar(15)
      ,client            int
    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL    
   ----------sync exceptionNode------------
    IF EXISTS(SELECT * FROM @EXCEPTIONNODE WHERE client = 0) 
    BEGIN
      /* server exception */
        INSERT APM.ExceptionNode (
            eventid     
           ,exceptionmessage      
           ,exceptionclass       
           ,functionname
           ,modulename
           ,linenumber               
           ,description
           ,hashcode    
           ,entryid
           ,rowguid         
        )
        SELECT 
            e.eventid   
           ,sync.exceptionmessage      
           ,sync.exceptionclass      
           ,sync.functionname
           ,sync.modulename
           ,sync.linenumber              
           ,sync.description
           ,sync.hashcode   
           ,sync.entryid
           ,sync.rowguid            
       FROM
         @EXCEPTIONNODE sync
         JOIN APM.Event e ON e.rowguid = sync.eventrowguid  
       WHERE sync.client = 0 AND NOT EXISTS(SELECT * FROM APM.ExceptionNode WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
       IF @TRACELEVEL = 4 
       BEGIN
         SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
         RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'ExceptionNode') WITH NOWAIT;
       END
       SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EXCEPTIONNODE where client = 0
       SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
       SET @INSERTED_ROWCOUNT = 0
    END
    IF EXISTS(SELECT * FROM @EXCEPTIONNODE WHERE client = 1) 
    BEGIN
      /* client exception */
        INSERT APM.CSEXEVENT (
            cseventid   
           ,action      
           ,exmessage        
           ,extype
           ,exfunction
           ,rowguid         
        )
        SELECT 
            e.cseventid     
           ,sync.eventAction      
           ,sync.exceptionmessage
           ,sync.exceptionclass      
           ,sync.functionname
           ,sync.rowguid            
       FROM
         @EXCEPTIONNODE sync
         JOIN APM.CSEvent e ON e.rowguid = sync.eventrowguid    
       WHERE sync.client = 1 AND NOT EXISTS(SELECT * FROM APM.ExceptionNode WHERE rowguid = sync.rowguid)
       SET @INSERTED_ROWCOUNT = @@ROWCOUNT
       IF @TRACELEVEL = 4 
       BEGIN
         SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
         RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEXEVENT') WITH NOWAIT;
       END
       SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EXCEPTIONNODE WHERE client = 1
       SET @ROWNOTAFFECTED = @ROWNOTAFFECTED + @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
     
    END 
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PerfHourly_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PerfHourly_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[PerfHourly_sync]
   @OBJECTKEYXML      ntext,
   @DATABASEID        int,
   @TRACELEVEL        int, 
   @ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@INSERTED_ROWCOUNT int
      ,@UPDATED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT  int
      ,@CURSOR_OPENED     bit
    SELECT @CHANGED_ROWCOUNT = 0, @UPDATED_ROWCOUNT = 0, @INSERTED_ROWCOUNT = 0, @CHANGED_ROWCOUNT = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'PerfHourly_sync', @EXECRESULT)
    END
    DECLARE @PERFHOURLY TABLE (
       type                   nvarchar(255) collate database_default
      ,machinename              nvarchar(255) collate database_default
      ,source                   nvarchar(255) collate database_default
      ,pcprocessHash            nvarchar(50) collate database_default    
      ,is_state                 int
      ,utcdate                  datetime
      ,averagevalue             float   
      ,minvalue                 float
      ,maxvalue                 float
      ,samplecount              float
      ,sumvalue                 float
      ,packagecounter           int
      ,hashvalue                nvarchar(50) collate database_default 
      ,inserted                 bit
    )   
    
    INSERT @PERFHOURLY (
       type                   
      ,machinename              
      ,source                   
      ,pcprocessHash            
      ,is_state                 
      ,utcdate                  
      ,averagevalue             
      ,minvalue                 
      ,maxvalue                 
      ,samplecount              
      ,sumvalue                 
      ,packagecounter           
      ,hashvalue                
    )
    SELECT
       type                   
      ,machinename              
      ,source                   
      ,pcprocessHash            
      ,is_state                 
      ,utcdate                  
      ,averagevalue             
      ,minvalue                 
      ,maxvalue                 
      ,samplecount              
      ,sumvalue                 
      ,packagecounter           
      ,hashvalue                
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       type                   nvarchar(255)
      ,machinename              nvarchar(255)
      ,source                   nvarchar(255)
      ,pcprocesshash            nvarchar(50)    
      ,is_state                 int
      ,utcdate                  datetime
      ,averagevalue             float   
      ,minvalue                 float
      ,maxvalue                 float
      ,samplecount              float
      ,sumvalue                 float
      ,packagecounter           int
      ,hashvalue                nvarchar(50) 
      ) xml
    SET @CHANGED_ROWCOUNT = @@ROWCOUNT
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
	------- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
	INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
		SELECT DISTINCT machinename FROM @PERFHOURLY p
		   WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = p.machinename) AND p.machinename is NOT null
		   
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
		   
	----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
	INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
		SELECT DISTINCT source FROM @PERFHOURLY p
		   WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = p.source) AND p.source is NOT null
		   
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
    UPDATE sync
        SET sync.inserted = 1
      FROM @PERFHOURLY sync
         WHERE NOT EXISTS(SELECT * FROM APM.PerfHourly p WHERE p.hashvalue = sync.hashvalue)        
    IF EXISTS(SELECT * FROM @PERFHOURLY sync WHERE sync.inserted = 1) 
    BEGIN
      INSERT perfHourly( 
               pctypeid
              ,machineid    
              ,sourceid
              ,pcprocessId  
              ,is_state
              ,utcdate
              ,averagevalue
              ,minvalue
              ,maxvalue
              ,samplecount
              ,sumvalue
              ,packagecounter
              ,hashvalue
           )
           SELECT 
               t.pctypeid                   
              ,m.machineid              
              ,s.sourceId                   
              ,pr.pcprocessId           
              ,sync.is_state                    
              ,sync.utcdate                 
              ,sync.averagevalue                
              ,sync.minvalue                    
              ,sync.maxvalue                    
              ,sync.samplecount             
              ,sync.sumvalue                    
              ,sync.packagecounter          
              ,sync.hashvalue
         FROM
           @PERFHOURLY sync 
           JOIN APM.Machine m ON m.machine = sync.machinename
           JOIN APM.PCType t ON t.type = sync.type
           LEFT JOIN APM.Source s ON s.source = sync.source
           LEFT JOIN APM.PCProcess Pr ON PR.hashvalue = sync.pcprocessHash
         WHERE                  
           sync.inserted = 1    
         SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    END
    IF EXISTS(SELECT * FROM @PERFHOURLY sync WHERE sync.inserted is null) 
    BEGIN
      UPDATE p
         SET     
           p.minvalue = CASE WHEN sync.minvalue &lt; p.minvalue THEN sync.minvalue ELSE p.minvalue END 
          ,p.maxvalue = CASE WHEN sync.maxvalue &gt; p.maxvalue THEN sync.maxvalue ELSE p.maxvalue END 
          ,p.samplecount = p.samplecount + sync.samplecount
          ,p.sumvalue = p.sumvalue + sync.sumvalue
          ,p.packagecounter = p.packagecounter + sync.packagecounter
          ,p.averagevalue = p.sumvalue / p.samplecount
         FROM 
           APM.PerfHourly p 
            JOIN @PERFHOURLY sync ON sync.hashvalue = p.hashvalue   
            JOIN APM.Machine m ON m.machine = sync.machinename
            JOIN APM.PCType t ON t.type = sync.type
            LEFT JOIN APM.Source s ON s.source = sync.source
            LEFT JOIN APM.PCProcess Pr ON PR.hashvalue = sync.pcprocessHash
         WHERE sync.inserted IS NULL
            
         SET @UPDATED_ROWCOUNT =  @@ROWCOUNT
    END
    SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - (@INSERTED_ROWCOUNT + @UPDATED_ROWCOUNT)  
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckDatabaseId'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckDatabaseId AS RETURN 1')
  END
GO
/* Procedure check database unique identificator and return error codes:  */
/* 0 : Success. Database is synhronized with SEViewer database */
/* 1 : Error. Database is not synhronized with SEViewer database */
/* 2 : Error. Database is partialy synhronized with SEViewer database */
/* 3 : Error. Database is new */
ALTER PROCEDURE APM.CheckDatabaseId
    @DBGUID uniqueidentifier
AS
BEGIN
    DECLARE @ERROR  int
  
    SET @ERROR = 0
    IF NOT EXISTS(SELECT * FROM APM.SEVIewerDB SV (NOLOCK) WHERE SV.DatabaseId = @DBGUID)
    BEGIN
      IF NOT EXISTS(SELECT * FROM APM.TASKS (NOLOCK))
      BEGIN
        SET @ERROR = 3
        GOTO QUIT
      END
      IF EXISTS(SELECT * FROM APM.TASKS t (NOLOCK) WHERE t.SEVIewerDBId IS NULL) 
      BEGIN 
        SET @ERROR = 1       
        GOTO QUIT
      END
    END 
    IF EXISTS(SELECT * FROM APM.TASKS t (NOLOCK) WHERE t.SEVIewerDBId IS NULL) 
    BEGIN
      SET @ERROR = 2       
      GOTO QUIT
    END
QUIT:
    RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckAndCreateDatabaseId'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckAndCreateDatabaseId AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* Procedure check database unique identificator and find or create internal database identifier  */
/* Procedure return error code:  */
/* 0 : Success. Database is synhronized with SEViewer database */
/* 1 : Error. Database is not synhronized with SEViewer database */
/* 2 : Error. Database is partialy synhronized with SEViewer database */
/**************************************************************************************************/
/* Parameters: */
/* @DBGUID unique identificator */
/* @SEVIEWERURL unique identificator */
/* @DBGUID unique identificator */
ALTER PROCEDURE APM.CheckAndCreateDatabaseId 
        @DBGUID uniqueidentifier
       ,@SEVIEWERURL NVARCHAR(255)
       ,@TRACELEVEL INT
       ,@DBID int OUTPUT
AS
BEGIN
  DECLARE @ERROR  int
  EXECUTE @ERROR = APM.CheckDatabaseId @DBGUID
  
  SELECT @DBID = SEVIewerDBId FROM APM.SEVIewerDB SV (NOLOCK) WHERE SV.DatabaseId = @DBGUID 
  IF @@ROWCOUNT = 0
  BEGIN
    INSERT APM.SEVIEWERDB(DatabaseId, Address) Values(@DBGUID, @SEVIEWERURL)
    SET @DBID = SCOPE_IDENTITY()
  END
  RETURN @ERROR
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Config_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Config_sync AS RETURN 1')
  END
GO
alter PROCEDURE APM.Config_sync
  @OBJECTKEYXML       ntext
 ,@TRACELEVEL         INT
 ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT        int
      ,@XMLDOCHANDLE      int
      ,@ERROR_MESSAGE     nvarchar(max)      
      ,@UPDATED_ROWCOUNT  int
      ,@CHANGEDROWCOUNT    int 
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Config_sync', @EXECRESULT)
    END
    
    DECLARE @CONFIG TABLE (
       configname           nvarchar(50)  NOT NULL
      ,configvalue          nvarchar(max) NULL
      ,databaseid           int
    )
    
    INSERT @CONFIG (
       configname
      ,configvalue
      ,databaseid
    )
    SELECT
       configname
      ,configvalue
      ,databaseid
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       configname           nvarchar(50)  
      ,configvalue          nvarchar(max) 
      ,databaseid           int) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    UPDATE sv SET 
        Address = sync.configvalue
    FROM
      APM.SEViewerDb sv
      JOIN @CONFIG sync ON sv.seviewerdbid = sync.databaseid AND sync.configname = 'SEVIEWERADDRESS'        
    SET @UPDATED_ROWCOUNT = @@ROWCOUNT   
    SELECT @CHANGEDROWCOUNT = COUNT(*) FROM @CONFIG WHERE configname = 'SEVIEWERADDRESS'
    SET @ROWNOTAFFECTED = @CHANGEDROWCOUNT - @UPDATED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PageEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PageEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: PageEvent_sync                                                             */
/* USED IN: Intercept reporting Service. Fill content information for the csm       */
/*          performance events. Internal stored procedure                           */
/* INPUT PARAMETERS:                                                                */
/*      @XMLDOCHANDLE - memory handle (from sp_xml_preparedocument)                 */
/*      @TRACELEVEL    - trace flag (4 - diagnostic message will be generated       */
/************************************************************************************/
ALTER PROCEDURE APM.PageEvent_sync
   @XMLDOCHANDLE      int
  ,@TRACELEVEL        int
AS
BEGIN
    SET NOCOUNT ON
    DECLARE 
       @INSERTED_ROWCOUNT  int
      ,@MESSAGE            nvarchar(max)
    DECLARE @PAGEEVENT TABLE (
       event_rowguid        nvarchar(15) collate database_default    
      ,networktime          decimal (35,0) 
      ,servertime           decimal (35,0)  
      ,domtime              decimal (35,0)
      ,peripheraltime       decimal (35,0)
      ,onloadtime           decimal (35,0)
      ,totaltime            decimal (35,0)
      ,totalsize            bigint
      ,latency              bigint
      ,utcdate              datetime
      ,SourceName           nvarchar (255) collate database_default     
    )
    INSERT @PAGEEVENT (
       event_rowguid        
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,SourceName                       
    )
    SELECT
       event_rowguid              
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,SourceName                       
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/pageevent') WITH (
       event_rowguid        nvarchar(15) '../@rowguid'      
      ,networktime          decimal (35,0) 
      ,servertime           decimal (35,0)  
      ,domtime              decimal (35,0)
      ,peripheraltime       decimal (35,0)
      ,onloadtime           decimal (35,0)
      ,totaltime            decimal (35,0)
      ,totalsize            bigint
      ,latency              bigint 
      ,utcdate          datetime '../@utceventdate'     
      ,sourceName           nvarchar (255) '../@source'
      ,client               int '../@client'
    ) xml
    WHERE xml.client = 2
    -- Fill CSPageEvent table--------
    INSERT APM.CSPageEvent (
       cseventid
      ,networktime          
      ,servertime           
      ,domtime              
      ,peripheraltime       
      ,onloadtime           
      ,totaltime            
      ,totalsize
      ,latency
      ,utcdate
      ,sourceid
    )
    SELECT 
       e.cseventid            
      ,sync.networktime         
      ,sync.servertime          
      ,sync.domtime             
      ,sync.peripheraltime      
      ,sync.onloadtime          
      ,sync.totaltime           
      ,sync.totalsize
      ,sync.latency
      ,sync.utcdate
      ,s.SourceId           
    FROM
        @PAGEEVENT sync
        JOIN APM.csevent e ON sync.event_rowguid = e.rowguid
        JOIN APM.source s ON s.source = sync.SourceName
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSPageEvent') WITH NOWAIT;
    END
    -- Fill Periphial and Periphial Detail table--------
    DECLARE @PERIPHIAL TABLE (
       event_rowguid        nvarchar(15) collate database_default    
      ,type                 nvarchar (50) collate database_default
      ,totalsize            bigint
      ,totaltime            decimal (35,0)
      ,htmlSize             bigint
    )
    INSERT INTO @PERIPHIAL 
    (
       event_rowguid
      ,type     
      ,totalsize    
      ,totaltime    
      ,htmlSize 
    )
    SELECT
       event_rowguid              
      ,type 
      ,totalsize
      ,totaltime
      ,htmlSize 
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/peripheral/row', 2) WITH (
       event_rowguid        nvarchar(15)        '../../@rowguid'     
      ,type                 nvarchar (50)   '@type' 
      ,totalsize            bigint          '@totalsize'
      ,totaltime            decimal (35,0)  '@totaltime'
      ,htmlSize             bigint              '../@htmlsize'
      ,client               int             '../../@client'     
    ) xml
    WHERE xml.client = 2 
    DECLARE @PERIPHIALDETAIL TABLE (
       event_rowguid        nvarchar(15)  collate database_default    
      ,type                 nvarchar (50) collate database_default 
      ,domain               nvarchar (255) collate database_default 
      ,path                 nvarchar (255) collate database_default 
      ,size                 bigint
      ,detail_totaltime     decimal (35,0)
    )
    INSERT INTO @PERIPHIALDETAIL 
    (
       event_rowguid
      ,type     
      ,domain       
      ,path     
      ,size     
      ,detail_totaltime
    )
    SELECT
       event_rowguid              
      ,type 
      ,domain   
      ,path 
      ,size 
      ,detail_totaltime
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/peripheral/row/row', 2) WITH (
       event_rowguid        nvarchar(15)        '../../../@rowguid'     
      ,type                 nvarchar (50)   '../@type' 
      ,domain               nvarchar (255)  '@domain' 
      ,path                 nvarchar (255)  '@path'
      ,size                 bigint              '@size'
      ,detail_totaltime     decimal (35,0)  '@totaltime'
      ,client               int             '../../../@client'  
    ) xml
    WHERE xml.client = 2 AND xml.size &gt; 0
    -- Fill summary content information 
    INSERT APM.csperipheral 
    (
         cseventid
        ,type
        ,totalsize
        ,totaltime
    )
    SELECT 
       e.cseventid
      ,sync.type
      ,sync.totalsize
      ,sync.totaltime
    FROM
      @PERIPHIAL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid 
    WHERE sync.totalsize &gt; 0 
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheral') WITH NOWAIT;
    END
    -- Fill html size
    INSERT APM.csperipheral 
    (
         cseventid
        ,type
        ,totalsize
    )
    SELECT DISTINCT
        e.cseventid
       ,N'html'
       ,sync.htmlSize
    FROM
      @PERIPHIAL sync
    JOIN
      csevent e ON sync.event_rowguid = e.rowguid
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheral {html}') WITH NOWAIT;
    END
    -- Fill detail content information
    INSERT APM.csperipheraldetail 
    (
        csperipheralid
       ,domain
       ,path
       ,size
       ,totaltime
    )
    SELECT 
       p.csperipheralid
      ,sync.domain
      ,sync.path
      ,sync.size
      ,sync.detail_totaltime
    FROM
      @PERIPHIALDETAIL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid
    JOIN
      APM.csperipheral p ON e.cseventid = p.cseventid AND sync.type = p.type
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csperipheraldetail') WITH NOWAIT;
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.AjaxCall_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.AjaxCall_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.AjaxCall_sync
   @XMLDOCHANDLE      int
  ,@PATH              nvarchar(100)
  ,@TRACELEVEL        int
AS
BEGIN
   SET NOCOUNT ON
   DECLARE
     @MESSAGE         nvarchar(max)
    ,@RECORDCOUNT     int
--------- Fill Ajax call --------
    DECLARE @AJAXCALL TABLE (
       ajax_call_id         int identity(1,1)       
      ,event_rowguid        nvarchar(15) collate database_default 
      ,uri                  nvarchar (255) collate database_default 
      ,networktime          decimal (35,0)
      ,servertime           decimal (35,0)
      ,totaltime            decimal (35,0) 
      ,requestsize          bigint          
      ,responsesize         bigint
      ,responsetime         decimal (35,0)
      ,handlertime          decimal (35,0)  
      ,latency              bigint
      ,utcdate              datetime
      ,SourceName           nvarchar (255) collate database_default                      
    )
    INSERT INTO @AJAXCALL 
    (
       event_rowguid        
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime
      ,handlertime          
      ,latency
      ,utcdate
      ,SourceName                   
    )
    SELECT
       event_rowguid        
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime
      ,handlertime
      ,latency
      ,utcdate
      ,SourceName               
     FROM OPENXML(@XMLDOCHANDLE, @PATH) WITH (
       event_rowguid        nvarchar(15)            '../../@rowguid'    
      ,uri                  nvarchar (255) 
      ,networktime          decimal (35,0)
      ,servertime           decimal (35,0)
      ,totaltime            decimal (35,0) 
      ,requestsize          bigint 
      ,responsesize         bigint                  
      ,responsetime         decimal (35,0)      
      ,handlertime          decimal (35,0)      '../@handlertime' 
      ,latency              bigint
      ,utcdate          datetime '../../@utceventdate'     
      ,sourceName           nvarchar (255) '../../@source'                      
    ) xml
    INSERT APM.csajax 
    (
       cseventid    
      ,uri                  
      ,networktime          
      ,servertime           
      ,totaltime            
      ,requestsize          
      ,responsesize         
      ,responsetime         
      ,synchronous
      ,latency
      ,utcdate
      ,sourceid
      ,IsHeaviestNode                   
    )
    SELECT 
       e.cseventid
      ,sync.uri                 
      ,sync.networktime         
      ,sync.servertime          
      ,sync.totaltime           
      ,sync.requestsize         
      ,sync.responsesize            
      ,sync.responsetime
      ,CASE WHEN handlertime IS NULL THEN 1 ELSE 0 END  
      ,sync.latency
      ,sync.utcdate
      ,s.SourceId
      ,CASE 
            WHEN sync.ajax_call_id = (SELECT TOP(1) ajax_call_id FROM @AJAXCALL AS a WHERE sync.event_rowguid = a.event_rowguid ORDER BY TotalTime DESC, ajax_call_id)
            THEN 1
            ELSE 0
        END
    FROM
      @AJAXCALL sync
    JOIN
      APM.csevent e ON sync.event_rowguid = e.rowguid
      JOIN APM.source s ON s.source = sync.SourceName
    SELECT @RECORDCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, 'csajax') WITH NOWAIT;
    END
    ---Find Async ajax call-----------
    IF EXISTS(SELECT * FROM  @AJAXCALL WHERE handlertime IS NOT NULL)
    BEGIN
      INSERT APM.csasyncajax
      (
         cseventid
        ,totaltime
        ,handlertime
      ) 
      SELECT 
         e.cseventid
        ,sync.totaltime 
        ,sync.handlertime
      FROM
        @AJAXCALL sync
      JOIN
        APM.csevent e ON sync.event_rowguid = e.rowguid
      WHERE 
        sync.handlertime IS NOT NULL
      SELECT @RECORDCOUNT = @@ROWCOUNT
      IF @TRACELEVEL = 4 
      BEGIN
        SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
        RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, 'csasyncajax') WITH NOWAIT;
      END
    END 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.JScriptEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.JScriptEvent_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.JScriptEvent_sync
   @XMLDOCHANDLE    int
  ,@TRACELEVEL      int
AS
BEGIN
  SET NOCOUNT ON
    DECLARE 
       @INSERTED_ROWCOUNT  int
      ,@MESSAGE            nvarchar(max)
    DECLARE @SCRIPTEVENT TABLE (
       event_rowguid        nvarchar(15)  collate database_default    
      ,action               nvarchar(255)  collate database_default
      ,totaltime            nvarchar(255)  collate database_default
      ,utcdate              datetime
      ,SourceName           nvarchar (255)  collate database_default        
    )
    INSERT @SCRIPTEVENT (
       event_rowguid        
      ,action           
      ,totaltime
      ,utcdate
      ,SourceName                   
    )
    SELECT
       event_rowguid              
      ,action           
      ,totaltime
      ,utcdate
      ,SourceName                   
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row/jscript') WITH (
       event_rowguid        nvarchar(15) '../@rowguid'      
      ,action               nvarchar(255)
      ,totaltime            decimal (35,0)
      ,utcdate              datetime '../@utceventdate'     
      ,sourceName           nvarchar (255) '../@source'   
    ) xml
    -- Fill CSJSCRIPTEVENT table--------
    INSERT APM.csjscriptevent (
       cseventid
      ,action                   
      ,totaltime
      ,utcdate
      ,sourceid         
    )
    SELECT 
       e.cseventid            
      ,sync.action          
      ,sync.totaltime
      ,sync.utcdate
      ,s.SourceId                   
    FROM
        @SCRIPTEVENT sync
        JOIN APM.csevent e ON sync.event_rowguid = e.rowguid
        JOIN APM.source s ON s.source = sync.SourceName 
    SET @INSERTED_ROWCOUNT = @@ROWCOUNT
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'csjscriptevent') WITH NOWAIT;
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientEvent_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientEvent_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ClientEvent_sync                                                           */
/* USED IN: Synchronization client event.                                           */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.                                                               */
/************************************************************************************/
ALTER PROCEDURE [APM].[ClientEvent_sync]
   @OBJECTKEYXML      ntext
  ,@DATABASEID        int
  ,@TRACELEVEL        int
  ,@ROWNOTAFFECTED    int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE
     @MESSAGE         nvarchar(max)
    ,@RECORDCOUNT     int
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@INSERTED_ROWCOUNT  int
      ,@CHANGED_ROWCOUNT   int
      ,@ERROR_MESSAGE      nvarchar(max)      
    --allocate memory for xml package
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ClientEvent_sync', @EXECRESULT)
    END
 -----temporary table variable for the keeping xml package
    DECLARE @EVENT TABLE (
       grouphash            nvarchar(50) collate database_default
      ,source               nvarchar(255) collate database_default   
      ,machinename          nvarchar(255) collate database_default   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50) collate database_default
      ,eventclass           nvarchar(50) collate database_default    
      ,description          nvarchar(255) collate database_default
      ,ip                   nvarchar(50) collate database_default
      ,subnetc              nvarchar(50) collate database_default
      ,pageuri              nvarchar(255) collate database_default
      ,browser              nvarchar(255) collate database_default
      ,userName             nvarchar(255) collate database_default   
      ,rowguid              nvarchar(15) collate database_default      
      ,seviewerdbid         int
      ,sevieweregid         int
      ,client               int 
      ,pmstatus             tinyint 
      ,category            nvarchar(50) collate database_default 
      ,rootnodename         nvarchar(255) collate database_default             
      ,rootfunction         nvarchar(255) collate database_default   
    )
    
 ---- parse and insert xml package to the temporary table variabale
    INSERT @EVENT (
       grouphash
      ,source   
      ,machinename
      ,utceventdate
      ,eventclasstype
      ,eventclass
      ,description  
      ,ip           
      ,subnetc      
      ,pageuri
      ,browser
      ,userName         
      ,rowguid
      ,sevieweregid
      ,client
      ,pmstatus     
      ,category
      ,rootnodename
      ,rootfunction
    )
    SELECT
       grouphash
      ,source   
      ,machinename
      ,utceventdate
      ,eventclasstype
      ,eventclass
      ,description  
      ,ip           
      ,subnetc      
      ,pageuri  
      ,browser
      ,username 
      ,rowguid
      ,sevieweregid         
      ,client   
      ,pmstatus
      ,category
      ,rootnodename
      ,rootfunction
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row') WITH (
       grouphash            nvarchar(50) 
      ,source               nvarchar(255)   
      ,machinename          nvarchar(255)   
      ,utceventdate         datetime    
      ,eventclasstype       nvarchar(50)    
      ,eventclass           nvarchar(50)    
      ,description          nvarchar(255)
      ,ip                   nvarchar(50)
      ,subnetc              nvarchar(50)
      ,pageuri              nvarchar(255)
      ,browser              nvarchar(255)
      ,username             nvarchar(255)   
      ,rowguid              nvarchar(15)  
      ,sevieweregid         int
      ,client               int
      ,pmstatus             tinyint    
      ,category             nvarchar(50) 
      ,rootnodename         nvarchar(255)             
      ,rootfunction         nvarchar(255)
    ) xml
    
    SELECT @RECORDCOUNT = @@ROWCOUNT
    --- Trace about package size
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
      RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, '@EVENT') WITH NOWAIT;
    END
    UPDATE @EVENT SET seviewerdbid = @DATABASEID
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
  ----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
    INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	  SELECT DISTINCT machinename FROM @EVENT e
	     WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = e.machinename)
	     
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
	     
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
	   
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @EVENT e 
	     WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = e.source)
    
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
   -------- sync Users table--------------- 
    INSERT Users (name)
        SELECT DISTINCT sync.userName FROM @EVENT sync
          WHERE NOT EXISTS(SELECT u.name FROM APM.Users u WHERE sync.userName = u.name)
                AND sync.userName IS NOT NULL AND sync.userName &lt;&gt; '' 
   -- Fill Ip table--------
   INSERT APM.ip (ip, subnetc) 
    SELECT DISTINCT 
        sync.ip
       ,sync.subnetc
    FROM 
        @EVENT sync 
    WHERE 
        sync.ip IS NOT NULL AND sync.ip &lt;&gt; '' AND NOT EXISTS(SELECT * FROM APM.ip ip WHERE ip.ip = sync.ip)
        
     -- temporary table for traces. It will contains event id of the new events.    
    CREATE TABLE #STATUSTABLE(EVENTID int, PMSTATUS tinyint)
   -- Fill CSEvent table--------
    INSERT APM.CSEVENT (
       cseventgroupid
      ,sourceid 
      ,machineid
      ,utcdate
      ,classtype
      ,eventclass   
      ,description  
      ,ipid         
      ,pageuri
      ,browser      
      ,rowguid
      ,seviewerdbid
      ,sevieweregid
      ,pmstatus 
    )
    OUTPUT INSERTED.csEventId, INSERTED.pmstatus 
    INTO #STATUSTABLE
    SELECT 
       g.cseventgroupid     
      ,s.sourceid      
      ,m.MACHINEID       
      ,sync.utceventdate      
      ,sync.eventclasstype 
      ,sync.eventclass   
      ,sync.description
      ,ip.ipid       
      ,sync.pageuri 
      ,sync.browser 
      ,sync.rowguid
      ,sync.seviewerdbid
      ,sync.sevieweregid    -------- reference to the seviewer event group ---       
      ,sync.pmstatus
   FROM
     @EVENT sync
     JOIN APM.source s ON s.source = sync.source
     JOIN APM.CSEventGroup g ON g.hashvalue = sync.grouphash
     JOIN APM.MACHINE m ON m.machine = sync.machinename
     LEFT JOIN APM.ip ip ON sync.ip = ip.ip
  WHERE NOT EXISTS(SELECT * FROM APM.csevent e WHERE sync.rowguid = e.rowguid) 
  SET @INSERTED_ROWCOUNT = @@ROWCOUNT  
 
  --Create event traces for client events
  EXEC APM.PMCREATEEVENTTRACES 1, NULL 
  INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'CATEGORY'
    ,sync.category
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid
     
  INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'ROOTNODENAME'
    ,sync.rootnodename
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid  
 
   INSERT APM.CSEVENTDETAIL
  (
        CSEventId
        ,Name
        ,[Value]
        ,[ValueType]
  )
  SELECT
    e.CSEventId
    ,'ROOTFUNCTION'
    ,sync.rootfunction
    ,'PM'
  FROM
     @EVENT AS sync
     JOIN APM.CSEvent AS e (NOLOCK) ON sync.rowguid = e.rowguid
     
  --------- trace about number of inserted records into csevent table -----------
  IF @TRACELEVEL = 4 
  BEGIN
    SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50024
    RAISERROR (@MESSAGE, 0, 1, @INSERTED_ROWCOUNT, 'CSEvent') WITH NOWAIT;
  END
  SELECT @CHANGED_ROWCOUNT = COUNT(*) FROM @EVENT
  SET @ROWNOTAFFECTED = @CHANGED_ROWCOUNT - @INSERTED_ROWCOUNT
  -----------sync csevent with username------------------
  UPDATE e SET 
       e.userid = u.userid
    FROM 
        APM.csevent e 
      JOIN @EVENT sync ON sync.rowguid = e.rowguid 
      JOIN APM.Users u ON sync.userName = u.Name   
  IF EXISTS(SELECT * FROM @EVENT WHERE client = 2) 
  BEGIN
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50025
      RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
    END
    ----exists pageevents--------    
    EXECUTE APM.PageEvent_sync @XMLDOCHANDLE, @TRACELEVEL
  END
  ------ Fill ajax calls--------------
  EXEC APM.AjaxCall_sync @XMLDOCHANDLE, N'rows/row/ajaxcalls/row', @TRACELEVEL
    
  --------Check Ajax events and script events
  IF EXISTS(SELECT * FROM @EVENT WHERE client = 1) 
  BEGIN
    IF @TRACELEVEL = 4 
    BEGIN
      SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50026
      RAISERROR (@MESSAGE, 0, 1) WITH NOWAIT;
    END
    ----Find and sync script events --------
    EXEC APM.AjaxCall_sync @XMLDOCHANDLE, N'rows/row/jscript/row', @TRACELEVEL
    EXECUTE APM.JScriptEvent_sync @XMLDOCHANDLE, @TRACELEVEL
  END
 -- Update  CSEvent table with totaltime, total size and latency values
   UPDATE e SET 
       e.TotalTime = COALESCE(p.TotalTime, COALESCE(js.TotalTime, a.TotalTime)),
       e.TotalSize = COALESCE(P.TotalSize, 0) + COALESCE(a.TotalSize, 0),
       e.Latency = COALESCE(p.Latency, a.Latency)
    FROM 
        APM.csevent e 
        JOIN @EVENT sync ON sync.rowguid = e.rowguid
        LEFT OUTER JOIN APM.CSPAGEEVENT AS p ON p.CSEventId = e.CSEventId
        LEFT OUTER JOIN APM.CSJSCRIPTEVENT AS js ON js.CSEventId = e.CSEventId
        OUTER APPLY
        (
            SELECT
                SUM(a.TotalTime) AS TotalTime,
                SUM(a.ResponseSize + a.REQUESTSIZE) AS TotalSize,
                AVG(a.Latency) AS Latency
            FROM
                APM.CSAJAX AS a 
            WHERE
                A.CSEventId = e.CSEventId
        ) AS a
 --free memory of xml package
  EXEC sp_xml_removedocument @XMLDOCHANDLE
    
  SET @XMLDOCHANDLE = NULL  
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CheckConfiguration'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CheckConfiguration AS RETURN 1')
  END
GO
ALTER PROCEDURE [APM].[CheckConfiguration]
	@VERSION		nvarchar(15)
   ,@SCHEMAVERSION	nvarchar(15)
   ,@TRACELEVEL		INT
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE 
	@ERROR INT
  SET @ERROR = 0
  IF NOT EXISTS(SELECT * FROM APM.Config WHERE ConfigName = N'DATABASE_VERSION' 
					AND CAST(ConfigValue AS nvarchar(15)) = @VERSION)
  BEGIN
	SET @ERROR = 1
	GOTO QUIT
  END
-- Check that schema is valid
  IF NOT EXISTS(SELECT * FROM APM.Config WHERE ConfigName = N'SCHEMA_VERSION' 
					AND CAST(ConfigValue AS nvarchar(15)) = @SCHEMAVERSION)
  BEGIN
	SET @ERROR = 1
	GOTO QUIT
  END
QUIT:
	RETURN @ERROR
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CreateOrUpdateTaskStatus'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CreateOrUpdateTaskStatus AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.CreateOrUpdateTaskStatus 
     @DATABASEID      int
    ,@TASK            nvarchar(50)
    ,@OPERATION       int
    ,@STATUS          nvarchar(50)
    ,@STARTED         bit    
    ,@DATE            dateTime
    ,@LASTTIMESTAMP   bigint
    ,@TRACELEVEL      int
    ,@OPERATIONINDEX  bigint OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE
        @RECORDCOUNT int
    SELECT 
        @OPERATIONINDEX = t.LastTimeStamp 
    FROM 
        APM.Tasks t
    WHERE 
      t.TableName = @TASK 
      AND t.SEViewerDbId = @DATABASEID
    SELECT @RECORDCOUNT = @@ROWCOUNT  
    
    IF @RECORDCOUNT = 1 
    BEGIN        
      UPDATE 
        APM.Tasks  
      SET Status = @STATUS  
         ,StartDate = CASE WHEN @STARTED = 1 THEN @DATE ELSE StartDate END
         ,EndDate = CASE WHEN @STARTED = 0 THEN @DATE ELSE EndDate END
         ,LastTimeStamp = CASE WHEN @STARTED = 0 THEN @LASTTIMESTAMP ELSE LastTimeStamp END
         ,OperationId = @OPERATION
      WHERE
        TableName = @TASK 
        AND SEViewerDbId = @DATABASEID
      IF @STARTED = 0
        Set @OPERATIONINDEX = @LASTTIMESTAMP
    END
    IF @RECORDCOUNT = 0 
    BEGIN
        INSERT 
          APM.Tasks (TableName, StartDate, OperationId, LastTimeStamp, Status, SEViewerDbId)   
        VALUES (
          @TASK    
         ,@DATE  
         ,@OPERATION
         ,0
         ,@STATUS
         ,@DATABASEID
        )
       SET @OPERATIONINDEX = 0
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SelectAbsDateORRelative'), 'IsScalarFunction') IS NULL)
  BEGIN
    EXECUTE('CREATE FUNCTION APM.SelectAbsDateORRelative ()
		RETURNS int
		AS begin return 1 end')    
  END
GO
ALTER FUNCTION APM.SelectAbsDateORRelative(
    @RELATIVEDATE INT,
    @ABSDATE DATETIME,
--@ISENDDATE parameter defines how to return relative date
--if @ISENDDATE = 1, then appropriate date returned with 23:59 hours, otherwise it would be rounded to 00:00
    @ISENDDATE BIT,
--Offset field is used to return time value in client timezone, it can be different from SQL server
    @OFFSET INT) RETURNS DATETIME
AS
BEGIN
    DECLARE @RESULTDATE DATETIME
    -- Current time in user timezone
    DECLARE @CURRENTUSERDATE DATETIME
    SELECT @CURRENTUSERDATE = DATEADD(minute, @OFFSET, GETUTCDATE())
    IF @RELATIVEDATE &lt;&gt; 0
    BEGIN
        SELECT @RESULTDATE = 
            CASE @RELATIVEDATE 
                -- This Week: First Day
                WHEN 10 THEN DATEADD(d, -(DATEPART(WEEKDAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE)
                -- This Week: Last Day
                WHEN 20 THEN DATEADD(d, (7 - DATEPART(WEEKDAY, @CURRENTUSERDATE)), @CURRENTUSERDATE)
                -- Previous Week: First Day
                WHEN 30 THEN DATEADD(WEEK, -1, DATEADD(d, -(DATEPART(WEEKDAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE))
                -- Previous Week: Last Day
                WHEN 40 THEN DATEADD(WEEK, -1, DATEADD(d, (7 - DATEPART(WEEKDAY, @CURRENTUSERDATE)), @CURRENTUSERDATE)) 
                -- This Month: First Day
                WHEN 50 THEN DATEADD(DAY, -(DATEPART(DAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE)
                -- This Month: Last Day
                WHEN 60 THEN DATEADD(d, -DATEPART(DAY, DATEADD(MONTH, 1, @CURRENTUSERDATE)), DATEADD(MONTH, 1, @CURRENTUSERDATE))
                -- Previous Month: First Day
                WHEN 70 THEN DATEADD(MONTH, -1, DATEADD(DAY, -(DATEPART(DAY, @CURRENTUSERDATE) - 1), @CURRENTUSERDATE))
                -- Previous Month: Last Day
                WHEN 80 THEN DATEADD(DAY, -DATEPART(DAY, @CURRENTUSERDATE), @CURRENTUSERDATE)
                -- Today
                WHEN 90 THEN @CURRENTUSERDATE
                -- Yesterday
                WHEN 100 THEN DATEADD(DAY, -1, @CURRENTUSERDATE)
                -- Tomorrow
                WHEN 110 THEN DATEADD(DAY, 1, @CURRENTUSERDATE)
          END  
--Round datetime to date, without hours
        SELECT @RESULTDATE = CONVERT(NVARCHAR, @RESULTDATE, 112)
        
        IF @ISENDDATE &gt; 0
        BEGIN
--If IsEndDate parameter specified, take all day (time value equal to 23:59:59)
            SELECT @RESULTDATE = DATEADD(second, -1, DATEADD(d, 1, @RESULTDATE))
            IF @RESULTDATE &gt; @CURRENTUSERDATE
                SELECT @RESULTDATE = DATEADD(HOUR, DATEPART(HOUR,@CURRENTUSERDATE)+1, CONVERT(NVARCHAR, @CURRENTUSERDATE, 112))
        END
    END
    ELSE
        SELECT @RESULTDATE =@ABSDATE
    RETURN @RESULTDATE
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.EventDetail_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.EventDetail_sync AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.EventDetail_sync
  @OBJECTKEYXML       ntext
 ,@TRACELEVEL         INT
 ,@ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    DECLARE 
       @EXECRESULT         int
      ,@XMLDOCHANDLE       int
      ,@ERROR_MESSAGE      nvarchar(max)      
      ,@INSERTED_ROWCOUNT  int
      ,@UPDATED_ROWCOUNT   int
      ,@CHANGEDROWCOUNT    int 
    SET @ROWNOTAFFECTED = 0
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'EventDetail_sync', @EXECRESULT)
    END
    
    DECLARE @EVENTDETAIL TABLE (
       eventrowguid         nvarchar(15) collate database_default 
      ,name                 nvarchar(50) collate database_default  
      ,val1                 nvarchar(255) collate database_default 
      ,val2                 nvarchar(255) collate database_default
      ,client               bit
    )
    
    INSERT @EVENTDETAIL (
       eventrowguid
      ,name
      ,val1
      ,val2
      ,client
    )
    SELECT
       eventrowguid
      ,name
      ,val1
      ,val2
      ,client
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
       eventrowguid         nvarchar(15)    
      ,name                 nvarchar(50)  
      ,val1                 nvarchar(255) 
      ,val2                 nvarchar(255)
      ,client               bit
    ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
   -- Fill Ip table--------
   INSERT APM.ip (ip, subnetc) 
    SELECT DISTINCT 
        sync.val1
       ,sync.val2
    FROM 
        @EVENTDETAIL sync 
    WHERE 
        sync.name = 'IPADDRESS' AND
        sync.val1 IS NOT NULL AND sync.val1 &lt;&gt; '' AND NOT EXISTS(SELECT * FROM APM.ip ip WHERE ip.ip = sync.val1)
    UPDATE e
        SET e.ipid = ip.ipid
    FROM 
        APM.Event e
        JOIN @EVENTDETAIL sync ON e.rowguid = sync.eventrowguid AND sync.name = 'IPADDRESS' and sync.client = 0
        JOIN APM.Ip ip ON sync.val1 = ip.ip
         
    SET @UPDATED_ROWCOUNT = @@ROWCOUNT   
    SELECT @CHANGEDROWCOUNT = COUNT(*) FROM @EVENTDETAIL WHERE name = 'IPADDRESS' AND client = 0
    SET @ROWNOTAFFECTED = @CHANGEDROWCOUNT - @UPDATED_ROWCOUNT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetDependentComputersList'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetDependentComputersList AS RETURN 1')
  END
GO
ALTER PROCEDURE APM.GetDependentComputersList 
        @SOURCE NVARCHAR(MAX)
       ,@COMPUTERS NVARCHAR(MAX)
       ,@STARTDATE DateTime
       ,@ENDDATE DateTime
AS
BEGIN
    CREATE TABLE #SOURCEMACHINEMULTIVALUE
    (
        TYPEID int, VALUE int
    )
    INSERT 
        INTO #SOURCEMACHINEMULTIVALUE
            SELECT 
                p.typeid,
                CAST(p.value AS Int)
            FROM 
                APM.GetMultiParameters(@SOURCE, @COMPUTERS) p
--Select machine for server events
    SELECT DISTINCT m.machine, m.machineid
    FROM 
        APM.Machine AS m (NOLOCK) 
        JOIN #SOURCEMACHINEMULTIVALUE AS f2 ON (f2.TYPEID = 2 and f2.VALUE = M.machineid)
    UNION
    --Computer parameter have to contain at leat one value, or an exception occures in reports
    select N'', -1
END 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusSummaryStatistics'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusSummaryStatistics AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationStatusSummaryStatistics                                         */
/* USED IN: Application Status  Report                                              */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEIDS - List of the source id, separated by comma. Exp: '1,2,3'        */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @ENDDATE     - End date of the period                                       */
/*      @PERIOD      - Period type(Day, Week or Month).                             */
/*                   - Use for the Start Date calculate of the period               */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values   */
/*                          be calculated. Possible values: 1(1 month), 2(2 month), */
/*                          3(3 month), 6(6 month), 17 (7 day)                      */
/*      @TRESHOLD    - Event duration treshold                                      */
/*      @PROBLEM     - Event problem type (all, critical)                           */
/*      @TIMEZONE    - correlate parameter (timezone by min)                        */
/*                   - for the End Date calculate                                   */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationStatusSummaryStatistics 
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)   
WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON;
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    --Calculate End Date in view of timezone
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = APM.GetQueryDateCount(@PERIOD, @ENDDATE)
    --Calculate Start Date in view of period type
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @ENDDATE)
    --Calculate previos period Start Date
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @STARTDATE)
    --Calculate average period Start Date 
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
    /************************************************************************************/
    /*                          ASSISTING TEMP TABLES                                   */
    /************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    /************************************************************************************/
    /*                          Filtered events for further manipulations               */
    /************************************************************************************/
    ;WITH GetSummaryStatistics_EventsFiltered AS
    (
        SELECT
            e.SourceId,
            e.EventId,
            e.UtcEventDate AS Date,
            ABS(DATEDIFF(d, DATEADD(minute, @TIMEZONE, e.UtcEventDate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId
        FROM
            APM.Event AS e
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE
            (e.EventClassType = N'exception' OR (e.EventClassType = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD))
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    /************************************************************************************/
    /*                          Resource Utilizayion Queries                            */
    /************************************************************************************/
-- Calculate resource utilization by Source in one hour.
-- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId AS [Type],    
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,   
            
            ABS(DATEDIFF(day, DATEADD(minute, @TIMEZONE, ph.utcdate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId     
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeId = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
            --Join with #SOURCEMACHINEFILTERTABLE with typeId = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeId IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId
    ),
    --Calculate average application resource utilization over all specified period per machine
    --and for specified grouping period         
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilization AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId
    ),
    -- Count Monitored Requests and Avg. Request Timefor Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)  
            END AS LastMonRequest,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) 
            END AS CurMonRequest,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTypeID = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeID = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END) 
            END AS AvgReqTime,
            ABS(DATEDIFF(day, DATEADD(minute, @TIMEZONE, ph.utcdate), @ENDDATE)) / @PERIODDAYSCOUNT AS PeriodId     
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate
    ),
--Calculate average request time  and  sum request count for specified grouping period 
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByMachinePrepare ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId
    ),
--Union .NET counters and process counters for period Id.   
--PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
    ActivePreparePCounters AS (
        SELECT 
            pc.machineId,
            pc.SourceId,            
            
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurInstanceCount) AS CurInstanceCount, 
            MAX(pc.LastInstanceCount) AS LastInstanceCount,
            AVG(pc.AvgInstanceCount) AS AvgInstanceCount,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM 
            ApplicationResourceUtilizationByMachines AS pc
            LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId
       GROUP BY
            pc.machineId,
            pc.SourceId  
    ),
--Group PC between machines
    PCounters AS 
    (
        SELECT
            pc.SourceId AS SourceId,
            SUM(pc.CurReqCount) AS CurReqCount, 
            SUM(pc.LastReqCount) AS LastReqCount,
            SUM(pc.AvgReqCount) AS AvgReqCount,
            AVG(pc.CurAvgReqTime) AS CurAvgReqTime, 
            AVG(pc.LastAvgReqTime) AS LastAvgReqTime,
            AVG(pc.AvgReqTime) AS AvgReqTime,
            AVG(pc.CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(pc.LastCPUSum / COALESCE(m.CPUCount, 1)) AS LastCPUSum,
            AVG(pc.AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(pc.CurMemSum) AS CurMemSum, 
            AVG(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            AVG(pc.CurIOSum) AS CurIOSum, 
            AVG(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum,
            AVG(pc.CurInstanceCount) AS CurInstanceCount, 
            AVG(pc.LastInstanceCount) AS LastInstanceCount,
            AVG(pc.AvgInstanceCount) AS AvgInstanceCount
        FROM
            ActivePreparePCounters AS pc
            JOIN APM.Machine AS m ON m.MachineId = pc.MachineId
        GROUP BY 
            pc.SourceId
    ),
    PrepareEvents AS
    (
        SELECT
            e.SourceId,
            e.PeriodId,
            COUNT(CASE WHEN e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE THEN e.eventid END) AS CurEventCount,
            COUNT(CASE WHEN e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE THEN e.eventid END) AS LastEventCount,
            COUNT(CASE WHEN e.date &lt; @STARTDATE THEN e.eventid END) AS AverageEventCount
        FROM
            GetSummaryStatistics_EventsFiltered AS e
        GROUP BY 
            e.SourceId,
            e.PeriodId      
    ),
--Aggregate average event count. As PeriodId differs only for avg value, it doesn't matter which aggregation function is taken for other values
    Events AS
    (
        SELECT
            e.SourceId,
            MAX(e.CurEventCount) AS CurEventCount,
            MAX(e.LastEventCount) AS LastEventCount,
            --Average counting should not include current period
            AVG(CASE WHEN PeriodID &gt; 0 THEN e.AverageEventCount END) AS AverageEventCount
        FROM
            PrepareEvents AS e
        GROUP BY 
            e.SourceId      
    ),
    --  this query separated from GetSummaryStatistics_EventsFiltered as it has smaller period
    GetSummaryStatistics_EventsProblemsFiltered AS
    (
        SELECT
            e.SourceId,
            e.EventId,
            e.EventClassType,
            e.Description,
            e.RootNodeName,
            --Forms description for perfNode this way to avoid duration in event description
            COALESCE(RIGHT(pn.Description, LEN(pn.Description) - CHARINDEX(':', pn.Description)), N'') AS PerfNode,
            e.UtcEventDate AS Date,
            eg.FirstEventDate
        FROM
            APM.Event AS e
            JOIN APM.EventGroup AS eg ON e.eventgroupId = eg.EventGroupId
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
            OUTER APPLY (
                SELECT TOP(1)
                    pn.description
                FROM
                    APM.PerformanceNode AS pn
                WHERE
                    pn.eventid = e.eventid AND e.resourceid = pn.resourceid
                ORDER BY
                    pn.selfduration DESC
            ) AS pn
        WHERE
            (e.EventClassType = N'exception' OR (e.EventClassType = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD))
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    EventProblems AS
    (
        SELECT
            e.SourceId,
            COUNT(DISTINCT CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN rootnodeName + perfNode END) AS CurPerformanceProblemCount,
            COUNT(DISTINCT CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.description END) AS CurExceptionProblemCount,
            COUNT(CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.eventid END) AS CurPerformanceEventCount,
            COUNT(CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.eventid END) AS CurExceptionEventCount,
            COUNT(DISTINCT CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN rootnodeName + perfNode END) AS LastPerformanceProblemCount,
            COUNT(DISTINCT CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.description END) AS LastExceptionProblemCount,
            COUNT(CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.eventid END) AS LastPerformanceEventCount,
            COUNT(CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.eventid END) AS LastExceptionEventCount,
            COUNT(DISTINCT CASE WHEN (e.EventClassType = 'performance' AND e.firsteventdate &gt;= @STARTDATE) THEN e.rootnodeName + perfNode END) as NewPerfProblemsCount,
            COUNT(DISTINCT CASE WHEN (e.EventClassType &lt;&gt; 'performance' AND e.firsteventdate &gt;= @STARTDATE) THEN e.description END) as NewExpProblemsCount
        FROM
            GetSummaryStatistics_EventsProblemsFiltered AS e
        GROUP BY 
            e.SourceId
    ),
    ResultQuery AS
    (
        SELECT 
            ROW_NUMBER() OVER(ORDER BY s.SourceId) AS Id,
            s.SourceId,            
            s.Source,
            COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
            COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
            COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
            COALESCE(pc.CurAvgReqTime, 0) AS CurAvrValue,
            COALESCE(pc.LastAvgReqTime, 0) AS LastAvgValue,
            COALESCE(pc.AvgReqTime, 0) AS AvgValue,
            COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
            COALESCE(pc.LastCPUSum, 0) AS LastCPUValue,
            COALESCE(pc.AvgCPUSum, 0) AS CPUAvgValue,
            COALESCE(pc.CurMemSum, 0) AS CurMemValue,
            COALESCE(pc.LastMemSum, 0) AS LastMemValue,
            COALESCE(pc.AvgMemSum, 0) AS MemAvgValue,
            COALESCE(pc.CurIOSum, 0) AS CurIOValue,
            COALESCE(pc.LastIOSum, 0) AS LastIOValue,
            COALESCE(pc.AvgIOSum, 0) AS IOAvgValue,
            
            COALESCE(pc.CurInstanceCount, 0) AS CurInstanceCount,
            COALESCE(pc.LastInstanceCount, 0) AS LastInstanceCount,
            COALESCE(pc.AvgInstanceCount, 0) AS AvgInstanceCount,
            
            COALESCE(E.LastEventCount, 0) AS LastEventCount,
            COALESCE(e.CurEventCount, 0) AS CurrentEventCount,  
            COALESCE(e.AverageEventCount, 0) AS AvgEventsCount,
            COALESCE(p.CurExceptionEventCount, 0) AS CurExceptionEventCount,
            COALESCE(p.CurPerformanceEventCount, 0) AS CurPerformanceEventCount,
            COALESCE(p.LastPerformanceEventCount, 0) AS LastPerformanceEventCount,
            COALESCE(p.LastExceptionEventCount, 0) AS LastExceptionEventCount,
            COALESCE(p.CurPerformanceProblemCount, 0) AS CurPerformanceProblemCount,
            COALESCE(p.CurExceptionProblemCount, 0) AS CurExceptionProblemCount,
            COALESCE(p.LastPerformanceProblemCount, 0) AS LastPerformanceProblemCount,
            COALESCE(p.LastExceptionProblemCount, 0) AS LastExceptionProblemCount,
            COALESCE(p.NewPerfProblemsCount, 0) AS NewPerfProblemsCount,
            COALESCE(p.NewExpProblemsCount, 0) AS NewExpProblemsCount
        FROM 
            #SOURCEMACHINEFILTERTABLE AS sd 
            JOIN APM.Source AS s (NOLOCK) ON sd.VALUEID = s.SourceId
            LEFT OUTER JOIN PCounters AS pc ON s.SourceId = pc.Sourceid
            LEFT OUTER JOIN Events AS e ON s.Sourceid = e.Sourceid
            LEFT OUTER JOIN EventProblems AS p ON s.Sourceid = p.Sourceid
        WHERE
            sd.TYPEID = 1
    )
        SELECT 
            LastResults.Id AS RowId,
            SourceId,            
            Source,
            -------Instance Count----------
            CurInstanceCount,
            LastInstanceCount,
            AvgInstanceCount,           
            -------MonitoredRequest--------
            CurMonitoredRequestSum,
            LastMonitoredRequestSum,
            AvgMonitoredRequestSum,
            -------Avg value----------
            CurAvrValue, 
            LastAvgValue,
            AvgValue,
            ------CPU Value----------
            CurCPUValue, 
            LastCPUValue,
            CPUAvgValue,
            ------ Mem value------------
            CurMemValue, 
            LastMemValue,
            MemAvgValue, 
            --------- IO value-------------
            CurIOValue,
            LastIOValue,
            IOAvgValue,
            ------- Events count----------
            AvgEventsCount,
            CurrentEventCount,
            LastEventCount,
            --------- Exception &amp; Performance Event Count ---------
            CurExceptionEventCount,
            CurPerformanceEventCount,
            LastPerformanceEventCount,
            LastExceptionEventCount,
            --------  Exception &amp; Performance Problem Count ---------
            CurPerformanceProblemCount,
            CurExceptionProblemCount,
            LastPerformanceProblemCount,
            LastExceptionProblemCount,
            NewPerfProblemsCount,
            NewExpProblemsCount
        FROM
            ResultQuery AS LastResults
        ORDER BY            
            RowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusDrillthrough'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusDrillthrough AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusDrillthrough                                                  */
/* USED IN: Application Status  Report, Application Daily Activity                      */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period                                        */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationStatusDrillthrough
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -(CASE WHEN @PERIOD = 1 THEN 1 WHEN @PERIOD = 2 THEN 7 ELSE 31 END), @ENDDATE)    
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = APM.GetQueryDateCount(@PERIOD, @STARTDATE);
    
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Apps\Avg. Request Time'
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- To form application pool with all sources run in it, it is need to get all sources and its process
    CREATE TABLE #PROCESSFORSOURCE
    (
        SOURCEID INT,
        PCPROCESSID INT,
        MACHINEID INT,
        EXTRAINFO NVARCHAR(255) collate database_default,
        PROCESS NVARCHAR(255) collate database_default
    )
    
    INSERT INTO #PROCESSFORSOURCE
        SELECT
            ph.SOURCEID,
            ph.PCPROCESSID,
            ph.MACHINEID,
            COALESCE(p.EXTRAINFO, N'') AS EXTRAINFO,
            --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
            APM.RemoveProcessIdFromName(p.PROCESS) AS Process           
        FROM
            (
                SELECT DISTINCT
                    ph.SOURCEID,
                    ph.PCPROCESSID,
                    ph.MACHINEID
                FROM
                    APM.PerfHourly AS ph (NOLOCK)
                WHERE
                    ph.PCPROCESSID IS NOT NULL
                    AND ph.UTCDATE &gt;= @STARTDATE
                    AND ph.UTCDATE &lt; @ENDDATE
            ) AS ph
            JOIN APM.PCProcess AS p (NOLOCK) ON p.PCPROCESSID = ph.PCPROCESSID 
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MACHINEID = f.VALUEID)
/************************************************************************************/
/*                          Main query                                              */
/************************************************************************************/
  
-- Report frame. It contains all sources, for which data sould be selected, 
-- and date values accordingly to specified period and grouping type.  
   ;WITH SourcesDates AS
    (
        SELECT
            VALUEID AS sourceid,
            s.SOURCE AS source,
            Hours.n-1 AS hours,
            D.date AS date
        FROM
            #SOURCEMACHINEFILTERTABLE AS source
            JOIN APM.source (NOLOCK) AS s ON s.SOURCEID = source.VALUEID,
            APM.fn_nums(                
                (CASE
                    WHEN @GROUPBY = 'WeekDay' THEN 24
                    ELSE 1
                END)) AS Hours,
            (SELECT
                (CASE
                    WHEN @GROUPBY = 'Hour' THEN n-1
                    WHEN @GROUPBY = 'WeekDay' THEN n
                    WHEN @GROUPBY = 'MonthDay' THEN n
                END) AS date
            FROM 
                APM.fn_nums(
                    CASE
                        WHEN @GROUPBY = 'Hour' THEN 24
                        WHEN @GROUPBY = 'WeekDay' THEN 7
                        WHEN @GROUPBY = 'MonthDay' THEN 31
                    END     
                )           
            ) AS D
        WHERE
            source.TYPEID = 1
    ),
-- Get sources name, ids list separated by comma per app pool
-- This info should be selected for all sources, even they are in the same application pool
-- as in this report grouping by source is applied not by application pool.
    AppPoolInfo AS 
    (
        SELECT 
            c.SOURCEID,
            c.EXTRAINFO,
            c.PROCESS,
            -- all source names which have the same process name as passed in @SOURCEIDS
            (SELECT A.source AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        N'''' + s.source + N'''' +  N',' AS source
                    FROM 
                        #PROCESSFORSOURCE AS c1
                        JOIN APM.Source AS s ON c1.SOURCEID = s.SourceId
                    WHERE 
                        c1.EXTRAINFO = c.EXTRAINFO 
                        AND c1.PROCESS = c.PROCESS
                        AND c1.MACHINEID = c.MACHINEID
                ) AS A
                FOR XML PATH ('') 
            ) AS AppPoolSources
        FROM
            #PROCESSFORSOURCE AS c
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
        GROUP BY
            c.SOURCEID, 
            c.MACHINEID,
            c.EXTRAINFO,
            c.PROCESS
    ),
    --Add Pool name in-front of source list, if it is executable application, then app pool countains source name
    PrepareAppPoolInfo AS (
        SELECT DISTINCT
            CASE 
                WHEN COALESCE(info.EXTRAINFO,'') = '' THEN CASE info.AppPoolSources WHEN '' THEN '' ELSE LEFT(info.AppPoolSources, LEN(info.AppPoolSources)-1) END
                ELSE info.EXTRAINFO + CASE info.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(info.AppPoolSources, LEN(info.AppPoolSources) - 1) + ')' END
            END AppPool,
            info.SOURCEID,
            info.EXTRAINFO
        FROM 
            AppPoolInfo AS info
    ),
-- Forms application pool list for each source
-- Format: AppPool1 ('Source1', 'Source2', Source3), AppPool2 ('Source1', 'Source4')
    SourceAppPools AS (
        SELECT 
            s.SOURCEID,
            s.SOURCE,
            COALESCE((SELECT a.AppPool AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        info.AppPool +  N',' AS AppPool
                    FROM 
                        PrepareAppPoolInfo as info
                    WHERE 
                        info.Sourceid = s.Sourceid 
                ) AS A
                FOR XML PATH ('') 
            ),s.SOURCE +  '-') AS AppPoolInfo
        FROM 
            APM.Source AS s
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = s.SOURCEID)
    ),    
--Prepares and filters events for further manipulations
    ActivityBreakdown_EventsFiltered AS
    (
        SELECT
            e.SOURCEID,
            e.EVENTID,
            e.UTCEVENTDATE AS eventdate,
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            END as date,
            CASE 
                WHEN @GROUPBY = 'WeekDay' 
                    THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate)) 
                ELSE 0 
            END AS Hour,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, e.UTCEVENTDATE, @STARTDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId,
            e.EVENTGROUPID,
            db.ADDRESS AS SeViewerAddress
        FROM
            APM.Event AS e
            JOIN APM.SeViewerDB AS db ON e.SEVIEWERDBID = db.SEVIEWERDBID
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID and f2.TYPEID = 2)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)              
        WHERE
            ((e.EVENTCLASSTYPE = N'Performance' AND e.EVENTDURATION / 1000000.0 &gt;= @THRESHOLD) 
            OR e.EVENTCLASSTYPE = N'exception')
            AND (e.CATEGORY LIKE @PROBLEM OR e.CATEGORY IS NULL)
            AND e.UTCEVENTDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND e.UTCEVENTDATE &lt; @ENDDATE
            AND (e.HEAVYLIGHT &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    /************************************************************************************/
    /*                          Base pcounter queries                                   */
    /************************************************************************************/
    -- Calculate resource utilization by Source in one hour.
    -- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE,
            ph.PCTYPEID AS Type,    
            
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,   
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            END as Date,
            (CASE WHEN @GROUPBY = 'WeekDay' THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int),  ph.UTCDate)) ELSE 0 END) AS Hours,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, ph.UTCDATE, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SOURCEID)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MACHINEID)
        WHERE
            ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDATE &lt; @ENDDATE
            AND ph.PCTYPEID IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE,
            ph.PCTYPEID
    )
    ,
--Calculate average source resource utilization for each resource type
--and for specified grouping period and date          
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilization AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours
    ),
    -- Count Monitored Requests and Avg. Request Time for Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MACHINEID,
            ph.SOURCEID,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END)  
            END AS LastMonRequest,
            CASE WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END) 
            END AS CurMonRequest,
            CASE WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END) 
            END AS AvgReqTime,
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            END as Date,
            (CASE WHEN @GROUPBY = 'WeekDay' THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int),  ph.UTCDATE)) ELSE 0 END) AS Hours,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, ph.UTCDATE, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SOURCEID = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MACHINEID)
        WHERE
            ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDATE &lt; @ENDDATE
            AND ph.PCTYPEID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE
    ),
--Calculate average request time  and  sum request count for specified grouping period and date          
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByMachinePrepare ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours
    ),
--  Union .NET counters and process counters for period Id. Period Id differs only for average(last three months) values, so grouping only for them
    PCountersGroupedByMachineId AS (
        SELECT 
            pc.machineId,
            pc.SourceId,
            pc.Hours,
            pc.date,
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM ApplicationResourceUtilizationByMachines pc
       LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId 
                AND netApp.Hours = pc.Hours AND netApp.Date = pc.Date 
        GROUP BY
            pc.machineId,
            pc.SourceId,
            pc.Hours,
            pc.date
    ),
-- Calculate average source resource utilization between machines  
    ActivePreparePCounters AS (
        SELECT 
            pc.SourceId,
            pc.Hours,
            pc.date,            
            SUM(CurReqCount) AS CurReqCount, 
            SUM(LastReqCount) AS LastReqCount,
            SUM(AvgReqCount) AS AvgReqCount,
            AVG(CurAvgReqTime) AS CurAvgReqTime, 
            AVG(LastAvgReqTime) AS LastAvgReqTime,
            AVG(AvgReqTime) AS AvgReqTime,
            AVG(CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(LastCPUSum / COALESCE(m.CPUCount, 1) ) AS LastCPUSum,
            AVG(AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(CurMemSum) AS CurMemSum, 
            AVG(LastMemSum) AS LastMemSum,
            AVG(AvgMemSum) AS AvgMemSum,
            AVG(CurIOSum) AS CurIOSum, 
            AVG(LastIOSum) AS LastIOSum,
            AVG(AvgIOSum) AS AvgIOSum
        FROM 
            PCountersGroupedByMachineId pc
            JOIN APM.Machine AS m ON m.MACHINEID = pc.MachineId
        GROUP BY    
            pc.SourceId,
            pc.Hours,
            pc.date
    ),
--Count events for the current, last and average period. PeriodId differs only for average
    PrepareEventsAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.date,
            e.hour,
            e.PeriodId,         
            MAX(E.SeViewerAddress) AS SeViewerAddress,  
            COUNT(CASE WHEN e.eventdate &gt;= @STARTDATE AND e.eventdate &lt; @ENDDATE THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.eventdate &gt;= @LASTPERIODSTARTDATE  AND e.eventdate &lt; @STARTDATE THEN eventid END) AS LasEventsCount,
            COUNT(CASE WHEN E.eventdate &gt;= @AVERAGEPERIODSTARTDATE AND E.eventdate &lt; @STARTDATE THEN eventid END) AS AvgEventsCount
        FROM
            ActivityBreakdown_EventsFiltered AS e
        GROUP BY 
            sourceid,
            PeriodId,
            e.date,
            e.hour
    ),
    Events AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.date,
            e.hour,
            MAX(E.SeViewerAddress) AS SeViewerAddress,
            --PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LasEventsCount) AS LasEventsCount,
            --Average counting is not included current period
            AVG(AvgEventsCount) AS AvgEventsCount
        FROM
            PrepareEventsAvg AS e
        GROUP BY 
            sourceid,
            e.date,
            e.hour  
    ),
    MachineCPUUndefinedFlag AS
    (
        SELECT
            sf.SOURCEID,
            MIN(COALESCE(m.CPUCOUNT, -1)) AS CPUUndefinedFlag
        FROM
            #PROCESSFORSOURCE AS sf
            JOIN APM.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MACHINEID
        GROUP BY
            sf.SOURCEID
    )
    SELECT
    -- This fake fields is need to provide compatibility with SP ApplicationStatusDrillthrough
    GetDate() AS ClientDate,
        SourcesDates.date AS Date,
        SourcesDates.Hours AS Hours,
        SourcesDates.Sourceid,
        SourcesDates.Source AS Source,
--Period is used to organize result values, for example if @PERIOD is Day and @ENDDATE = '05/06/2009 13:00', 
--this value should put 23 hour of 05/05/2009 before 10 hour of 05/06/2009
        (CASE 
            WHEN (SourcesDates.date - APM.GetDatePart(@GROUPBY, DATEADD(mi, CAST(@TIMEZONE AS int), @ENDDATE))
            ) &lt; 0 THEN 0
            WHEN (SourcesDates.date - APM.GetDatePart(@GROUPBY, DATEADD(mi, CAST(@TIMEZONE AS int), @ENDDATE))
            ) &gt;= 0 THEN 1
        END) AS Period,
        COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
        COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
        COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
        COALESCE(pc.CurAvgReqTime, 0) AS CurAvgReqTime,
        COALESCE(pc.LastAvgReqTime, 0) AS LastAvgReqTime,
        COALESCE(pc.AvgReqTime, 0) AS AvgReqTime,
        COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
        COALESCE(pc.lastCPUSum, 0) AS LastCPUValue,
        COALESCE(pc.AvgCPUSum, 0) AS AvgValue,
        COALESCE(pc.CurMemSum, 0) AS CurMemValue,
        COALESCE(pc.LastMemSum, 0) AS LastMemValue,
        COALESCE(pc.AvgMemSum, 0) AS AvgMemValue,
        COALESCE(pc.CurIOSum, 0) AS CurIOValue,
        COALESCE(pc.LastIOSum, 0) AS LastIOValue,
        COALESCE(pc.AvgIOSum, 0) AS AvgIOValue,
        COALESCE(e.CurrentEventsCount, 0) AS NewEventsCount,
        COALESCE(e.LasEventsCount, 0) AS OldEventsCount,
        COALESCE(e.AvgEventsCount, 0) AS AvgEventsCount,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one process PCounter row
        -- in PerfHourly table for specified period. If so there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag,
        (CASE 
            WHEN (@GROUPBY = 'Hour' AND ((SourcesDates.date % 2) = 0)) THEN  SourcesDates.date
            WHEN (@GROUPBY = 'WeekDay' AND ((SourcesDates.Hours + 12) % 24) = 0) THEN  SourcesDates.date
            WHEN (@GROUPBY = 'MonthDay') THEN  SourcesDates.date
            ELSE -1
        END) AS OutputDate,
        CASE LEFT(AppPool.AppPoolInfo,1) 
            WHEN N'''' THEN N'' 
            WHEN N'' THEN ''
            ELSE REPLACE(LEFT(AppPool.AppPoolInfo, LEN(AppPool.AppPoolInfo)-1), N'''', N'')
        END AS pool,
        E.SeViewerAddress
    FROM 
        SourcesDates
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON SourcesDates.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ActivePreparePCounters AS pc ON (pc.date = SourcesDates.date AND pc.SourceId = SourcesDates.Sourceid AND SourcesDates.Hours = pc.Hours)
        LEFT OUTER JOIN Events AS e ON (e.date = SourcesDates.date AND e.Sourceid = SourcesDates.Sourceid AND e.hour = SourcesDates.Hours)
        JOIN SourceAppPools AS AppPool ON (AppPool.Sourceid = SourcesDates.Sourceid)
    ORDER BY    
        Source, 
        Period DESC, 
        Date, 
        Hours 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Application_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Application_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Application_sync                                                           */
/* USED IN: Synchronization of SE-Viewer.'Application' table.                       */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Application_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Application_sync', @EXECRESULT)
    END
    
    DECLARE @APPLICATION TABLE (
       application  nvarchar(255) collate database_default  NOT NULL
    )
    
    ----Fill table from package
    INSERT @APPLICATION (
       application
    )
    SELECT
       application
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    application  nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --insert not existing applications
    INSERT APM.application (application,type)
    SELECT DISTINCT sync.application , 3
    FROM @APPLICATION sync
    WHERE NOT EXISTS (SELECT * FROM APM.application a WHERE (a.application = sync.application))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationSourceMachine_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationSourceMachine_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationSourceMachine_sync                                              */
/* USED IN: Synchronization of SE_VIEWER:'applicationsourcemachine' table.          */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE [APM].[ApplicationSourceMachine_sync]
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ApplicationSourceMachine_sync', @EXECRESULT)
    END
    
    DECLARE @APPLICATIONSOURCEMACHINE TABLE (
        application nvarchar(255) collate database_default  NOT NULL,
        source          nvarchar(255) collate database_default          ,
        machine         nvarchar(255) collate database_default  
    )
    
    ----Fill table from package
    INSERT @APPLICATIONSOURCEMACHINE(
       application,source,machine
    )
    SELECT
       application,source,machinename
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    application  nvarchar(255),
                    source nvarchar(255),
                    machinename nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
	----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
	INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	   SELECT DISTINCT machine FROM @APPLICATIONSOURCEMACHINE app
		   WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = app.machine) AND app.machine IS NOT NULL 
		   
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
		   
	  ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
	INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @APPLICATIONSOURCEMACHINE app
		 WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = app.source) AND app.source IS NOT NULL
    
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
    --insert not existing rows
    --don't transfers rows with source is not found or machine is not found
    INSERT APM.applicationsourcemachine (applicationid,sourceid,machineid)
    SELECT DISTINCT a.applicationid,s.sourceid,m.machineid
    FROM    @APPLICATIONSOURCEMACHINE sync
            JOIN APM.Application a  ON a.application = sync.application
            JOIN APM.Source s       ON s.source = sync.source
            JOIN APM.Machine m      ON m.machine = sync.machine
    WHERE NOT EXISTS (  SELECT * FROM APM.applicationsourcemachine asm 
                        WHERE ( asm.applicationid = a.applicationid AND
                                asm.sourceid = s.sourceid AND
                                asm.machineid = m.machineid
                                ))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryQualityAnalysis'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryQualityAnalysis AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryQualityAnalysis                                                     */
/* USED IN: SummaryQualityAnalysisSubReport.rdl                                     */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/*      @TRESHOLD    - Event duration treshold                                      */
/*      @PROBLEM     - Event problem type (all, critical)                           */
/************************************************************************************/
ALTER PROCEDURE [APM].[SummaryQualityAnalysis] 
    @SOURCEID NVARCHAR(255),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @THRESHOLD  INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50) WITH RECOMPILE
AS
BEGIN
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEID, @COMPUTERIDS) AS p
                
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p                
  CREATE TABLE #SUMMARYQUALITYANALYSISTMP 
  (
    ID int,
    RESOURCE nvarchar(255) collate database_default,
    RESTYPE nvarchar(50) collate database_default,
    RESCOUNT int,
    FAILCOUNT int,
    CONNCOUNT int,
    PERFCOUNT int,
    SECCOUNT int 
  ) 
  INSERT INTO #SUMMARYQUALITYANALYSISTMP
    SELECT 
        ROW_NUMBER() OVER (ORDER BY COUNT(e.eventid) desc) AS ID,
        r.resourceuri AS RESOURCE,
        rg.name AS RESTYPE,
        COUNT(e.eventid) AS RESCOUNT,
        COUNT(CASE aspect WHEN 'applicationfailure' THEN 1 END) AS FAILCOUNT, 
        COUNT(CASE aspect WHEN 'connectivity' THEN 1  END) AS CONNCOUNT, 
        COUNT(CASE aspect WHEN 'performance' THEN 1  END) AS PERFCOUNT, 
        COUNT(CASE aspect WHEN 'security' THEN 1  END) AS SECCOUNT
    FROM 
        APM.event AS e (NOLOCK) 
        JOIN APM.resource AS r (NOLOCK) on  e.resourceid = r.resourceid
        JOIN APM.resourcegroup AS rg (NOLOCK) on r.resourcegroupid = rg.resourcegroupid
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND f.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)            
    WHERE 
        ((e.aspect = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD) OR 
        e.aspect IN ('applicationfailure', 'connectivity', 'security'))
        AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
        AND e.sourceId = @SOURCEID
        AND e.utceventdate &gt;= @STARTDATE AND e.utceventdate &lt; @ENDDATE
        AND (e.category LIKE @PROBLEM OR e.category IS NULL)
    GROUP BY
        r.resourceuri, rg.name
    /*------------------ Base query -------------------------- */
    SELECT TOP 5
        R1.ID,
        R1.RESOURCE, 
        R1.RESTYPE as RESTYPE,
        R1.RESCOUNT, 
        R1.FAILCOUNT,
        R1.CONNCOUNT,
        R1.SECCOUNT,
        R1.PERFCOUNT, 
        R1.RESCOUNT + (
            SELECT CASE WHEN SUM(r2.RESCOUNT) IS NULL THEN 0 ELSE SUM(r2.RESCOUNT) END 
            FROM #SUMMARYQUALITYANALYSISTMP r2
            WHERE r2.ID &lt; r1.ID
        ) AS runValue,
        SUM(RESCOUNT) OVER() AS AllCount
    FROM 
       #SUMMARYQUALITYANALYSISTMP AS R1 
    ORDER BY 
       ID 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisReport                                                  */
/* USED IN: Summary Size Analysis Report                                            */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Page Content Size                                            */
/*                  2. Ajax Size                                                    */
/*                  3. Total Size                                                   */
/*                  4. Event Count                                                  */
/*                  5. Event Duration                                               */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50) 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    CSEVENTID,
    SOURCEID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID AND f2.TYPEID = 2)
    JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS) 
WHERE 
    e.PAGEURI IS NOT NULL 
    AND e.CLASSTYPE = N'Performance' 
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        0 AS IsPageEvent,
        ajax.TOTALTIME AS TotalTime,
        ajax.RESPONSESIZE + ajax.REQUESTSIZE AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEVENTID    
),
JSEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        0 AS IsPageEvent,
        js.TOTALTIME AS TotalTime,
        NULL AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON e.CSEVENTID = js.CSEVENTID
),
PageEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        1 AS IsPageEvent,
        p.TOTALTIME AS TotalTime,
        p.TOTALSIZE AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
),
UnionEvents AS
(
    SELECT * FROM AJAXEvents
    UNION ALL
    SELECT * FROM JSEvents
    UNION ALL
    SELECT * FROM PageEvents
),
EventAggregation AS
(
    SELECT 
        SOURCEID,
        CSEVENTID,
        MAX(IsPageEvent) AS IsPageEvent,
        MAX(TotalTime) AS TotalTime,        
        SUM(TotalSize) AS TotalSize
    FROM 
        UnionEvents
    GROUP BY 
        SOURCEID, 
        CSEVENTID
), 
SourceAggregation AS
(
    SELECT 
        SOURCEID,
        COUNT(*) AS EventCount,
        AVG(TotalTime) / 1000.0 AS EventDuration,
        -- Take into account AJAX call size, which occured during page load event
        AVG(CASE WHEN IsPageEvent = 1 THEN TotalSize END) / 1024.0 AS PageContentSize,
        AVG(TotalSize) / 1024.0 AS TotalSize,
        -- Calculate AJAX size only for JS with AJAX and for Asynch AJAX events 
        AVG(CASE WHEN IsPageEvent = 0 THEN TotalSize END) / 1024.0 AS AjaxSize
    FROM 
        EventAggregation
    GROUP BY 
        SOURCEID
)
SELECT TOP(10)
    Row_Number() OVER(ORDER BY 
                        CASE    
                            WHEN @ORDERBY = 1 THEN ds.PageContentSize
                            WHEN @ORDERBY = 2 THEN ds.AjaxSize 
                            WHEN @ORDERBY = 3 THEN ds.TotalSize
                            WHEN @ORDERBY = 4 THEN ds.EventCount
                            WHEN @ORDERBY = 5 THEN ds.EventDuration
                        END DESC) AS Id,
        ds.SOURCEID,
        s.SOURCE,
        ds.EventCount,
        ds.EventDuration,
        ds.PageContentSize,
        ds.TotalSize,
        ds.AjaxSize
FROM 
    SourceAggregation AS ds
    JOIN APM.Source AS s (NOLOCK) ON s.SOURCEID = ds.SOURCEID
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisTopAJAXSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisTopAJAXSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisTopAJAXSubReport                                        */
/* USED IN: Summary Size Analysis Sub Report for top AJAX call                      */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Source Id                                                       */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisTopAJAXSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50) 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids 
-- valueId filter value for machineId
CREATE TABLE #MACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #AJAXEVENT 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    AJAXURI NVARCHAR(255) collate database_default,
    AJAXDURATION DECIMAL(35, 0),
    RESPONSESIZE BIGINT,
    REQUESTSIZE BIGINT
)
INSERT INTO #AJAXEVENT
SELECT
    e.CSEventId,
    e.PageUri,
    ajax.Uri,
    ajax.TotalTime,
    ajax.ResponseSize,
    ajax.REQUESTSIZE
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON f.VALUEID = e.MACHINEID
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMSTATUS)     
    CROSS APPLY (
            SELECT TOP(1)
                ajax.Uri,
                ajax.TotalTime,
                ajax.RESPONSESIZE,
                ajax.REQUESTSIZE
            FROM
                APM.CSAJAX AS ajax (NOLOCK)
            WHERE
                ajax.CSEVENTID = e.CSEVENTID 
            ORDER BY 
                ajax.TOTALTIME DESC
            ) AS ajax 
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
    -- collected ajax calls except for page sync ajax calls 
    AND e.EVENTCLASS &lt;&gt; N'CSMPMonitorLog'
CREATE INDEX idx_Event ON #AJAXEVENT (CSEVENTID) 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
;WITH EventDuration AS
(
    SELECT 
        a.CSEVENTID,
        a.PAGEURI,
        a.AJAXURI,
        a.AJAXDURATION AS AJAXDuration,
        a.RESPONSESIZE,
        a.REQUESTSIZE
    FROM 
        #AJAXEVENT AS a
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON a.CSEVENTID = js.cseventid
),
AJAXSize AS
(
    SELECT
        COUNT(CSEventId) AS EventCount,
        PageUri,
        AJAXUri,
        AVG(AJAXDuration) AS AJAXDuration,
        AVG(ResponseSize) AS ResponseSize,
        AVG(RequestSize) AS RequestSize,
        AVG(ResponseSize + RequestSize) AS TotalSize
    FROM 
        EventDuration
    GROUP BY
        PageUri,
        AJAXUri     
),
NumberedRow AS
(
    SELECT
        Row_Number() OVER(ORDER BY TotalSize DESC) AS Id,
        EventCount,
        PageUri,
        AJAXUri,
        AJAXDuration/1000.0 AS AJAXDuration,
        ResponseSize/1024.0 AS ResponseSize,
        RequestSize/1024.0 AS RequestSize,
        TotalSize/1024.0 AS TotalSize,
        SUM(EventCount) OVER() AS TotalEventCount
    FROM
        AJAXSize
)
    SELECT TOP(4)
        Id,
        EventCount,
        PageUri,
        AJAXUri AS AjaxCall,
        AJAXDuration,
        ResponseSize,
        RequestSize,
        TotalSize,
        TotalEventCount
    FROM
        NumberedRow
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisTopPagesSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisTopPagesSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisTopPagesSubReport                                       */
/* USED IN: Summary Size Analysis Sub Report for top pages                          */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Source Id                                                       */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Image Size                                                   */
/*                  2. CssStyle Size                                                */
/*                  3. Htc Size                                                     */
/*                  4. Script Size                                                  */
/*                  5. HTML Size                                                    */
/*                  6. AjaxSize Size                                                */
/*                  7. TotalSize Size                                               */
/*                  8. Event Count                                                  */
/*                  9. Avg. Event Duration                                          */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisTopPagesSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids 
-- valueId filter value for machineid 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #PAGEEVENT 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    TOTALTIME DECIMAL(35, 0),
    TOTALSIZE DECIMAL(35, 0)
)
INSERT INTO #PAGEEVENT
SELECT
    e.CSEVENTID,
    e.PAGEURI,
    P.TOTALTIME,
    P.TOTALSIZE
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMSTATUS)         
    JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
WHERE 
    e.PAGEURI IS NOT NULL 
    AND e.SOURCEID = @SOURCEID
    AND e.CLASSTYPE = N'Performance' 
    AND e.SOURCEID &lt;&gt; -1
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
--Before grouping by page uri, event content with Null size should by transformed to 0,
-- to provide convergence with Avg total size
;WITH PeripheralSize AS
(
    SELECT 
        e.CSEVENTID,
        SUM(CASE WHEN p.TYPE = N'Image' THEN p.TotalSize END) AS Image,
        SUM(CASE WHEN p.TYPE = N'Script' THEN p.TotalSize END) AS Script,
        SUM(CASE WHEN p.TYPE = N'CssStyle' THEN p.TotalSize END) AS CssStyle,
        SUM(CASE WHEN p.TYPE = N'HtcBehavior' THEN p.TotalSize END) AS HtcBehavior,
        SUM(CASE WHEN p.TYPE = N'HTML' THEN p.TotalSize END) AS HTML
    FROM 
        APM.CSPeripheral AS p (NOLOCK) 
        JOIN  #PAGEEVENT AS e ON p.cseventid = e.CSEVENTID
    GROUP BY
        e.CSEVENTID
),
PageSize AS
(
    SELECT
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(COALESCE(p.Image, 0)) AS Image,
        AVG(COALESCE(p.Script, 0)) AS Script,
        AVG(COALESCE(p.CssStyle, 0)) AS CssStyle,
        AVG(COALESCE(p.HtcBehavior, 0)) AS HtcBehavior,
        AVG(COALESCE(p.HTML, 0)) AS HTML,
        AVG(e.TOTALTIME) AS EventDuration,
        AVG(e.TOTALSIZE) AS TotalSize
    FROM
        #PAGEEVENT AS e
        LEFT OUTER JOIN PeripheralSize AS p ON p.CSEventid = e.CSEVENTID
    GROUP BY 
        e.PAGEURI
),
AJAXSize AS
(
    SELECT 
        a.PageUri,
        AVG(a.AjaxSize) AS AjaxSize
    FROM
    (
        SELECT
            e.CSEVENTID,
            e.PAGEURI,
            SUM(COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0)) AS AjaxSize
        FROM 
            #PAGEEVENT AS e
            JOIN APM.CSAJAX AS ajax (NOLOCK) ON (ajax.CSEventId = e.CSEVENTID)
        GROUP BY
            e.CSEVENTID,
            e.PAGEURI
    ) AS a
    GROUP BY
        a.PageUri
),
NumberedResults AS
(
    SELECT  
        Row_Number() OVER(ORDER BY 
                            CASE    
                                WHEN @ORDERBY = 1 THEN p.Image
                                WHEN @ORDERBY = 2 THEN p.CssStyle
                                WHEN @ORDERBY = 3 THEN p.HtcBehavior
                                WHEN @ORDERBY = 4 THEN p.Script
                                WHEN @ORDERBY = 5 THEN p.HTML
                                WHEN @ORDERBY = 6 THEN ajax.AjaxSize
                                WHEN @ORDERBY = 7 THEN p.TotalSize + COALESCE(ajax.AjaxSize, 0)
                                WHEN @ORDERBY = 8 THEN p.EventCount
                                WHEN @ORDERBY = 9 THEN p.EventDuration
                            END DESC) AS Id,
        p.PageUri,
        p.EventCount,
        p.Image/(1024.0) AS Image,
        p.Script/(1024.0) AS Script,
        p.CssStyle/(1024.0) AS CssStyle,
        p.HtcBehavior/(1024.0) AS HtcBehavior,
        p.HTML/(1024.0) AS HTML,
        p.EventDuration/(1000.0) AS EventDuration,
        (p.TotalSize + COALESCE(ajax.AjaxSize, 0))/(1024.0) AS TotalSize,
        COALESCE(ajax.AjaxSize, 0)/(1024.0) AS AjaxSize,
        SUM(p.EventCount) OVER() AS TotalEventCount
    FROM
        PageSize AS p
        LEFT OUTER JOIN AJAXSize AS ajax ON Ajax.PageUri = p.PageUri
)
SELECT TOP(4) 
    Id,
    PageUri,
    EventCount,
    Image,
    Script,
    CssStyle,
    HtcBehavior,
    HTML,
    EventDuration,
    TotalSize,
    AjaxSize,
    TotalEventCount
FROM
    NumberedResults
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.TopUserPerformanceIssues'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.TopUserPerformanceIssues AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: TopUserPerformanceIssues                                                   */
/* USED IN: Top5UserPerformanceSubReport.rdl                                        */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/*      @TRESHOLD    - Event duration treshold                                      */
/************************************************************************************/
ALTER PROCEDURE [APM].[TopUserPerformanceIssues] 
(
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @THRESHOLD  INT,
    @USERNAME NVARCHAR(255),
	@PMSTATUS NVARCHAR(50)
) WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    CREATE TABLE #SUMUSERANALYSIS 
    (
        DESCRIPTION nvarchar(255) collate database_default,
        USERID int,
        USERFLAG BIT,
        SOURCEID int,
        EVENTCOUNT int,
        USERSUMSLOWESTNODEDUR decimal(35,0),
        USERCOUNTSLOWESTNODEDUR int,
        SLOWESTNODEDUR decimal(35,0),
        COUNTSLOWESTNODDUR int
    )
-- Select performance event information for all users
;WITH UsersInfo AS
(
    SELECT 
        pn.description AS Description,
        MIN(e.UserId) AS UserId,
        CASE u.Name WHEN @USERNAME THEN 1 ELSE 0 END AS UserFlag,
        e.sourceId,
        COUNT(e.EVENTID) AS EventCount,
        SUM(CASE u.Name WHEN @USERNAME THEN pn.selfduration END) AS  UserSumSlowestNodeDur,
        COUNT(CASE u.Name WHEN @USERNAME THEN e.EVENTID END) AS UserCountSlowestNodeDur,
        SUM(pn.selfduration) AS  SlowestNodeDur,
        COUNT(pn.selfduration) AS CountSlowestNodeDur
    FROM 
        APM.EVENT AS e
        JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
        JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)
        CROSS APPLY(SELECT TOP(1) pn1.SelfDuration, pn1.Description 
                        FROM 
                            APM.PerformanceNode AS pn1 
                        WHERE 
                            pn1.eventid = e.eventid 
                            AND pn1.resourceid = e.resourceid
                        ORDER BY
                            pn1.SelfDuration DESC) AS pn
        JOIN APM.Users AS u ON e.userid = u.userid
    WHERE
        E.UTCEVENTDATE &gt; @STARTDATE
        AND E.UTCEVENTDATE &lt; @ENDDATE
        AND E.EVENTDURATION / 1000000.0 &gt;= @THRESHOLD
        AND E.ASPECT = N'performance'
        AND COALESCE(E.HeavyLight, 1) &lt;&gt; 0
    GROUP BY
        e.sourceid, 
        pn.description,
        u.name
)
INSERT #SUMUSERANALYSIS 
SELECT 
    DESCRIPTION,
    USERID,
    USERFLAG,
    SOURCEID,
    EVENTCOUNT,
    USERSUMSLOWESTNODEDUR,
    USERCOUNTSLOWESTNODEDUR,
    SLOWESTNODEDUR,
    COUNTSLOWESTNODEDUR
FROM UsersInfo
CREATE INDEX temp1_idx ON  #SUMUSERANALYSIS(DESCRIPTION, SOURCEID) INCLUDE (USERID, EVENTCOUNT, SLOWESTNODEDUR)
-- Select information for current user
;WITH OrderedDataSet AS
(
    SELECT 
        u.DESCRIPTION,
        u.SOURCEID,      
        u.EVENTCOUNT,
        CASE 
            WHEN u.USERCOUNTSLOWESTNODEDUR &lt;&gt;0 THEN u.USERSUMSLOWESTNODEDUR / (u.USERCOUNTSLOWESTNODEDUR * 1000)
            ELSE 0
        END AS SlowestNodeDur
    FROM
        #SUMUSERANALYSIS AS u
    WHERE 
        u.USERFLAG = 1
),
--Select top 5 performance event for user
TopDataSet AS
(
   SELECT  TOP 5
     ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id, 
     1 AS UserId,   
     description,
     sourceId,
     EventCount,
     SlowestNodeDur,   
     EventCount AS SumEventCount,
     SUM(EventCount) OVER() AS TotalEventCount,
     0 AS UsersAffected
  FROM 
    OrderedDataSet
),
-- Calculate information for all users, but only for top 5 performence events 
EachUserInfo AS
(
    SELECT 
      f.Id,
      UserStat.DESCRIPTION,
      UserStat.SOURCEID,
      UserStat.EVENTCOUNT,
      UserStat.SLOWESTNODEDUR,
      UserStat.USERID
    FROM 
      #SUMUSERANALYSIS UserStat
      JOIN TopDataSet AS f ON (f.SOURCEID = UserStat.SOURCEID AND UserStat.DESCRIPTION = f.DESCRIPTION)
),
OtherUsersInfo AS
(
    SELECT 
        MAX(Id) AS Id,
        2 AS UserId,
        description,
        sourceId,
        AVG(EventCount * 1.0) AS EventCount,
        SUM(SlowestNodeDur)/1000.0/SUM(EventCount) AS SlowestNodeDur,
        0 AS SumEventCount,
        0 AS TotalEventCount,
        COUNT(DISTINCT COALESCE(userid,0)) AS UsersAffected
    FROM 
        EachUserInfo
    GROUP BY
        sourceId, 
        description
),
[Result] AS
(
  SELECT *
  FROM
    TopDataSet
  UNION
  SELECT *
  FROM
    OtherUsersInfo
)
SELECT 
    r.Id,
    r.UserId,
    r.description,
    s.Source,
    r.EventCount,
    r.SlowestNodeDur,
    r.SumEventCount,
    r.TotalEventCount,
    r.UsersAffected
FROM
    [Result] r
    JOIN APM.Source (NOLOCK) AS s ON s.SourceId = r.SourceId
ORDER BY 
    Id, UserId 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.TopUserExceptionIssues'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.TopUserExceptionIssues AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: TopUserExceptionIssues                                                     */
/* USED IN: Top5UserExceptionSubReport.rdl                                          */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/************************************************************************************/
ALTER PROCEDURE [APM].[TopUserExceptionIssues] 
(
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @USERNAME NVARCHAR(255),
    @PMSTATUS NVARCHAR(50)
) WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
  CREATE TABLE #SUMUSERANALYSIS 
  (
    DESCRIPTION nvarchar(255) collate database_default,
    USERID int,
    USERFLAG BIT,
    SOURCEID int,
    EVENTCOUNT int,
    SECURITYFAILURE int,
    APPLICATIONFAILURE int,
    CONNECTIVITYFAILURE int
  )
--Select information about events for all users
;WITH UsersInfo AS
(
    SELECT 
        e.DESCRIPTION AS DESCRIPTION,
        MIN(e.USERID) AS USERID,
        CASE u.Name WHEN @USERNAME THEN 1 ELSE 0 END AS USERFLAG,
        e.SOURCEID,
        COUNT(e.EVENTID) AS EVENTCOUNT,
        COUNT(CASE WHEN e.ASPECT = N'security' THEN  e.EVENTID END) AS SECURITYFAILURE,
        COUNT(CASE WHEN e.ASPECT = N'applicationfailure' THEN  e.EVENTID END) AS APPLICATIONFAILURE,
        COUNT(CASE WHEN e.ASPECT = N'connectivity' THEN  e.EVENTID END) AS CONNECTIVITYFAILURE
    FROM 
        APM.EVENT AS e
        --JOIN ExceptionNode AS en ON (en.eventid = e.eventid and en.resourceid = e.resourceid)
        JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
        JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)        
        JOIN APM.Users AS u ON e.USERID = u.USERID
    WHERE
        e.UTCEVENTDATE &gt; @STARTDATE
        AND e.UTCEVENTDATE &lt; @ENDDATE
        AND e.ASPECT IN ( N'security',N'applicationfailure',N'connectivity')
    GROUP BY
        e.SOURCEID, 
        e.DESCRIPTION,
        u.NAME
)
INSERT #SUMUSERANALYSIS 
SELECT 
    Description,
    UserId,
    UserFlag,
    SourceId,
    EventCount,
    SecurityFailure,
    ApplicationFailure,
    ConnectivityFailure
FROM UsersInfo
CREATE INDEX temp1_idx ON  #SUMUSERANALYSIS(DESCRIPTION, SOURCEID)
--  Select event information for current user only (condition UserFlag = 1 allows to filter event by current user)
;WITH OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY EVENTCOUNT DESC) AS ID,  
        DESCRIPTION,
        SOURCEID,
        EVENTCOUNT,
        SECURITYFAILURE,
        APPLICATIONFAILURE,
        CONNECTIVITYFAILURE,
        SUM(EVENTCOUNT) OVER() AS TOTALEVENTCOUNT
    FROM
        #SUMUSERANALYSIS AS u
    WHERE
        USERFLAG = 1
),
--Select top 5 exception events for current user
TopDataSet AS
(
    SELECT
        TOP(5)
        id,
        1 AS UserId,
        description,
        sourceId,
        EventCount,
        SecurityFailure,
        ApplicationFailure,
        ConnectivityFailure,
        EventCount AS SumEventCount,
        TotalEventCount,
        0 AS UsersAffected
    FROM 
        OrderedDataSet AS U
    ORDER BY Id
),
-- Select information about same exceptions for other users
EachUserInfo AS
(
    SELECT 
      f.ID,
      UserStat.DESCRIPTION,
      UserStat.SOURCEID,
      UserStat.EVENTCOUNT,
      UserStat.SECURITYFAILURE,
      UserStat.APPLICATIONFAILURE,
      UserStat.CONNECTIVITYFAILURE,
      UserStat.USERID
    FROM 
      #SUMUSERANALYSIS UserStat
      JOIN TopDataSet AS f ON (f.SOURCEID = UserStat.SOURCEID AND UserStat.DESCRIPTION = f.DESCRIPTION)
),
OtherUsersInfo AS
(
    SELECT 
        MAX(Id) AS Id,
        2 AS UserId,
        description,
        sourceId,
        AVG(EventCount * 1.0) AS EventCount,
        AVG(SecurityFailure * 1.0) AS SecurityFailure,
        AVG(ApplicationFailure * 1.0) AS ApplicationFailure,
        AVG(ConnectivityFailure * 1.0) AS ConnectivityFailure,
        0 AS SumEventCount,
        0 AS TotalEventCount,
        COUNT(DISTINCT COALESCE(userid,0)) AS UsersAffected
    FROM 
        EachUserInfo
    GROUP BY
        sourceId, 
        description
),
-- Unify information about current user and all users
[Result] AS (
SELECT *
FROM
    TopDataSet
UNION ALL
SELECT *
FROM
    OtherUsersInfo
)
SELECT 
  r.Id,
  r.UserId,
  r.description,
  s.Source,
  r.EventCount,
  r.SecurityFailure,
  r.ApplicationFailure,
  r.ConnectivityFailure,
  r.SumEventCount,
  r.TotalEventCount,
  r.UsersAffected
FROM 
  [Result] r
  JOIN apm.Source (NOLOCK) AS s ON s.SourceId = r.SourceId          
ORDER BY 
    Id, UserId 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReport                                           */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Request Count (temporary obsolete)                           */
/*                  2. Problems Count                                               */
/*                  3. Event Count                                                  */
/*                  4. MAX Event Duration                                           */
/*                  5. AVG Event Duration                                           */
/*                  6. Event Size                                                   */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50),
    @ORDERBY INT 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50),
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    e.SOURCEID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
	JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)     
WHERE 
    e.ClassType = N'Performance' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE
/****************************************************************************************************************/
/*                                          MAIN QUERY                                                          */
/****************************************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        E.CSEVENTID,
        SUM(COALESCE(ajax.REQUESTSIZE, 0))+ SUM(COALESCE(ajax.ResponseSize, 0)) AS AjaxSize, 
        -- This field will be used only for Asynch Ajax, and for Asycnch Ajax CSAJAX table 
        -- contains only one row for each event, so sum doesn't make any difference
        SUM(ajax.TotalTime) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
        
),
CSEvents AS
(
    SELECT 
        e.CSEVENTID,
        e.CSEVENTGROUPID,
        e.SOURCEID,
        js.CSEventId AS JavaScriptEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMAMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS AsyncAjaxEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMPMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS PageEventId,
        COALESCE(pe.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) AS EventDuration,
        COALESCE(pe.TotalSize, ajax.AjaxSize) AS EventSize
    FROM 
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON js.CSEventId  = e.CSEVENTID 
        LEFT OUTER JOIN AJAXEvents AS ajax (NOLOCK) ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.CSEventId = e.CSEVENTID
),
SourceStat AS
(
    SELECT 
        SourceId,
        COUNT(JavaScriptEventId) AS JavaScriptEventCount,
        COUNT(AsyncAjaxEventId) AS AsyncAjaxEventCount,
        COUNT(PageEventId) AS PageEventCount,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroupId) AS ProblemsCount,
        MAX(EventDuration) AS MAXEventDuration,
        AVG(EventDuration) AS AVGEventDuration,
        AVG(EventSize) AS EventSize
    FROM 
        CSEvents
    WHERE
        EventDuration / 1000.0 &gt;= @THRESHOLD
    GROUP BY
        SourceId
),
NumberedSources AS
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY
            WHEN 2 THEN e.ProblemsCount
            WHEN 3 THEN e.EventCount
            WHEN 4 THEN e.MAXEventDuration
            WHEN 5 THEN e.AVGEventDuration
            WHEN 6 THEN e.EventSize
        END) DESC) Id, 
        e.SourceId,
        s.Source,
        e.JavaScriptEventCount,
        e.AsyncAjaxEventCount,
        e.PageEventCount,
        e.EventCount,
        e.ProblemsCount,
        e.MAXEventDuration/1000.0 AS MAXEventDuration,
        e.AVGEventDuration/1000.0 AS AVGEventDuration,
        -- Temporary obsolete field, return appropriate value, than it will be returned
        1 AS requestCount,
        e.EventSize/1024.0 AS EventSize,
        SUM(e.EventCount) OVER() AS TotalEventCount
    FROM
        SourceStat AS e
        JOIN APM.Source AS s (NOLOCK) ON e.SourceId = s.SourceId
)
SELECT TOP (10) *
FROM
    NumberedSources
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReportMaxScale'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReportMaxScale AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReportMaxScale                                   */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReportMaxScale 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @THRESHOLD INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50) COLLATE database_default,
    SOURCEID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    e.SOURCEID,
    e.PAGEURI
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.IPID = f3.IPID
	JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMSTATUS)     
WHERE 
    e.CLASSTYPE = N'Performance'
    AND e.PAGEURI IS NOT NULL 
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
;WITH JSAndAJAXEvent AS
(
    SELECT  
        e.CSEVENTID,
        e.SOURCEID,
        e.PAGEURI,
        COALESCE(js.TotalTime, ajax.TotalTime) AS EventDuration,
        COALESCE(js.Action, ajax.Uri) AS Action
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEVENTID = e.CSEVENTID
        LEFT OUTER JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEVENTID = e.CSEVENTID
    WHERE
        EVENTCLASS = N'CSMAMonitorLog'  
        AND COALESCE(js.TotalTime, ajax.TOTALTIME)/1000.0 &gt;= @THRESHOLD
),
-- As main query shows only top 10 sources,
-- this should be take into account for choosing max durations
SourceFilter AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY COUNT(e.CSEVENTID) DESC) AS SourceRowNumber,
        e.SOURCEID
    FROM
        #CLIENTEVENT AS e
    GROUP BY 
        e.SOURCEID
),
JSAndAJAXEventsDuration AS
(
    SELECT 
        ROW_NUMBER() OVER(PARTITION BY E.SourceId ORDER BY COUNT(e.CSEventId) DESC) AS Id,
        e.SOURCEID, 
        e.PAGEURI,
        e.Action,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(EventDuration) AS EventDuration
    FROM
        JSAndAJAXEvent AS e
        JOIN SourceFilter AS s ON s.SOURCEID = e.SOURCEID
    WHERE
        s.SourceRowNumber &lt;= 10
    GROUP BY
        e.SOURCEID, 
        e.PAGEURI,
        e.Action
),
PageEvent AS
(
    SELECT ROW_NUMBER() OVER(PARTITION BY e.SOURCEID ORDER BY COUNT(e.CSEVENTID) DESC) AS Id,
        e.SOURCEID,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(pe.TOTALTIME) AS EventDuration,
        e.PAGEURI
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.CSEVENTID = e.CSEVENTID 
        JOIN SourceFilter AS s ON s.SOURCEID = e.SOURCEID
    WHERE
        pe.TOTALTIME/1000.0 &gt;=@THRESHOLD
        AND s.SourceRowNumber &lt;= 10
    GROUP BY
        e.SOURCEID,
        e.PAGEURI
)
SELECT
(   
    SELECT 
        COALESCE(MAX(EventDuration),0)/1000.0 
    FROM
        PageEvent
    WHERE
        Id &lt;= 5
)AS MaxPageEventDuration,
(   
    SELECT 
        COALESCE(MAX(EventDuration),0)/1000.0 
    FROM
        JSAndAJAXEventsDuration
    WHERE
        Id &lt;= 5
)AS MaxJSEventDuration
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNet'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNet AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNet                                              */
/* USED IN: Load Time Analysis Based On Subnet as main data set query               */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Request Count (temporary obsolete)                           */
/*                  2. Problems Count                                               */
/*                  4. Avg Event Duration                                           */
/*                  5. Latency                                                      */
/************************************************************************************/
ALTER PROCEDURE APM.LoadTimeAnalysisBasedOnSubNet 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default 
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    IPID,
    SUBNETC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SUBNETC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SUBNETC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50)  COLLATE database_default ,
    SUBNETC NVARCHAR(50)  COLLATE database_default 
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    f2.SUBNETC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.IPID = f2.IPID
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)     
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.PAGEURI IS NOT NULL
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
;WITH AJAXEvent AS
(
    SELECT
        e.CSEVENTID,
        e.SUBNETC,
        ajax.Synchronous,
        SUM(ajax.NetworkTime) AS NetworkTime,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.ResponseTime) AS ResponseTime,
        AVG(ajax.Latency) AS Latency,
        SUM(ajax.TotalTime) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEventId = e.CSEVENTID
    GROUP BY
        e.CSEVENTID,
        e.SUBNETC,
        ajax.Synchronous
),
ClientEvents AS
(
    SELECT
        e.SUBNETC,
        e.CSEVENTID,
        e.CSEVENTGROUPID,
        -- if JScript table has corresponding row (not null value), than consider it is java script event
        js.CSEventId AS JavaScriptEventId,
        -- If it is not JavaScript event, then define its type by event class type
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMAMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS AsyncAjaxEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMPMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS PageEventId,
        -- Define duration by joined table. As Page Event, Asynch Ajax and Java script 
        -- events are mutually exclusive it can be done as folllows
        COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) AS EventDuration,
        p.NetworkTime AS PageLoadNetworkTime,
        p.ServerTime AS PageLoadServerTime,
        p.DOMTime AS PageDOMLoad,
        p.PeripheralTime AS PagePeripheralTime,
        p.OnLoadTime AS PageOnLoadTime,
        p.TotalTime AS PageEventTime,
        (ajax.NetworkTime + ajax.ResponseTime) AS AjaxNetworkTime,
        ajax.ServerTime AS AjaxServerTime,
        -- If event is asynch ajax, then there is no corresponding row in JavaScript table,
        -- If it is synch ajax, then its total duration should be taken from java script total time
        COALESCE(js.TotalTime, ajax.TotalTime) AS AjaxTotalTime,
        -- Client time should be calculated as total time, minus network, server and response time,
        -- But total time should be taken not from ajax table, it is depend on event type 
        COALESCE(js.TotalTime, ajax.TotalTime) 
                -- For AJAX event ther could by no corresponding row in AJAX table, then all time consider to be Client
                - COALESCE(ajax.NetworkTime + ajax.ResponseTime + ajax.ServerTime, 0) AS AjaxClientTime,
        --Latency belongs either to page event or to Ajax event
        COALESCE(p.Latency, ajax.Latency) AS Latency,
        COUNT(e.CSEVENTID) OVER() AS TotalEventCount
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN AJAXEvent AS ajax ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPageEvent AS p (NOLOCK) ON P.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEventId = e.CSEVENTID
    WHERE
        COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) / 1000.0 &gt;= @THRESHOLD
),
-- Aggregate data for each subnet
SubnetSummary AS
(
    SELECT
        SubnetC,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroupId) AS ProblemCount,
        -- For counting events by types, use that COUNT does not calculates null values     
        COUNT(JavaScriptEventId) AS JSEventCount,
        COUNT(AsyncAjaxEventId) AS AsynchAjaxEvent,
        COUNT(PageEventId) AS PageEventCount,
        AVG(PageLoadNetworkTime)/1000.0 AS PageLoadNetworkTime,
        AVG(PageLoadServerTime)/1000.0 AS PageLoadServerTime,
        AVG(PageDOMLoad)/1000.0 AS PageDOMLoad,
        AVG(PagePeripheralTime)/1000.0 AS PagePeripheralTime,
        AVG(PageOnLoadTime)/1000.0 AS PageOnLoadTime,
        AVG(Latency) AS Latency,
        AVG(AjaxNetworkTime)/1000.0 AS AjaxNetworkTime,
        AVG(AjaxServerTime)/1000.0 AS AjaxServerTime,
        AVG(AjaxClientTime)/1000.0 AS ClientTime,
        AVG(EventDuration)/1000.0 AS AvgEventDuration,
        -- This aggregation has no difference as it is same for all rows
        MAX(TotalEventCount) AS TotalEventCount
    FROM
        ClientEvents
    GROUP BY
        SubnetC
)
    SELECT TOP(20)
        row_number() OVER(ORDER BY (CASE @ORDERBY
            WHEN 1 THEN ProblemCount
            WHEN 2 THEN EventCount
            WHEN 3 THEN coalesce(PageLoadServerTime, 0) + coalesce(AjaxServerTime, 0)
            WHEN 4 THEN AvgEventDuration
            WHEN 5 THEN Latency
        END) DESC) Id,  
        SubnetC,
        EventCount,
        ProblemCount,
        PageEventCount,
        JSEventCount,
        AsynchAjaxEvent,
        PageLoadNetworkTime,
        PageLoadServerTime,
        PageDOMLoad,
        PagePeripheralTime,
        PageOnLoadTime,
        AjaxNetworkTime,
        AjaxServerTime,
        ClientTime,
        Latency,
        AvgEventDuration,
        TotalEventCount
    FROM 
        SubnetSummary
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetMaxScale'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetMaxScale AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNet                                              */
/* USED IN: Load Time Analysis Based On Subnet for calculating max value in         */
/*          subreports, to make one scaling for all sub reports                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/************************************************************************************/
alter PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetMaxScale 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #IPFILTER
(
    IPID INT
)
INSERT INTO #IPFILTER
SELECT DISTINCT
    ipid
FROM
    apm.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
    
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    EVENTCLASS NVARCHAR(50) COLLATE database_default,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.EVENTCLASS,
    e.PAGEURI,
    ip.SUBNETC
FROM
-- Max values should be selected not only for appropriate subnetc, but for all
-- (as in subreports, relative values to other is shown). So filtering by subnets could not be hold here
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #IPFILTER AS f2 ON (e.IPID = f2.IPID)
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)
    JOIN APM.IP AS ip (NOLOCK) ON ip.IPID = e.IPID
    
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.PAGEURI IS NOT NULL
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    SUBNETC NVARCHAR(50) COLLATE database_default   
)
-- In report shown only top 20 subnets by event count
-- Besides, user specifies filter by subnet, so select subnets, for which MAX should be selected
INSERT INTO #SUBNETCFILTERTABLE
SELECT
    TOP(20)
    e.SUBNETC
FROM
    #CLIENTEVENT AS e
GROUP BY
    e.SUBNETC
ORDER BY
    COUNT(e.CSEVENTID) DESC
/****************************************************************************************/
/*                              MAIN QUERIES                                            */
/****************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        e.CSEVENTID,
        -- This field need only for asynch ajax events, and for this type here can by only one row,
        -- so aggregation doesn't matter
        MAX(ajax.URI) AS AjaxAction,
        SUM(ajax.TOTALTIME) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEVENTID = e.CSEVENTID
    WHERE
        e.EVENTCLASS = N'CSMAMonitorLog' OR e.EVENTCLASS = N'CSMSMonitorLog'
    GROUP BY
        e.CSEVENTID
),
JSEvents AS
(
    SELECT
        e.CSEVENTID,
        e.SUBNETC,
        e.PAGEURI,
        COALESCE(js.ACTION, ajax.AjaxAction) AS Action,
        COALESCE(js.TOTALTIME, ajax.TotalTime) AS EventDuration,
--Calculate average event duration for all subnets
        AVG(COALESCE(js.TOTALTIME, ajax.TotalTime)) OVER(PARTITION BY e.PAGEURI,
                                COALESCE(js.Action, ajax.AjaxAction)) AS CommonDuration
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEVENTID = e.CSEVENTID
        LEFT OUTER JOIN AJAXEvents AS ajax ON ajax.CSEVENTID = e.CSEVENTID      
    WHERE
        e.EVENTCLASS = N'CSMAMonitorLog' OR e.EVENTCLASS = N'CSMSMonitorLog'
),
JSActionsForSubnets AS 
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY js.SUBNETC ORDER BY COUNT(CSEVENTID) DESC) AS Id,
        COUNT(CSEVENTID) AS EventCount, 
        js.SUBNETC,
        Action,
        PAGEURI,
        MAX(CommonDuration) AS CommonDuration,
        AVG(EventDuration) AS AvgActionDuration
    FROM
        JSEvents AS js
        JOIN #SUBNETCFILTERTABLE AS f ON f.SUBNETC = js.SUBNETC
    GROUP BY
        js.SUBNETC,
        PageUri,
        Action  
),
PageEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC,
        p.TOTALTIME,
        --Calculate Average page load duration for all subnets
        AVG(p.TOTALTIME) OVER(PARTITION BY e.PAGEURI) AS PageAvgDuration
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
),
PageEventsForSubNets AS
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY e.SUBNETC ORDER BY COUNT(e.CSEVENTID) DESC) AS Id,
        e.SUBNETC,
        e.PAGEURI,
        AVG(e.TOTALTIME) AS PageAvgSubNetDuration,
        MAX(e.PageAvgDuration) AS PageAvgDuration
    FROM
        PageEvents AS e
        JOIN #SUBNETCFILTERTABLE AS f ON f.SUBNETC = e.SUBNETC
    GROUP BY
        e.SUBNETC,
        e.PAGEURI           
)
SELECT
    (SELECT COALESCE(MAX(CASE WHEN CommonDuration &gt;= AvgActionDuration THEN CommonDuration ELSE AvgActionDuration END)/1000.0, 0)
        FROM
            JSActionsForSubnets
        WHERE Id &lt;= 5) AS MaxAjaxDuration,
    (SELECT COALESCE(MAX(CASE WHEN PageAvgDuration &gt;= PageAvgSubNetDuration THEN PageAvgDuration ELSE PageAvgSubNetDuration END)/1000.0, 0)
        FROM
            PageEventsForSubNets
        WHERE Id &lt;= 5) AS MaxPageLoadDuration
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls                             */
/* USED IN: Load Time Analysis Based On Subnet for Top JS ajax calls subreport      */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - SubnetC for which data should be selected                        */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
alter PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SUBNETC NVARCHAR(25),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #CLIENTEVENTFORALLSUBNETS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    SUBNETC NVARCHAR(50) collate database_default
)
-- Filter Event Table by incoming parameters
-- Filtering by SubnetC is not made here, as relative time information 
-- for all other sources should be also calculated
INSERT INTO #CLIENTEVENTFORALLSUBNETS
SELECT
    e.CSEventId,
    e.PageUri,
    ip.SubNetC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMStatus)     
    JOIN APM.IP (NOLOCK) ON ip.ipid = e.ipid
WHERE 
    e.SourceId = @SOURCEID
--Select only Asynch AJAX and JS events
    AND (e.EventClass = N'CSMAMonitorLog' OR e.EventClass = N'CSMSMonitorLog')
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
    AND PageUri IS NOT NULL
-- Events should be selected only for that pages, which are actual for specified @SUBNETC
-- If for the @SUBNETC there is no one event for some page, events for this page should not be selected at all
CREATE TABLE #CLIENTEVENTFILTEREDBYPAGEURI 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
INSERT INTO #CLIENTEVENTFILTEREDBYPAGEURI
SELECT 
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC
    FROM 
        #CLIENTEVENTFORALLSUBNETS AS e
    WHERE 
        e.SUBNETC = @SUBNETC
        AND e.PAGEURI IN (SELECT
                                e1.PAGEURI 
                        FROM 
                            #CLIENTEVENTFORALLSUBNETS AS e1 
                        WHERE 
                            e1.SUBNETC = @SUBNETC
                        )
/********************************************************************************************************/
/*                              MAIN  QUERY                                                             */
/********************************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC,
        -- This field need only for asynch ajax events, and for this type here can by only one row,
        -- so aggregation doesn't matter
        MAX(ajax.Uri) AS AjaxAction,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.NetworkTime + ajax.ResponseTime) AS NetworkTime,
        SUM(ajax.TotalTime) AS TotalTime,
        SUM(COALESCE(ajax.REQUESTSIZE, 0) + COALESCE(ajax.ResponseSize, 0)) AS CallSize
    FROM
        #CLIENTEVENTFILTEREDBYPAGEURI AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID,
        e.PAGEURI,      
        e.SUBNETC
),
CSJSEvents AS
(
    SELECT
        e.PAGEURI,
        e.SUBNETC,
        e.CSEVENTID,
        COALESCE(js.Action, ajax.AjaxAction) AS AjaxAction,
        COALESCE(js.TotalTime, ajax.TotalTime)/1000.0 AS TotalTime,
        COALESCE(ajax.NetworkTime, 0)/1000.0 AS NetworkTime,
        COALESCE(ajax.ServerTime, 0)/1000.0 AS ServerTime,
        -- don't change size to 0, as average size should be calculated only for ajax calls, not all events
        ajax.CallSize/1024.0 AS CallSize
    FROM
        #CLIENTEVENTFILTEREDBYPAGEURI AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEventid = e.CSEVENTID
        LEFT OUTER JOIN AJAXEvents AS ajax (NOLOCK) ON ajax.CSEventid = e.CSEVENTID
    WHERE 
        -- Threshold condition should be applied only for Asynch Ajax Events,
        -- For Synch Ajax this condition is applied to JS event
        COALESCE(js.TotalTime, ajax.TotalTime)/1000.0 &gt;= @THRESHOLD
),
AJAXActionInfo AS
(
    SELECT
        PageUri,
        AjaxAction,
        COUNT(CASE WHEN Subnetc = @SUBNETC THEN CSEventId END) AS EventCount,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN NetworkTime END) AS NetworkTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN ServerTime END) AS ServerTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN TotalTime - (NetworkTime + ServerTime) END) AS ClientTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN TotalTime END) AS TotalTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN CallSize END) AS AJAXCallSize,
        AVG(NetworkTime) AS CommonNetworkTime,
        AVG(ServerTime) AS CommonServerTime,
        AVG(TotalTime - (NetworkTime + ServerTime)) AS CommonClientTime,
        AVG(TotalTime) AS CommonTotalTime
    FROM
        CSJSEvents
    GROUP BY
        PageUri,
        AjaxAction
),
OrderedActions AS
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id,
        EventCount,
        AjaxAction,
        pageUri,
        ClientTime,
        NetworkTime,
        ServerTime,
        TotalTime,
        CommonClientTime,
        CommonNetworkTime,
        CommonServerTime,
        CommonTotalTime,
        AJAXCallSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        AJAXActionInfo
)
--Second row is used to show relative AJAX execution time for other subnets
SELECT 
    d.id,
    rowId.n AS rowId,
    d.pageUri,
    d.AjaxAction,
    (CASE WHEN rowId.n = 1 THEN d.EventCount ELSE 0 END )AS EventCount,
    (CASE WHEN rowId.n = 1 THEN d.ClientTime ELSE d.CommonClientTime END )AS ClientTime,
    (CASE WHEN rowId.n = 1 THEN d.NetworkTime ELSE d.CommonNetworkTime END )AS NetworkTime,
    (CASE WHEN rowId.n = 1 THEN d.ServerTime ELSE d.CommonServerTime END )AS ServerTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalTime ELSE d.CommonTotalTime END) AS TotalTime,
    (CASE WHEN rowId.n = 1 THEN d.AJAXCallSize ELSE 0 END )AS AJAXCallSize,
    (CASE WHEN rowId.n = 1 THEN d.TotalEvents ELSE 0 END )AS TotalEvents
FROM
    APM.fn_nums(2) AS rowId,
    OrderedActions AS d
WHERE
    d.id &lt;= 5
ORDER BY 
    id, 
    rowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNetTopPages                                      */
/* USED IN: Load Time Analysis Based On Subnet for Top pages subreport              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - SubnetC for which data should be selected                        */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SUBNETC NVARCHAR(25),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
    
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
CREATE TABLE #CLIENTEVENTFORALLSUBNETS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Filter Event Table by incoming parameters
-- Filtering by SubnetC is not made here, as relative time information 
-- for all other sources should be also calculated
INSERT INTO #CLIENTEVENTFORALLSUBNETS
SELECT
    e.CSEventId,
    e.PageUri,
    ip.SubNetC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMStatus)     
    JOIN APM.IP (NOLOCK) ON ip.ipid = e.ipid
WHERE 
    e.SourceId = @SOURCEID
    AND e.EventClass = N'CSMPMonitorLog' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
    AND PageUri IS NOT NULL
    
-- Events should be selected only for that pages, which are actual for specified @SUBNETC
-- If for the @SUBNETC there is no one event for some page, events for this page should not be selected at all
;WITH CSPageEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        pe.NetworkTime,
        pe.ServerTime,
        pe.DOMTime,
        pe.PeripheralTime,
        pe.OnLoadTime,
        pe.TotalTime,
        pe.TotalSize,
        e.SUBNETC
    FROM
        #CLIENTEVENTFORALLSUBNETS (NOLOCK) AS e
        JOIN APM.CSPageEvent AS pe ON pe.cseventid = e.CSEVENTID
    WHERE 
        e.PAGEURI IN (SELECT DISTINCT 
                                e1.PAGEURI 
                            FROM 
                                #CLIENTEVENTFORALLSUBNETS AS e1 
                            WHERE 
                                e1.SUBNETC = @SUBNETC
                        )
        AND pe.TotalTime/1000.0 &gt; @THRESHOLD
),
PageProcessingTime AS
(
    SELECT 
        PageUri,
        COUNT(CASE WHEN Subnetc = @SUBNETC THEN CSEVENTID END) AS EventCount,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(NetworkTime, 0) END)/1000 AS NetworkTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(ServerTime, 0) END)/1000 AS ServerTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(DOMTime, 0) END)/1000 AS DOMTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(PeripheralTime, 0) END)/1000 AS PeripheralTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(OnLoadTime, 0) END)/1000 AS OnLoadTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(TotalTime, 0) END)/1000 AS TotalTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(TotalSize, 0) END)/1024.0 AS TotalSize,
        AVG(NetworkTime)/1000 AS CommonNetworkTime,
        AVG(ServerTime)/1000 AS CommonServerTime,
        AVG(DOMTime)/1000 AS CommonDOMTime,
        AVG(PeripheralTime)/1000 AS CommonPeripheralTime,
        AVG(OnLoadTime)/1000 AS CommonOnLoadTime,
        AVG(TotalTime)/1000 AS CommonTotalTime
    FROM 
        CSPageEvents
    GROUP BY
        PageUri  
),
NumberedPages AS
(
    SELECT 
        row_number() OVER(ORDER BY EventCount DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        CommonNetworkTime,
        CommonServerTime,
        CommonDOMTime,
        CommonPeripheralTime,
        CommonOnLoadTime,
        CommonTotalTime,
        SUM(EventCount) OVER() AS TotalEvents   
    FROM 
        PageProcessingTime  
),
OneRowData AS
(
    SELECT
        TOP(5)
            id,
            PageUri,
            EventCount,
            NetworkTime,
            ServerTime,
            DOMTime,
            PeripheralTime,
            OnLoadTime,
            TotalTime,
            TotalSize,
            CommonNetworkTime,
            CommonServerTime,
            CommonDOMTime,
            CommonPeripheralTime,
            CommonOnLoadTime,
            (COALESCE(CommonNetworkTime, 0) + COALESCE(CommonServerTime, 0)+ COALESCE(CommonDOMTime, 0) + COALESCE(CommonPeripheralTime, 0) + COALESCE(CommonOnLoadTime, 0)) AS CommonTotalTime,
            TotalEvents
        FROM 
            NumberedPages   
        WHERE 
            EventCount &gt; 0
        ORDER BY id
)
--Second row is used to show relative Page Load time for other subnets
SELECT 
    d.id,
    rowId.n AS rowId,
    d.PageUri,
    (CASE WHEN rowId.n = 1 THEN d.EventCount ELSE 0 END )AS EventCount,
    (CASE WHEN rowId.n = 1 THEN d.NetworkTime ELSE d.CommonNetworkTime END )AS NetworkTime,
    (CASE WHEN rowId.n = 1 THEN d.ServerTime ELSE d.CommonServerTime END )AS ServerTime,
    (CASE WHEN rowId.n = 1 THEN d.DOMTime ELSE d.CommonDOMTime END )AS DOMTime,
    (CASE WHEN rowId.n = 1 THEN d.PeripheralTime ELSE d.CommonPeripheralTime END )AS PeripheralTime,
    (CASE WHEN rowId.n = 1 THEN d.OnLoadTime ELSE d.CommonOnLoadTime END )AS OnLoadTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalTime ELSE d.CommonTotalTime END )AS TotalTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalSize ELSE d.TotalSize END )AS TotalSize,
    (CASE WHEN rowId.n = 1 THEN d.TotalEvents ELSE d.TotalEvents END )AS TotalEvents,
    --Get ajax call flag
    CASE WHEN EXISTS(
            SELECT * 
                FROM #CLIENTEVENTFORALLSUBNETS c
                     JOIN APM.CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                       
                WHERE d.PageUri = c.PAGEURI
        ) THEN '*' ELSE ''
    END AS Extension
FROM
    APM.fn_nums(2) AS rowId,
    OneRowData AS d
ORDER BY 
    id, 
    rowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientLatencyDistributionBySources'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientLatencyDistributionBySources AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:ClientLatencyDistributionBySources                                          */
/* USED IN: Client Latency Distribution for summary table by sources                */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - List subnet type C, selected by user                             */
/*      @ORDERBY - Specifies latency range to which ordering should be applied      */
/************************************************************************************/
ALTER PROCEDURE APM.ClientLatencyDistributionBySources 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    ip.SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEventId,
    e.SourceId
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
    JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus) 
WHERE 
    e.ClassType = N'Performance' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
CREATE TABLE #LATENCIES 
(
    ID INT,
    MIN INT,
    MAX INT 
)
INSERT INTO #LATENCIES VALUES (1, 0, 100)
INSERT INTO #LATENCIES VALUES (2, 101, 300)
INSERT INTO #LATENCIES VALUES (3, 301, 600)
INSERT INTO #LATENCIES VALUES (4, 601, 1000)
INSERT INTO #LATENCIES VALUES (5, 1001, 2000)
INSERT INTO #LATENCIES VALUES (6, 2001, 99999999)
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        ajax.TotalTime AS TotalTime,
        ajax.Latency AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
),
JSEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        js.TotalTime AS TotalTime,
        NULL AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON e.CSEVENTID = js.CSEventId
),
PageEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        p.TotalTime AS TotalTime,
        p.Latency AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPAGEEVENT AS p (NOLOCK) ON e.CSEVENTID = p.CSEventId
),
UnionEvents AS
(
    SELECT * from AJAXEvents
    UNION ALL
    SELECT * from JSEvents
    UNION ALL
    SELECT * from PageEvents
),
EventAggregation AS
(
    SELECT 
        SourceId,
        MAX(TotalTime) / 1000.0 AS TotalTime,
        AVG(Latency) AS Latency
    FROM UnionEvents
    GROUP BY 
        CSEventId, SourceId
),
NumberedDataSet AS 
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY COUNT(CASE
                WHEN @ORDERBY = 1 AND L.ID = 1 THEN 1
                WHEN @ORDERBY = 2 AND L.ID = 2 THEN 1
                WHEN @ORDERBY = 3 AND L.ID = 3 THEN 1
                WHEN @ORDERBY = 4 AND L.ID = 4 THEN 1
                WHEN @ORDERBY = 5 AND L.ID = 5 THEN 1
                WHEN @ORDERBY = 6 THEN 1
            END) DESC) AS Id, 
        SourceId,
        COUNT(CASE WHEN L.ID = 1 THEN 1 END) AS EventCount1,
        COUNT(CASE WHEN L.ID = 2 THEN 1 END) AS EventCount2,
        COUNT(CASE WHEN L.ID = 3 THEN 1 END) AS EventCount3,
        COUNT(CASE WHEN L.ID = 4 THEN 1 END) AS EventCount4,
        COUNT(CASE WHEN L.ID = 5 THEN 1 END) AS EventCount5,
        COUNT(CASE WHEN L.ID = 6 THEN 1 END) AS EventCount6,
        AVG(CASE WHEN L.ID = 1 THEN TotalTime END) AS EventDuration1,
        AVG(CASE WHEN L.ID = 2 THEN TotalTime END) AS EventDuration2,
        AVG(CASE WHEN L.ID = 3 THEN TotalTime END) AS EventDuration3,
        AVG(CASE WHEN L.ID = 4 THEN TotalTime END) AS EventDuration4,
        AVG(CASE WHEN L.ID = 5 THEN TotalTime END) AS EventDuration5,
        COUNT(*) AS EventCount
    FROM EventAggregation AS EA 
    JOIN #LATENCIES AS L ON COALESCE(EA.Latency, 99999999) &gt;= L.MIN AND COALESCE(EA.Latency, 99999999) &lt;= L.MAX
    GROUP BY SourceId
)
--Select each range info into separate row to provide better view in report charts
    SELECT 
        sr.Id,
        r.n AS LatencyRange,
        sr.EventCount,
        s.Source,   
        sr.SourceId,
        (CASE WHEN r.n = 1 THEN sr.EventCount1 END) AS EventCount1,
        (CASE WHEN r.n = 2 THEN sr.EventCount2 END) AS EventCount2,
        (CASE WHEN r.n = 3 THEN sr.EventCount3 END) AS EventCount3,
        (CASE WHEN r.n = 4 THEN sr.EventCount4 END) AS EventCount4,
        (CASE WHEN r.n = 5 THEN sr.EventCount5 END) AS EventCount5,
        (CASE WHEN r.n = 1 THEN COALESCE(sr.EventDuration1, 0) END) AS EventDuration1,
        (CASE WHEN r.n = 2 THEN COALESCE(sr.EventDuration2, 0) END) AS EventDuration2,
        (CASE WHEN r.n = 3 THEN COALESCE(sr.EventDuration3, 0) END) AS EventDuration3,
        (CASE WHEN r.n = 4 THEN COALESCE(sr.EventDuration4, 0) END) AS EventDuration4,
        (CASE WHEN r.n = 5 THEN COALESCE(sr.EventDuration5, 0) END) AS EventDuration5
    FROM
        NumberedDataSet AS sr
        JOIN APM.Source AS s (NOLOCK) ON sr.SourceId = s.SourceId,
        APM.fn_nums(5) AS r
    ORDER BY 
        sr.Id,
        r.n
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientLatencyDistributionSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientLatencyDistributionSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:ClientLatencyDistributionSubReport                                          */
/* USED IN: Client Latency Distribution for sub report                              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Id of the source                                                */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - List subnet type C, selected by user                             */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Event Count                                                  */
/*                  2. Problems Count                                               */
/*                  4. Event Duration                                               */
/*                  5. Latency                                                      */
/************************************************************************************/
ALTER PROCEDURE APM.ClientLatencyDistributionSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
 WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value for machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT
    ipid,
    ip.SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    SUBNETC NVARCHAR(50) collate database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEventId,
    e.CSEventGroupId,
    f3.SUBNETC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f1 ON f1.VALUEID = e.MachineId 
	JOIN #PMSTATUSFILTERTABLE AS f2 ON (f2.VALUEID = e.PMStatus)     
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
WHERE 
    e.ClassType = N'Performance' 
    AND e.SourceId = @SOURCEID
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
-- Aggregate AJAX by event id, as several synchronous ajax call can belong to one event
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
         -- Aggregation by Total Time make no difference, as for synch ajaxes total time will
         -- be taken from JS event, and for asynch AJAX here can be only one row
        AVG(ajax.TotalTime) AS TotalTime,
        -- For synch ajax select average latency among calls, for asynch here will be only one row
        AVG(ajax.Latency) AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
),
-- For each subnet choose its average latency and event duration
SubNetCStatistics AS
(
    SELECT
        e.SUBNETC,
        COUNT(e.CSEVENTID) AS EventCount,
        COUNT(DISTINCT e.CSEVENTGROUPID) AS ProblemCount,
        -- Event could by either Page or JavaScript or Asycnh Ajax. Row in AJAX table will be presented for both synch and asynch ajaxes,
        -- But for synch AJAXes only latency should by taken and Total Time should by taken from either Page event or Jscript event        
        AVG(COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)))/1000.0 AS EventDuration,
         --Latency could be either in page event or in Ajax event
        AVG(COALESCE(p.Latency, ajax.Latency)) AS Latency
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN AJAXEvents AS ajax ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON e.CSEVENTID = js.CSEventId     
    GROUP BY 
        e.SUBNETC
)
-- Select top 5 rows, ordered by specified parameter @ORDERBY
SELECT TOP(5)
    ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY
        WHEN 1 THEN EventCount
        WHEN 2 THEN ProblemCount
        WHEN 3 THEN EventDuration
        WHEN 4 THEN Latency
    END) DESC) AS Id,
    SubNetC AS Client,
    EventCount,
    ProblemCount,
    EventDuration,
    Latency
FROM
    SubNetCStatistics
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisJScriptWithAjaxCalls'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisJScriptWithAjaxCalls AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisJScriptWithAjaxCalls                                    */
/* USED IN: Application Analysis report for TOP slowest Ajax, top slowest JS,       */
/*          TOP largest AJAX                                                        */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY1 - Specifies field to which sorting for largest AJAX calls         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Request Size                                             */
/*                      3. Response Size                                            */
/*                      4. Total Size                                               */
/*                      5. Total Time                                               */
/*      @ORDERBY2 - Specifies field to which sorting for slowest AJAX calls         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Client Time                                              */
/*                      3. Network Time                                             */
/*                      4. Server Time                                              */
/*                      5. Total Time                                               */
/*                      6. Request Size                                             */
/*                      7. Response Size                                            */
/*                      8. Latency                                                  */  
/*      @ORDERBY3 - Specifies field to which sorting for slowest JavaScript         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. AJAX Call Count                                          */
/*                      3. Client Time                                              */
/*                      4. Network Time                                             */
/*                      5. Server Time                                              */
/*                      6. Total Time                                               */
/*                      7. Avg Event Size                                           */
/*                      8. Latency                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisJScriptWithAjaxCalls 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY1 INT,
    @ORDERBY2 INT,
    @ORDERBY3 INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) collate database_default   
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    SubNetC
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    CLASSTYPE NVARCHAR(50) COLLATE database_default,
    CSEVENTGROUPID INT
)
INSERT INTO #CLIENTEVENTS
SELECT
    e.CSEventId,    
    e.PageUri,
    e.ClassType,
    e.CSEventGroupId
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
    JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus) 
WHERE 
    e.sourceId = @SOURCEID
    AND PageUri IS NOT NULL
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE
    AND e.EventClass &lt;&gt; N'CSMPMonitorLog'
CREATE TABLE #AJAXCALLS
(
        ID INT,
        CSEVENTID INT,
        PAGEURI NVARCHAR(255) COLLATE database_default,
        AJAXACTION NVARCHAR(255) COLLATE database_default,
        TOTALTIME DECIMAL(35, 0),
        NETWORKTIME DECIMAL(35, 0),
        SERVERTIME DECIMAL(35, 0),
        RESPONSETIME DECIMAL(35, 0),
        REQUESTSIZE DECIMAL(35, 0),
        RESPONSESIZE DECIMAL(35, 0),
        LATENCY BIGINT,
        TOTALAJAXCALLCOUNT INT,
        AVGAJAXCALLDURATION FLOAT,
        SYNCHRONOUS BIT
)
-- Several synchronous Ajax calls could belong to one event, in that case only heaviest (by Total duration) should be taken.
-- Numerate Ajax calls for each event by Total Time in descending order.
-- Next step is to take ajax calls with id equal to 1.
-- For asynch ajaxes all rows will be with id = 1
;WITH AjaxCallsInternal AS 
(
    SELECT 
        ROW_NUMBER() OVER(PARTITION BY E.CSEVENTID ORDER BY ajax.TOTALTIME DESC, ajax.CSAJAXId) AS Id,
        e.CSEVENTID,
        e.PAGEURI,
        ajax.URI,
        COALESCE(ajax.TOTALTIME, 0) AS TotalTime,
        COALESCE(ajax.NETWORKTIME, 0) AS NetworkTime,
        COALESCE(ajax.SERVERTIME, 0) AS ServerTime,
        COALESCE(ajax.RESPONSETIME, 0) AS ResponseTime,
        COALESCE(ajax.REQUESTSIZE, 0) AS RequestSize,
        COALESCE(ajax.RESPONSESIZE, 0) AS ResponseSize,
        ajax.LATENCY,
        COUNT(CSAJAXId) OVER(PARTITION BY e.CSEVENTID) AS TotalAjaxCallCount,
        ajax.SYNCHRONOUS
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = ajax.CSEVENTID
),
AjaxCallsWithAvg AS
(
    SELECT 
        Id,
        CSEVENTID,
        PAGEURI,
        URI,
        TotalTime,
        NetworkTime,
        ServerTime,
        ResponseTime,
        RequestSize,
        ResponseSize,
        LATENCY,
        TotalAjaxCallCount,
        --calculate avg only for haviest ajax calls by ms
        AVG(CASE Id WHEN 1 THEN TotalTime END) OVER() AS AvgAjaxCallDuration,
        SYNCHRONOUS
    FROM
        AjaxCallsInternal   
)
INSERT INTO #AJAXCALLS
    SELECT * FROM AjaxCallsWithAvg
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
--Group information over ajax calls
;WITH HeaviestAjaxCalls AS
(
    SELECT
        PAGEURI,
        AJAXACTION,
        SYNCHRONOUS,
        COUNT(CSEVENTID) AS EventCount,
        AVG(TOTALTIME)/1000.0 AS TotalTime,
        AVG(NETWORKTIME)/1000.0 AS NetworkTime,
        AVG(SERVERTIME)/1000.0 AS ServerTime,
        AVG(RESPONSETIME)/1000.0 AS ResponseTime,
        AVG(REQUESTSIZE)/1024.0 AS RequestSize,
        AVG(RESPONSESIZE)/1024.0 AS ResponseSize,
        AVG(LATENCY) AS Latency,
        MAX(REQUESTSIZE + RESPONSESIZE)/1024.0 AS MaxAjaxCall,
        MAX(TOTALTIME)/1000.0 AS MaxAjaxCallDuration,
        SUM(TOTALAJAXCALLCOUNT) AS TotalAjaxCallCount,
        MIN(AVGAJAXCALLDURATION) / 1000.0 AS AvgAjaxCallDuration
    FROM 
        #AJAXCALLS
    WHERE
        --Select only heaviest AJAX calls for each event 
        ID = 1 
    GROUP BY 
        PAGEURI,
        AJAXACTION,
        SYNCHRONOUS
),
-- Select information for top 10 Largest AJAX calls
LargestAjaxCalls AS
(
    SELECT 
        ROW_NUMBER() OVER (ORDER BY CASE @ORDERBY1
                WHEN 1 THEN EventCount
                WHEN 2 THEN RequestSize
                WHEN 3 THEN ResponseSize
                WHEN 4 THEN COALESCE(RequestSize, 0) + COALESCE(ResponseSize, 0)
                WHEN 5 THEN TotalTime
            END DESC) AS Id,
        PageUri,
        AjaxAction,
        EventCount,
        RequestSize,
        ResponseSize,
        TotalTime,
        TotalAjaxCallCount,
        SUM(EventCount) OVER() AS TotalAjaxEventCount,
        AVG(RequestSize + ResponseSize) OVER() AS AvgAjaxCallSize,
        MAX(MaxAjaxCall) OVER() AS LargestAjaxCallSize
    FROM
        HeaviestAjaxCalls AS h
),
--Select information for top Slowest Ajax Calls (only asynch AJAXes)
SlowestAjaxCalls AS
(
    SELECT 
        ROW_NUMBER() OVER (ORDER BY CASE @ORDERBY2
                WHEN 1 THEN EventCount
                WHEN 2 THEN TotalTime - (NetworkTime + ResponseTime + ServerTime)
                WHEN 3 THEN NetworkTime + ResponseTime 
                WHEN 4 THEN ServerTime
                WHEN 5 THEN TotalTime
                WHEN 6 THEN RequestSize
                WHEN 7 THEN ResponseSize
                WHEN 8 THEN Latency
            END DESC) AS Id,
        PageUri,
        AjaxAction,
        EventCount,
        NetworkTime + ResponseTime AS NetworkTime,
        ServerTime,
        TotalTime - (NetworkTime + ResponseTime + ServerTime) AS ClientTime,
        TotalTime,
        RequestSize,
        ResponseSize,
        Latency,
        SUM(EventCount) OVER() AS TotalAjaxEventCount,
        AvgAjaxCallDuration,
        MAX(MaxAjaxCallDuration) OVER() AS MaxAjaxCallDuration
    FROM
        HeaviestAjaxCalls AS h
    WHERE
        -- Select only Asynch AJAXes
        Synchronous = 0
),
JavaScriptActions AS
(
    SELECT
        js.ACTION,
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        SUM(COALESCE(ajax.TOTALAJAXCALLCOUNT, 0)) AS AjaxCallCount,
        AVG(COALESCE(ajax.NETWORKTIME + ajax.RESPONSETIME, 0))/1000.0  AS JSNetworkTime,
        AVG(COALESCE(ajax.SERVERTIME, 0))/1000.0 AS JSServerTime,
        -- Clinet time is calculated as jsevent time minus ajax call time
        -- If JavaScript function has no ajax calls, then all time consider to be client time
        AVG(js.TOTALTIME - COALESCE(ajax.TOTALTIME, 0))/1000.0  AS JSClientTime,
        AVG(js.TOTALTIME)/1000.0  AS JSTotalTime,
        AVG(REQUESTSIZE + RESPONSESIZE)/1024.0  AS AvgSize,
        AVG(LATENCY) AS Latency,
        MAX(js.TOTALTIME)/1000.0 AS JSMaxTime       
    FROM
        APM.CSJScriptEvent AS js (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = js.CSEVENTID   
        -- If Java script has ajax events, condition id = 1 alows to select largest (by total time) ajax call
        LEFT OUTER JOIN #AJAXCALLS AS ajax ON (ajax.ID = 1 AND ajax.CSEVENTID = js.CSEVENTID)
    GROUP BY
        js.ACTION,
        e.PAGEURI
),
-- Order java script info by specified parameter
SlowestJScript AS 
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY3
                WHEN 1 THEN EventCount
                WHEN 2 THEN AJAXCallCount
                WHEN 3 THEN JSClientTime
                WHEN 4 THEN JSNetworkTime
                WHEN 5 THEN JSServerTime
                WHEN 6 THEN JSTotalTime
                WHEN 7 THEN AvgSize
                WHEN 8 THEN Latency
            END) DESC) AS id,
        Action AS JSAction,
        PageUri,
        EventCount,
        AJAXCallCount,
        JSClientTime,
        JSNetworkTime,
        JSServerTime,
        JSTotalTime,
        AvgSize,
        Latency,
        SUM(EventCount) OVER() AS TotalJSEventCount,
        MAX(JSMaxTime) OVER() AS JScriptMaxTime,
        -- Calculate average time for all java script events
        (SUM(JSTotalTime*EventCount) OVER())/(SUM(EventCount) OVER()) AS AverageJScriptTime
    FROM
        JavaScriptActions       
)
--select TOP 10 rows from each query
SELECT 
        [top].n AS Id,
-- Largest Ajax Calls
        la.PageUri AS la_PageUri,
        la.AjaxAction AS la_AjaxAction,
        la.EventCount AS la_EventCount,
        la.RequestSize AS la_RequestSize,
        la.ResponseSize AS la_ResponseSize,
        la.TotalTime AS la_TotalTime,
-- End Largest Ajax Calls
-- Slowest AJAX Calls
        sa.PageUri AS sa_PageUri,
        sa.AjaxAction AS sa_AjaxAction,
        sa.EventCount AS sa_EventCount,
        sa.NetworkTime AS sa_NetworkTime,
        sa.ServerTime AS sa_ServerTime,
        sa.ClientTime AS sa_ClientTime,
        sa.TotalTime AS sa_TotalTime,
        sa.RequestSize AS sa_RequestSize,
        sa.ResponseSize AS sa_ResponseSize,
        sa.Latency AS sa_Latency,
        sa.TotalAjaxEventCount AS sa_TotalAsynchAjaxesCount,
-- End Slowest AJAX Calls
-- Slowest JavaScript
        js.JSAction AS js_Action,
        js.PageUri AS js_PageUri,
        js.EventCount AS js_EventCount,
        js.AJAXCallCount AS js_AJAXCallCount,
        js.JSClientTime AS js_JSClientTime,
        js.JSNetworkTime AS js_JSNetworkTime,
        js.JSServerTime AS js_JSServerTime,
        js.JSTotalTime AS js_JSTotalTime,
        js.AvgSize AS js_AvgSize,
        js.Latency AS js_Latency,
        js.TotalJSEventCount,
-- End Slowest JavaScript
-- Summary information
        la.TotalAjaxCallCount,
        la.TotalAjaxEventCount,
        la.AvgAjaxCallSize,
        la.LargestAjaxCallSize,
        sa.AvgAjaxCallDuration,
        sa.MaxAjaxCallDuration,
        js.JScriptMaxTime,
        js.AverageJScriptTime
-- End Summary Information
FROM
    APM.fn_nums(10) AS [top]
    LEFT OUTER JOIN LargestAjaxCalls AS la ON [top].n = la.Id
    LEFT OUTER JOIN SlowestAjaxCalls AS sa ON [top].n = sa.Id
    LEFT OUTER JOIN SlowestJScript AS js ON [top].n = js.Id
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisTopPages                                                */
/* USED IN: Application Analysis report for TOP 10 slowest ans top 10 largest pages */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet masks list, which should be excluded                */
/*      @ORDERBY1 - Specifies field to which sorting for largest pages              */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Image Size                                               */
/*                      3. CSS Size                                                 */
/*                      4. HTC Behavior Size                                        */
/*                      5. Script Size                                              */
/*                      6. HTML Size                                                */
/*                      7. AJAX Size                                                */
/*                      8. Avg Page Size                                            */
/*                      9. Event Duration Time                                      */
/*      @ORDERBY2 - Specifies field to which sorting for slowest pages              */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Network Time                                             */
/*                      3. Server Time                                              */
/*                      4. DOM Time                                                 */
/*                      5. Peripheral Time                                          */
/*                      6. OnLoad Time                                              */
/*                      7. Event Duration                                           */  
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY1 INT,
    @ORDERBY2 INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE DATABASE_DEFAULT  
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    CLASSTYPE NVARCHAR(50) COLLATE DATABASE_DEFAULT,
    CSEVENTGROUPID INT
)
INSERT INTO #CLIENTEVENTS
SELECT
    e.CSEVENTID,    
    e.PAGEURI,
    e.CLASSTYPE,
    e.CSEVENTGROUPID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)     
WHERE 
    e.SOURCEID = @SOURCEID
    AND e.PAGEURI IS NOT NULL
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE
    AND e.EVENTCLASS = N'CSMPMonitorLog'
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
;WITH AjaxCalls AS
(
    SELECT 
        e.CSEVENTID,
        SUM(ajax.RESPONSESIZE) AS ResponseSize,
        SUM(ajax.REQUESTSIZE) AS RequestSize
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
),
-- Select information about page content size for each event (this information is available only for page events)
PeripheralDetails AS
(
    SELECT 
        b.CSEventId,
        COALESCE(b.Image, 0) AS Image, 
        COALESCE(b.HtcBehavior, 0) AS HtcBehavior, 
        COALESCE(b.Script, 0) AS Script, 
        COALESCE(b.html, 0) AS html, 
        COALESCE(b.CssStyle, 0) AS CssStyle,
        COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0) AS Ajax,
        COALESCE(b.Image, 0) + COALESCE(b.HtcBehavior, 0) + COALESCE(b.Script, 0) 
            + COALESCE(b.html, 0) + COALESCE(b.CssStyle, 0) 
            + COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0) AS TotalSize
    FROM
    (
        SELECT
            e.CSEVENTID,
            p.TYPE,
            p.TOTALSIZE
        FROM
            #CLIENTEVENTS AS e
            JOIN APM.CSPeripheral AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
    )AS A
    PIVOT (SUM(TotalSize) FOR Type IN (Image, HtcBehavior, Script, html, CssStyle)) AS b
    LEFT OUTER JOIN AjaxCalls AS ajax ON (ajax.CSEVENTID = b.CSEVENTID)
),
-- Group page events information by pages
PageEvents AS
(
    SELECT
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        -- All null values in time segments should be changed to 0, to provide convergence with average total time
        AVG(COALESCE(p.NetworkTime, 0))/1000.0 AS NetworkTime,
        AVG(COALESCE(p.ServerTime, 0))/1000.0 AS ServerTime,
        AVG(COALESCE(p.DomTime, 0))/1000.0 AS DomTime,
        AVG(COALESCE(p.PeripheralTime, 0))/1000.0 AS PeripheralTime,
        AVG(COALESCE(p.OnLoadTime, 0))/1000.0 AS OnLoadTime,    
        AVG(p.TotalTime)/1000.0 AS EventDuration,
        MAX(p.TotalTime)/1000.0 AS MaxEventDuration,
        AVG(d.TotalSize)/1024.0 AS AveragePageSize,
        MAX(d.TotalSize)/1024.0 AS MaxPageSize,
        AVG(d.Image)/1024.0 AS ImageSize, 
        AVG(d.HtcBehavior)/1024.0 AS HtcBehaviorSize, 
        AVG(d.Script)/1024.0 AS ScriptSize, 
        AVG(d.html)/1024.0 AS HTMLSize, 
        AVG(d.CssStyle)/1024.0 AS CssStyleSize,
        AVG(Ajax)/1024.0 AS AJAXCallSize    
    FROM
        #CLIENTEVENTS AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN PeripheralDetails AS d ON d.CSEventId = e.CSEVENTID
    GROUP BY
        e.PAGEURI       
),
-- Select information for top 10 largest pages
LargesPage AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY1
            WHEN 1 THEN EventCount
            WHEN 2 THEN ImageSize
            WHEN 3 THEN CssStyleSize
            WHEN 4 THEN HtcBehaviorSize
            WHEN 5 THEN ScriptSize
            WHEN 6 THEN HTMLSize
            WHEN 7 THEN AJAXCallSize
            WHEN 8 THEN AveragePageSize
            WHEN 9 THEN EventDuration
        END) DESC) AS id,   
        PageUri,
        EventCount,
        ImageSize,
        CssStyleSize,
        HtcBehaviorSize,
        ScriptSize,
        HTMLSize,
        AJAXCallSize,
        AveragePageSize AS TotalSize,
        EventDuration,
        SUM(EventCount) OVER() AS TotalPageEventCount,
        -- Select information about max page size and average page size over all application events,
        -- This information will be shown in report summary information
        MAX(MaxPageSize) OVER() AS MaxPageSize,
        (SUM(AveragePageSize*EventCount) OVER())/(SUM(EventCount) OVER()) AS AveragePageSize
    FROM
        PageEvents
),
-- Select information for top 10 slowest pages
SlowestPage AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY2
            WHEN 1 THEN EventCount
            WHEN 2 THEN NetworkTime
            WHEN 3 THEN ServerTime
            WHEN 4 THEN DomTime
            WHEN 5 THEN PeripheralTime
            WHEN 6 THEN OnLoadTime
            WHEN 7 THEN EventDuration
        END) DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DomTime,
        PeripheralTime,
        OnLoadTime,
        EventDuration AS TotalTime,
        -- Select information about max page load time and average page load time over all application events,
        -- This information will be shown in report summary information
        MAX(MaxEventDuration) OVER() AS MaxPageLoadTime,
        (SUM(EventDuration*EventCount) OVER())/(SUM(EventCount) OVER()) AS AveragePageLoadTime,
    --Get ajax call flag
        CASE WHEN EXISTS(
               SELECT * 
                 FROM #CLIENTEVENTS c
                    JOIN CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                        
               WHERE d.PageUri = c.PAGEURI
             ) THEN '*' ELSE ''
        END AS Extension
    FROM
        PageEvents d
)
SELECT 
    [top].n AS Id,
-- Largest Pages
        lp.PageUri AS lp_PageUri,
        lp.EventCount AS lp_EventCount,
        lp.ImageSize AS lp_ImageSize,
        lp.CssStyleSize AS lp_CssStyleSize,
        lp.HtcBehaviorSize AS lp_HtcBehaviorSize,
        lp.ScriptSize AS lp_ScriptSize,
        lp.HTMLSize AS lp_HTMLSize,
        lp.AJAXCallSize AS lp_AJAXCallSize,
        lp.TotalSize AS lp_TotalSize,
        lp.EventDuration AS lp_EventDuration,
-- End Largest Pages        
-- Slowest Pages
        sp.PageUri AS sp_PageUri,
        sp.EventCount AS sp_EventCount,
        sp.NetworkTime AS sp_NetworkTime,
        sp.ServerTime AS sp_ServerTime,
        sp.DomTime AS sp_DomTime,
        sp.PeripheralTime AS sp_PeripheralTime,
        sp.OnLoadTime AS sp_OnLoadTime,
        sp.TotalTime AS sp_TotalTime,
        sp.Extension AS sp_Extension,
-- End Slowest Pages
-- Summary information
        lp.TotalPageEventCount AS TotalPageEventCount,
        lp.MaxPageSize,
        lp.AveragePageSize,
        sp.MaxPageLoadTime,
        sp.AveragePageLoadTime  
-- End Summary Information
FROM
    APM.fn_nums(10) AS [top]
    LEFT OUTER JOIN LargesPage AS lp ON [top].n = lp.Id 
    LEFT OUTER JOIN SlowestPage AS sp ON [top].n = sp.Id 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceTopPages                                                 */
/* USED IN: SummaryPerfTop5PageSubReport.rdl subreport                              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
CREATE TABLE #CLIENTEVENTS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE DATABASE_DEFAULT
)
-- Filter Event Table by incoming parameters
INSERT INTO #CLIENTEVENTS
    SELECT 
        e.CSEventId,
        e.PageUri        
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
        JOIN #SUBNETCFILTERTABLE AS f1 ON (f1.IPID = e.ipid)
        JOIN #PMSTATUSFILTERTABLE AS f2 ON (f2.VALUEID = e.PMStatus) 
    WHERE 
        e.sourceId = @SOURCEID
        AND UTCDATE &gt;= @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND EventClass = 'CSMPMonitorLog'
;WITH CSPageEvents AS
(
    SELECT 
        e.CSEVENTID,
        e.PAGEURI,
        -- Null values should be replaced by 0, to get convergence with Total time after averaging
        COALESCE(pe.NetworkTime, 0) AS NetworkTime,
        COALESCE(pe.ServerTime, 0) AS ServerTime,
        COALESCE(pe.DOMTime, 0) AS DOMTime,
        COALESCE(pe.PeripheralTime, 0) AS PeripheralTime,
        COALESCE(pe.OnLoadTime, 0) AS OnLoadTime,
        pe.TotalTime,
        pe.TotalSize
    FROM 
        #CLIENTEVENTS e
        JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.cseventid = e.CSEVENTID AND pe.TotalTime/1000.0 &gt;= @THRESHOLD
        
),
PageProcessingTime AS
(
    SELECT 
        PageUri,
        COUNT(CSEVENTID) AS EventCount,
        AVG(NetworkTime)/1000 AS NetworkTime,
        AVG(ServerTime)/1000 AS ServerTime,
        AVG(DOMTime)/1000 AS DOMTime,
        AVG(PeripheralTime)/1000 AS PeripheralTime,
        AVG(OnLoadTime)/1000 AS OnLoadTime,
        AVG(TotalTime)/1000 AS TotalTime,
        AVG(TotalSize)/(1024.0) AS TotalSize
    FROM 
        CSPageEvents
    GROUP BY
        PageUri  
),
NumberedPages AS
(
    SELECT 
        row_number() OVER(ORDER BY EventCount DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        PageProcessingTime  
)
SELECT
    TOP(5)
        id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        TotalEvents,
        --Get ajax call flag
        CASE WHEN EXISTS(
            SELECT * 
                FROM #CLIENTEVENTS c
                     JOIN CSPageEvent AS pe (NOLOCK) ON pe.cseventid = c.CSEVENTID
                     JOIN CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                       
                WHERE d.PageUri = c.PAGEURI
        ) THEN '*' ELSE ''
        END AS Extension
    FROM 
        NumberedPages d 
    ORDER BY id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisExceptionEvents'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisExceptionEvents AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisExceptionEvents                                             */
/* USED IN: Application Analysis report for exception events    */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisExceptionEvents 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #MACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
;WITH RequestPCTypeId AS
(
    SELECT
        PCTypeID
    FROM
        APM.PCTYPE 
    WHERE
        TYPE = N'\Apps\Monitored Requests'
),
RequestCount AS
(
    SELECT
        SUM(SUMVALUE) AS RequestCount
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (ph.MachineId = f1.VALUEID)
        JOIN RequestPCTypeId AS pct ON pct.PCTypeID = ph.PCTypeID
    WHERE
        UTCDATE &gt;= @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND ph.sourceid = @SOURCEID
),
EventDescription AS
(
    SELECT 
        COUNT(CSEVENTID) AS EventCount,
        COUNT(DISTINCT CSEVENTGROUPID) AS ProblemCount,
        COUNT(CASE WHEN CHARINDEX(N'MSIE', E.BROWSER) &gt; 0 THEN E.CSEVENTID ELSE NULL END) AS IEEventCount,
        COUNT(CASE WHEN CHARINDEX(N'Firefox', E.BROWSER) &gt; 0 THEN E.CSEVENTID ELSE NULL END) AS FirefoxEventCount,
        DESCRIPTION
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (e.MachineId = f1.VALUEID)
        -- Filter client events by subnets
        JOIN #SUBNETCFILTERTABLE AS f2 ON (e.ipid = f2.IPID)
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.ClassType = N'exception'
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND e.sourceid = @SOURCEID
    GROUP BY 
        DESCRIPTION
),
OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY E.EventCount DESC) AS id,
        EventCount,
        ProblemCount,
        IEEventCount,
        FirefoxEventCount,
        Description,
        SUM(E.EventCount) OVER() AS TotalEventCount,
        SUM(E.ProblemCount) OVER() AS TotalProblemCount
    FROM
        EventDescription AS e
)
SELECT 
    TOP(10) E.*, req.RequestCount
FROM
    OrderedDataSet AS e
    CROSS JOIN RequestCount AS req
ORDER BY
    E.ID
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisOverallStatistics'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisOverallStatistics AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisOverallStatistics                                       */
/* USED IN: Application Analysis report                                         */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisOverallStatistics 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #MACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    CLASSTYPE NVARCHAR(50) COLLATE DATABASE_DEFAULT
)
INSERT INTO #CLIENTEVENTS
    SELECT 
        e.cseventid,
        e.csEventGroupId,
        e.ClassType
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (e.MachineId = f1.VALUEID)
        -- Filter client events by subnets
        JOIN #SUBNETCFILTERTABLE AS f2 ON (e.ipid = f2.IPID)
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.sourceid = @SOURCEID
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE
;WITH RequestPCTypeId AS
(
    SELECT
        PCTypeID
    FROM
        APM.PCTYPE 
    WHERE
        TYPE = N'\Apps\Monitored Requests'
),
RequestCount AS
(
    SELECT
        SUM(SUMVALUE) AS RequestCount
    FROM
        APM.PerfHourly AS ph
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (ph.MachineId = f1.VALUEID)
        JOIN RequestPCTypeId AS pct ON pct.PCTypeID = ph.PCTypeID
    WHERE
        ph.sourceid = @SOURCEID
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE  
),
AJAXEvents AS
(
    SELECT
        AVG(ajax.REQUESTSIZE + ajax.ResponseSize) AS AjaxCallSize,
        AVG(ajax.TotalTime) AS AjaxCallDuration,
        MAX(ajax.REQUESTSIZE + ajax.ResponseSize) AS MaxAjaxCallSize,
        MAX(ajax.TotalTime) AS MaxAjaxCallDuration,
        COUNT(ajax.CSEventId) AS AjaxCallCount
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON ajax.CSEventId = e.CSEVENTID
    WHERE
        e.CLASSTYPE = N'performance'
),
ExceptionEvents AS
(
    SELECT
        COUNT(CSEVENTID) AS EventCount,
        COUNT(CSEVENTGROUPID) AS ProblemCount
    FROM
        #CLIENTEVENTS AS e
    WHERE
        e.CLASSTYPE = N'exception'
),
PerformanceEvents AS
(
    SELECT
        COUNT(CSEVENTID) AS EventCount,
        COUNT(CSEVENTGROUPID) AS ProblemCount
    FROM
        #CLIENTEVENTS AS e
    WHERE
        e.CLASSTYPE = N'performance'
)
SELECT 
    e.EventCount AS ExceptionEventsCount,
    e.ProblemCount AS ExceptionProblemCount,
    perf.EventCount AS PerformanceEventsCount,
    perf.ProblemCount AS PerformanceProblemCount,
    ajax.AjaxCallSize/1024.0 AS AjaxCallSize,
    ajax.AjaxCallDuration/1000.0 AS AjaxCallDuration,
    ajax.MaxAjaxCallSize/1024.0 AS MaxAjaxCallSize,
    ajax.MaxAjaxCallDuration/1000.0 AS MaxAjaxCallDuration,
    ajax.AjaxCallCount,
    req.RequestCount
FROM
    ExceptionEvents AS e
    CROSS JOIN PerformanceEvents AS perf
    CROSS JOIN RequestCount AS req
    CROSS JOIN AJAXEvents AS ajax
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReportTopJS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReportTopJS AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReportTopJS                                  */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCE - source Id                                                     */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReportTopJS 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCE INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains msource ids
CREATE TABLE #SOURCEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
;WITH CSAjaxPageEvents AS
(
    SELECT
        e.CSEventID,
        e.pageUri,
        -- This name will be used only for Asynch Ajax Event, and for this events here will be only one row
        MAX(ajax.uri) AS ActionName,
        SUM(ajax.TotalTime) AS AJAXCallProcessingTime,
        SUM(ajax.NetworkTime) AS NetworkTime,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.REQUESTSIZE) AS RequestSize,
        SUM(ajax.ResponseSize) AS ResponseSize
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        JOIN #SOURCEFILTERTABLE AS f1 ON (f1.VALUEID = e.MachineId)
        JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
        LEFT OUTER JOIN APM.CSAjax (NOLOCK) AS ajax ON ajax.cseventid = e.cseventid
    WHERE 
        e.sourceId = @SOURCE
        AND e.UTCDate &gt;= @STARTDATE
        AND e.UTCDate &lt; @ENDDATE
        AND e.EventClass &lt;&gt; N'CSMPMonitorLog'
    GROUP BY
        e.CSEventID,
        e.pageUri       
),
AJAXEventSummary AS
(
    SELECT
        e.CSEventID,
        e.pageUri,
        COALESCE(js.Action, e.ActionName) AS JSActionName,
        COALESCE(js.TotalTime, e.AJAXCallProcessingTime) AS TotalTime,
        COALESCE(js.TotalTime - COALESCE(e.AJAXCallProcessingTime, 0), asyncAjax.HandlerTime) AS ClientTime,
        COALESCE(e.NetworkTime, 0) AS NetworkTime,
        COALESCE(e.ServerTime, 0) AS ServerTime,
        e.REQUESTSIZE,
        e.ResponseSize
    FROM
        CSAjaxPageEvents AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.cseventid = e.cseventid
        LEFT OUTER JOIN APM.CSAsyncAjax AS asyncAjax (NOLOCK) ON asyncAjax.cseventid = e.cseventid
    WHERE
        COALESCE(js.TotalTime, e.AJAXCallProcessingTime)/1000.0 &gt;= @THRESHOLD
),
AjaxPage AS
(
    SELECT 
        JSActionName,
        pageUri,
        COUNT(CSEventID) AS EventCount,
        AVG(ClientTime)/1000 AS ClientTime,
        AVG(NetworkTime)/1000 AS NetworkTime,
        AVG(ServerTime)/1000 AS ServerTime,
        AVG(TotalTime)/1000 AS AJAXTotalTime,
        AVG(RequestSize)/(1024.0) AS RequestSize,
        AVG(ResponseSize)/(1024.0) AS ResponseSize
    FROM
        AJAXEventSummary
    GROUP BY
        JSActionName,pageUri
),
OrderedActions AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id,
        EventCount,
        JSActionName,
        pageUri,
        ClientTime,
        NetworkTime,
        ServerTime,
        AJAXTotalTime AS TotalTime,
        RequestSize + ResponseSize AS AJAXCallSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        AjaxPage
)
SELECT TOP(5)
    *
FROM 
    OrderedActions
ORDER BY
    id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationActivityBreakdownByMonthDate'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationActivityBreakdownByMonthDate AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationActivityBreakdownByMonthDate                                        */
/* USED IN: Application Status  Report, Application Activity                            */
/* DESCRIPTION: This SP is used in report above in case, when grouping by month date    */
/*      specified                                                                       */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period in Client time zone                    */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
ALTER PROCEDURE APM.ApplicationActivityBreakdownByMonthDate
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = 31
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @ENDDATE)    
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @STARTDATE)
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
    
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- To form application pool with all sources run in it, it is need to get all sources and its process
    CREATE TABLE #PROCESSFORSOURCE
    (
        SOURCEID INT,
        PCPROCESSID INT,
        MACHINEID INT,
        EXTRAINFO NVARCHAR(255) COLLATE DATABASE_DEFAULT,
        PROCESS NVARCHAR(255) COLLATE DATABASE_DEFAULT
    )
    
    INSERT INTO #PROCESSFORSOURCE
        SELECT
            ph.SourceId,
            ph.PCProcessId,
            ph.MachineId,
            COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
            --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
            APM.RemoveProcessIdFromName(p.Process) AS Process           
        FROM
            (
                SELECT DISTINCT
                    ph.SourceId,
                    ph.pcprocessId,
                    ph.MachineId
                FROM
                    APM.PerfHourly AS ph (NOLOCK)
                WHERE
                    ph.pcprocessId IS NOT NULL
                    AND ph.UTCDate &gt;= @STARTDATE
                    AND ph.UTCDate &lt; @ENDDATE 
            ) AS ph
            JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.pcprocessId 
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MachineId = f.VALUEID)
    -- Report frame. It contains all sources, for which values sould be selected, 
    -- and dates for the specified period (StartDate : EndDate)  
    ;WITH SourcesDates AS
    (
        SELECT
            VALUEID AS sourceid,
            s.source AS source,
            -- Select 31 day from end date in ClientTime zone, without hours
            CONVERT(NVARCHAR, DATEADD(d, -d.n, DATEADD(minute, @TIMEZONE, @ENDDATE)), 112) AS ClientDate
        FROM
            #SOURCEMACHINEFILTERTABLE AS source
            JOIN APM.source (NOLOCK) AS s ON s.sourceid = source.VALUEID
            CROSS JOIN APM.fn_nums(31) AS d
        WHERE
            source.TYPEID = 1
    ),
    AppPoolInfo AS 
    (
        SELECT 
            c.SOURCEID,
            c.EXTRAINFO,
            c.PROCESS,
            -- all source names which have the same process name as passed in @SOURCEIDS
            (SELECT A.source AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        N'''' + s.source + N'''' +  N',' AS source
                    FROM 
                        #PROCESSFORSOURCE AS c1
                        JOIN APM.Source AS s ON c1.SOURCEID = s.SourceId
                    WHERE 
                        c1.EXTRAINFO = c.EXTRAINFO 
                        AND c1.PROCESS = c.PROCESS
                        AND c1.MACHINEID = c.MACHINEID
                ) AS A
                FOR XML PATH ('') 
            ) AS AppPoolSources
        FROM
            #PROCESSFORSOURCE AS c
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
        GROUP BY
            c.SOURCEID, 
            c.MACHINEID,
            c.EXTRAINFO,
            c.PROCESS
    ),
    --Add Pool name in-front of source list, if it is executable application, then app pool countains source name
    PrepareAppPoolInfo AS (
        SELECT DISTINCT
            CASE 
                WHEN COALESCE(info.ExtraInfo,'') = '' THEN CASE info.AppPoolSources WHEN '' THEN '' ELSE LEFT(info.AppPoolSources, LEN(info.AppPoolSources)-1) END
                ELSE info.ExtraInfo + CASE info.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(info.AppPoolSources, LEN(info.AppPoolSources) - 1) + ')' END
            END AppPool,
            info.SourceId,
            info.ExtraInfo
        FROM 
            AppPoolInfo AS info
    ),
    -- Forms application pool list for each source
    -- Format: AppPool1 ('Source1', 'Source2', Source3), AppPool2 ('Source1', 'Source4')
    SourceAppPools AS (
        SELECT 
            s.SourceId,
            s.Source,
            COALESCE((SELECT a.AppPool AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        info.AppPool +  N',' AS AppPool
                    FROM 
                        PrepareAppPoolInfo as info
                    WHERE 
                        info.Sourceid = s.Sourceid 
                ) AS A
                FOR XML PATH ('') 
            ),s.Source +  '-') AS AppPoolInfo
        FROM 
            APM.Source AS s
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = s.SourceId)
    ),    
    --Prepares and filters events for further manipulations
    ActivityBreakdown_EventsFiltered AS
    (
        SELECT
            e.sourceid,
            e.eventid,
            e.utceventdate AS eventdate,
            -- Event Date in Client Timezone without hours
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE, e.utceventdate), 112) AS ClientDate,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, e.utceventdate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId,
            e.eventgroupid,
            db.ADDRESS AS SeViewerAddress
        FROM
            APM.Event AS e
            JOIN APM.SeViewerDB AS db ON e.seviewerdbid = db.seviewerdbid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.sourceid and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.machineid and f2.TYPEID = 2)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE
            ((e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD) 
            OR e.EventClassType = N'exception')
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)            
    ),
    /************************************************************************************/
    /*                          Base pcounter queries                                   */
    /************************************************************************************/
    -- Calculate resource utilization by Source in one hour.
    -- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PerfHourly date in client time zone without hours
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE ,ph.UTCDate), 112) AS ClientDate,
            ph.PCTypeId AS Type,    
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,
            ABS(DATEDIFF(hour, ph.UTCDate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeId IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId
    ),
    -- Bring ClientDate to current period, as in result data set, data only for current period are shown
    -- (all other should be shown relative to current period)
    SourceHourlyResourceUtilizationByCurrentPeriod AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, ph.PeriodId*31, ClientDate) AS ClientDate,
            ph.Type,    
            ph.LastInstanceCount,
            ph.CurInstanceCount,
            ph.AvgInstanceCount,
            ph.LastValue,
            ph.CurValue,
            ph.AvgValue,
            ph.PeriodId
        FROM
            SourceHourlyResourceUtilization AS ph
    ),
    --Calculate average source resource utilization for each resource type
    --and for specified grouping period and date          
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilizationByCurrentPeriod AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate
    ),
    -- Count Monitored Requests and Avg. Request Timefor Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE, ph.UTCDate), 112) AS ClientDate,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)  
            END AS LastMonRequest,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) 
            END AS CurMonRequest,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END) 
            END AS AvgReqTime,
            ABS(DATEDIFF(hour, ph.UTCDate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate
    ),
    -- Bring ClientDate to current period, as in result data set, data only for current period are shown
    -- (all other should be shown relative to current period)
    ApplicationNetAppCountersByCurrentPeriod AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, ph.PeriodId*31, ClientDate) AS ClientDate,
            ph.LastMonRequest,
            ph.CurMonRequest,
            ph.AvgMonRequest,
            ph.LastAvgReqTime,
            ph.CurAvgReqTime,
            ph.AvgReqTime,
            ph.PeriodId
        FROM
            ApplicationNetAppCountersByMachinePrepare AS ph 
    ),
    --Calculate average request time  and  sum request count for specified grouping period and date          
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByCurrentPeriod ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate
    ),
    --  Union .NET counters and process counters for period Id. Period Id differs only for average(last three months) values, so grouping only for them
    PCountersGroupedByMachineId AS (
        SELECT 
            pc.machineId,
            pc.SourceId,
            pc.ClientDate,
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM ApplicationResourceUtilizationByMachines pc
       LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId 
                AND netApp.ClientDate = pc.ClientDate
        GROUP BY
            pc.machineId,
            pc.SourceId,
            pc.ClientDate
    ),
    -- Calculate average source resource utilization between machines  
    ActivePreparePCounters AS (
        SELECT 
            pc.SourceId,
            -- Convert date to appropriate format to provide correct comparison
            pc.ClientDate,
            SUM(CurReqCount) AS CurReqCount, 
            SUM(LastReqCount) AS LastReqCount,
            SUM(AvgReqCount) AS AvgReqCount,
            AVG(CurAvgReqTime) AS CurAvgReqTime, 
            AVG(LastAvgReqTime) AS LastAvgReqTime,
            AVG(AvgReqTime) AS AvgReqTime,
            AVG(CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(LastCPUSum / COALESCE(m.CPUCount, 1) ) AS LastCPUSum,
            AVG(AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(CurMemSum) AS CurMemSum, 
            AVG(LastMemSum) AS LastMemSum,
            AVG(AvgMemSum) AS AvgMemSum,
            AVG(CurIOSum) AS CurIOSum, 
            AVG(LastIOSum) AS LastIOSum,
            AVG(AvgIOSum) AS AvgIOSum
        FROM 
            PCountersGroupedByMachineId AS pc
            JOIN apm.Machine AS m ON m.MachineId = pc.MachineId
        GROUP BY    
            pc.SourceId,
            pc.ClientDate
    ),
    -- Count events for the current, last and average period. 
    -- PeriodId is 0 for Current period, 1 for last period, and 1..n for average period
    PrepareEventsAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, e.PeriodId*31, e.ClientDate) AS ClientDate,
            e.PeriodId,         
            MAX(E.SeViewerAddress) AS SeViewerAddress,  
            COUNT(CASE WHEN e.eventdate &gt;= @STARTDATE AND e.eventdate &lt; @ENDDATE THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.eventdate &gt;= @LASTPERIODSTARTDATE  AND e.eventdate &lt; @STARTDATE THEN eventid END) AS LasEventsCount,
            COUNT(CASE WHEN E.eventdate &gt;= @AVERAGEPERIODSTARTDATE AND E.eventdate &lt; @STARTDATE THEN eventid END) AS AvgEventsCount
        FROM
            ActivityBreakdown_EventsFiltered AS e
        GROUP BY 
            e.sourceid,
            e.PeriodId,
            e.ClientDate
    ),
    Events AS
    (
        SELECT
            e.sourceid AS sourceid,
            -- Convert date to appropriate format to provide correct comparison
            e.ClientDate,
            MAX(E.SeViewerAddress) AS SeViewerAddress,
            --PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LasEventsCount) AS LasEventsCount,
            --Average counting is not included current period
            AVG(AvgEventsCount) AS AvgEventsCount
        FROM
            PrepareEventsAvg AS e
        GROUP BY 
            sourceid,
            e.ClientDate
    ),
    -- Check that CPU count is defined for all computers, where application run.
    -- Computers set, where application run, does not depend on specified period by design, as otherwise there is performance problems
    MachineCPUUndefinedFlag AS
    (
        SELECT
            sf.SOURCEID,
            MIN(COALESCE(m.CPUCount, -1)) AS CPUUndefinedFlag
        FROM
            #PROCESSFORSOURCE AS sf
            JOIN apm.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MachineId
        GROUP BY
            sf.SOURCEID
    )
    SELECT
	-- Convert to ISO8601 format to work properly with VB Script. This cannot be done earlier as join is done on this fields
	CONVERT(DATETIME,  SourcesDates.ClientDate, 126) AS ClientDate,
        -- These fake fields are need to provide compatibility with SP ApplicationStatusDrillthrough
        1 AS Date,
        0 AS Hours,
        1 AS OutputDate,
        1 AS Period,
        SourcesDates.Sourceid,
        SourcesDates.Source AS Source,
        COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
        COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
        COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
        COALESCE(pc.CurAvgReqTime, 0) AS CurAvgReqTime,
        COALESCE(pc.LastAvgReqTime, 0) AS LastAvgReqTime,
        COALESCE(pc.AvgReqTime, 0) AS AvgReqTime,
        COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
        COALESCE(pc.lastCPUSum, 0) AS LastCPUValue,
        COALESCE(pc.AvgCPUSum, 0) AS AvgValue,
        COALESCE(pc.CurMemSum, 0) AS CurMemValue,
        COALESCE(pc.LastMemSum, 0) AS LastMemValue,
        COALESCE(pc.AvgMemSum, 0) AS AvgMemValue,
        COALESCE(pc.CurIOSum, 0) AS CurIOValue,
        COALESCE(pc.LastIOSum, 0) AS LastIOValue,
        COALESCE(pc.AvgIOSum, 0) AS AvgIOValue,
        COALESCE(e.CurrentEventsCount, 0) AS NewEventsCount,
        COALESCE(e.LasEventsCount, 0) AS OldEventsCount,
        COALESCE(e.AvgEventsCount, 0) AS AvgEventsCount,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one PCounter row
        -- in PerfHourly table for specified period. If so, there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag,
        CASE LEFT(AppPool.AppPoolInfo,1) 
            WHEN N'''' THEN N'' 
            WHEN N'' THEN ''
            ELSE REPLACE(LEFT(AppPool.AppPoolInfo, LEN(AppPool.AppPoolInfo)-1), N'''', N'')
        END AS pool,
        E.SeViewerAddress
    FROM 
        SourcesDates
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON SourcesDates.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ActivePreparePCounters AS pc ON (pc.ClientDate = SourcesDates.ClientDate AND pc.SourceId = SourcesDates.Sourceid)
        LEFT OUTER JOIN Events AS e ON (e.ClientDate = SourcesDates.ClientDate AND e.Sourceid = SourcesDates.Sourceid)
        JOIN SourceAppPools AS AppPool ON (AppPool.Sourceid = SourcesDates.Sourceid)
    ORDER BY    
        Source, 
        ClientDate
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationActivityBreakdown'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationActivityBreakdown AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationActivityBreakdown                                                   */
/* USED IN: Application Status  Report, Application Activity                            */
/* DESCRIPTION: Temporary SP which provides unique call for different group by          */
/* parameters, which realy need different SP                                            */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period                                        */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationActivityBreakdown
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    IF @GROUPBY = 'MonthDay'
        exec APM.ApplicationActivityBreakdownByMonthDate
                    @SOURCEIDS,
                    @COMPUTERIDS,
                    @ENDDATE,
                    @TIMEZONE,
                    @PERIOD,
                    @AVERAGEINTERVAL,
                    @GROUPBY,
                    @THRESHOLD,
                    @PROBLEM,
                    @PMSTATUS
    ELSE
        exec APM.ApplicationStatusDrillthrough
                    @SOURCEIDS,
                    @COMPUTERIDS,
                    @ENDDATE,
                    @TIMEZONE,
                    @PERIOD,
                    @AVERAGEINTERVAL,
                    @GROUPBY,
                    @THRESHOLD,
                    @PROBLEM,
                    @PMSTATUS
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryUserAnalysisCSM'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryUserAnalysisCSM AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:SummaryUserAnalysisCSM                                                      */
/* USED IN: Summary User Analysis Report - summary table                            */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @ORDERBY - Specifies column ordering should be applied                      */
/*                  1 - EventCount                                                  */
/*                  2 - ProblemCount                                                */
/*                  3 - PerformanceEventCount                                       */
/*                  4 - ExceptionEventCount                                         */
/*                  5 - MaxTotalTime                                                */
/*                  6 - TotalTime                                                   */
/*                  7 - MaxTotalSize                                                */
/*                  8 - TotalSize                                                   */
/************************************************************************************/
/*  This stored procedure returns top 10 users ordered by user defined input        */
/*  parameter @ORDERBY. Every user have exactly five records of data with top five  */
/*  page,java script and ajax, exception events ordered by events count of each     */
/*  specific event.                                                                 */
/*  Each record is also contains overall statistics for the Summary table and       */
/*  charts.                                                                         */
/************************************************************************************/
alter PROCEDURE [APM].[SummaryUserAnalysisCSM] 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD DECIMAL(35,0),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) collate database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    ip.SubNetC
FROM
    apm.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
/*************************************************** Main Query ***************************************************/
-- Calculating information about Page events
;WITH PageEvents AS
(
    SELECT
        NULL AS classType,
        ROW_NUMBER() OVER(PARTITION BY UserId ORDER BY COUNT(CSEventId) DESC, PageUri ASC) AS RowId,
        PageUri,
        UserId,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroup) AS ProblemCount,
        AVG(NetworkTime) AS NetworkTime,
        AVG(ServerTime) AS ServerTime,
        AVG(DOMTime) AS DOMTime,
        AVG(PeripheralTime) AS PeripheralTime,
        AVG(OnLoadTime) AS OnLoadTime,
        AVG(TotalTime) AS TotalTime,
        AVG(TotalSize) AS TotalSize,
        -- This value is needed for ordering by maximum total time in the summary table
        MAX(MAX(TotalTime)) OVER(PARTITION BY UserId) AS MaxTotalTime,
        -- These values are needed to calculate average event duration and average size for user     
        SUM(SUM(TotalTime)) OVER(PARTITION BY UserId) AS UserSumTime,
        SUM(SUM(TotalSize)) OVER(PARTITION BY UserId) AS UserSumSize,
        -- This value is page event count for current user
        SUM(COUNT(*)) OVER(PARTITION BY UserId) AS UserPageEventCount,
