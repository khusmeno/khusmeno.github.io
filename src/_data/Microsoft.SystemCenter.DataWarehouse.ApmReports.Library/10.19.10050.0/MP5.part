            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    EventProblems AS
    (
        SELECT
            e.SourceId,
            COUNT(DISTINCT CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN rootnodeName + perfNode END) AS CurPerformanceProblemCount,
            COUNT(DISTINCT CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.description END) AS CurExceptionProblemCount,
            COUNT(CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.eventid END) AS CurPerformanceEventCount,
            COUNT(CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @STARTDATE AND e.date &lt; @ENDDATE) THEN e.eventid END) AS CurExceptionEventCount,
            COUNT(DISTINCT CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN rootnodeName + perfNode END) AS LastPerformanceProblemCount,
            COUNT(DISTINCT CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.description END) AS LastExceptionProblemCount,
            COUNT(CASE WHEN (EventClassType = 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.eventid END) AS LastPerformanceEventCount,
            COUNT(CASE WHEN (EventClassType &lt;&gt; 'Performance' AND e.date &gt;= @LASTPERIODSTARTDATE AND e.date &lt; @STARTDATE) THEN e.eventid END) AS LastExceptionEventCount,
            COUNT(DISTINCT CASE WHEN (e.EventClassType = 'performance' AND e.firsteventdate &gt;= @STARTDATE) THEN e.rootnodeName + perfNode END) as NewPerfProblemsCount,
            COUNT(DISTINCT CASE WHEN (e.EventClassType &lt;&gt; 'performance' AND e.firsteventdate &gt;= @STARTDATE) THEN e.description END) as NewExpProblemsCount
        FROM
            GetSummaryStatistics_EventsProblemsFiltered AS e
        GROUP BY 
            e.SourceId
    ),
    ResultQuery AS
    (
        SELECT 
            ROW_NUMBER() OVER(ORDER BY s.SourceId) AS Id,
            s.SourceId,            
            s.Source,
            COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
            COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
            COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
            COALESCE(pc.CurAvgReqTime, 0) AS CurAvrValue,
            COALESCE(pc.LastAvgReqTime, 0) AS LastAvgValue,
            COALESCE(pc.AvgReqTime, 0) AS AvgValue,
            COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
            COALESCE(pc.LastCPUSum, 0) AS LastCPUValue,
            COALESCE(pc.AvgCPUSum, 0) AS CPUAvgValue,
            COALESCE(pc.CurMemSum, 0) AS CurMemValue,
            COALESCE(pc.LastMemSum, 0) AS LastMemValue,
            COALESCE(pc.AvgMemSum, 0) AS MemAvgValue,
            COALESCE(pc.CurIOSum, 0) AS CurIOValue,
            COALESCE(pc.LastIOSum, 0) AS LastIOValue,
            COALESCE(pc.AvgIOSum, 0) AS IOAvgValue,
            
            COALESCE(pc.CurInstanceCount, 0) AS CurInstanceCount,
            COALESCE(pc.LastInstanceCount, 0) AS LastInstanceCount,
            COALESCE(pc.AvgInstanceCount, 0) AS AvgInstanceCount,
            
            COALESCE(E.LastEventCount, 0) AS LastEventCount,
            COALESCE(e.CurEventCount, 0) AS CurrentEventCount,  
            COALESCE(e.AverageEventCount, 0) AS AvgEventsCount,
            COALESCE(p.CurExceptionEventCount, 0) AS CurExceptionEventCount,
            COALESCE(p.CurPerformanceEventCount, 0) AS CurPerformanceEventCount,
            COALESCE(p.LastPerformanceEventCount, 0) AS LastPerformanceEventCount,
            COALESCE(p.LastExceptionEventCount, 0) AS LastExceptionEventCount,
            COALESCE(p.CurPerformanceProblemCount, 0) AS CurPerformanceProblemCount,
            COALESCE(p.CurExceptionProblemCount, 0) AS CurExceptionProblemCount,
            COALESCE(p.LastPerformanceProblemCount, 0) AS LastPerformanceProblemCount,
            COALESCE(p.LastExceptionProblemCount, 0) AS LastExceptionProblemCount,
            COALESCE(p.NewPerfProblemsCount, 0) AS NewPerfProblemsCount,
            COALESCE(p.NewExpProblemsCount, 0) AS NewExpProblemsCount
        FROM 
            #SOURCEMACHINEFILTERTABLE AS sd 
            JOIN APM.Source AS s (NOLOCK) ON sd.VALUEID = s.SourceId
            LEFT OUTER JOIN PCounters AS pc ON s.SourceId = pc.Sourceid
            LEFT OUTER JOIN Events AS e ON s.Sourceid = e.Sourceid
            LEFT OUTER JOIN EventProblems AS p ON s.Sourceid = p.Sourceid
        WHERE
            sd.TYPEID = 1
    )
        SELECT 
            LastResults.Id AS RowId,
            SourceId,            
            Source,
            -------Instance Count----------
            CurInstanceCount,
            LastInstanceCount,
            AvgInstanceCount,           
            -------MonitoredRequest--------
            CurMonitoredRequestSum,
            LastMonitoredRequestSum,
            AvgMonitoredRequestSum,
            -------Avg value----------
            CurAvrValue, 
            LastAvgValue,
            AvgValue,
            ------CPU Value----------
            CurCPUValue, 
            LastCPUValue,
            CPUAvgValue,
            ------ Mem value------------
            CurMemValue, 
            LastMemValue,
            MemAvgValue, 
            --------- IO value-------------
            CurIOValue,
            LastIOValue,
            IOAvgValue,
            ------- Events count----------
            AvgEventsCount,
            CurrentEventCount,
            LastEventCount,
            --------- Exception &amp; Performance Event Count ---------
            CurExceptionEventCount,
            CurPerformanceEventCount,
            LastPerformanceEventCount,
            LastExceptionEventCount,
            --------  Exception &amp; Performance Problem Count ---------
            CurPerformanceProblemCount,
            CurExceptionProblemCount,
            LastPerformanceProblemCount,
            LastExceptionProblemCount,
            NewPerfProblemsCount,
            NewExpProblemsCount
        FROM
            ResultQuery AS LastResults
        ORDER BY            
            RowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusDrillthrough'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusDrillthrough AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusDrillthrough                                                  */
/* USED IN: Application Status  Report, Application Daily Activity                      */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period                                        */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationStatusDrillthrough
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -(CASE WHEN @PERIOD = 1 THEN 1 WHEN @PERIOD = 2 THEN 7 ELSE 31 END), @ENDDATE)    
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = APM.GetQueryDateCount(@PERIOD, @STARTDATE);
    
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE TYPE = N'\Apps\Avg. Request Time'
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- To form application pool with all sources run in it, it is need to get all sources and its process
    CREATE TABLE #PROCESSFORSOURCE
    (
        SOURCEID INT,
        PCPROCESSID INT,
        MACHINEID INT,
        EXTRAINFO NVARCHAR(255) collate database_default,
        PROCESS NVARCHAR(255) collate database_default
    )
    
    INSERT INTO #PROCESSFORSOURCE
        SELECT
            ph.SOURCEID,
            ph.PCPROCESSID,
            ph.MACHINEID,
            COALESCE(p.EXTRAINFO, N'') AS EXTRAINFO,
            --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
            APM.RemoveProcessIdFromName(p.PROCESS) AS Process           
        FROM
            (
                SELECT DISTINCT
                    ph.SOURCEID,
                    ph.PCPROCESSID,
                    ph.MACHINEID
                FROM
                    APM.PerfHourly AS ph (NOLOCK)
                WHERE
                    ph.PCPROCESSID IS NOT NULL
                    AND ph.UTCDATE &gt;= @STARTDATE
                    AND ph.UTCDATE &lt; @ENDDATE
            ) AS ph
            JOIN APM.PCProcess AS p (NOLOCK) ON p.PCPROCESSID = ph.PCPROCESSID 
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MACHINEID = f.VALUEID)
/************************************************************************************/
/*                          Main query                                              */
/************************************************************************************/
  
-- Report frame. It contains all sources, for which data sould be selected, 
-- and date values accordingly to specified period and grouping type.  
   ;WITH SourcesDates AS
    (
        SELECT
            VALUEID AS sourceid,
            s.SOURCE AS source,
            Hours.n-1 AS hours,
            D.date AS date
        FROM
            #SOURCEMACHINEFILTERTABLE AS source
            JOIN APM.source (NOLOCK) AS s ON s.SOURCEID = source.VALUEID,
            APM.fn_nums(                
                (CASE
                    WHEN @GROUPBY = 'WeekDay' THEN 24
                    ELSE 1
                END)) AS Hours,
            (SELECT
                (CASE
                    WHEN @GROUPBY = 'Hour' THEN n-1
                    WHEN @GROUPBY = 'WeekDay' THEN n
                    WHEN @GROUPBY = 'MonthDay' THEN n
                END) AS date
            FROM 
                APM.fn_nums(
                    CASE
                        WHEN @GROUPBY = 'Hour' THEN 24
                        WHEN @GROUPBY = 'WeekDay' THEN 7
                        WHEN @GROUPBY = 'MonthDay' THEN 31
                    END     
                )           
            ) AS D
        WHERE
            source.TYPEID = 1
    ),
-- Get sources name, ids list separated by comma per app pool
-- This info should be selected for all sources, even they are in the same application pool
-- as in this report grouping by source is applied not by application pool.
    AppPoolInfo AS 
    (
        SELECT 
            c.SOURCEID,
            c.EXTRAINFO,
            c.PROCESS,
            -- all source names which have the same process name as passed in @SOURCEIDS
            (SELECT A.source AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        N'''' + s.source + N'''' +  N',' AS source
                    FROM 
                        #PROCESSFORSOURCE AS c1
                        JOIN APM.Source AS s ON c1.SOURCEID = s.SourceId
                    WHERE 
                        c1.EXTRAINFO = c.EXTRAINFO 
                        AND c1.PROCESS = c.PROCESS
                        AND c1.MACHINEID = c.MACHINEID
                ) AS A
                FOR XML PATH ('') 
            ) AS AppPoolSources
        FROM
            #PROCESSFORSOURCE AS c
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
        GROUP BY
            c.SOURCEID, 
            c.MACHINEID,
            c.EXTRAINFO,
            c.PROCESS
    ),
    --Add Pool name in-front of source list, if it is executable application, then app pool countains source name
    PrepareAppPoolInfo AS (
        SELECT DISTINCT
            CASE 
                WHEN COALESCE(info.EXTRAINFO,'') = '' THEN CASE info.AppPoolSources WHEN '' THEN '' ELSE LEFT(info.AppPoolSources, LEN(info.AppPoolSources)-1) END
                ELSE info.EXTRAINFO + CASE info.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(info.AppPoolSources, LEN(info.AppPoolSources) - 1) + ')' END
            END AppPool,
            info.SOURCEID,
            info.EXTRAINFO
        FROM 
            AppPoolInfo AS info
    ),
-- Forms application pool list for each source
-- Format: AppPool1 ('Source1', 'Source2', Source3), AppPool2 ('Source1', 'Source4')
    SourceAppPools AS (
        SELECT 
            s.SOURCEID,
            s.SOURCE,
            COALESCE((SELECT a.AppPool AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        info.AppPool +  N',' AS AppPool
                    FROM 
                        PrepareAppPoolInfo as info
                    WHERE 
                        info.Sourceid = s.Sourceid 
                ) AS A
                FOR XML PATH ('') 
            ),s.SOURCE +  '-') AS AppPoolInfo
        FROM 
            APM.Source AS s
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = s.SOURCEID)
    ),    
--Prepares and filters events for further manipulations
    ActivityBreakdown_EventsFiltered AS
    (
        SELECT
            e.SOURCEID,
            e.EVENTID,
            e.UTCEVENTDATE AS eventdate,
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate))
            END as date,
            CASE 
                WHEN @GROUPBY = 'WeekDay' 
                    THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate)) 
                ELSE 0 
            END AS Hour,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, e.UTCEVENTDATE, @STARTDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId,
            e.EVENTGROUPID,
            db.ADDRESS AS SeViewerAddress
        FROM
            APM.Event AS e
            JOIN APM.SeViewerDB AS db ON e.SEVIEWERDBID = db.SEVIEWERDBID
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID and f2.TYPEID = 2)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)              
        WHERE
            ((e.EVENTCLASSTYPE = N'Performance' AND e.EVENTDURATION / 1000000.0 &gt;= @THRESHOLD) 
            OR e.EVENTCLASSTYPE = N'exception')
            AND (e.CATEGORY LIKE @PROBLEM OR e.CATEGORY IS NULL)
            AND e.UTCEVENTDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND e.UTCEVENTDATE &lt; @ENDDATE
            AND (e.HEAVYLIGHT &lt;&gt; 0 OR e.HeavyLight IS NULL)
    ),
    /************************************************************************************/
    /*                          Base pcounter queries                                   */
    /************************************************************************************/
    -- Calculate resource utilization by Source in one hour.
    -- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE,
            ph.PCTYPEID AS Type,    
            
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN SUM(ph.SAMPLECOUNT)*1.0/MAX(ph.PACKAGECOUNTER)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,   
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate))
            END as Date,
            (CASE WHEN @GROUPBY = 'WeekDay' THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int),  ph.UTCDate)) ELSE 0 END) AS Hours,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, ph.UTCDATE, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SOURCEID)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MACHINEID)
        WHERE
            ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDATE &lt; @ENDDATE
            AND ph.PCTYPEID IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE,
            ph.PCTYPEID
    )
    ,
--Calculate average source resource utilization for each resource type
--and for specified grouping period and date          
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilization AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours
    ),
    -- Count Monitored Requests and Avg. Request Time for Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MACHINEID,
            ph.SOURCEID,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END)  
            END AS LastMonRequest,
            CASE WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END) 
            END AS CurMonRequest,
            CASE WHEN ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTYPEID = @MONITOREDREQUESTCOUNTERID THEN ph.SUMVALUE END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UTCDATE &gt;= @LASTPERIODSTARTDATE AND ph.UTCDATE &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UTCDATE &gt;= @STARTDATE AND ph.UTCDATE &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTYPEID = @REQUESTTIMECOUNTERID THEN ph.SUMVALUE / ph.SAMPLECOUNT END) 
            END AS AvgReqTime,
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @GROUPBY 
            WHEN 'Hour' THEN Datepart(hh, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            WHEN 'WeekDay' THEN Datepart(dw, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            WHEN 'MonthDay' THEN Datepart(d, DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDATE))
            END as Date,
            (CASE WHEN @GROUPBY = 'WeekDay' THEN DatePart(Hour, DATEADD(mi, CAST(@TIMEZONE AS int),  ph.UTCDATE)) ELSE 0 END) AS Hours,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, ph.UTCDATE, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SOURCEID = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MACHINEID)
        WHERE
            ph.UTCDATE &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDATE &lt; @ENDDATE
            AND ph.PCTYPEID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MACHINEID,
            ph.SOURCEID,
            ph.UTCDATE
    ),
--Calculate average request time  and  sum request count for specified grouping period and date          
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByMachinePrepare ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.Date,
            ph.Hours
    ),
--  Union .NET counters and process counters for period Id. Period Id differs only for average(last three months) values, so grouping only for them
    PCountersGroupedByMachineId AS (
        SELECT 
            pc.machineId,
            pc.SourceId,
            pc.Hours,
            pc.date,
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM ApplicationResourceUtilizationByMachines pc
       LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId 
                AND netApp.Hours = pc.Hours AND netApp.Date = pc.Date 
        GROUP BY
            pc.machineId,
            pc.SourceId,
            pc.Hours,
            pc.date
    ),
-- Calculate average source resource utilization between machines  
    ActivePreparePCounters AS (
        SELECT 
            pc.SourceId,
            pc.Hours,
            pc.date,            
            SUM(CurReqCount) AS CurReqCount, 
            SUM(LastReqCount) AS LastReqCount,
            SUM(AvgReqCount) AS AvgReqCount,
            AVG(CurAvgReqTime) AS CurAvgReqTime, 
            AVG(LastAvgReqTime) AS LastAvgReqTime,
            AVG(AvgReqTime) AS AvgReqTime,
            AVG(CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(LastCPUSum / COALESCE(m.CPUCount, 1) ) AS LastCPUSum,
            AVG(AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(CurMemSum) AS CurMemSum, 
            AVG(LastMemSum) AS LastMemSum,
            AVG(AvgMemSum) AS AvgMemSum,
            AVG(CurIOSum) AS CurIOSum, 
            AVG(LastIOSum) AS LastIOSum,
            AVG(AvgIOSum) AS AvgIOSum
        FROM 
            PCountersGroupedByMachineId pc
            JOIN APM.Machine AS m ON m.MACHINEID = pc.MachineId
        GROUP BY    
            pc.SourceId,
            pc.Hours,
            pc.date
    ),
--Count events for the current, last and average period. PeriodId differs only for average
    PrepareEventsAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.date,
            e.hour,
            e.PeriodId,         
            MAX(E.SeViewerAddress) AS SeViewerAddress,  
            COUNT(CASE WHEN e.eventdate &gt;= @STARTDATE AND e.eventdate &lt; @ENDDATE THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.eventdate &gt;= @LASTPERIODSTARTDATE  AND e.eventdate &lt; @STARTDATE THEN eventid END) AS LasEventsCount,
            COUNT(CASE WHEN E.eventdate &gt;= @AVERAGEPERIODSTARTDATE AND E.eventdate &lt; @STARTDATE THEN eventid END) AS AvgEventsCount
        FROM
            ActivityBreakdown_EventsFiltered AS e
        GROUP BY 
            sourceid,
            PeriodId,
            e.date,
            e.hour
    ),
    Events AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.date,
            e.hour,
            MAX(E.SeViewerAddress) AS SeViewerAddress,
            --PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LasEventsCount) AS LasEventsCount,
            --Average counting is not included current period
            AVG(AvgEventsCount) AS AvgEventsCount
        FROM
            PrepareEventsAvg AS e
        GROUP BY 
            sourceid,
            e.date,
            e.hour  
    ),
    MachineCPUUndefinedFlag AS
    (
        SELECT
            sf.SOURCEID,
            MIN(COALESCE(m.CPUCOUNT, -1)) AS CPUUndefinedFlag
        FROM
            #PROCESSFORSOURCE AS sf
            JOIN APM.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MACHINEID
        GROUP BY
            sf.SOURCEID
    )
    SELECT
    -- This fake fields is need to provide compatibility with SP ApplicationStatusDrillthrough
    GetDate() AS ClientDate,
        SourcesDates.date AS Date,
        SourcesDates.Hours AS Hours,
        SourcesDates.Sourceid,
        SourcesDates.Source AS Source,
--Period is used to organize result values, for example if @PERIOD is Day and @ENDDATE = '05/06/2009 13:00', 
--this value should put 23 hour of 05/05/2009 before 10 hour of 05/06/2009
        (CASE 
            WHEN (SourcesDates.date - APM.GetDatePart(@GROUPBY, DATEADD(mi, CAST(@TIMEZONE AS int), @ENDDATE))
            ) &lt; 0 THEN 0
            WHEN (SourcesDates.date - APM.GetDatePart(@GROUPBY, DATEADD(mi, CAST(@TIMEZONE AS int), @ENDDATE))
            ) &gt;= 0 THEN 1
        END) AS Period,
        COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
        COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
        COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
        COALESCE(pc.CurAvgReqTime, 0) AS CurAvgReqTime,
        COALESCE(pc.LastAvgReqTime, 0) AS LastAvgReqTime,
        COALESCE(pc.AvgReqTime, 0) AS AvgReqTime,
        COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
        COALESCE(pc.lastCPUSum, 0) AS LastCPUValue,
        COALESCE(pc.AvgCPUSum, 0) AS AvgValue,
        COALESCE(pc.CurMemSum, 0) AS CurMemValue,
        COALESCE(pc.LastMemSum, 0) AS LastMemValue,
        COALESCE(pc.AvgMemSum, 0) AS AvgMemValue,
        COALESCE(pc.CurIOSum, 0) AS CurIOValue,
        COALESCE(pc.LastIOSum, 0) AS LastIOValue,
        COALESCE(pc.AvgIOSum, 0) AS AvgIOValue,
        COALESCE(e.CurrentEventsCount, 0) AS NewEventsCount,
        COALESCE(e.LasEventsCount, 0) AS OldEventsCount,
        COALESCE(e.AvgEventsCount, 0) AS AvgEventsCount,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one process PCounter row
        -- in PerfHourly table for specified period. If so there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag,
        (CASE 
            WHEN (@GROUPBY = 'Hour' AND ((SourcesDates.date % 2) = 0)) THEN  SourcesDates.date
            WHEN (@GROUPBY = 'WeekDay' AND ((SourcesDates.Hours + 12) % 24) = 0) THEN  SourcesDates.date
            WHEN (@GROUPBY = 'MonthDay') THEN  SourcesDates.date
            ELSE -1
        END) AS OutputDate,
        CASE LEFT(AppPool.AppPoolInfo,1) 
            WHEN N'''' THEN N'' 
            WHEN N'' THEN ''
            ELSE REPLACE(LEFT(AppPool.AppPoolInfo, LEN(AppPool.AppPoolInfo)-1), N'''', N'')
        END AS pool,
        E.SeViewerAddress
    FROM 
        SourcesDates
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON SourcesDates.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ActivePreparePCounters AS pc ON (pc.date = SourcesDates.date AND pc.SourceId = SourcesDates.Sourceid AND SourcesDates.Hours = pc.Hours)
        LEFT OUTER JOIN Events AS e ON (e.date = SourcesDates.date AND e.Sourceid = SourcesDates.Sourceid AND e.hour = SourcesDates.Hours)
        JOIN SourceAppPools AS AppPool ON (AppPool.Sourceid = SourcesDates.Sourceid)
    ORDER BY    
        Source, 
        Period DESC, 
        Date, 
        Hours 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.Application_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.Application_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: Application_sync                                                           */
/* USED IN: Synchronization of SE-Viewer.'Application' table.                       */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE APM.Application_sync
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'Application_sync', @EXECRESULT)
    END
    
    DECLARE @APPLICATION TABLE (
       application  nvarchar(255) collate database_default  NOT NULL
    )
    
    ----Fill table from package
    INSERT @APPLICATION (
       application
    )
    SELECT
       application
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    application  nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    --insert not existing applications
    INSERT APM.application (application,type)
    SELECT DISTINCT sync.application , 3
    FROM @APPLICATION sync
    WHERE NOT EXISTS (SELECT * FROM APM.application a WHERE (a.application = sync.application))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationSourceMachine_sync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationSourceMachine_sync AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationSourceMachine_sync                                              */
/* USED IN: Synchronization of SE_VIEWER:'applicationsourcemachine' table.          */
/* Call by Intercept Reporting Services                                             */
/* INPUT PARAMETERS:                                                                */
/*      @OBJECTKEYXML - xml package syncronization data                             */
/*      @TRACELEVEL - trace level. Reserved.                                        */
/* OUTPUT PARAMETERS:                                                               */
/*      @ROWNOTAFFECTED - number of records from package which haven't been         */
/*      synchronized.Reserved.                                                      */
/* Note:                                                                            */
/* If there are records which have not been transferred that they have been already */
/* transferred from other SEVIEWER database earlier. Any other reason will cause a  */
/* exception at an insert                                                           */
/************************************************************************************/
ALTER PROCEDURE [APM].[ApplicationSourceMachine_sync]
  @OBJECTKEYXML       ntext,
  @TRACELEVEL         int, 
  @ROWNOTAFFECTED     int output
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        bit
    ,@ERRORMESSAGE    nvarchar(max)
    ,@ERRORNUMBER     int
    ,@ERRORSEVERITY   int
    ,@ERRORSTATE      int
    ,@ERRORLINE       int
    ,@ERRORPROCEDURE  nvarchar(256)
    ,@ERRORMESSAGETEXT nvarchar(max)
  SET @ERRORIND = 0
  BEGIN TRY
    SET @ROWNOTAFFECTED = 0
    
    DECLARE 
       @EXECRESULT      int
      ,@XMLDOCHANDLE    int
      ,@ERROR_MESSAGE     nvarchar(max)      
    EXEC @EXECRESULT = sp_xml_preparedocument @XMLDOCHANDLE OUTPUT, @OBJECTKEYXML
    IF @EXECRESULT &lt;&gt; 0 
    BEGIN
      SELECT  @ERROR_MESSAGE = message FROM APM.messages WHERE id = 50002   
      RAISERROR(@ERROR_MESSAGE, 16, 1, 'ApplicationSourceMachine_sync', @EXECRESULT)
    END
    
    DECLARE @APPLICATIONSOURCEMACHINE TABLE (
        application nvarchar(255) collate database_default  NOT NULL,
        source          nvarchar(255) collate database_default          ,
        machine         nvarchar(255) collate database_default  
    )
    
    ----Fill table from package
    INSERT @APPLICATIONSOURCEMACHINE(
       application,source,machine
    )
    SELECT
       application,source,machinename
    FROM OPENXML(@XMLDOCHANDLE, 'rows/row', 2) WITH (
                    application  nvarchar(255),
                    source nvarchar(255),
                    machinename nvarchar(255) ) xml
    EXEC sp_xml_removedocument @XMLDOCHANDLE
    
    SET @XMLDOCHANDLE = NULL
    
    DECLARE @ALLAPPID int
    DECLARE @NEWMACHINES TABLE (machineId int)
    
	----- machine can be removed using "Remove computers wizard" so it is need synchronize machines ----                 
	INSERT APM.MACHINE (MACHINE) OUTPUT INSERTED.MACHINEID INTO @NEWMACHINES
	   SELECT DISTINCT machine FROM @APPLICATIONSOURCEMACHINE app
		   WHERE NOT EXISTS (SELECT * FROM APM.machine m (NOLOCK) WHERE m.machine = app.machine) AND app.machine IS NOT NULL 
		   
    IF EXISTS(SELECT * FROM @NEWMACHINES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new sources      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.SourceId 
           ,m.machineId
        FROM 
           APM.SOURCE (NOLOCK) AS s
		   CROSS JOIN @NEWMACHINES as m 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceId AND a.APPLICATIONID = @ALLAPPID AND m.machineId = a.machineid
		   )	                    
    END
    ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
    DECLARE @NEWSOURCES TABLE (sourceid int)
		   
	  ----- sources can be removed using "Remove applications wizard" so it is need synchronize sources ----                 
	INSERT APM.SOURCE (SOURCE) OUTPUT INSERTED.SOURCEID INTO @NEWSOURCES  
	  SELECT DISTINCT source FROM @APPLICATIONSOURCEMACHINE app
		 WHERE NOT EXISTS (SELECT * FROM APM.source s (NOLOCK) WHERE s.source = app.source) AND app.source IS NOT NULL
    
    IF EXISTS(SELECT * FROM @NEWSOURCES) 
    BEGIN
        IF @ALLAPPID IS NULL
			SELECT @ALLAPPID = APPLICATIONID FROM APM.APPLICATION (NOLOCK) WHERE APPLICATION = N'All'
  	    ---- it is need to create the links with 'All' application group for new machines      
		INSERT APM.APPLICATIONSOURCEMACHINE
        ( APPLICATIONID ,
          SOURCEID ,
          MACHINEID
        )
        SELECT 
           @ALLAPPID
           ,s.sourceid 
           ,m.machineId
        FROM 
           APM.MACHINE (NOLOCK) AS m
		   CROSS JOIN @NEWSOURCES as s 
		WHERE
		   NOT EXISTS
		   (
		      SELECT * FROM APM.APPLICATIONSOURCEMACHINE (NOLOCK) AS a 
		          WHERE a.SOURCEID = s.sourceid AND a.APPLICATIONID = @ALLAPPID AND m.MACHINEid = a.machineid
		   )	                    
    END
    --insert not existing rows
    --don't transfers rows with source is not found or machine is not found
    INSERT APM.applicationsourcemachine (applicationid,sourceid,machineid)
    SELECT DISTINCT a.applicationid,s.sourceid,m.machineid
    FROM    @APPLICATIONSOURCEMACHINE sync
            JOIN APM.Application a  ON a.application = sync.application
            JOIN APM.Source s       ON s.source = sync.source
            JOIN APM.Machine m      ON m.machine = sync.machine
    WHERE NOT EXISTS (  SELECT * FROM APM.applicationsourcemachine asm 
                        WHERE ( asm.applicationid = a.applicationid AND
                                asm.sourceid = s.sourceid AND
                                asm.machineid = m.machineid
                                ))
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  IF @XMLDOCHANDLE IS NOT NULL
    EXEC sp_xml_removedocument @XMLDOCHANDLE
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryQualityAnalysis'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryQualityAnalysis AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryQualityAnalysis                                                     */
/* USED IN: SummaryQualityAnalysisSubReport.rdl                                     */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/*      @TRESHOLD    - Event duration treshold                                      */
/*      @PROBLEM     - Event problem type (all, critical)                           */
/************************************************************************************/
ALTER PROCEDURE [APM].[SummaryQualityAnalysis] 
    @SOURCEID NVARCHAR(255),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @THRESHOLD  INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50) WITH RECOMPILE
AS
BEGIN
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEID, @COMPUTERIDS) AS p
                
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p                
  CREATE TABLE #SUMMARYQUALITYANALYSISTMP 
  (
    ID int,
    RESOURCE nvarchar(255) collate database_default,
    RESTYPE nvarchar(50) collate database_default,
    RESCOUNT int,
    FAILCOUNT int,
    CONNCOUNT int,
    PERFCOUNT int,
    SECCOUNT int 
  ) 
  INSERT INTO #SUMMARYQUALITYANALYSISTMP
    SELECT 
        ROW_NUMBER() OVER (ORDER BY COUNT(e.eventid) desc) AS ID,
        r.resourceuri AS RESOURCE,
        rg.name AS RESTYPE,
        COUNT(e.eventid) AS RESCOUNT,
        COUNT(CASE aspect WHEN 'applicationfailure' THEN 1 END) AS FAILCOUNT, 
        COUNT(CASE aspect WHEN 'connectivity' THEN 1  END) AS CONNCOUNT, 
        COUNT(CASE aspect WHEN 'performance' THEN 1  END) AS PERFCOUNT, 
        COUNT(CASE aspect WHEN 'security' THEN 1  END) AS SECCOUNT
    FROM 
        APM.event AS e (NOLOCK) 
        JOIN APM.resource AS r (NOLOCK) on  e.resourceid = r.resourceid
        JOIN APM.resourcegroup AS rg (NOLOCK) on r.resourcegroupid = rg.resourcegroupid
        JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND f.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)            
    WHERE 
        ((e.aspect = 'performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD) OR 
        e.aspect IN ('applicationfailure', 'connectivity', 'security'))
        AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
        AND e.sourceId = @SOURCEID
        AND e.utceventdate &gt;= @STARTDATE AND e.utceventdate &lt; @ENDDATE
        AND (e.category LIKE @PROBLEM OR e.category IS NULL)
    GROUP BY
        r.resourceuri, rg.name
    /*------------------ Base query -------------------------- */
    SELECT TOP 5
        R1.ID,
        R1.RESOURCE, 
        R1.RESTYPE as RESTYPE,
        R1.RESCOUNT, 
        R1.FAILCOUNT,
        R1.CONNCOUNT,
        R1.SECCOUNT,
        R1.PERFCOUNT, 
        R1.RESCOUNT + (
            SELECT CASE WHEN SUM(r2.RESCOUNT) IS NULL THEN 0 ELSE SUM(r2.RESCOUNT) END 
            FROM #SUMMARYQUALITYANALYSISTMP r2
            WHERE r2.ID &lt; r1.ID
        ) AS runValue,
        SUM(RESCOUNT) OVER() AS AllCount
    FROM 
       #SUMMARYQUALITYANALYSISTMP AS R1 
    ORDER BY 
       ID 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisReport                                                  */
/* USED IN: Summary Size Analysis Report                                            */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Page Content Size                                            */
/*                  2. Ajax Size                                                    */
/*                  3. Total Size                                                   */
/*                  4. Event Count                                                  */
/*                  5. Event Duration                                               */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50) 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    CSEVENTID,
    SOURCEID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID AND f2.TYPEID = 2)
    JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS) 
WHERE 
    e.PAGEURI IS NOT NULL 
    AND e.CLASSTYPE = N'Performance' 
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        0 AS IsPageEvent,
        ajax.TOTALTIME AS TotalTime,
        ajax.RESPONSESIZE + ajax.REQUESTSIZE AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEVENTID    
),
JSEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        0 AS IsPageEvent,
        js.TOTALTIME AS TotalTime,
        NULL AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON e.CSEVENTID = js.CSEVENTID
),
PageEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        1 AS IsPageEvent,
        p.TOTALTIME AS TotalTime,
        p.TOTALSIZE AS TotalSize
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
),
UnionEvents AS
(
    SELECT * FROM AJAXEvents
    UNION ALL
    SELECT * FROM JSEvents
    UNION ALL
    SELECT * FROM PageEvents
),
EventAggregation AS
(
    SELECT 
        SOURCEID,
        CSEVENTID,
        MAX(IsPageEvent) AS IsPageEvent,
        MAX(TotalTime) AS TotalTime,        
        SUM(TotalSize) AS TotalSize
    FROM 
        UnionEvents
    GROUP BY 
        SOURCEID, 
        CSEVENTID
), 
SourceAggregation AS
(
    SELECT 
        SOURCEID,
        COUNT(*) AS EventCount,
        AVG(TotalTime) / 1000.0 AS EventDuration,
        -- Take into account AJAX call size, which occured during page load event
        AVG(CASE WHEN IsPageEvent = 1 THEN TotalSize END) / 1024.0 AS PageContentSize,
        AVG(TotalSize) / 1024.0 AS TotalSize,
        -- Calculate AJAX size only for JS with AJAX and for Asynch AJAX events 
        AVG(CASE WHEN IsPageEvent = 0 THEN TotalSize END) / 1024.0 AS AjaxSize
    FROM 
        EventAggregation
    GROUP BY 
        SOURCEID
)
SELECT TOP(10)
    Row_Number() OVER(ORDER BY 
                        CASE    
                            WHEN @ORDERBY = 1 THEN ds.PageContentSize
                            WHEN @ORDERBY = 2 THEN ds.AjaxSize 
                            WHEN @ORDERBY = 3 THEN ds.TotalSize
                            WHEN @ORDERBY = 4 THEN ds.EventCount
                            WHEN @ORDERBY = 5 THEN ds.EventDuration
                        END DESC) AS Id,
        ds.SOURCEID,
        s.SOURCE,
        ds.EventCount,
        ds.EventDuration,
        ds.PageContentSize,
        ds.TotalSize,
        ds.AjaxSize
FROM 
    SourceAggregation AS ds
    JOIN APM.Source AS s (NOLOCK) ON s.SOURCEID = ds.SOURCEID
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisTopAJAXSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisTopAJAXSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisTopAJAXSubReport                                        */
/* USED IN: Summary Size Analysis Sub Report for top AJAX call                      */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Source Id                                                       */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisTopAJAXSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50) 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids 
-- valueId filter value for machineId
CREATE TABLE #MACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #AJAXEVENT 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    AJAXURI NVARCHAR(255) collate database_default,
    AJAXDURATION DECIMAL(35, 0),
    RESPONSESIZE BIGINT,
    REQUESTSIZE BIGINT
)
INSERT INTO #AJAXEVENT
SELECT
    e.CSEventId,
    e.PageUri,
    ajax.Uri,
    ajax.TotalTime,
    ajax.ResponseSize,
    ajax.REQUESTSIZE
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON f.VALUEID = e.MACHINEID
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMSTATUS)     
    CROSS APPLY (
            SELECT TOP(1)
                ajax.Uri,
                ajax.TotalTime,
                ajax.RESPONSESIZE,
                ajax.REQUESTSIZE
            FROM
                APM.CSAJAX AS ajax (NOLOCK)
            WHERE
                ajax.CSEVENTID = e.CSEVENTID 
            ORDER BY 
                ajax.TOTALTIME DESC
            ) AS ajax 
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
    -- collected ajax calls except for page sync ajax calls 
    AND e.EVENTCLASS &lt;&gt; N'CSMPMonitorLog'
CREATE INDEX idx_Event ON #AJAXEVENT (CSEVENTID) 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
;WITH EventDuration AS
(
    SELECT 
        a.CSEVENTID,
        a.PAGEURI,
        a.AJAXURI,
        a.AJAXDURATION AS AJAXDuration,
        a.RESPONSESIZE,
        a.REQUESTSIZE
    FROM 
        #AJAXEVENT AS a
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON a.CSEVENTID = js.cseventid
),
AJAXSize AS
(
    SELECT
        COUNT(CSEventId) AS EventCount,
        PageUri,
        AJAXUri,
        AVG(AJAXDuration) AS AJAXDuration,
        AVG(ResponseSize) AS ResponseSize,
        AVG(RequestSize) AS RequestSize,
        AVG(ResponseSize + RequestSize) AS TotalSize
    FROM 
        EventDuration
    GROUP BY
        PageUri,
        AJAXUri     
),
NumberedRow AS
(
    SELECT
        Row_Number() OVER(ORDER BY TotalSize DESC) AS Id,
        EventCount,
        PageUri,
        AJAXUri,
        AJAXDuration/1000.0 AS AJAXDuration,
        ResponseSize/1024.0 AS ResponseSize,
        RequestSize/1024.0 AS RequestSize,
        TotalSize/1024.0 AS TotalSize,
        SUM(EventCount) OVER() AS TotalEventCount
    FROM
        AJAXSize
)
    SELECT TOP(4)
        Id,
        EventCount,
        PageUri,
        AJAXUri AS AjaxCall,
        AJAXDuration,
        ResponseSize,
        RequestSize,
        TotalSize,
        TotalEventCount
    FROM
        NumberedRow
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummarySizeAnalysisTopPagesSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummarySizeAnalysisTopPagesSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummarySizeAnalysisTopPagesSubReport                                       */
/* USED IN: Summary Size Analysis Sub Report for top pages                          */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Source Id                                                       */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Image Size                                                   */
/*                  2. CssStyle Size                                                */
/*                  3. Htc Size                                                     */
/*                  4. Script Size                                                  */
/*                  5. HTML Size                                                    */
/*                  6. AjaxSize Size                                                */
/*                  7. TotalSize Size                                               */
/*                  8. Event Count                                                  */
/*                  9. Avg. Event Duration                                          */
/************************************************************************************/
ALTER PROCEDURE APM.SummarySizeAnalysisTopPagesSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids 
-- valueId filter value for machineid 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #PAGEEVENT 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    TOTALTIME DECIMAL(35, 0),
    TOTALSIZE DECIMAL(35, 0)
)
INSERT INTO #PAGEEVENT
SELECT
    e.CSEVENTID,
    e.PAGEURI,
    P.TOTALTIME,
    P.TOTALSIZE
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMSTATUS)         
    JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
WHERE 
    e.PAGEURI IS NOT NULL 
    AND e.SOURCEID = @SOURCEID
    AND e.CLASSTYPE = N'Performance' 
    AND e.SOURCEID &lt;&gt; -1
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                      MAIN QUERY                                                      */
/****************************************************************************************/
--Before grouping by page uri, event content with Null size should by transformed to 0,
-- to provide convergence with Avg total size
;WITH PeripheralSize AS
(
    SELECT 
        e.CSEVENTID,
        SUM(CASE WHEN p.TYPE = N'Image' THEN p.TotalSize END) AS Image,
        SUM(CASE WHEN p.TYPE = N'Script' THEN p.TotalSize END) AS Script,
        SUM(CASE WHEN p.TYPE = N'CssStyle' THEN p.TotalSize END) AS CssStyle,
        SUM(CASE WHEN p.TYPE = N'HtcBehavior' THEN p.TotalSize END) AS HtcBehavior,
        SUM(CASE WHEN p.TYPE = N'HTML' THEN p.TotalSize END) AS HTML
    FROM 
        APM.CSPeripheral AS p (NOLOCK) 
        JOIN  #PAGEEVENT AS e ON p.cseventid = e.CSEVENTID
    GROUP BY
        e.CSEVENTID
),
PageSize AS
(
    SELECT
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(COALESCE(p.Image, 0)) AS Image,
        AVG(COALESCE(p.Script, 0)) AS Script,
        AVG(COALESCE(p.CssStyle, 0)) AS CssStyle,
        AVG(COALESCE(p.HtcBehavior, 0)) AS HtcBehavior,
        AVG(COALESCE(p.HTML, 0)) AS HTML,
        AVG(e.TOTALTIME) AS EventDuration,
        AVG(e.TOTALSIZE) AS TotalSize
    FROM
        #PAGEEVENT AS e
        LEFT OUTER JOIN PeripheralSize AS p ON p.CSEventid = e.CSEVENTID
    GROUP BY 
        e.PAGEURI
),
AJAXSize AS
(
    SELECT 
        a.PageUri,
        AVG(a.AjaxSize) AS AjaxSize
    FROM
    (
        SELECT
            e.CSEVENTID,
            e.PAGEURI,
            SUM(COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0)) AS AjaxSize
        FROM 
            #PAGEEVENT AS e
            JOIN APM.CSAJAX AS ajax (NOLOCK) ON (ajax.CSEventId = e.CSEVENTID)
        GROUP BY
            e.CSEVENTID,
            e.PAGEURI
    ) AS a
    GROUP BY
        a.PageUri
),
NumberedResults AS
(
    SELECT  
        Row_Number() OVER(ORDER BY 
                            CASE    
                                WHEN @ORDERBY = 1 THEN p.Image
                                WHEN @ORDERBY = 2 THEN p.CssStyle
                                WHEN @ORDERBY = 3 THEN p.HtcBehavior
                                WHEN @ORDERBY = 4 THEN p.Script
                                WHEN @ORDERBY = 5 THEN p.HTML
                                WHEN @ORDERBY = 6 THEN ajax.AjaxSize
                                WHEN @ORDERBY = 7 THEN p.TotalSize + COALESCE(ajax.AjaxSize, 0)
                                WHEN @ORDERBY = 8 THEN p.EventCount
                                WHEN @ORDERBY = 9 THEN p.EventDuration
                            END DESC) AS Id,
        p.PageUri,
        p.EventCount,
        p.Image/(1024.0) AS Image,
        p.Script/(1024.0) AS Script,
        p.CssStyle/(1024.0) AS CssStyle,
        p.HtcBehavior/(1024.0) AS HtcBehavior,
        p.HTML/(1024.0) AS HTML,
        p.EventDuration/(1000.0) AS EventDuration,
        (p.TotalSize + COALESCE(ajax.AjaxSize, 0))/(1024.0) AS TotalSize,
        COALESCE(ajax.AjaxSize, 0)/(1024.0) AS AjaxSize,
        SUM(p.EventCount) OVER() AS TotalEventCount
    FROM
        PageSize AS p
        LEFT OUTER JOIN AJAXSize AS ajax ON Ajax.PageUri = p.PageUri
)
SELECT TOP(4) 
    Id,
    PageUri,
    EventCount,
    Image,
    Script,
    CssStyle,
    HtcBehavior,
    HTML,
    EventDuration,
    TotalSize,
    AjaxSize,
    TotalEventCount
FROM
    NumberedResults
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.TopUserPerformanceIssues'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.TopUserPerformanceIssues AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: TopUserPerformanceIssues                                                   */
/* USED IN: Top5UserPerformanceSubReport.rdl                                        */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/*      @TRESHOLD    - Event duration treshold                                      */
/************************************************************************************/
ALTER PROCEDURE [APM].[TopUserPerformanceIssues] 
(
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @THRESHOLD  INT,
    @USERNAME NVARCHAR(255),
	@PMSTATUS NVARCHAR(50)
) WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    CREATE TABLE #SUMUSERANALYSIS 
    (
        DESCRIPTION nvarchar(255) collate database_default,
        USERID int,
        USERFLAG BIT,
        SOURCEID int,
        EVENTCOUNT int,
        USERSUMSLOWESTNODEDUR decimal(35,0),
        USERCOUNTSLOWESTNODEDUR int,
        SLOWESTNODEDUR decimal(35,0),
        COUNTSLOWESTNODDUR int
    )
-- Select performance event information for all users
;WITH UsersInfo AS
(
    SELECT 
        pn.description AS Description,
        MIN(e.UserId) AS UserId,
        CASE u.Name WHEN @USERNAME THEN 1 ELSE 0 END AS UserFlag,
        e.sourceId,
        COUNT(e.EVENTID) AS EventCount,
        SUM(CASE u.Name WHEN @USERNAME THEN pn.selfduration END) AS  UserSumSlowestNodeDur,
        COUNT(CASE u.Name WHEN @USERNAME THEN e.EVENTID END) AS UserCountSlowestNodeDur,
        SUM(pn.selfduration) AS  SlowestNodeDur,
        COUNT(pn.selfduration) AS CountSlowestNodeDur
    FROM 
        APM.EVENT AS e
        JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
        JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)
        CROSS APPLY(SELECT TOP(1) pn1.SelfDuration, pn1.Description 
                        FROM 
                            APM.PerformanceNode AS pn1 
                        WHERE 
                            pn1.eventid = e.eventid 
                            AND pn1.resourceid = e.resourceid
                        ORDER BY
                            pn1.SelfDuration DESC) AS pn
        JOIN APM.Users AS u ON e.userid = u.userid
    WHERE
        E.UTCEVENTDATE &gt; @STARTDATE
        AND E.UTCEVENTDATE &lt; @ENDDATE
        AND E.EVENTDURATION / 1000000.0 &gt;= @THRESHOLD
        AND E.ASPECT = N'performance'
        AND COALESCE(E.HeavyLight, 1) &lt;&gt; 0
    GROUP BY
        e.sourceid, 
        pn.description,
        u.name
)
INSERT #SUMUSERANALYSIS 
SELECT 
    DESCRIPTION,
    USERID,
    USERFLAG,
    SOURCEID,
    EVENTCOUNT,
    USERSUMSLOWESTNODEDUR,
    USERCOUNTSLOWESTNODEDUR,
    SLOWESTNODEDUR,
    COUNTSLOWESTNODEDUR
FROM UsersInfo
CREATE INDEX temp1_idx ON  #SUMUSERANALYSIS(DESCRIPTION, SOURCEID) INCLUDE (USERID, EVENTCOUNT, SLOWESTNODEDUR)
-- Select information for current user
;WITH OrderedDataSet AS
(
    SELECT 
        u.DESCRIPTION,
        u.SOURCEID,      
        u.EVENTCOUNT,
        CASE 
            WHEN u.USERCOUNTSLOWESTNODEDUR &lt;&gt;0 THEN u.USERSUMSLOWESTNODEDUR / (u.USERCOUNTSLOWESTNODEDUR * 1000)
            ELSE 0
        END AS SlowestNodeDur
    FROM
        #SUMUSERANALYSIS AS u
    WHERE 
        u.USERFLAG = 1
),
--Select top 5 performance event for user
TopDataSet AS
(
   SELECT  TOP 5
     ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id, 
     1 AS UserId,   
     description,
     sourceId,
     EventCount,
     SlowestNodeDur,   
     EventCount AS SumEventCount,
     SUM(EventCount) OVER() AS TotalEventCount,
     0 AS UsersAffected
  FROM 
    OrderedDataSet
),
-- Calculate information for all users, but only for top 5 performence events 
EachUserInfo AS
(
    SELECT 
      f.Id,
      UserStat.DESCRIPTION,
      UserStat.SOURCEID,
      UserStat.EVENTCOUNT,
      UserStat.SLOWESTNODEDUR,
      UserStat.USERID
    FROM 
      #SUMUSERANALYSIS UserStat
      JOIN TopDataSet AS f ON (f.SOURCEID = UserStat.SOURCEID AND UserStat.DESCRIPTION = f.DESCRIPTION)
),
OtherUsersInfo AS
(
    SELECT 
        MAX(Id) AS Id,
        2 AS UserId,
        description,
        sourceId,
        AVG(EventCount * 1.0) AS EventCount,
        SUM(SlowestNodeDur)/1000.0/SUM(EventCount) AS SlowestNodeDur,
        0 AS SumEventCount,
        0 AS TotalEventCount,
        COUNT(DISTINCT COALESCE(userid,0)) AS UsersAffected
    FROM 
        EachUserInfo
    GROUP BY
        sourceId, 
        description
),
[Result] AS
(
  SELECT *
  FROM
    TopDataSet
  UNION
  SELECT *
  FROM
    OtherUsersInfo
)
SELECT 
    r.Id,
    r.UserId,
    r.description,
    s.Source,
    r.EventCount,
    r.SlowestNodeDur,
    r.SumEventCount,
    r.TotalEventCount,
    r.UsersAffected
FROM
    [Result] r
    JOIN APM.Source (NOLOCK) AS s ON s.SourceId = r.SourceId
ORDER BY 
    Id, UserId 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.TopUserExceptionIssues'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.TopUserExceptionIssues AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: TopUserExceptionIssues                                                     */
/* USED IN: Top5UserExceptionSubReport.rdl                                          */
/* INPUT PARAMETERS:                                                                */
/*      @SOURCEID    - Source id                                                    */
/*      @COMPUTERIDS - List of the computer id, separated by comma. Exp: '1,2,3'    */
/*      @STARTDATE   - Start date of the period                                     */
/*      @ENDDATE     - End date of the period                                       */
/************************************************************************************/
ALTER PROCEDURE [APM].[TopUserExceptionIssues] 
(
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @STARTDATE DATETIME, 
    @ENDDATE DATETIME, 
    @USERNAME NVARCHAR(255),
    @PMSTATUS NVARCHAR(50)
) WITH RECOMPILE
AS
BEGIN
  SET NOCOUNT ON
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
  CREATE TABLE #SUMUSERANALYSIS 
  (
    DESCRIPTION nvarchar(255) collate database_default,
    USERID int,
    USERFLAG BIT,
    SOURCEID int,
    EVENTCOUNT int,
    SECURITYFAILURE int,
    APPLICATIONFAILURE int,
    CONNECTIVITYFAILURE int
  )
--Select information about events for all users
;WITH UsersInfo AS
(
    SELECT 
        e.DESCRIPTION AS DESCRIPTION,
        MIN(e.USERID) AS USERID,
        CASE u.Name WHEN @USERNAME THEN 1 ELSE 0 END AS USERFLAG,
        e.SOURCEID,
        COUNT(e.EVENTID) AS EVENTCOUNT,
        COUNT(CASE WHEN e.ASPECT = N'security' THEN  e.EVENTID END) AS SECURITYFAILURE,
        COUNT(CASE WHEN e.ASPECT = N'applicationfailure' THEN  e.EVENTID END) AS APPLICATIONFAILURE,
        COUNT(CASE WHEN e.ASPECT = N'connectivity' THEN  e.EVENTID END) AS CONNECTIVITYFAILURE
    FROM 
        APM.EVENT AS e
        --JOIN ExceptionNode AS en ON (en.eventid = e.eventid and en.resourceid = e.resourceid)
        JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = e.SourceId)
        JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = e.MachineId)
        JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)        
        JOIN APM.Users AS u ON e.USERID = u.USERID
    WHERE
        e.UTCEVENTDATE &gt; @STARTDATE
        AND e.UTCEVENTDATE &lt; @ENDDATE
        AND e.ASPECT IN ( N'security',N'applicationfailure',N'connectivity')
    GROUP BY
        e.SOURCEID, 
        e.DESCRIPTION,
        u.NAME
)
INSERT #SUMUSERANALYSIS 
SELECT 
    Description,
    UserId,
    UserFlag,
    SourceId,
    EventCount,
    SecurityFailure,
    ApplicationFailure,
    ConnectivityFailure
FROM UsersInfo
CREATE INDEX temp1_idx ON  #SUMUSERANALYSIS(DESCRIPTION, SOURCEID)
--  Select event information for current user only (condition UserFlag = 1 allows to filter event by current user)
;WITH OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY EVENTCOUNT DESC) AS ID,  
        DESCRIPTION,
        SOURCEID,
        EVENTCOUNT,
        SECURITYFAILURE,
        APPLICATIONFAILURE,
        CONNECTIVITYFAILURE,
        SUM(EVENTCOUNT) OVER() AS TOTALEVENTCOUNT
    FROM
        #SUMUSERANALYSIS AS u
    WHERE
        USERFLAG = 1
),
--Select top 5 exception events for current user
TopDataSet AS
(
    SELECT
        TOP(5)
        id,
        1 AS UserId,
        description,
        sourceId,
        EventCount,
        SecurityFailure,
        ApplicationFailure,
        ConnectivityFailure,
        EventCount AS SumEventCount,
        TotalEventCount,
        0 AS UsersAffected
    FROM 
        OrderedDataSet AS U
    ORDER BY Id
),
-- Select information about same exceptions for other users
EachUserInfo AS
(
    SELECT 
      f.ID,
      UserStat.DESCRIPTION,
      UserStat.SOURCEID,
      UserStat.EVENTCOUNT,
      UserStat.SECURITYFAILURE,
      UserStat.APPLICATIONFAILURE,
      UserStat.CONNECTIVITYFAILURE,
      UserStat.USERID
    FROM 
      #SUMUSERANALYSIS UserStat
      JOIN TopDataSet AS f ON (f.SOURCEID = UserStat.SOURCEID AND UserStat.DESCRIPTION = f.DESCRIPTION)
),
OtherUsersInfo AS
(
    SELECT 
        MAX(Id) AS Id,
        2 AS UserId,
        description,
        sourceId,
        AVG(EventCount * 1.0) AS EventCount,
        AVG(SecurityFailure * 1.0) AS SecurityFailure,
        AVG(ApplicationFailure * 1.0) AS ApplicationFailure,
        AVG(ConnectivityFailure * 1.0) AS ConnectivityFailure,
        0 AS SumEventCount,
        0 AS TotalEventCount,
        COUNT(DISTINCT COALESCE(userid,0)) AS UsersAffected
    FROM 
        EachUserInfo
    GROUP BY
        sourceId, 
        description
),
-- Unify information about current user and all users
[Result] AS (
SELECT *
FROM
    TopDataSet
UNION ALL
SELECT *
FROM
    OtherUsersInfo
)
SELECT 
  r.Id,
  r.UserId,
  r.description,
  s.Source,
  r.EventCount,
  r.SecurityFailure,
  r.ApplicationFailure,
  r.ConnectivityFailure,
  r.SumEventCount,
  r.TotalEventCount,
  r.UsersAffected
FROM 
  [Result] r
  JOIN apm.Source (NOLOCK) AS s ON s.SourceId = r.SourceId          
ORDER BY 
    Id, UserId 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReport                                           */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Request Count (temporary obsolete)                           */
/*                  2. Problems Count                                               */
/*                  3. Event Count                                                  */
/*                  4. MAX Event Duration                                           */
/*                  5. AVG Event Duration                                           */
/*                  6. Event Size                                                   */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50),
    @ORDERBY INT 
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50),
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    e.SOURCEID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
	JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)     
WHERE 
    e.ClassType = N'Performance' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE
/****************************************************************************************************************/
/*                                          MAIN QUERY                                                          */
/****************************************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        E.CSEVENTID,
        SUM(COALESCE(ajax.REQUESTSIZE, 0))+ SUM(COALESCE(ajax.ResponseSize, 0)) AS AjaxSize, 
        -- This field will be used only for Asynch Ajax, and for Asycnch Ajax CSAJAX table 
        -- contains only one row for each event, so sum doesn't make any difference
        SUM(ajax.TotalTime) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
        
),
CSEvents AS
(
    SELECT 
        e.CSEVENTID,
        e.CSEVENTGROUPID,
        e.SOURCEID,
        js.CSEventId AS JavaScriptEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMAMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS AsyncAjaxEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMPMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS PageEventId,
        COALESCE(pe.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) AS EventDuration,
        COALESCE(pe.TotalSize, ajax.AjaxSize) AS EventSize
    FROM 
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON js.CSEventId  = e.CSEVENTID 
        LEFT OUTER JOIN AJAXEvents AS ajax (NOLOCK) ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.CSEventId = e.CSEVENTID
),
SourceStat AS
(
    SELECT 
        SourceId,
        COUNT(JavaScriptEventId) AS JavaScriptEventCount,
        COUNT(AsyncAjaxEventId) AS AsyncAjaxEventCount,
        COUNT(PageEventId) AS PageEventCount,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroupId) AS ProblemsCount,
        MAX(EventDuration) AS MAXEventDuration,
        AVG(EventDuration) AS AVGEventDuration,
        AVG(EventSize) AS EventSize
    FROM 
        CSEvents
    WHERE
        EventDuration / 1000.0 &gt;= @THRESHOLD
    GROUP BY
        SourceId
),
NumberedSources AS
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY
            WHEN 2 THEN e.ProblemsCount
            WHEN 3 THEN e.EventCount
            WHEN 4 THEN e.MAXEventDuration
            WHEN 5 THEN e.AVGEventDuration
            WHEN 6 THEN e.EventSize
        END) DESC) Id, 
        e.SourceId,
        s.Source,
        e.JavaScriptEventCount,
        e.AsyncAjaxEventCount,
        e.PageEventCount,
        e.EventCount,
        e.ProblemsCount,
        e.MAXEventDuration/1000.0 AS MAXEventDuration,
        e.AVGEventDuration/1000.0 AS AVGEventDuration,
        -- Temporary obsolete field, return appropriate value, than it will be returned
        1 AS requestCount,
        e.EventSize/1024.0 AS EventSize,
        SUM(e.EventCount) OVER() AS TotalEventCount
    FROM
        SourceStat AS e
        JOIN APM.Source AS s (NOLOCK) ON e.SourceId = s.SourceId
)
SELECT TOP (10) *
FROM
    NumberedSources
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReportMaxScale'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReportMaxScale AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReportMaxScale                                   */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReportMaxScale 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @THRESHOLD INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50) COLLATE database_default,
    SOURCEID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    e.SOURCEID,
    e.PAGEURI
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SOURCEID AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MACHINEID AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.IPID = f3.IPID
	JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMSTATUS)     
WHERE 
    e.CLASSTYPE = N'Performance'
    AND e.PAGEURI IS NOT NULL 
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
;WITH JSAndAJAXEvent AS
(
    SELECT  
        e.CSEVENTID,
        e.SOURCEID,
        e.PAGEURI,
        COALESCE(js.TotalTime, ajax.TotalTime) AS EventDuration,
        COALESCE(js.Action, ajax.Uri) AS Action
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEVENTID = e.CSEVENTID
        LEFT OUTER JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEVENTID = e.CSEVENTID
    WHERE
        EVENTCLASS = N'CSMAMonitorLog'  
        AND COALESCE(js.TotalTime, ajax.TOTALTIME)/1000.0 &gt;= @THRESHOLD
),
-- As main query shows only top 10 sources,
-- this should be take into account for choosing max durations
SourceFilter AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY COUNT(e.CSEVENTID) DESC) AS SourceRowNumber,
        e.SOURCEID
    FROM
        #CLIENTEVENT AS e
    GROUP BY 
        e.SOURCEID
),
JSAndAJAXEventsDuration AS
(
    SELECT 
        ROW_NUMBER() OVER(PARTITION BY E.SourceId ORDER BY COUNT(e.CSEventId) DESC) AS Id,
        e.SOURCEID, 
        e.PAGEURI,
        e.Action,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(EventDuration) AS EventDuration
    FROM
        JSAndAJAXEvent AS e
        JOIN SourceFilter AS s ON s.SOURCEID = e.SOURCEID
    WHERE
        s.SourceRowNumber &lt;= 10
    GROUP BY
        e.SOURCEID, 
        e.PAGEURI,
        e.Action
),
PageEvent AS
(
    SELECT ROW_NUMBER() OVER(PARTITION BY e.SOURCEID ORDER BY COUNT(e.CSEVENTID) DESC) AS Id,
        e.SOURCEID,
        COUNT(e.CSEVENTID) AS EventCount,
        AVG(pe.TOTALTIME) AS EventDuration,
        e.PAGEURI
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.CSEVENTID = e.CSEVENTID 
        JOIN SourceFilter AS s ON s.SOURCEID = e.SOURCEID
    WHERE
        pe.TOTALTIME/1000.0 &gt;=@THRESHOLD
        AND s.SourceRowNumber &lt;= 10
    GROUP BY
        e.SOURCEID,
        e.PAGEURI
)
SELECT
(   
    SELECT 
        COALESCE(MAX(EventDuration),0)/1000.0 
    FROM
        PageEvent
    WHERE
        Id &lt;= 5
)AS MaxPageEventDuration,
(   
    SELECT 
        COALESCE(MAX(EventDuration),0)/1000.0 
    FROM
        JSAndAJAXEventsDuration
    WHERE
        Id &lt;= 5
)AS MaxJSEventDuration
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNet'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNet AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNet                                              */
/* USED IN: Load Time Analysis Based On Subnet as main data set query               */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Request Count (temporary obsolete)                           */
/*                  2. Problems Count                                               */
/*                  4. Avg Event Duration                                           */
/*                  5. Latency                                                      */
/************************************************************************************/
ALTER PROCEDURE APM.LoadTimeAnalysisBasedOnSubNet 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default 
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    IPID,
    SUBNETC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SUBNETC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SUBNETC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    EVENTCLASS NVARCHAR(50)  COLLATE database_default ,
    SUBNETC NVARCHAR(50)  COLLATE database_default 
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.CSEVENTGROUPID,
    e.EVENTCLASS,
    f2.SUBNETC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.IPID = f2.IPID
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)     
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.PAGEURI IS NOT NULL
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE 
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
;WITH AJAXEvent AS
(
    SELECT
        e.CSEVENTID,
        e.SUBNETC,
        ajax.Synchronous,
        SUM(ajax.NetworkTime) AS NetworkTime,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.ResponseTime) AS ResponseTime,
        AVG(ajax.Latency) AS Latency,
        SUM(ajax.TotalTime) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEventId = e.CSEVENTID
    GROUP BY
        e.CSEVENTID,
        e.SUBNETC,
        ajax.Synchronous
),
ClientEvents AS
(
    SELECT
        e.SUBNETC,
        e.CSEVENTID,
        e.CSEVENTGROUPID,
        -- if JScript table has corresponding row (not null value), than consider it is java script event
        js.CSEventId AS JavaScriptEventId,
        -- If it is not JavaScript event, then define its type by event class type
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMAMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS AsyncAjaxEventId,
        (CASE WHEN ((js.CSEventId IS NULL) AND (e.EVENTCLASS =N'CSMPMonitorLog')) THEN e.CSEVENTID ELSE NULL END) AS PageEventId,
        -- Define duration by joined table. As Page Event, Asynch Ajax and Java script 
        -- events are mutually exclusive it can be done as folllows
        COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) AS EventDuration,
        p.NetworkTime AS PageLoadNetworkTime,
        p.ServerTime AS PageLoadServerTime,
        p.DOMTime AS PageDOMLoad,
        p.PeripheralTime AS PagePeripheralTime,
        p.OnLoadTime AS PageOnLoadTime,
        p.TotalTime AS PageEventTime,
        (ajax.NetworkTime + ajax.ResponseTime) AS AjaxNetworkTime,
        ajax.ServerTime AS AjaxServerTime,
        -- If event is asynch ajax, then there is no corresponding row in JavaScript table,
        -- If it is synch ajax, then its total duration should be taken from java script total time
        COALESCE(js.TotalTime, ajax.TotalTime) AS AjaxTotalTime,
        -- Client time should be calculated as total time, minus network, server and response time,
        -- But total time should be taken not from ajax table, it is depend on event type 
        COALESCE(js.TotalTime, ajax.TotalTime) 
                -- For AJAX event ther could by no corresponding row in AJAX table, then all time consider to be Client
                - COALESCE(ajax.NetworkTime + ajax.ResponseTime + ajax.ServerTime, 0) AS AjaxClientTime,
        --Latency belongs either to page event or to Ajax event
        COALESCE(p.Latency, ajax.Latency) AS Latency,
        COUNT(e.CSEVENTID) OVER() AS TotalEventCount
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN AJAXEvent AS ajax ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPageEvent AS p (NOLOCK) ON P.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEventId = e.CSEVENTID
    WHERE
        COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)) / 1000.0 &gt;= @THRESHOLD
),
-- Aggregate data for each subnet
SubnetSummary AS
(
    SELECT
        SubnetC,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroupId) AS ProblemCount,
        -- For counting events by types, use that COUNT does not calculates null values     
        COUNT(JavaScriptEventId) AS JSEventCount,
        COUNT(AsyncAjaxEventId) AS AsynchAjaxEvent,
        COUNT(PageEventId) AS PageEventCount,
        AVG(PageLoadNetworkTime)/1000.0 AS PageLoadNetworkTime,
        AVG(PageLoadServerTime)/1000.0 AS PageLoadServerTime,
        AVG(PageDOMLoad)/1000.0 AS PageDOMLoad,
        AVG(PagePeripheralTime)/1000.0 AS PagePeripheralTime,
        AVG(PageOnLoadTime)/1000.0 AS PageOnLoadTime,
        AVG(Latency) AS Latency,
        AVG(AjaxNetworkTime)/1000.0 AS AjaxNetworkTime,
        AVG(AjaxServerTime)/1000.0 AS AjaxServerTime,
        AVG(AjaxClientTime)/1000.0 AS ClientTime,
        AVG(EventDuration)/1000.0 AS AvgEventDuration,
        -- This aggregation has no difference as it is same for all rows
        MAX(TotalEventCount) AS TotalEventCount
    FROM
        ClientEvents
    GROUP BY
        SubnetC
)
    SELECT TOP(20)
        row_number() OVER(ORDER BY (CASE @ORDERBY
            WHEN 1 THEN ProblemCount
            WHEN 2 THEN EventCount
            WHEN 3 THEN coalesce(PageLoadServerTime, 0) + coalesce(AjaxServerTime, 0)
            WHEN 4 THEN AvgEventDuration
            WHEN 5 THEN Latency
        END) DESC) Id,  
        SubnetC,
        EventCount,
        ProblemCount,
        PageEventCount,
        JSEventCount,
        AsynchAjaxEvent,
        PageLoadNetworkTime,
        PageLoadServerTime,
        PageDOMLoad,
        PagePeripheralTime,
        PageOnLoadTime,
        AjaxNetworkTime,
        AjaxServerTime,
        ClientTime,
        Latency,
        AvgEventDuration,
        TotalEventCount
    FROM 
        SubnetSummary
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetMaxScale'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetMaxScale AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNet                                              */
/* USED IN: Load Time Analysis Based On Subnet for calculating max value in         */
/*          subreports, to make one scaling for all sub reports                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/************************************************************************************/
alter PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetMaxScale 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #IPFILTER
(
    IPID INT
)
INSERT INTO #IPFILTER
SELECT DISTINCT
    ipid
FROM
    apm.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
    
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    EVENTCLASS NVARCHAR(50) COLLATE database_default,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEVENTID,
    e.EVENTCLASS,
    e.PAGEURI,
    ip.SUBNETC
FROM
-- Max values should be selected not only for appropriate subnetc, but for all
-- (as in subreports, relative values to other is shown). So filtering by subnets could not be hold here
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #IPFILTER AS f2 ON (e.IPID = f2.IPID)
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)
    JOIN APM.IP AS ip (NOLOCK) ON ip.IPID = e.IPID
    
WHERE 
    e.CLASSTYPE = N'Performance' 
    AND e.PAGEURI IS NOT NULL
    AND e.SOURCEID = @SOURCEID
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    SUBNETC NVARCHAR(50) COLLATE database_default   
)
-- In report shown only top 20 subnets by event count
-- Besides, user specifies filter by subnet, so select subnets, for which MAX should be selected
INSERT INTO #SUBNETCFILTERTABLE
SELECT
    TOP(20)
    e.SUBNETC
FROM
    #CLIENTEVENT AS e
GROUP BY
    e.SUBNETC
ORDER BY
    COUNT(e.CSEVENTID) DESC
/****************************************************************************************/
/*                              MAIN QUERIES                                            */
/****************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        e.CSEVENTID,
        -- This field need only for asynch ajax events, and for this type here can by only one row,
        -- so aggregation doesn't matter
        MAX(ajax.URI) AS AjaxAction,
        SUM(ajax.TOTALTIME) AS TotalTime
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON ajax.CSEVENTID = e.CSEVENTID
    WHERE
        e.EVENTCLASS = N'CSMAMonitorLog' OR e.EVENTCLASS = N'CSMSMonitorLog'
    GROUP BY
        e.CSEVENTID
),
JSEvents AS
(
    SELECT
        e.CSEVENTID,
        e.SUBNETC,
        e.PAGEURI,
        COALESCE(js.ACTION, ajax.AjaxAction) AS Action,
        COALESCE(js.TOTALTIME, ajax.TotalTime) AS EventDuration,
--Calculate average event duration for all subnets
        AVG(COALESCE(js.TOTALTIME, ajax.TotalTime)) OVER(PARTITION BY e.PAGEURI,
                                COALESCE(js.Action, ajax.AjaxAction)) AS CommonDuration
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEVENTID = e.CSEVENTID
        LEFT OUTER JOIN AJAXEvents AS ajax ON ajax.CSEVENTID = e.CSEVENTID      
    WHERE
        e.EVENTCLASS = N'CSMAMonitorLog' OR e.EVENTCLASS = N'CSMSMonitorLog'
),
JSActionsForSubnets AS 
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY js.SUBNETC ORDER BY COUNT(CSEVENTID) DESC) AS Id,
        COUNT(CSEVENTID) AS EventCount, 
        js.SUBNETC,
        Action,
        PAGEURI,
        MAX(CommonDuration) AS CommonDuration,
        AVG(EventDuration) AS AvgActionDuration
    FROM
        JSEvents AS js
        JOIN #SUBNETCFILTERTABLE AS f ON f.SUBNETC = js.SUBNETC
    GROUP BY
        js.SUBNETC,
        PageUri,
        Action  
),
PageEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC,
        p.TOTALTIME,
        --Calculate Average page load duration for all subnets
        AVG(p.TOTALTIME) OVER(PARTITION BY e.PAGEURI) AS PageAvgDuration
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
),
PageEventsForSubNets AS
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY e.SUBNETC ORDER BY COUNT(e.CSEVENTID) DESC) AS Id,
        e.SUBNETC,
        e.PAGEURI,
        AVG(e.TOTALTIME) AS PageAvgSubNetDuration,
        MAX(e.PageAvgDuration) AS PageAvgDuration
    FROM
        PageEvents AS e
        JOIN #SUBNETCFILTERTABLE AS f ON f.SUBNETC = e.SUBNETC
    GROUP BY
        e.SUBNETC,
        e.PAGEURI           
)
SELECT
    (SELECT COALESCE(MAX(CASE WHEN CommonDuration &gt;= AvgActionDuration THEN CommonDuration ELSE AvgActionDuration END)/1000.0, 0)
        FROM
            JSActionsForSubnets
        WHERE Id &lt;= 5) AS MaxAjaxDuration,
    (SELECT COALESCE(MAX(CASE WHEN PageAvgDuration &gt;= PageAvgSubNetDuration THEN PageAvgDuration ELSE PageAvgSubNetDuration END)/1000.0, 0)
        FROM
            PageEventsForSubNets
        WHERE Id &lt;= 5) AS MaxPageLoadDuration
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls                             */
/* USED IN: Load Time Analysis Based On Subnet for Top JS ajax calls subreport      */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - SubnetC for which data should be selected                        */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
alter PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopJSAndAJAXCalls 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SUBNETC NVARCHAR(25),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
CREATE TABLE #CLIENTEVENTFORALLSUBNETS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) collate database_default,
    SUBNETC NVARCHAR(50) collate database_default
)
-- Filter Event Table by incoming parameters
-- Filtering by SubnetC is not made here, as relative time information 
-- for all other sources should be also calculated
INSERT INTO #CLIENTEVENTFORALLSUBNETS
SELECT
    e.CSEventId,
    e.PageUri,
    ip.SubNetC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMStatus)     
    JOIN APM.IP (NOLOCK) ON ip.ipid = e.ipid
WHERE 
    e.SourceId = @SOURCEID
--Select only Asynch AJAX and JS events
    AND (e.EventClass = N'CSMAMonitorLog' OR e.EventClass = N'CSMSMonitorLog')
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
    AND PageUri IS NOT NULL
-- Events should be selected only for that pages, which are actual for specified @SUBNETC
-- If for the @SUBNETC there is no one event for some page, events for this page should not be selected at all
CREATE TABLE #CLIENTEVENTFILTEREDBYPAGEURI 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
INSERT INTO #CLIENTEVENTFILTEREDBYPAGEURI
SELECT 
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC
    FROM 
        #CLIENTEVENTFORALLSUBNETS AS e
    WHERE 
        e.SUBNETC = @SUBNETC
        AND e.PAGEURI IN (SELECT
                                e1.PAGEURI 
                        FROM 
                            #CLIENTEVENTFORALLSUBNETS AS e1 
                        WHERE 
                            e1.SUBNETC = @SUBNETC
                        )
/********************************************************************************************************/
/*                              MAIN  QUERY                                                             */
/********************************************************************************************************/
;WITH AJAXEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        e.SUBNETC,
        -- This field need only for asynch ajax events, and for this type here can by only one row,
        -- so aggregation doesn't matter
        MAX(ajax.Uri) AS AjaxAction,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.NetworkTime + ajax.ResponseTime) AS NetworkTime,
        SUM(ajax.TotalTime) AS TotalTime,
        SUM(COALESCE(ajax.REQUESTSIZE, 0) + COALESCE(ajax.ResponseSize, 0)) AS CallSize
    FROM
        #CLIENTEVENTFILTEREDBYPAGEURI AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID,
        e.PAGEURI,      
        e.SUBNETC
),
CSJSEvents AS
(
    SELECT
        e.PAGEURI,
        e.SUBNETC,
        e.CSEVENTID,
        COALESCE(js.Action, ajax.AjaxAction) AS AjaxAction,
        COALESCE(js.TotalTime, ajax.TotalTime)/1000.0 AS TotalTime,
        COALESCE(ajax.NetworkTime, 0)/1000.0 AS NetworkTime,
        COALESCE(ajax.ServerTime, 0)/1000.0 AS ServerTime,
        -- don't change size to 0, as average size should be calculated only for ajax calls, not all events
        ajax.CallSize/1024.0 AS CallSize
    FROM
        #CLIENTEVENTFILTEREDBYPAGEURI AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.CSEventid = e.CSEVENTID
        LEFT OUTER JOIN AJAXEvents AS ajax (NOLOCK) ON ajax.CSEventid = e.CSEVENTID
    WHERE 
        -- Threshold condition should be applied only for Asynch Ajax Events,
        -- For Synch Ajax this condition is applied to JS event
        COALESCE(js.TotalTime, ajax.TotalTime)/1000.0 &gt;= @THRESHOLD
),
AJAXActionInfo AS
(
    SELECT
        PageUri,
        AjaxAction,
        COUNT(CASE WHEN Subnetc = @SUBNETC THEN CSEventId END) AS EventCount,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN NetworkTime END) AS NetworkTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN ServerTime END) AS ServerTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN TotalTime - (NetworkTime + ServerTime) END) AS ClientTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN TotalTime END) AS TotalTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN CallSize END) AS AJAXCallSize,
        AVG(NetworkTime) AS CommonNetworkTime,
        AVG(ServerTime) AS CommonServerTime,
        AVG(TotalTime - (NetworkTime + ServerTime)) AS CommonClientTime,
        AVG(TotalTime) AS CommonTotalTime
    FROM
        CSJSEvents
    GROUP BY
        PageUri,
        AjaxAction
),
OrderedActions AS
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id,
        EventCount,
        AjaxAction,
        pageUri,
        ClientTime,
        NetworkTime,
        ServerTime,
        TotalTime,
        CommonClientTime,
        CommonNetworkTime,
        CommonServerTime,
        CommonTotalTime,
        AJAXCallSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        AJAXActionInfo
)
--Second row is used to show relative AJAX execution time for other subnets
SELECT 
    d.id,
    rowId.n AS rowId,
    d.pageUri,
    d.AjaxAction,
    (CASE WHEN rowId.n = 1 THEN d.EventCount ELSE 0 END )AS EventCount,
    (CASE WHEN rowId.n = 1 THEN d.ClientTime ELSE d.CommonClientTime END )AS ClientTime,
    (CASE WHEN rowId.n = 1 THEN d.NetworkTime ELSE d.CommonNetworkTime END )AS NetworkTime,
    (CASE WHEN rowId.n = 1 THEN d.ServerTime ELSE d.CommonServerTime END )AS ServerTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalTime ELSE d.CommonTotalTime END) AS TotalTime,
    (CASE WHEN rowId.n = 1 THEN d.AJAXCallSize ELSE 0 END )AS AJAXCallSize,
    (CASE WHEN rowId.n = 1 THEN d.TotalEvents ELSE 0 END )AS TotalEvents
FROM
    APM.fn_nums(2) AS rowId,
    OrderedActions AS d
WHERE
    d.id &lt;= 5
ORDER BY 
    id, 
    rowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.LoadTimeAnalysisBasedOnSubNetTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: LoadTimeAnalysisBasedOnSubNetTopPages                                      */
/* USED IN: Load Time Analysis Based On Subnet for Top pages subreport              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - SubnetC for which data should be selected                        */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.LoadTimeAnalysisBasedOnSubNetTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @SUBNETC NVARCHAR(25),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
    
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
CREATE TABLE #CLIENTEVENTFORALLSUBNETS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Filter Event Table by incoming parameters
-- Filtering by SubnetC is not made here, as relative time information 
-- for all other sources should be also calculated
INSERT INTO #CLIENTEVENTFORALLSUBNETS
SELECT
    e.CSEventId,
    e.PageUri,
    ip.SubNetC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
	JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMStatus)     
    JOIN APM.IP (NOLOCK) ON ip.ipid = e.ipid
WHERE 
    e.SourceId = @SOURCEID
    AND e.EventClass = N'CSMPMonitorLog' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
    AND PageUri IS NOT NULL
    
-- Events should be selected only for that pages, which are actual for specified @SUBNETC
-- If for the @SUBNETC there is no one event for some page, events for this page should not be selected at all
;WITH CSPageEvents AS
(
    SELECT
        e.CSEVENTID,
        e.PAGEURI,
        pe.NetworkTime,
        pe.ServerTime,
        pe.DOMTime,
        pe.PeripheralTime,
        pe.OnLoadTime,
        pe.TotalTime,
        pe.TotalSize,
        e.SUBNETC
    FROM
        #CLIENTEVENTFORALLSUBNETS (NOLOCK) AS e
        JOIN APM.CSPageEvent AS pe ON pe.cseventid = e.CSEVENTID
    WHERE 
        e.PAGEURI IN (SELECT DISTINCT 
                                e1.PAGEURI 
                            FROM 
                                #CLIENTEVENTFORALLSUBNETS AS e1 
                            WHERE 
                                e1.SUBNETC = @SUBNETC
                        )
        AND pe.TotalTime/1000.0 &gt; @THRESHOLD
),
PageProcessingTime AS
(
    SELECT 
        PageUri,
        COUNT(CASE WHEN Subnetc = @SUBNETC THEN CSEVENTID END) AS EventCount,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(NetworkTime, 0) END)/1000 AS NetworkTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(ServerTime, 0) END)/1000 AS ServerTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(DOMTime, 0) END)/1000 AS DOMTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(PeripheralTime, 0) END)/1000 AS PeripheralTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(OnLoadTime, 0) END)/1000 AS OnLoadTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(TotalTime, 0) END)/1000 AS TotalTime,
        AVG(CASE WHEN Subnetc = @SUBNETC THEN COALESCE(TotalSize, 0) END)/1024.0 AS TotalSize,
        AVG(NetworkTime)/1000 AS CommonNetworkTime,
        AVG(ServerTime)/1000 AS CommonServerTime,
        AVG(DOMTime)/1000 AS CommonDOMTime,
        AVG(PeripheralTime)/1000 AS CommonPeripheralTime,
        AVG(OnLoadTime)/1000 AS CommonOnLoadTime,
        AVG(TotalTime)/1000 AS CommonTotalTime
    FROM 
        CSPageEvents
    GROUP BY
        PageUri  
),
NumberedPages AS
(
    SELECT 
        row_number() OVER(ORDER BY EventCount DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        CommonNetworkTime,
        CommonServerTime,
        CommonDOMTime,
        CommonPeripheralTime,
        CommonOnLoadTime,
        CommonTotalTime,
        SUM(EventCount) OVER() AS TotalEvents   
    FROM 
        PageProcessingTime  
),
OneRowData AS
(
    SELECT
        TOP(5)
            id,
            PageUri,
            EventCount,
            NetworkTime,
            ServerTime,
            DOMTime,
            PeripheralTime,
            OnLoadTime,
            TotalTime,
            TotalSize,
            CommonNetworkTime,
            CommonServerTime,
            CommonDOMTime,
            CommonPeripheralTime,
            CommonOnLoadTime,
            (COALESCE(CommonNetworkTime, 0) + COALESCE(CommonServerTime, 0)+ COALESCE(CommonDOMTime, 0) + COALESCE(CommonPeripheralTime, 0) + COALESCE(CommonOnLoadTime, 0)) AS CommonTotalTime,
            TotalEvents
        FROM 
            NumberedPages   
        WHERE 
            EventCount &gt; 0
        ORDER BY id
)
--Second row is used to show relative Page Load time for other subnets
SELECT 
    d.id,
    rowId.n AS rowId,
    d.PageUri,
    (CASE WHEN rowId.n = 1 THEN d.EventCount ELSE 0 END )AS EventCount,
    (CASE WHEN rowId.n = 1 THEN d.NetworkTime ELSE d.CommonNetworkTime END )AS NetworkTime,
    (CASE WHEN rowId.n = 1 THEN d.ServerTime ELSE d.CommonServerTime END )AS ServerTime,
    (CASE WHEN rowId.n = 1 THEN d.DOMTime ELSE d.CommonDOMTime END )AS DOMTime,
    (CASE WHEN rowId.n = 1 THEN d.PeripheralTime ELSE d.CommonPeripheralTime END )AS PeripheralTime,
    (CASE WHEN rowId.n = 1 THEN d.OnLoadTime ELSE d.CommonOnLoadTime END )AS OnLoadTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalTime ELSE d.CommonTotalTime END )AS TotalTime,
    (CASE WHEN rowId.n = 1 THEN d.TotalSize ELSE d.TotalSize END )AS TotalSize,
    (CASE WHEN rowId.n = 1 THEN d.TotalEvents ELSE d.TotalEvents END )AS TotalEvents,
    --Get ajax call flag
    CASE WHEN EXISTS(
            SELECT * 
                FROM #CLIENTEVENTFORALLSUBNETS c
                     JOIN APM.CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                       
                WHERE d.PageUri = c.PAGEURI
        ) THEN '*' ELSE ''
    END AS Extension
FROM
    APM.fn_nums(2) AS rowId,
    OneRowData AS d
ORDER BY 
    id, 
    rowId
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientLatencyDistributionBySources'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientLatencyDistributionBySources AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:ClientLatencyDistributionBySources                                          */
/* USED IN: Client Latency Distribution for summary table by sources                */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - List subnet type C, selected by user                             */
/*      @ORDERBY - Specifies latency range to which ordering should be applied      */
/************************************************************************************/
ALTER PROCEDURE APM.ClientLatencyDistributionBySources 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    ip.SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    SOURCEID INT
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEventId,
    e.SourceId
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
    JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus) 
WHERE 
    e.ClassType = N'Performance' 
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
CREATE TABLE #LATENCIES 
(
    ID INT,
    MIN INT,
    MAX INT 
)
INSERT INTO #LATENCIES VALUES (1, 0, 100)
INSERT INTO #LATENCIES VALUES (2, 101, 300)
INSERT INTO #LATENCIES VALUES (3, 301, 600)
INSERT INTO #LATENCIES VALUES (4, 601, 1000)
INSERT INTO #LATENCIES VALUES (5, 1001, 2000)
INSERT INTO #LATENCIES VALUES (6, 2001, 99999999)
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        ajax.TotalTime AS TotalTime,
        ajax.Latency AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
),
JSEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        js.TotalTime AS TotalTime,
        NULL AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSJSCRIPTEVENT AS js (NOLOCK) ON e.CSEVENTID = js.CSEventId
),
PageEvents AS 
(
    SELECT
        e.CSEVENTID,
        e.SOURCEID,
        p.TotalTime AS TotalTime,
        p.Latency AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSPAGEEVENT AS p (NOLOCK) ON e.CSEVENTID = p.CSEventId
),
UnionEvents AS
(
    SELECT * from AJAXEvents
    UNION ALL
    SELECT * from JSEvents
    UNION ALL
    SELECT * from PageEvents
),
EventAggregation AS
(
    SELECT 
        SourceId,
        MAX(TotalTime) / 1000.0 AS TotalTime,
        AVG(Latency) AS Latency
    FROM UnionEvents
    GROUP BY 
        CSEventId, SourceId
),
NumberedDataSet AS 
(
    SELECT 
        ROW_NUMBER() OVER(ORDER BY COUNT(CASE
                WHEN @ORDERBY = 1 AND L.ID = 1 THEN 1
                WHEN @ORDERBY = 2 AND L.ID = 2 THEN 1
                WHEN @ORDERBY = 3 AND L.ID = 3 THEN 1
                WHEN @ORDERBY = 4 AND L.ID = 4 THEN 1
                WHEN @ORDERBY = 5 AND L.ID = 5 THEN 1
                WHEN @ORDERBY = 6 THEN 1
            END) DESC) AS Id, 
        SourceId,
        COUNT(CASE WHEN L.ID = 1 THEN 1 END) AS EventCount1,
        COUNT(CASE WHEN L.ID = 2 THEN 1 END) AS EventCount2,
        COUNT(CASE WHEN L.ID = 3 THEN 1 END) AS EventCount3,
        COUNT(CASE WHEN L.ID = 4 THEN 1 END) AS EventCount4,
        COUNT(CASE WHEN L.ID = 5 THEN 1 END) AS EventCount5,
        COUNT(CASE WHEN L.ID = 6 THEN 1 END) AS EventCount6,
        AVG(CASE WHEN L.ID = 1 THEN TotalTime END) AS EventDuration1,
        AVG(CASE WHEN L.ID = 2 THEN TotalTime END) AS EventDuration2,
        AVG(CASE WHEN L.ID = 3 THEN TotalTime END) AS EventDuration3,
        AVG(CASE WHEN L.ID = 4 THEN TotalTime END) AS EventDuration4,
        AVG(CASE WHEN L.ID = 5 THEN TotalTime END) AS EventDuration5,
        COUNT(*) AS EventCount
    FROM EventAggregation AS EA 
    JOIN #LATENCIES AS L ON COALESCE(EA.Latency, 99999999) &gt;= L.MIN AND COALESCE(EA.Latency, 99999999) &lt;= L.MAX
    GROUP BY SourceId
)
--Select each range info into separate row to provide better view in report charts
    SELECT 
        sr.Id,
        r.n AS LatencyRange,
        sr.EventCount,
        s.Source,   
        sr.SourceId,
        (CASE WHEN r.n = 1 THEN sr.EventCount1 END) AS EventCount1,
        (CASE WHEN r.n = 2 THEN sr.EventCount2 END) AS EventCount2,
        (CASE WHEN r.n = 3 THEN sr.EventCount3 END) AS EventCount3,
        (CASE WHEN r.n = 4 THEN sr.EventCount4 END) AS EventCount4,
        (CASE WHEN r.n = 5 THEN sr.EventCount5 END) AS EventCount5,
        (CASE WHEN r.n = 1 THEN COALESCE(sr.EventDuration1, 0) END) AS EventDuration1,
        (CASE WHEN r.n = 2 THEN COALESCE(sr.EventDuration2, 0) END) AS EventDuration2,
        (CASE WHEN r.n = 3 THEN COALESCE(sr.EventDuration3, 0) END) AS EventDuration3,
        (CASE WHEN r.n = 4 THEN COALESCE(sr.EventDuration4, 0) END) AS EventDuration4,
        (CASE WHEN r.n = 5 THEN COALESCE(sr.EventDuration5, 0) END) AS EventDuration5
    FROM
        NumberedDataSet AS sr
        JOIN APM.Source AS s (NOLOCK) ON sr.SourceId = s.SourceId,
        APM.fn_nums(5) AS r
    ORDER BY 
        sr.Id,
        r.n
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ClientLatencyDistributionSubReport'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ClientLatencyDistributionSubReport AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:ClientLatencyDistributionSubReport                                          */
/* USED IN: Client Latency Distribution for sub report                              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - Id of the source                                                */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @SUBNETC - List subnet type C, selected by user                             */
/*      @ORDERBY - Specifies field to which sorting should be applayed              */
/*                  1. Event Count                                                  */
/*                  2. Problems Count                                               */
/*                  4. Event Duration                                               */
/*                  5. Latency                                                      */
/************************************************************************************/
ALTER PROCEDURE APM.ClientLatencyDistributionSubReport 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
 WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value for machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT
    ipid,
    ip.SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENT 
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    SUBNETC NVARCHAR(50) collate database_default
)
INSERT INTO #CLIENTEVENT
SELECT
    e.CSEventId,
    e.CSEventGroupId,
    f3.SUBNETC
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f1 ON f1.VALUEID = e.MachineId 
	JOIN #PMSTATUSFILTERTABLE AS f2 ON (f2.VALUEID = e.PMStatus)     
    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
WHERE 
    e.ClassType = N'Performance' 
    AND e.SourceId = @SOURCEID
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE 
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
-- Aggregate AJAX by event id, as several synchronous ajax call can belong to one event
;WITH AJAXEvents AS 
(
    SELECT
        e.CSEVENTID,
         -- Aggregation by Total Time make no difference, as for synch ajaxes total time will
         -- be taken from JS event, and for asynch AJAX here can be only one row
        AVG(ajax.TotalTime) AS TotalTime,
        -- For synch ajax select average latency among calls, for asynch here will be only one row
        AVG(ajax.Latency) AS Latency
    FROM
        #CLIENTEVENT AS e
        JOIN APM.CSAJAX AS ajax (NOLOCK) ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
),
-- For each subnet choose its average latency and event duration
SubNetCStatistics AS
(
    SELECT
        e.SUBNETC,
        COUNT(e.CSEVENTID) AS EventCount,
        COUNT(DISTINCT e.CSEVENTGROUPID) AS ProblemCount,
        -- Event could by either Page or JavaScript or Asycnh Ajax. Row in AJAX table will be presented for both synch and asynch ajaxes,
        -- But for synch AJAXes only latency should by taken and Total Time should by taken from either Page event or Jscript event        
        AVG(COALESCE(p.TotalTime, COALESCE(js.TotalTime, ajax.TotalTime)))/1000.0 AS EventDuration,
         --Latency could be either in page event or in Ajax event
        AVG(COALESCE(p.Latency, ajax.Latency)) AS Latency
    FROM
        #CLIENTEVENT AS e
        LEFT OUTER JOIN AJAXEvents AS ajax ON ajax.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON e.CSEVENTID = js.CSEventId     
    GROUP BY 
        e.SUBNETC
)
-- Select top 5 rows, ordered by specified parameter @ORDERBY
SELECT TOP(5)
    ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY
        WHEN 1 THEN EventCount
        WHEN 2 THEN ProblemCount
        WHEN 3 THEN EventDuration
        WHEN 4 THEN Latency
    END) DESC) AS Id,
    SubNetC AS Client,
    EventCount,
    ProblemCount,
    EventDuration,
    Latency
FROM
    SubNetCStatistics
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisJScriptWithAjaxCalls'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisJScriptWithAjaxCalls AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisJScriptWithAjaxCalls                                    */
/* USED IN: Application Analysis report for TOP slowest Ajax, top slowest JS,       */
/*          TOP largest AJAX                                                        */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/*      @THRESHOLD - Event threshold                                                */
/*      @ORDERBY1 - Specifies field to which sorting for largest AJAX calls         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Request Size                                             */
/*                      3. Response Size                                            */
/*                      4. Total Size                                               */
/*                      5. Total Time                                               */
/*      @ORDERBY2 - Specifies field to which sorting for slowest AJAX calls         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Client Time                                              */
/*                      3. Network Time                                             */
/*                      4. Server Time                                              */
/*                      5. Total Time                                               */
/*                      6. Request Size                                             */
/*                      7. Response Size                                            */
/*                      8. Latency                                                  */  
/*      @ORDERBY3 - Specifies field to which sorting for slowest JavaScript         */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. AJAX Call Count                                          */
/*                      3. Client Time                                              */
/*                      4. Network Time                                             */
/*                      5. Server Time                                              */
/*                      6. Total Time                                               */
/*                      7. Avg Event Size                                           */
/*                      8. Latency                                                  */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisJScriptWithAjaxCalls 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY1 INT,
    @ORDERBY2 INT,
    @ORDERBY3 INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) collate database_default   
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    SubNetC
FROM
    IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE database_default,
    CLASSTYPE NVARCHAR(50) COLLATE database_default,
    CSEVENTGROUPID INT
)
INSERT INTO #CLIENTEVENTS
SELECT
    e.CSEventId,    
    e.PageUri,
    e.ClassType,
    e.CSEventGroupId
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
    JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus) 
WHERE 
    e.sourceId = @SOURCEID
    AND PageUri IS NOT NULL
    AND e.UTCDate &gt;= @STARTDATE
    AND e.UTCDate &lt; @ENDDATE
    AND e.EventClass &lt;&gt; N'CSMPMonitorLog'
CREATE TABLE #AJAXCALLS
(
        ID INT,
        CSEVENTID INT,
        PAGEURI NVARCHAR(255) COLLATE database_default,
        AJAXACTION NVARCHAR(255) COLLATE database_default,
        TOTALTIME DECIMAL(35, 0),
        NETWORKTIME DECIMAL(35, 0),
        SERVERTIME DECIMAL(35, 0),
        RESPONSETIME DECIMAL(35, 0),
        REQUESTSIZE DECIMAL(35, 0),
        RESPONSESIZE DECIMAL(35, 0),
        LATENCY BIGINT,
        TOTALAJAXCALLCOUNT INT,
        AVGAJAXCALLDURATION FLOAT,
        SYNCHRONOUS BIT
)
-- Several synchronous Ajax calls could belong to one event, in that case only heaviest (by Total duration) should be taken.
-- Numerate Ajax calls for each event by Total Time in descending order.
-- Next step is to take ajax calls with id equal to 1.
-- For asynch ajaxes all rows will be with id = 1
;WITH AjaxCallsInternal AS 
(
    SELECT 
        ROW_NUMBER() OVER(PARTITION BY E.CSEVENTID ORDER BY ajax.TOTALTIME DESC, ajax.CSAJAXId) AS Id,
        e.CSEVENTID,
        e.PAGEURI,
        ajax.URI,
        COALESCE(ajax.TOTALTIME, 0) AS TotalTime,
        COALESCE(ajax.NETWORKTIME, 0) AS NetworkTime,
        COALESCE(ajax.SERVERTIME, 0) AS ServerTime,
        COALESCE(ajax.RESPONSETIME, 0) AS ResponseTime,
        COALESCE(ajax.REQUESTSIZE, 0) AS RequestSize,
        COALESCE(ajax.RESPONSESIZE, 0) AS ResponseSize,
        ajax.LATENCY,
        COUNT(CSAJAXId) OVER(PARTITION BY e.CSEVENTID) AS TotalAjaxCallCount,
        ajax.SYNCHRONOUS
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = ajax.CSEVENTID
),
AjaxCallsWithAvg AS
(
    SELECT 
        Id,
        CSEVENTID,
        PAGEURI,
        URI,
        TotalTime,
        NetworkTime,
        ServerTime,
        ResponseTime,
        RequestSize,
        ResponseSize,
        LATENCY,
        TotalAjaxCallCount,
        --calculate avg only for haviest ajax calls by ms
        AVG(CASE Id WHEN 1 THEN TotalTime END) OVER() AS AvgAjaxCallDuration,
        SYNCHRONOUS
    FROM
        AjaxCallsInternal   
)
INSERT INTO #AJAXCALLS
    SELECT * FROM AjaxCallsWithAvg
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
--Group information over ajax calls
;WITH HeaviestAjaxCalls AS
(
    SELECT
        PAGEURI,
        AJAXACTION,
        SYNCHRONOUS,
        COUNT(CSEVENTID) AS EventCount,
        AVG(TOTALTIME)/1000.0 AS TotalTime,
        AVG(NETWORKTIME)/1000.0 AS NetworkTime,
        AVG(SERVERTIME)/1000.0 AS ServerTime,
        AVG(RESPONSETIME)/1000.0 AS ResponseTime,
        AVG(REQUESTSIZE)/1024.0 AS RequestSize,
        AVG(RESPONSESIZE)/1024.0 AS ResponseSize,
        AVG(LATENCY) AS Latency,
        MAX(REQUESTSIZE + RESPONSESIZE)/1024.0 AS MaxAjaxCall,
        MAX(TOTALTIME)/1000.0 AS MaxAjaxCallDuration,
        SUM(TOTALAJAXCALLCOUNT) AS TotalAjaxCallCount,
        MIN(AVGAJAXCALLDURATION) / 1000.0 AS AvgAjaxCallDuration
    FROM 
        #AJAXCALLS
    WHERE
        --Select only heaviest AJAX calls for each event 
        ID = 1 
    GROUP BY 
        PAGEURI,
        AJAXACTION,
        SYNCHRONOUS
),
-- Select information for top 10 Largest AJAX calls
LargestAjaxCalls AS
(
    SELECT 
        ROW_NUMBER() OVER (ORDER BY CASE @ORDERBY1
                WHEN 1 THEN EventCount
                WHEN 2 THEN RequestSize
                WHEN 3 THEN ResponseSize
                WHEN 4 THEN COALESCE(RequestSize, 0) + COALESCE(ResponseSize, 0)
                WHEN 5 THEN TotalTime
            END DESC) AS Id,
        PageUri,
        AjaxAction,
        EventCount,
        RequestSize,
        ResponseSize,
        TotalTime,
        TotalAjaxCallCount,
        SUM(EventCount) OVER() AS TotalAjaxEventCount,
        AVG(RequestSize + ResponseSize) OVER() AS AvgAjaxCallSize,
        MAX(MaxAjaxCall) OVER() AS LargestAjaxCallSize
    FROM
        HeaviestAjaxCalls AS h
),
--Select information for top Slowest Ajax Calls (only asynch AJAXes)
SlowestAjaxCalls AS
(
    SELECT 
        ROW_NUMBER() OVER (ORDER BY CASE @ORDERBY2
                WHEN 1 THEN EventCount
                WHEN 2 THEN TotalTime - (NetworkTime + ResponseTime + ServerTime)
                WHEN 3 THEN NetworkTime + ResponseTime 
                WHEN 4 THEN ServerTime
                WHEN 5 THEN TotalTime
                WHEN 6 THEN RequestSize
                WHEN 7 THEN ResponseSize
                WHEN 8 THEN Latency
            END DESC) AS Id,
        PageUri,
        AjaxAction,
        EventCount,
        NetworkTime + ResponseTime AS NetworkTime,
        ServerTime,
        TotalTime - (NetworkTime + ResponseTime + ServerTime) AS ClientTime,
        TotalTime,
        RequestSize,
        ResponseSize,
        Latency,
        SUM(EventCount) OVER() AS TotalAjaxEventCount,
        AvgAjaxCallDuration,
        MAX(MaxAjaxCallDuration) OVER() AS MaxAjaxCallDuration
    FROM
        HeaviestAjaxCalls AS h
    WHERE
        -- Select only Asynch AJAXes
        Synchronous = 0
),
JavaScriptActions AS
(
    SELECT
        js.ACTION,
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        SUM(COALESCE(ajax.TOTALAJAXCALLCOUNT, 0)) AS AjaxCallCount,
        AVG(COALESCE(ajax.NETWORKTIME + ajax.RESPONSETIME, 0))/1000.0  AS JSNetworkTime,
        AVG(COALESCE(ajax.SERVERTIME, 0))/1000.0 AS JSServerTime,
        -- Clinet time is calculated as jsevent time minus ajax call time
        -- If JavaScript function has no ajax calls, then all time consider to be client time
        AVG(js.TOTALTIME - COALESCE(ajax.TOTALTIME, 0))/1000.0  AS JSClientTime,
        AVG(js.TOTALTIME)/1000.0  AS JSTotalTime,
        AVG(REQUESTSIZE + RESPONSESIZE)/1024.0  AS AvgSize,
        AVG(LATENCY) AS Latency,
        MAX(js.TOTALTIME)/1000.0 AS JSMaxTime       
    FROM
        APM.CSJScriptEvent AS js (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = js.CSEVENTID   
        -- If Java script has ajax events, condition id = 1 alows to select largest (by total time) ajax call
        LEFT OUTER JOIN #AJAXCALLS AS ajax ON (ajax.ID = 1 AND ajax.CSEVENTID = js.CSEVENTID)
    GROUP BY
        js.ACTION,
        e.PAGEURI
),
-- Order java script info by specified parameter
SlowestJScript AS 
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY3
                WHEN 1 THEN EventCount
                WHEN 2 THEN AJAXCallCount
                WHEN 3 THEN JSClientTime
                WHEN 4 THEN JSNetworkTime
                WHEN 5 THEN JSServerTime
                WHEN 6 THEN JSTotalTime
                WHEN 7 THEN AvgSize
                WHEN 8 THEN Latency
            END) DESC) AS id,
        Action AS JSAction,
        PageUri,
        EventCount,
        AJAXCallCount,
        JSClientTime,
        JSNetworkTime,
        JSServerTime,
        JSTotalTime,
        AvgSize,
        Latency,
        SUM(EventCount) OVER() AS TotalJSEventCount,
        MAX(JSMaxTime) OVER() AS JScriptMaxTime,
        -- Calculate average time for all java script events
        (SUM(JSTotalTime*EventCount) OVER())/(SUM(EventCount) OVER()) AS AverageJScriptTime
    FROM
        JavaScriptActions       
)
--select TOP 10 rows from each query
SELECT 
        [top].n AS Id,
-- Largest Ajax Calls
        la.PageUri AS la_PageUri,
        la.AjaxAction AS la_AjaxAction,
        la.EventCount AS la_EventCount,
        la.RequestSize AS la_RequestSize,
        la.ResponseSize AS la_ResponseSize,
        la.TotalTime AS la_TotalTime,
-- End Largest Ajax Calls
-- Slowest AJAX Calls
        sa.PageUri AS sa_PageUri,
        sa.AjaxAction AS sa_AjaxAction,
        sa.EventCount AS sa_EventCount,
        sa.NetworkTime AS sa_NetworkTime,
        sa.ServerTime AS sa_ServerTime,
        sa.ClientTime AS sa_ClientTime,
        sa.TotalTime AS sa_TotalTime,
        sa.RequestSize AS sa_RequestSize,
        sa.ResponseSize AS sa_ResponseSize,
        sa.Latency AS sa_Latency,
        sa.TotalAjaxEventCount AS sa_TotalAsynchAjaxesCount,
-- End Slowest AJAX Calls
-- Slowest JavaScript
        js.JSAction AS js_Action,
        js.PageUri AS js_PageUri,
        js.EventCount AS js_EventCount,
        js.AJAXCallCount AS js_AJAXCallCount,
        js.JSClientTime AS js_JSClientTime,
        js.JSNetworkTime AS js_JSNetworkTime,
        js.JSServerTime AS js_JSServerTime,
        js.JSTotalTime AS js_JSTotalTime,
        js.AvgSize AS js_AvgSize,
        js.Latency AS js_Latency,
        js.TotalJSEventCount,
-- End Slowest JavaScript
-- Summary information
        la.TotalAjaxCallCount,
        la.TotalAjaxEventCount,
        la.AvgAjaxCallSize,
        la.LargestAjaxCallSize,
        sa.AvgAjaxCallDuration,
        sa.MaxAjaxCallDuration,
        js.JScriptMaxTime,
        js.AverageJScriptTime
-- End Summary Information
FROM
    APM.fn_nums(10) AS [top]
    LEFT OUTER JOIN LargestAjaxCalls AS la ON [top].n = la.Id
    LEFT OUTER JOIN SlowestAjaxCalls AS sa ON [top].n = sa.Id
    LEFT OUTER JOIN SlowestJScript AS js ON [top].n = js.Id
ORDER BY
    Id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisTopPages                                                */
/* USED IN: Application Analysis report for TOP 10 slowest ans top 10 largest pages */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet masks list, which should be excluded                */
/*      @ORDERBY1 - Specifies field to which sorting for largest pages              */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Image Size                                               */
/*                      3. CSS Size                                                 */
/*                      4. HTC Behavior Size                                        */
/*                      5. Script Size                                              */
/*                      6. HTML Size                                                */
/*                      7. AJAX Size                                                */
/*                      8. Avg Page Size                                            */
/*                      9. Event Duration Time                                      */
/*      @ORDERBY2 - Specifies field to which sorting for slowest pages              */
/*                  should be applayed. Possible Values:                            */
/*                      1. Event Count                                              */
/*                      2. Network Time                                             */
/*                      3. Server Time                                              */
/*                      4. DOM Time                                                 */
/*                      5. Peripheral Time                                          */
/*                      6. OnLoad Time                                              */
/*                      7. Event Duration                                           */  
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50),
    @ORDERBY1 INT,
    @ORDERBY2 INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) COLLATE DATABASE_DEFAULT  
)
-- Insert into filter id of the SubnetC to increase performance for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    SubNetC
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE DATABASE_DEFAULT,
    CLASSTYPE NVARCHAR(50) COLLATE DATABASE_DEFAULT,
    CSEVENTGROUPID INT
)
INSERT INTO #CLIENTEVENTS
SELECT
    e.CSEVENTID,    
    e.PAGEURI,
    e.CLASSTYPE,
    e.CSEVENTGROUPID
FROM
    APM.CSEvent (NOLOCK) AS e
    JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MACHINEID)
    JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
	JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMSTATUS)     
WHERE 
    e.SOURCEID = @SOURCEID
    AND e.PAGEURI IS NOT NULL
    AND e.UTCDATE &gt;= @STARTDATE
    AND e.UTCDATE &lt; @ENDDATE
    AND e.EVENTCLASS = N'CSMPMonitorLog'
/****************************************************************************************/
/*                              MAIN QUERY                                              */
/****************************************************************************************/
;WITH AjaxCalls AS
(
    SELECT 
        e.CSEVENTID,
        SUM(ajax.RESPONSESIZE) AS ResponseSize,
        SUM(ajax.REQUESTSIZE) AS RequestSize
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON e.CSEVENTID = ajax.CSEventId
    GROUP BY
        e.CSEVENTID
),
-- Select information about page content size for each event (this information is available only for page events)
PeripheralDetails AS
(
    SELECT 
        b.CSEventId,
        COALESCE(b.Image, 0) AS Image, 
        COALESCE(b.HtcBehavior, 0) AS HtcBehavior, 
        COALESCE(b.Script, 0) AS Script, 
        COALESCE(b.html, 0) AS html, 
        COALESCE(b.CssStyle, 0) AS CssStyle,
        COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0) AS Ajax,
        COALESCE(b.Image, 0) + COALESCE(b.HtcBehavior, 0) + COALESCE(b.Script, 0) 
            + COALESCE(b.html, 0) + COALESCE(b.CssStyle, 0) 
            + COALESCE(ajax.ResponseSize + ajax.REQUESTSIZE, 0) AS TotalSize
    FROM
    (
        SELECT
            e.CSEVENTID,
            p.TYPE,
            p.TOTALSIZE
        FROM
            #CLIENTEVENTS AS e
            JOIN APM.CSPeripheral AS p (NOLOCK) ON e.CSEVENTID = p.CSEVENTID
    )AS A
    PIVOT (SUM(TotalSize) FOR Type IN (Image, HtcBehavior, Script, html, CssStyle)) AS b
    LEFT OUTER JOIN AjaxCalls AS ajax ON (ajax.CSEVENTID = b.CSEVENTID)
),
-- Group page events information by pages
PageEvents AS
(
    SELECT
        e.PAGEURI,
        COUNT(e.CSEVENTID) AS EventCount,
        -- All null values in time segments should be changed to 0, to provide convergence with average total time
        AVG(COALESCE(p.NetworkTime, 0))/1000.0 AS NetworkTime,
        AVG(COALESCE(p.ServerTime, 0))/1000.0 AS ServerTime,
        AVG(COALESCE(p.DomTime, 0))/1000.0 AS DomTime,
        AVG(COALESCE(p.PeripheralTime, 0))/1000.0 AS PeripheralTime,
        AVG(COALESCE(p.OnLoadTime, 0))/1000.0 AS OnLoadTime,    
        AVG(p.TotalTime)/1000.0 AS EventDuration,
        MAX(p.TotalTime)/1000.0 AS MaxEventDuration,
        AVG(d.TotalSize)/1024.0 AS AveragePageSize,
        MAX(d.TotalSize)/1024.0 AS MaxPageSize,
        AVG(d.Image)/1024.0 AS ImageSize, 
        AVG(d.HtcBehavior)/1024.0 AS HtcBehaviorSize, 
        AVG(d.Script)/1024.0 AS ScriptSize, 
        AVG(d.html)/1024.0 AS HTMLSize, 
        AVG(d.CssStyle)/1024.0 AS CssStyleSize,
        AVG(Ajax)/1024.0 AS AJAXCallSize    
    FROM
        #CLIENTEVENTS AS e
        JOIN APM.CSPageEvent AS p (NOLOCK) ON p.CSEventId = e.CSEVENTID
        LEFT OUTER JOIN PeripheralDetails AS d ON d.CSEventId = e.CSEVENTID
    GROUP BY
        e.PAGEURI       
),
-- Select information for top 10 largest pages
LargesPage AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY1
            WHEN 1 THEN EventCount
            WHEN 2 THEN ImageSize
            WHEN 3 THEN CssStyleSize
            WHEN 4 THEN HtcBehaviorSize
            WHEN 5 THEN ScriptSize
            WHEN 6 THEN HTMLSize
            WHEN 7 THEN AJAXCallSize
            WHEN 8 THEN AveragePageSize
            WHEN 9 THEN EventDuration
        END) DESC) AS id,   
        PageUri,
        EventCount,
        ImageSize,
        CssStyleSize,
        HtcBehaviorSize,
        ScriptSize,
        HTMLSize,
        AJAXCallSize,
        AveragePageSize AS TotalSize,
        EventDuration,
        SUM(EventCount) OVER() AS TotalPageEventCount,
        -- Select information about max page size and average page size over all application events,
        -- This information will be shown in report summary information
        MAX(MaxPageSize) OVER() AS MaxPageSize,
        (SUM(AveragePageSize*EventCount) OVER())/(SUM(EventCount) OVER()) AS AveragePageSize
    FROM
        PageEvents
),
-- Select information for top 10 slowest pages
SlowestPage AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY (CASE @ORDERBY2
            WHEN 1 THEN EventCount
            WHEN 2 THEN NetworkTime
            WHEN 3 THEN ServerTime
            WHEN 4 THEN DomTime
            WHEN 5 THEN PeripheralTime
            WHEN 6 THEN OnLoadTime
            WHEN 7 THEN EventDuration
        END) DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DomTime,
        PeripheralTime,
        OnLoadTime,
        EventDuration AS TotalTime,
        -- Select information about max page load time and average page load time over all application events,
        -- This information will be shown in report summary information
        MAX(MaxEventDuration) OVER() AS MaxPageLoadTime,
        (SUM(EventDuration*EventCount) OVER())/(SUM(EventCount) OVER()) AS AveragePageLoadTime,
    --Get ajax call flag
        CASE WHEN EXISTS(
               SELECT * 
                 FROM #CLIENTEVENTS c
                    JOIN CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                        
               WHERE d.PageUri = c.PAGEURI
             ) THEN '*' ELSE ''
        END AS Extension
    FROM
        PageEvents d
)
SELECT 
    [top].n AS Id,
-- Largest Pages
        lp.PageUri AS lp_PageUri,
        lp.EventCount AS lp_EventCount,
        lp.ImageSize AS lp_ImageSize,
        lp.CssStyleSize AS lp_CssStyleSize,
        lp.HtcBehaviorSize AS lp_HtcBehaviorSize,
        lp.ScriptSize AS lp_ScriptSize,
        lp.HTMLSize AS lp_HTMLSize,
        lp.AJAXCallSize AS lp_AJAXCallSize,
        lp.TotalSize AS lp_TotalSize,
        lp.EventDuration AS lp_EventDuration,
-- End Largest Pages        
-- Slowest Pages
        sp.PageUri AS sp_PageUri,
        sp.EventCount AS sp_EventCount,
        sp.NetworkTime AS sp_NetworkTime,
        sp.ServerTime AS sp_ServerTime,
        sp.DomTime AS sp_DomTime,
        sp.PeripheralTime AS sp_PeripheralTime,
        sp.OnLoadTime AS sp_OnLoadTime,
        sp.TotalTime AS sp_TotalTime,
        sp.Extension AS sp_Extension,
-- End Slowest Pages
-- Summary information
        lp.TotalPageEventCount AS TotalPageEventCount,
        lp.MaxPageSize,
        lp.AveragePageSize,
        sp.MaxPageLoadTime,
        sp.AveragePageLoadTime  
-- End Summary Information
FROM
    APM.fn_nums(10) AS [top]
    LEFT OUTER JOIN LargesPage AS lp ON [top].n = lp.Id 
    LEFT OUTER JOIN SlowestPage AS sp ON [top].n = sp.Id 
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceTopPages'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceTopPages AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceTopPages                                                 */
/* USED IN: SummaryPerfTop5PageSubReport.rdl subreport                              */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceTopPages 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- valueId filter value - machine id 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
CREATE TABLE #CLIENTEVENTS 
(
    CSEVENTID INT,
    PAGEURI NVARCHAR(255) COLLATE DATABASE_DEFAULT
)
-- Filter Event Table by incoming parameters
INSERT INTO #CLIENTEVENTS
    SELECT 
        e.CSEventId,
        e.PageUri        
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        JOIN #MACHINEFILTERTABLE AS f ON (f.VALUEID = e.MachineId)
        JOIN #SUBNETCFILTERTABLE AS f1 ON (f1.IPID = e.ipid)
        JOIN #PMSTATUSFILTERTABLE AS f2 ON (f2.VALUEID = e.PMStatus) 
    WHERE 
        e.sourceId = @SOURCEID
        AND UTCDATE &gt;= @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND EventClass = 'CSMPMonitorLog'
;WITH CSPageEvents AS
(
    SELECT 
        e.CSEVENTID,
        e.PAGEURI,
        -- Null values should be replaced by 0, to get convergence with Total time after averaging
        COALESCE(pe.NetworkTime, 0) AS NetworkTime,
        COALESCE(pe.ServerTime, 0) AS ServerTime,
        COALESCE(pe.DOMTime, 0) AS DOMTime,
        COALESCE(pe.PeripheralTime, 0) AS PeripheralTime,
        COALESCE(pe.OnLoadTime, 0) AS OnLoadTime,
        pe.TotalTime,
        pe.TotalSize
    FROM 
        #CLIENTEVENTS e
        JOIN APM.CSPAGEEVENT AS pe (NOLOCK) ON pe.cseventid = e.CSEVENTID AND pe.TotalTime/1000.0 &gt;= @THRESHOLD
        
),
PageProcessingTime AS
(
    SELECT 
        PageUri,
        COUNT(CSEVENTID) AS EventCount,
        AVG(NetworkTime)/1000 AS NetworkTime,
        AVG(ServerTime)/1000 AS ServerTime,
        AVG(DOMTime)/1000 AS DOMTime,
        AVG(PeripheralTime)/1000 AS PeripheralTime,
        AVG(OnLoadTime)/1000 AS OnLoadTime,
        AVG(TotalTime)/1000 AS TotalTime,
        AVG(TotalSize)/(1024.0) AS TotalSize
    FROM 
        CSPageEvents
    GROUP BY
        PageUri  
),
NumberedPages AS
(
    SELECT 
        row_number() OVER(ORDER BY EventCount DESC) AS id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        PageProcessingTime  
)
SELECT
    TOP(5)
        id,
        PageUri,
        EventCount,
        NetworkTime,
        ServerTime,
        DOMTime,
        PeripheralTime,
        OnLoadTime,
        TotalTime,
        TotalSize,
        TotalEvents,
        --Get ajax call flag
        CASE WHEN EXISTS(
            SELECT * 
                FROM #CLIENTEVENTS c
                     JOIN CSPageEvent AS pe (NOLOCK) ON pe.cseventid = c.CSEVENTID
                     JOIN CSAJAX AS csaj (NOLOCK) ON csaj.cseventid = c.CSEVENTID                                       
                WHERE d.PageUri = c.PAGEURI
        ) THEN '*' ELSE ''
        END AS Extension
    FROM 
        NumberedPages d 
    ORDER BY id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisExceptionEvents'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisExceptionEvents AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisExceptionEvents                                             */
/* USED IN: Application Analysis report for exception events    */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisExceptionEvents 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #MACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
;WITH RequestPCTypeId AS
(
    SELECT
        PCTypeID
    FROM
        APM.PCTYPE 
    WHERE
        TYPE = N'\Apps\Monitored Requests'
),
RequestCount AS
(
    SELECT
        SUM(SUMVALUE) AS RequestCount
    FROM
        APM.PerfHourly AS ph (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (ph.MachineId = f1.VALUEID)
        JOIN RequestPCTypeId AS pct ON pct.PCTypeID = ph.PCTypeID
    WHERE
        UTCDATE &gt;= @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND ph.sourceid = @SOURCEID
),
EventDescription AS
(
    SELECT 
        COUNT(CSEVENTID) AS EventCount,
        COUNT(DISTINCT CSEVENTGROUPID) AS ProblemCount,
        COUNT(CASE WHEN CHARINDEX(N'MSIE', E.BROWSER) &gt; 0 THEN E.CSEVENTID ELSE NULL END) AS IEEventCount,
        COUNT(CASE WHEN CHARINDEX(N'Firefox', E.BROWSER) &gt; 0 THEN E.CSEVENTID ELSE NULL END) AS FirefoxEventCount,
        DESCRIPTION
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (e.MachineId = f1.VALUEID)
        -- Filter client events by subnets
        JOIN #SUBNETCFILTERTABLE AS f2 ON (e.ipid = f2.IPID)
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.ClassType = N'exception'
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE
        AND e.sourceid = @SOURCEID
    GROUP BY 
        DESCRIPTION
),
OrderedDataSet AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY E.EventCount DESC) AS id,
        EventCount,
        ProblemCount,
        IEEventCount,
        FirefoxEventCount,
        Description,
        SUM(E.EventCount) OVER() AS TotalEventCount,
        SUM(E.ProblemCount) OVER() AS TotalProblemCount
    FROM
        EventDescription AS e
)
SELECT 
    TOP(10) E.*, req.RequestCount
FROM
    OrderedDataSet AS e
    CROSS JOIN RequestCount AS req
ORDER BY
    E.ID
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationAnalysisOverallStatistics'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationAnalysisOverallStatistics AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: ApplicationAnalysisOverallStatistics                                       */
/* USED IN: Application Analysis report                                         */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEID - SourceId                                                        */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - List masks, which should be included                       */
/*      @EXCLUDESUBNET - List masks, which should be excluded                       */
/************************************************************************************/
ALTER PROCEDURE APM.ApplicationAnalysisOverallStatistics 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEID NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
    
-- Filter table, which contains machine ids 
CREATE TABLE #MACHINEFILTERTABLE(
    VALUEID INT
)
-- Fill table #MACHINEFILTERTABLE
INSERT 
    INTO #MACHINEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
CREATE TABLE #CLIENTEVENTS
(
    CSEVENTID INT,
    CSEVENTGROUPID INT,
    CLASSTYPE NVARCHAR(50) COLLATE DATABASE_DEFAULT
)
INSERT INTO #CLIENTEVENTS
    SELECT 
        e.cseventid,
        e.csEventGroupId,
        e.ClassType
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (e.MachineId = f1.VALUEID)
        -- Filter client events by subnets
        JOIN #SUBNETCFILTERTABLE AS f2 ON (e.ipid = f2.IPID)
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
    WHERE
        e.sourceid = @SOURCEID
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE
;WITH RequestPCTypeId AS
(
    SELECT
        PCTypeID
    FROM
        APM.PCTYPE 
    WHERE
        TYPE = N'\Apps\Monitored Requests'
),
RequestCount AS
(
    SELECT
        SUM(SUMVALUE) AS RequestCount
    FROM
        APM.PerfHourly AS ph
        -- Filter client events by machines
        JOIN #MACHINEFILTERTABLE AS f1 ON (ph.MachineId = f1.VALUEID)
        JOIN RequestPCTypeId AS pct ON pct.PCTypeID = ph.PCTypeID
    WHERE
        ph.sourceid = @SOURCEID
        AND UTCDATE &gt; @STARTDATE
        AND UTCDATE &lt; @ENDDATE  
),
AJAXEvents AS
(
    SELECT
        AVG(ajax.REQUESTSIZE + ajax.ResponseSize) AS AjaxCallSize,
        AVG(ajax.TotalTime) AS AjaxCallDuration,
        MAX(ajax.REQUESTSIZE + ajax.ResponseSize) AS MaxAjaxCallSize,
        MAX(ajax.TotalTime) AS MaxAjaxCallDuration,
        COUNT(ajax.CSEventId) AS AjaxCallCount
    FROM
        APM.CSAJAX AS ajax (NOLOCK)
        JOIN #CLIENTEVENTS AS e ON ajax.CSEventId = e.CSEVENTID
    WHERE
        e.CLASSTYPE = N'performance'
),
ExceptionEvents AS
(
    SELECT
        COUNT(CSEVENTID) AS EventCount,
        COUNT(CSEVENTGROUPID) AS ProblemCount
    FROM
        #CLIENTEVENTS AS e
    WHERE
        e.CLASSTYPE = N'exception'
),
PerformanceEvents AS
(
    SELECT
        COUNT(CSEVENTID) AS EventCount,
        COUNT(CSEVENTGROUPID) AS ProblemCount
    FROM
        #CLIENTEVENTS AS e
    WHERE
        e.CLASSTYPE = N'performance'
)
SELECT 
    e.EventCount AS ExceptionEventsCount,
    e.ProblemCount AS ExceptionProblemCount,
    perf.EventCount AS PerformanceEventsCount,
    perf.ProblemCount AS PerformanceProblemCount,
    ajax.AjaxCallSize/1024.0 AS AjaxCallSize,
    ajax.AjaxCallDuration/1000.0 AS AjaxCallDuration,
    ajax.MaxAjaxCallSize/1024.0 AS MaxAjaxCallSize,
    ajax.MaxAjaxCallDuration/1000.0 AS MaxAjaxCallDuration,
    ajax.AjaxCallCount,
    req.RequestCount
FROM
    ExceptionEvents AS e
    CROSS JOIN PerformanceEvents AS perf
    CROSS JOIN RequestCount AS req
    CROSS JOIN AJAXEvents AS ajax
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryPerformanceAnalysisReportTopJS'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryPerformanceAnalysisReportTopJS AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME: SummaryPerformanceAnalysisReportTopJS                                  */
/* USED IN: Summary Performance Analysis Report                                     */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCE - source Id                                                     */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @THRESHOLD - Event threshold                                                */
/************************************************************************************/
ALTER PROCEDURE APM.SummaryPerformanceAnalysisReportTopJS 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCE INT, 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
/****************************************************************************************/
/*                      ASSISTING TEMP TABLES                                           */
/****************************************************************************************/
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains msource ids
CREATE TABLE #SOURCEFILTERTABLE(
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT 
    INTO #SOURCEFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@MACHINEIDS, N'') AS p 
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid
FROM
    APM.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
        
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
                
;WITH CSAjaxPageEvents AS
(
    SELECT
        e.CSEventID,
        e.pageUri,
        -- This name will be used only for Asynch Ajax Event, and for this events here will be only one row
        MAX(ajax.uri) AS ActionName,
        SUM(ajax.TotalTime) AS AJAXCallProcessingTime,
        SUM(ajax.NetworkTime) AS NetworkTime,
        SUM(ajax.ServerTime) AS ServerTime,
        SUM(ajax.REQUESTSIZE) AS RequestSize,
        SUM(ajax.ResponseSize) AS ResponseSize
    FROM 
        APM.CSEVENT AS e (NOLOCK)
        JOIN #SOURCEFILTERTABLE AS f1 ON (f1.VALUEID = e.MachineId)
        JOIN #SUBNETCFILTERTABLE AS f2 ON e.ipid = f2.IPID
		JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)         
        LEFT OUTER JOIN APM.CSAjax (NOLOCK) AS ajax ON ajax.cseventid = e.cseventid
    WHERE 
        e.sourceId = @SOURCE
        AND e.UTCDate &gt;= @STARTDATE
        AND e.UTCDate &lt; @ENDDATE
        AND e.EventClass &lt;&gt; N'CSMPMonitorLog'
    GROUP BY
        e.CSEventID,
        e.pageUri       
),
AJAXEventSummary AS
(
    SELECT
        e.CSEventID,
        e.pageUri,
        COALESCE(js.Action, e.ActionName) AS JSActionName,
        COALESCE(js.TotalTime, e.AJAXCallProcessingTime) AS TotalTime,
        COALESCE(js.TotalTime - COALESCE(e.AJAXCallProcessingTime, 0), asyncAjax.HandlerTime) AS ClientTime,
        COALESCE(e.NetworkTime, 0) AS NetworkTime,
        COALESCE(e.ServerTime, 0) AS ServerTime,
        e.REQUESTSIZE,
        e.ResponseSize
    FROM
        CSAjaxPageEvents AS e
        LEFT OUTER JOIN APM.CSJScriptEvent AS js (NOLOCK) ON js.cseventid = e.cseventid
        LEFT OUTER JOIN APM.CSAsyncAjax AS asyncAjax (NOLOCK) ON asyncAjax.cseventid = e.cseventid
    WHERE
        COALESCE(js.TotalTime, e.AJAXCallProcessingTime)/1000.0 &gt;= @THRESHOLD
),
AjaxPage AS
(
    SELECT 
        JSActionName,
        pageUri,
        COUNT(CSEventID) AS EventCount,
        AVG(ClientTime)/1000 AS ClientTime,
        AVG(NetworkTime)/1000 AS NetworkTime,
        AVG(ServerTime)/1000 AS ServerTime,
        AVG(TotalTime)/1000 AS AJAXTotalTime,
        AVG(RequestSize)/(1024.0) AS RequestSize,
        AVG(ResponseSize)/(1024.0) AS ResponseSize
    FROM
        AJAXEventSummary
    GROUP BY
        JSActionName,pageUri
),
OrderedActions AS
(
    SELECT
        ROW_NUMBER() OVER(ORDER BY EventCount DESC) AS id,
        EventCount,
        JSActionName,
        pageUri,
        ClientTime,
        NetworkTime,
        ServerTime,
        AJAXTotalTime AS TotalTime,
        RequestSize + ResponseSize AS AJAXCallSize,
        SUM(EventCount) OVER() AS TotalEvents
    FROM 
        AjaxPage
)
SELECT TOP(5)
    *
FROM 
    OrderedActions
ORDER BY
    id
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationActivityBreakdownByMonthDate'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationActivityBreakdownByMonthDate AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationActivityBreakdownByMonthDate                                        */
/* USED IN: Application Status  Report, Application Activity                            */
/* DESCRIPTION: This SP is used in report above in case, when grouping by month date    */
/*      specified                                                                       */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period in Client time zone                    */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
ALTER PROCEDURE APM.ApplicationActivityBreakdownByMonthDate
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = 31
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @ENDDATE)    
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @STARTDATE)
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM APM.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
    
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- To form application pool with all sources run in it, it is need to get all sources and its process
    CREATE TABLE #PROCESSFORSOURCE
    (
        SOURCEID INT,
        PCPROCESSID INT,
        MACHINEID INT,
        EXTRAINFO NVARCHAR(255) COLLATE DATABASE_DEFAULT,
        PROCESS NVARCHAR(255) COLLATE DATABASE_DEFAULT
    )
    
    INSERT INTO #PROCESSFORSOURCE
        SELECT
            ph.SourceId,
            ph.PCProcessId,
            ph.MachineId,
            COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
            --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
            APM.RemoveProcessIdFromName(p.Process) AS Process           
        FROM
            (
                SELECT DISTINCT
                    ph.SourceId,
                    ph.pcprocessId,
                    ph.MachineId
                FROM
                    APM.PerfHourly AS ph (NOLOCK)
                WHERE
                    ph.pcprocessId IS NOT NULL
                    AND ph.UTCDate &gt;= @STARTDATE
                    AND ph.UTCDate &lt; @ENDDATE 
            ) AS ph
            JOIN APM.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.pcprocessId 
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MachineId = f.VALUEID)
    -- Report frame. It contains all sources, for which values sould be selected, 
    -- and dates for the specified period (StartDate : EndDate)  
    ;WITH SourcesDates AS
    (
        SELECT
            VALUEID AS sourceid,
            s.source AS source,
            -- Select 31 day from end date in ClientTime zone, without hours
            CONVERT(NVARCHAR, DATEADD(d, -d.n, DATEADD(minute, @TIMEZONE, @ENDDATE)), 112) AS ClientDate
        FROM
            #SOURCEMACHINEFILTERTABLE AS source
            JOIN APM.source (NOLOCK) AS s ON s.sourceid = source.VALUEID
            CROSS JOIN APM.fn_nums(31) AS d
        WHERE
            source.TYPEID = 1
    ),
    AppPoolInfo AS 
    (
        SELECT 
            c.SOURCEID,
            c.EXTRAINFO,
            c.PROCESS,
            -- all source names which have the same process name as passed in @SOURCEIDS
            (SELECT A.source AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        N'''' + s.source + N'''' +  N',' AS source
                    FROM 
                        #PROCESSFORSOURCE AS c1
                        JOIN APM.Source AS s ON c1.SOURCEID = s.SourceId
                    WHERE 
                        c1.EXTRAINFO = c.EXTRAINFO 
                        AND c1.PROCESS = c.PROCESS
                        AND c1.MACHINEID = c.MACHINEID
                ) AS A
                FOR XML PATH ('') 
            ) AS AppPoolSources
        FROM
            #PROCESSFORSOURCE AS c
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
        GROUP BY
            c.SOURCEID, 
            c.MACHINEID,
            c.EXTRAINFO,
            c.PROCESS
    ),
    --Add Pool name in-front of source list, if it is executable application, then app pool countains source name
    PrepareAppPoolInfo AS (
        SELECT DISTINCT
            CASE 
                WHEN COALESCE(info.ExtraInfo,'') = '' THEN CASE info.AppPoolSources WHEN '' THEN '' ELSE LEFT(info.AppPoolSources, LEN(info.AppPoolSources)-1) END
                ELSE info.ExtraInfo + CASE info.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(info.AppPoolSources, LEN(info.AppPoolSources) - 1) + ')' END
            END AppPool,
            info.SourceId,
            info.ExtraInfo
        FROM 
            AppPoolInfo AS info
    ),
    -- Forms application pool list for each source
    -- Format: AppPool1 ('Source1', 'Source2', Source3), AppPool2 ('Source1', 'Source4')
    SourceAppPools AS (
        SELECT 
            s.SourceId,
            s.Source,
            COALESCE((SELECT a.AppPool AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        info.AppPool +  N',' AS AppPool
                    FROM 
                        PrepareAppPoolInfo as info
                    WHERE 
                        info.Sourceid = s.Sourceid 
                ) AS A
                FOR XML PATH ('') 
            ),s.Source +  '-') AS AppPoolInfo
        FROM 
            APM.Source AS s
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = s.SourceId)
    ),    
    --Prepares and filters events for further manipulations
    ActivityBreakdown_EventsFiltered AS
    (
        SELECT
            e.sourceid,
            e.eventid,
            e.utceventdate AS eventdate,
            -- Event Date in Client Timezone without hours
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE, e.utceventdate), 112) AS ClientDate,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            ABS(DATEDIFF(hour, e.utceventdate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId,
            e.eventgroupid,
            db.ADDRESS AS SeViewerAddress
        FROM
            APM.Event AS e
            JOIN APM.SeViewerDB AS db ON e.seviewerdbid = db.seviewerdbid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.sourceid and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.machineid and f2.TYPEID = 2)
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE
            ((e.EventClassType = N'Performance' AND e.eventduration / 1000000.0 &gt;= @THRESHOLD) 
            OR e.EventClassType = N'exception')
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)            
    ),
    /************************************************************************************/
    /*                          Base pcounter queries                                   */
    /************************************************************************************/
    -- Calculate resource utilization by Source in one hour.
    -- Aggregation between instances should be done here (for cases when one source run in several process in one hour)
    SourceHourlyResourceUtilization AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PerfHourly date in client time zone without hours
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE ,ph.UTCDate), 112) AS ClientDate,
            ph.PCTypeId AS Type,    
            ---------- Pivot instance count by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS LastInstanceCount,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS CurInstanceCount,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN SUM(ph.SampleCount)*1.0/MAX(ph.PackageCounter)
            END) AS AvgInstanceCount,
            
            ---------- Pivot resource value by period type -----------
            (CASE 
                WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount)
            END) AS LastValue,
            (CASE 
                WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS CurValue,
            (CASE 
                WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE THEN SUM(SumValue)/SUM(SampleCount) 
            END) AS AvgValue,
            ABS(DATEDIFF(hour, ph.UTCDate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            APM.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 1 provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND f1.VALUEID = ph.SourceId)
            --Join with #SOURCEMACHINEFILTERTABLE with typeid = 2 provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeId IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate,
            ph.PCTypeId
    ),
    -- Bring ClientDate to current period, as in result data set, data only for current period are shown
    -- (all other should be shown relative to current period)
    SourceHourlyResourceUtilizationByCurrentPeriod AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, ph.PeriodId*31, ClientDate) AS ClientDate,
            ph.Type,    
            ph.LastInstanceCount,
            ph.CurInstanceCount,
            ph.AvgInstanceCount,
            ph.LastValue,
            ph.CurValue,
            ph.AvgValue,
            ph.PeriodId
        FROM
            SourceHourlyResourceUtilization AS ph
    ),
    --Calculate average source resource utilization for each resource type
    --and for specified grouping period and date          
    ApplicationResourceUtilizationByMachines AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate,
            -- Instance count should be same for different resource types in one hour for one process
            -- and averaging them won't make any difference but allow to avoid one aggregation step  
            AVG(ph.CurInstanceCount) AS CurInstanceCount,
            AVG(ph.LastInstanceCount) AS LastInstanceCount,
            AVG(ph.AvgInstanceCount) AS AvgInstanceCount,
            ---------- Pivot resource by counter type -----------
            ----------- 'Process% Processor Time' counter -------------------
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.CurValue END) AS CurCPUSum, 
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.LastValue END) AS LastCPUSum,
            AVG(CASE WHEN ph.type = @PROCESSORCOUNTERID THEN ph.AvgValue END) AS AvgCPUSum,
            ----------- 'ProcessPrivate Bytes' counter -------------------
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.CurValue END)  AS CurMemSum, 
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.LastValue END) AS LastMemSum,
            AVG(CASE WHEN ph.type = @MEMORYCOUNTERID THEN ph.AvgValue END)  AS AvgMemSum,
            ----------- 'ProcessIO Data Bytes/sec' counter -------------------
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.CurValue END) AS CurIOSum, 
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.LastValue END) AS LastIOSum,
            AVG(CASE WHEN ph.type = @IOCOUNTERID THEN ph.AvgValue END) AS AvgIOSum
        FROM
            SourceHourlyResourceUtilizationByCurrentPeriod AS ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate
    ),
    -- Count Monitored Requests and Avg. Request Timefor Application on each machine
    -- as source can run on different machines with same process name and app pool, but different sources set, 
    -- it is important to group by machine to, to avoid calculation of requests from the other app pool
    -- Summarize request count in each period (PeriodId differs only for AvgValue)
    ApplicationNetAppCountersByMachinePrepare AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            CONVERT(NVARCHAR, DATEADD(minute, @TIMEZONE, ph.UTCDate), 112) AS ClientDate,
            ----------------- Pivot Monitor Request Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                 THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)  
            END AS LastMonRequest,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) 
            END AS CurMonRequest,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE
                THEN SUM(CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END)
            END AS AvgMonRequest,
            
            ----------------- Pivot Avg. Request Time Counter by period ------------------
            CASE WHEN ph.UtcDate &gt;= @LASTPERIODSTARTDATE AND ph.UtcDate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS LastAvgReqTime,
            CASE WHEN ph.UtcDate &gt;= @STARTDATE AND ph.UtcDate &lt; @ENDDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END)
            END AS CurAvgReqTime,
            CASE WHEN ph.utcdate &gt;= @AVERAGEPERIODSTARTDATE AND ph.utcdate &lt; @STARTDATE 
                THEN AVG(CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END) 
            END AS AvgReqTime,
            ABS(DATEDIFF(hour, ph.UTCDate, @ENDDATE)) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.PerfHourly AS ph (NOLOCK)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by sourceid
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            --Join with #SOURCEMACHINEFILTERTABLE provides filtering perfHourly by machineid
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.UTCDate
    ),
    -- Bring ClientDate to current period, as in result data set, data only for current period are shown
    -- (all other should be shown relative to current period)
    ApplicationNetAppCountersByCurrentPeriod AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, ph.PeriodId*31, ClientDate) AS ClientDate,
            ph.LastMonRequest,
            ph.CurMonRequest,
            ph.AvgMonRequest,
            ph.LastAvgReqTime,
            ph.CurAvgReqTime,
            ph.AvgReqTime,
            ph.PeriodId
        FROM
            ApplicationNetAppCountersByMachinePrepare AS ph 
    ),
    --Calculate average request time  and  sum request count for specified grouping period and date          
    ApplicationNetAppCountersByMachine AS
    (
        SELECT 
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate,
            SUM(ph.LastMonRequest) AS LastMonRequest,
            SUM(ph.CurMonRequest) AS CurMonRequest,
            SUM(ph.AvgMonRequest) AS AvgMonRequest,
            AVG(ph.LastAvgReqTime) AS LastAvgReqTime,
            AVG(ph.CurAvgReqTime) AS CurAvgReqTime,
            AVG(ph.AvgReqTime) AS AvgReqTime  
        FROM 
            ApplicationNetAppCountersByCurrentPeriod ph
        GROUP BY
            ph.MachineId,
            ph.SourceId,
            ph.PeriodId,
            ph.ClientDate
    ),
    --  Union .NET counters and process counters for period Id. Period Id differs only for average(last three months) values, so grouping only for them
    PCountersGroupedByMachineId AS (
        SELECT 
            pc.machineId,
            pc.SourceId,
            pc.ClientDate,
            MAX(netApp.CurMonRequest) AS CurReqCount, 
            MAX(netApp.LastMonRequest) AS LastReqCount,
            AVG(netApp.AvgMonRequest) AS AvgReqCount,
            
            MAX(netApp.CurAvgReqTime) AS CurAvgReqTime, 
            MAX(netApp.LastAvgReqTime) AS LastAvgReqTime,
            AVG(netApp.AvgReqTime) AS AvgReqTime,
            
            MAX(pc.CurCPUSum) AS CurCPUSum, 
            MAX(pc.LastCPUSum) AS LastCPUSum,
            AVG(pc.AvgCPUSum) AS AvgCPUSum,
            MAX(pc.CurMemSum) AS CurMemSum, 
            MAX(pc.LastMemSum) AS LastMemSum,
            AVG(pc.AvgMemSum) AS AvgMemSum,
            MAX(pc.CurIOSum) AS CurIOSum, 
            MAX(pc.LastIOSum) AS LastIOSum,
            AVG(pc.AvgIOSum) AS AvgIOSum
       FROM ApplicationResourceUtilizationByMachines pc
       LEFT JOIN ApplicationNetAppCountersByMachine AS netApp ON netApp.MachineId = pc.MachineId 
                AND netApp.SourceId = pc.SourceId AND netApp.PeriodId = netApp.PeriodId 
                AND netApp.ClientDate = pc.ClientDate
        GROUP BY
            pc.machineId,
            pc.SourceId,
            pc.ClientDate
    ),
    -- Calculate average source resource utilization between machines  
    ActivePreparePCounters AS (
        SELECT 
            pc.SourceId,
            -- Convert date to appropriate format to provide correct comparison
            pc.ClientDate,
            SUM(CurReqCount) AS CurReqCount, 
            SUM(LastReqCount) AS LastReqCount,
            SUM(AvgReqCount) AS AvgReqCount,
            AVG(CurAvgReqTime) AS CurAvgReqTime, 
            AVG(LastAvgReqTime) AS LastAvgReqTime,
            AVG(AvgReqTime) AS AvgReqTime,
            AVG(CurCPUSum / COALESCE(m.CPUCount, 1)) AS CurCPUSum, 
            AVG(LastCPUSum / COALESCE(m.CPUCount, 1) ) AS LastCPUSum,
            AVG(AvgCPUSum / COALESCE(m.CPUCount, 1)) AS AvgCPUSum,
            AVG(CurMemSum) AS CurMemSum, 
            AVG(LastMemSum) AS LastMemSum,
            AVG(AvgMemSum) AS AvgMemSum,
            AVG(CurIOSum) AS CurIOSum, 
            AVG(LastIOSum) AS LastIOSum,
            AVG(AvgIOSum) AS AvgIOSum
        FROM 
            PCountersGroupedByMachineId AS pc
            JOIN apm.Machine AS m ON m.MachineId = pc.MachineId
        GROUP BY    
            pc.SourceId,
            pc.ClientDate
    ),
    -- Count events for the current, last and average period. 
    -- PeriodId is 0 for Current period, 1 for last period, and 1..n for average period
    PrepareEventsAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- this manipulation should bring Client date to current period
            DATEADD(day, e.PeriodId*31, e.ClientDate) AS ClientDate,
            e.PeriodId,         
            MAX(E.SeViewerAddress) AS SeViewerAddress,  
            COUNT(CASE WHEN e.eventdate &gt;= @STARTDATE AND e.eventdate &lt; @ENDDATE THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.eventdate &gt;= @LASTPERIODSTARTDATE  AND e.eventdate &lt; @STARTDATE THEN eventid END) AS LasEventsCount,
            COUNT(CASE WHEN E.eventdate &gt;= @AVERAGEPERIODSTARTDATE AND E.eventdate &lt; @STARTDATE THEN eventid END) AS AvgEventsCount
        FROM
            ActivityBreakdown_EventsFiltered AS e
        GROUP BY 
            e.sourceid,
            e.PeriodId,
            e.ClientDate
    ),
    Events AS
    (
        SELECT
            e.sourceid AS sourceid,
            -- Convert date to appropriate format to provide correct comparison
            e.ClientDate,
            MAX(E.SeViewerAddress) AS SeViewerAddress,
            --PeriodId differs only for average, so for current and last period it doesn't matter which agg function is taken   
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LasEventsCount) AS LasEventsCount,
            --Average counting is not included current period
            AVG(AvgEventsCount) AS AvgEventsCount
        FROM
            PrepareEventsAvg AS e
        GROUP BY 
            sourceid,
            e.ClientDate
    ),
    -- Check that CPU count is defined for all computers, where application run.
    -- Computers set, where application run, does not depend on specified period by design, as otherwise there is performance problems
    MachineCPUUndefinedFlag AS
    (
        SELECT
            sf.SOURCEID,
            MIN(COALESCE(m.CPUCount, -1)) AS CPUUndefinedFlag
        FROM
            #PROCESSFORSOURCE AS sf
            JOIN apm.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MachineId
        GROUP BY
            sf.SOURCEID
    )
    SELECT
	-- Convert to ISO8601 format to work properly with VB Script. This cannot be done earlier as join is done on this fields
	CONVERT(DATETIME,  SourcesDates.ClientDate, 126) AS ClientDate,
        -- These fake fields are need to provide compatibility with SP ApplicationStatusDrillthrough
        1 AS Date,
        0 AS Hours,
        1 AS OutputDate,
        1 AS Period,
        SourcesDates.Sourceid,
        SourcesDates.Source AS Source,
        COALESCE(pc.CurReqCount, 0) AS CurMonitoredRequestSum,
        COALESCE(pc.LastReqCount, 0) AS LastMonitoredRequestSum,
        COALESCE(pc.AvgReqCount, 0) AS AvgMonitoredRequestSum,
        COALESCE(pc.CurAvgReqTime, 0) AS CurAvgReqTime,
        COALESCE(pc.LastAvgReqTime, 0) AS LastAvgReqTime,
        COALESCE(pc.AvgReqTime, 0) AS AvgReqTime,
        COALESCE(pc.CurCPUSum, 0) AS CurCPUValue,
        COALESCE(pc.lastCPUSum, 0) AS LastCPUValue,
        COALESCE(pc.AvgCPUSum, 0) AS AvgValue,
        COALESCE(pc.CurMemSum, 0) AS CurMemValue,
        COALESCE(pc.LastMemSum, 0) AS LastMemValue,
        COALESCE(pc.AvgMemSum, 0) AS AvgMemValue,
        COALESCE(pc.CurIOSum, 0) AS CurIOValue,
        COALESCE(pc.LastIOSum, 0) AS LastIOValue,
        COALESCE(pc.AvgIOSum, 0) AS AvgIOValue,
        COALESCE(e.CurrentEventsCount, 0) AS NewEventsCount,
        COALESCE(e.LasEventsCount, 0) AS OldEventsCount,
        COALESCE(e.AvgEventsCount, 0) AS AvgEventsCount,
        -- cpuFlag.CPUUndefinedFlag is null for current source if there is no one PCounter row
        -- in PerfHourly table for specified period. If so, there is no need to show message about it
        COALESCE(cpuFlag.CPUUndefinedFlag, 1) AS CPUUndefinedFlag,
        CASE LEFT(AppPool.AppPoolInfo,1) 
            WHEN N'''' THEN N'' 
            WHEN N'' THEN ''
            ELSE REPLACE(LEFT(AppPool.AppPoolInfo, LEN(AppPool.AppPoolInfo)-1), N'''', N'')
        END AS pool,
        E.SeViewerAddress
    FROM 
        SourcesDates
        LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON SourcesDates.Sourceid = cpuFlag.Sourceid
        LEFT OUTER JOIN ActivePreparePCounters AS pc ON (pc.ClientDate = SourcesDates.ClientDate AND pc.SourceId = SourcesDates.Sourceid)
        LEFT OUTER JOIN Events AS e ON (e.ClientDate = SourcesDates.ClientDate AND e.Sourceid = SourcesDates.Sourceid)
        JOIN SourceAppPools AS AppPool ON (AppPool.Sourceid = SourcesDates.Sourceid)
    ORDER BY    
        Source, 
        ClientDate
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationActivityBreakdown'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationActivityBreakdown AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationActivityBreakdown                                                   */
/* USED IN: Application Status  Report, Application Activity                            */
/* DESCRIPTION: Temporary SP which provides unique call for different group by          */
/* parameters, which realy need different SP                                            */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period                                        */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @GROUPBY        - Specifies result gouping type. Possible values:               */
/*                  Hour - Group by hours.  Rersult set will contain 24 rows            */
/*                      corresponding to 24 hours. Date field - 0-23, Hour field - 0    */
/*                  WeekDay - Group by week days. For this grouping type extra grouping */
/*                      is applied - by hours. So result data set contains 7*24 rows.   */
/*                      Date field values - 1-7, Hour fields - 0-23                     */
/*                  Month - Group by Month. For this grouping type extra grouping       */
/*                      is applied - by months. So result data set contains 12*24 rows. */
/*                      and Hour field - 0-23                                           */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min)                         */
/*                      - for the End Date calculate                                    */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationActivityBreakdown
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @TIMEZONE INT,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @GROUPBY NVARCHAR(10),
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    IF @GROUPBY = 'MonthDay'
        exec APM.ApplicationActivityBreakdownByMonthDate
                    @SOURCEIDS,
                    @COMPUTERIDS,
                    @ENDDATE,
                    @TIMEZONE,
                    @PERIOD,
                    @AVERAGEINTERVAL,
                    @GROUPBY,
                    @THRESHOLD,
                    @PROBLEM,
                    @PMSTATUS
    ELSE
        exec APM.ApplicationStatusDrillthrough
                    @SOURCEIDS,
                    @COMPUTERIDS,
                    @ENDDATE,
                    @TIMEZONE,
                    @PERIOD,
                    @AVERAGEINTERVAL,
                    @GROUPBY,
                    @THRESHOLD,
                    @PROBLEM,
                    @PMSTATUS
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.SummaryUserAnalysisCSM'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.SummaryUserAnalysisCSM AS RETURN 1')
  END
GO
/************************************************************************************/
/* OBJECT: Stored Procedure                                                         */
/* NAME:SummaryUserAnalysisCSM                                                      */
/* USED IN: Summary User Analysis Report - summary table                            */
/* INPUT PARAMETERS:                                                                */
/*      @STARTDATE - Start date of the priod                                        */
/*      @ENDDATE - End date of the period                                           */
/*      @SOURCEIDS - List of source Id, separated by comma. Exp: '1,2,3'            */
/*      @MACHINEIDS - List of machine Id, separated by comma. Exp: '4,5,6'          */
/*      @INCLUDESUBNET - Subnet masks list, which should be included                */
/*      @EXCLUDESUBNET - Subnet mask list, which should be excluded                 */
/*      @ORDERBY - Specifies column ordering should be applied                      */
/*                  1 - EventCount                                                  */
/*                  2 - ProblemCount                                                */
/*                  3 - PerformanceEventCount                                       */
/*                  4 - ExceptionEventCount                                         */
/*                  5 - MaxTotalTime                                                */
/*                  6 - TotalTime                                                   */
/*                  7 - MaxTotalSize                                                */
/*                  8 - TotalSize                                                   */
/************************************************************************************/
/*  This stored procedure returns top 10 users ordered by user defined input        */
/*  parameter @ORDERBY. Every user have exactly five records of data with top five  */
/*  page,java script and ajax, exception events ordered by events count of each     */
/*  specific event.                                                                 */
/*  Each record is also contains overall statistics for the Summary table and       */
/*  charts.                                                                         */
/************************************************************************************/
alter PROCEDURE [APM].[SummaryUserAnalysisCSM] 
    @STARTDATE DATETIME,
    @ENDDATE DATETIME,
    @SOURCEIDS NVARCHAR(MAX), 
    @MACHINEIDS NVARCHAR(MAX),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @THRESHOLD DECIMAL(35,0),
    @ORDERBY INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON
SELECT
    @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
    @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')
-- Filter table, which contains machine ids and source ids
-- typeid defines filter type - 1 for source and 2 for machine
-- valueId filter value - source id and machine id 
CREATE TABLE #SOURCEMACHINEFILTERTABLE(
    TYPEID INT, 
    VALUEID INT
)
-- Fill table #SOURCEMACHINEFILTERTABLE
INSERT INTO #SOURCEMACHINEFILTERTABLE
        SELECT 
            p.typeId AS TYPEID,
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@SOURCEIDS, @MACHINEIDS) AS p 
-- Filter table, which contains PM Statuses of Events
CREATE TABLE #PMSTATUSFILTERTABLE(
    VALUEID INT
)
-- Fill table #PMSTATUSFILTERTABLE
INSERT 
    INTO #PMSTATUSFILTERTABLE
        SELECT 
            CAST(p.value AS INT) AS VALUEID
        FROM 
            --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
            APM.GetMultiParameters(@PMSTATUS, N'') AS p
-- Filter table for SubnetC values
CREATE TABLE #SUBNETCFILTERTABLE
(
    IPID INT,
    SUBNETC NVARCHAR(50) collate database_default
)
-- Insert into filter id of the SubnetC to increase performence for event table
INSERT INTO #SUBNETCFILTERTABLE
SELECT DISTINCT
    ipid,
    ip.SubNetC
FROM
    apm.IP AS ip (NOLOCK)
    JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
    LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
WHERE
--Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
    p2.typeId IS NULL
/*************************************************** Main Query ***************************************************/
-- Calculating information about Page events
;WITH PageEvents AS
(
    SELECT
        NULL AS classType,
        ROW_NUMBER() OVER(PARTITION BY UserId ORDER BY COUNT(CSEventId) DESC, PageUri ASC) AS RowId,
        PageUri,
        UserId,
        COUNT(CSEventId) AS EventCount,
        COUNT(DISTINCT CSEventGroup) AS ProblemCount,
        AVG(NetworkTime) AS NetworkTime,
        AVG(ServerTime) AS ServerTime,
        AVG(DOMTime) AS DOMTime,
        AVG(PeripheralTime) AS PeripheralTime,
        AVG(OnLoadTime) AS OnLoadTime,
        AVG(TotalTime) AS TotalTime,
        AVG(TotalSize) AS TotalSize,
        -- This value is needed for ordering by maximum total time in the summary table
        MAX(MAX(TotalTime)) OVER(PARTITION BY UserId) AS MaxTotalTime,
        -- These values are needed to calculate average event duration and average size for user     
        SUM(SUM(TotalTime)) OVER(PARTITION BY UserId) AS UserSumTime,
        SUM(SUM(TotalSize)) OVER(PARTITION BY UserId) AS UserSumSize,
        -- This value is page event count for current user
        SUM(COUNT(*)) OVER(PARTITION BY UserId) AS UserPageEventCount,
        -- These values are needed to calculate average times for current page (information for "all" chart)
        SUM(COUNT(*)) OVER(PARTITION BY PageUri) AS SamePageEventCount,
        SUM(SUM(NetworkTime)) OVER(PARTITION BY PageUri) AS AvgPageNetworkTime,
        SUM(SUM(ServerTime)) OVER(PARTITION BY PageUri) AS AvgPageServerTime,
        SUM(SUM(DOMTime)) OVER(PARTITION BY PageUri) AS AvgPageDOMTime,
        SUM(SUM(PeripheralTime)) OVER(PARTITION BY PageUri) AS AvgPagePeripheralTime,
        SUM(SUM(OnLoadTime)) OVER(PARTITION BY PageUri) AS AvgPageOnLoadTime,
        COUNT(UserId) OVER(PARTITION BY PageUri) AS AffectedUserCount
    FROM
          (
                SELECT
                    e.CSEventId,
                    MAX(e.PageUri) AS PageUri,
                    MAX(e.UserId) AS UserId,
                    MAX(e.CSEventGroupId) AS CSEventGroup,
                    MAX(COALESCE(p.NetworkTime,0))/1000 AS NetworkTime,
                    MAX(COALESCE(p.ServerTime,0))/1000 AS ServerTime,
                    MAX(COALESCE(p.DOMTime,0))/1000 AS DOMTime,
                    MAX(COALESCE(p.PeripheralTime,0))/1000 AS PeripheralTime,
                    MAX(COALESCE(p.OnLoadTime,0))/1000 AS OnLoadTime,
                    MAX(p.TotalTime)/1000 AS TotalTime,
                    MAX(COALESCE(CAST(p.TotalSize AS DECIMAL(35,2)),0))/1024 + SUM(COALESCE(CAST(a.ResponseSize AS DECIMAL(35,2)),0) + COALESCE(CAST(a.REQUESTSIZE AS DECIMAL(35,2)),0))/1024 AS TotalSize
                FROM
                    apm.CSEvent AS e (NOLOCK)
                    JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
                    JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
                    JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
					JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)                     
                    JOIN apm.CSPageEvent AS p (NOLOCK) ON e.CSEventId = p.CSEventId
                    LEFT OUTER JOIN apm.CSAjax AS a (NOLOCK) ON e.CSEventId = a.CSEventId
                WHERE
                    e.UTCDate &gt;= @STARTDATE
                    AND e.UTCDate &lt; @ENDDATE 
                    AND e.UserId IS NOT NULL
                    AND e.PageUri IS NOT NULL
                    AND p.TotalTime/1000.0 &gt;= @THRESHOLD
                GROUP BY
                    E.CSEventId /* Grouping by Id of the specific event to be able to
                                   summarize data of page event with Ajax ones which
                                   were generated by it. */
          ) AS pe
    GROUP BY
          PageUri,
          UserId
),
-- Calculating information about Java script and Ajax events
JSandAjaxEvents AS
(
    SELECT
        classType,
        ROW_NUMBER() OVER(PARTITION BY UserId ORDER BY COUNT(EventId) DESC, PageUri, [Action] ASC) AS RowId,
        UserId,
        PageUri,
        [Action],
        COUNT(*) AS EventCount,     
        COUNT(DISTINCT EventGroupId) AS ProblemCount,
        AVG(NetworkTime) AS NetworkTime,
        AVG(ServerTime) AS ServerTime,
        AVG(TotalTime - NetworkTime - ServerTime) AS ClientTime,
        AVG(TotalTime) AS TotalTime,
        -- This value is needed for ordering by maximum total time in the summary table
        MAX(MAX(TotalTime)) OVER(PARTITION BY UserId) AS MaxTotalTime,
        AVG(TotalSize) AS TotalSize,
        SUM(SUM(TotalSize)) OVER(PARTITION BY UserId) AS UserSumSize,
        SUM(SUM(NetworkTime)) OVER(PARTITION BY PageUri,[Action]) AS AllNetworkTime,
        SUM(SUM(ServerTime)) OVER(PARTITION BY PageUri,[Action]) AS AllServerTime,
        SUM(SUM(TotalTime - NetworkTime - ServerTime)) OVER(PARTITION BY PageUri,[Action]) AS AllClientTime,
        SUM(SUM(TotalTime)) OVER(PARTITION BY PageUri,[Action]) AS AllTotalTime,
        SUM(SUM(TotalTime)) OVER(PARTITION BY UserId) AS UserSumTime,
        COUNT(UserId) OVER(PARTITION BY PageUri,[Action]) AS AffectedUserCount,
        SUM(COUNT(*)) OVER(PARTITION BY UserId) AS TotalUserEventCount,
        SUM(COUNT(*)) OVER(PARTITION BY PageUri,[Action]) AS TotalPageEventCount
    FROM
        (
            SELECT
                MAX(CASE WHEN COALESCE(a.Synchronous,1) = 0 THEN 1 ELSE 2 END) AS classType, 
                e.CSEventId AS EventId,
                MAX(e.UserId) AS UserId,
                MAX(e.CSEventGroupId) AS EventGroupId,
                MAX(e.PageUri) AS PageUri,
                MAX(CASE WHEN COALESCE(a.Synchronous,1) = 0 THEN a.Uri ELSE j.Action END) AS [Action],
                SUM((COALESCE(a.NetworkTime,0) + COALESCE(a.ResponseTime,0))/1000) AS NetworkTime,
                SUM(COALESCE(a.ServerTime,0))/1000 AS ServerTime,
                MAX(COALESCE(j.TotalTime, a.TotalTime))/1000 AS TotalTime,
                CAST(SUM(COALESCE(a.REQUESTSIZE,0) + COALESCE(a.ResponseSize,0)) AS DECIMAL(35,2))/1024 AS TotalSize
            FROM
                apm.CSEvent (NOLOCK) as e
                JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
                JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
                JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
				JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)                 
                LEFT OUTER JOIN apm.CSJScriptEvent AS j ON e.CSEventId = j.CSEventId
                LEFT OUTER JOIN apm.CSAjax AS a ON e.CSEventId = a.CSEventId
            WHERE
                e.UTCDate &gt;= @STARTDATE
                AND e.UTCDate &lt; @ENDDATE
                AND e.UserId IS NOT NULL
                AND e.PageUri IS NOT NULL
                AND e.EventClass &lt;&gt; N'CSMPMonitorLog'
                AND e.CLassType = N'performance'
                AND COALESCE(j.TotalTime, a.TotalTime)/1000.0 &gt;= @THRESHOLD
            GROUP BY
                e.CSEventId  
        ) AS jsax
    GROUP BY
        jsax.UserId,
        jsax.PageUri,
        jsax.Action,
        jsax.classType
),
-- Prepairing template in which every user will have exactly five rows for top page, exceptionevents
PreResultTemplate AS
(
    SELECT
        UserId
    FROM
        apm.CSEvent (NOLOCK) AS e
        JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
        JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
        JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID      
		JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)         
    WHERE
        UTCDate &gt;= @STARTDATE
        AND UTCDate &lt; @ENDDATE
        AND PageUri IS NOT NULL
        AND UserId IS NOT NULL
    GROUP BY 
        UserId
),
ResultTemplate AS -- Template which has exactly 5 rows for each user
(
    SELECT 
        pr.UserId,
        n.n AS RowId
    FROM
        PreResultTemplate as pr 
        CROSS JOIN APM.fn_numS(5) AS n
),
-- Calculating information about Exception events
ExceptionEvents AS
(
      SELECT
            4 AS classType,
            ROW_NUMBER() OVER(PARTITION BY UserId ORDER BY COUNT(CSEventId) DESC, [Description] ASC) AS RowId,
            UserId,
            Description,
            COUNT(CSEventId) AS EventCount,
            COUNT(DISTINCT CSEventGroupId) AS ProblemCount,
            COUNT(CASE WHEN CHARINDEX(N'MSIE', E.Browser) &gt; 0 THEN E.CSEventId END) AS IEEventCount,
            COUNT(CASE WHEN CHARINDEX(N'Firefox', E.Browser) &gt; 0 THEN E.CSEventId END) AS FirefoxEventCount,
            AVG(COUNT(CSEventId)*1.0) OVER(PARTITION BY [Description]) AS AllEventCount,
            AVG(COUNT(CASE WHEN CHARINDEX(N'MSIE', E.Browser) &gt; 0 THEN E.CSEventId END)*1.0) OVER(PARTITION BY [Description]) AS AllIEEventCount,
            AVG(COUNT(CASE WHEN CHARINDEX(N'Firefox', E.Browser) &gt; 0 THEN E.CSEventId END)*1.0) OVER(PARTITION BY [Description]) AS AllFirefoxEventCount,
            COUNT(UserId) OVER(PARTITION BY [Description]) AS AffectedUserCount,
            SUM(COUNT(CSEventId)) OVER(PARTITION BY UserId) AS UserEventCount
      FROM
            apm.CSEvent (NOLOCK) AS e
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.SourceId AND f1.TYPEID = 1)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.MachineId AND f2.TYPEID = 2)
            JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
            JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus) 
      WHERE
            e.UTCDate &gt;= @STARTDATE
            AND e.UTCDate &lt; @ENDDATE 
            AND e.UserId IS NOT NULL
            AND e.PageUri IS NOT NULL
            AND e.ClassType = N'exception'
      GROUP BY
            UserId,
            [Description]
),
-- Summarizing data from PageEvents, ExceptionEvents and JSandAjaxEvents CTE's
ResultTable AS
(
SELECT
        /* Create additional field to have an ability to sort out the unusual events when
        creating URLs*/
        js.classType,   
        /* Create additional field for sorting according to the @ORDERBY input parameter.
           Selecting maximum value of selected field for each user.                    */
        CASE @ORDERBY
            WHEN 1 THEN MAX(COALESCE(ex.UserEventCount,0) + COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0)) OVER(PARTITION BY rt.UserId)
            WHEN 2 THEN SUM(COALESCE(ex.ProblemCount,0) + COALESCE(pg.ProblemCount,0) + COALESCE(js.ProblemCount,0)) OVER(PARTITION BY rt.UserId)
            WHEN 3 THEN MAX(COALESCE(pg.EventCount,0)) OVER(PARTITION BY rt.UserId)
            WHEN 4 THEN MAX(COALESCE(ex.EventCount,0)) OVER(PARTITION BY rt.UserId)
            -- Choosing the maximum value from the page and javascript event
            WHEN 5 THEN 
                    MAX(CASE WHEN COALESCE(pg.MaxTotalTime,0) &gt;= COALESCE(js.MaxTotalTime,0) 
                            THEN COALESCE(pg.MaxTotalTime,0)
                            ELSE COALESCE(js.MaxTotalTime,0)
                            END) OVER(PARTITION BY rt.UserId)
            -- Caculating average user page, ajax and javascript event time
            WHEN 6 THEN
                   (CASE WHEN  (MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0))OVER(PARTITION BY rt.UserId)) &gt; 0
                            THEN (MAX(COALESCE(pg.UserSumTime,0) + COALESCE(js.UserSumTime,0)) OVER(PARTITION BY rt.UserId))/(MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0))  OVER(PARTITION BY rt.UserId))
                            ELSE 0
                            END)
            -- Calculating average user page, ajax and javascript event size
            WHEN 7 THEN
                    (CASE WHEN (MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0)) OVER(PARTITION BY rt.UserId))&gt; 0
                            THEN (MAX(COALESCE(pg.UserSumSize,0) + COALESCE(js.UserSumSize,0)) OVER(PARTITION BY rt.UserId))/(max(COALESCE(pg.UserPageEventCount,0)+COALESCE(js.TotalUserEventCount,0))OVER(PARTITION BY rt.UserId))
                            ELSE 0
                            END) 
      END   AS OrderData,
      rt.RowId,
      rt.UserId,
      (CASE WHEN (MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0)) OVER(PARTITION BY rt.UserId))&gt; 0
                            THEN (MAX(COALESCE(pg.UserSumSize,0) + COALESCE(js.UserSumSize,0)) OVER(PARTITION BY rt.UserId))/(max(COALESCE(pg.UserPageEventCount,0)+COALESCE(js.TotalUserEventCount,0))OVER(PARTITION BY rt.UserId))
                            ELSE 0
                            END) AS UserAvgSize,
      (CASE WHEN  (MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0))OVER(PARTITION BY rt.UserId)) &gt; 0
                            THEN (MAX(COALESCE(pg.UserSumTime,0) + COALESCE(js.UserSumTime,0)) OVER(PARTITION BY rt.UserId))/(MAX(COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0))  OVER(PARTITION BY rt.UserId))
                            ELSE 0
                            END) AS UserAvgTime,
	-- Summarize problems count between all issues as this information is shown in summary table for user
      SUM(COALESCE(ex.ProblemCount,0) + COALESCE(pg.ProblemCount,0) + COALESCE(js.ProblemCount,0)) OVER(PARTITION BY rt.UserId) AS ProblemCount,
      MAX((COALESCE(ex.UserEventCount,0) + COALESCE(pg.UserPageEventCount,0) + COALESCE(js.TotalUserEventCount,0))) OVER(PARTITION BY rt.UserId) AS EventCount,
        -- Exception events details --
      (ex.Description) AS Ex_Description,
      (ex.EventCount) AS Ex_EventCount,
      (ex.IEEventCount) AS Ex_IEEventCount,
      (ex.FireFoxEventCount) AS Ex_FireFoxEventCount,
      (ex.AllEventCount) AS Ex_AllEventCount,
      (ex.AllIEEventCount) AS Ex_AllIEEventCount,
      (ex.AllFirefoxEventCount) AS Ex_AllFirefoxEventCount,
      (ex.AffectedUserCount) AS Ex_AffectedUserCount,
      MAX(COALESCE(ex.UserEventCount,0)) OVER(PARTITION BY rt.UserId) AS Ex_UserEventCount,
        -- Page events details --
      (pg.PageUri) AS Pg_PageUri,
      (pg.MaxTotalTime) AS Pg_MaxTotalTime,
      (pg.EventCount) AS Pg_EventCount,
      (pg.NetworkTime) AS Pg_NetworkTime,
      (pg.ServerTime) AS Pg_ServerTime,
      (pg.DOMTime) AS Pg_DOMTime,
      (pg.PeripheralTime) AS Pg_PeripheralTime,
      (pg.OnLoadTime) AS Pg_OnLoadTime,
      (pg.TotalTime) AS Pg_TotalTime,
      (pg.TotalSize) AS Pg_TotalSize,
      (pg.AvgPageNetworkTime / pg.SamePageEventCount) AS Pg_AvgPageNetworkTime,
      (pg.AvgPageServerTime / pg.SamePageEventCount) AS Pg_AvgPageServerTime,
      (pg.AvgPageDOMTime / pg.SamePageEventCount) AS Pg_AvgPageDOMTime,
      (pg.AvgPagePeripheralTime / pg.SamePageEventCount) AS Pg_AvgPagePeripheralTime,
      (pg.AvgPageOnLoadTime / pg.SamePageEventCount) AS Pg_AvgPageOnLoadTime,
      (pg.AffectedUserCount) AS Pg_AffectedUserCount,
      (pg.UserSumTime / pg.UserPageEventCount) AS Pg_AvgUserTime,
      (pg.UserSumSize / pg.UserPageEventCount) AS Pg_AvgUserSize,
      MAX(pg.UserPageEventCount) OVER(PARTITION BY rt.UserId) AS Pg_UserPageEventCount,
        -- Javascript and Ajax events details --
      (js.PageUri) AS Js_PageUri,
      (js.Action) AS Js_Action,
      (js.MaxTotalTime) AS Js_MaxTotalTime,
      (js.EventCount) AS Js_EventCount,
      (js.NetworkTime) AS Js_NetworkTime,
      (js.ServerTime) AS Js_ServerTime,
      (js.ClientTime) AS Js_ClientTime,
      (js.TotalTime) AS Js_TotalTime,
      (js.TotalSize) AS Js_TotalSize,
      (js.AllNetworkTime / js.TotalPageEventCount) AS Js_AllNetworkTime,
      (js.AllServerTime / js.TotalPageEventCount) AS Js_AllServerTime,
      (js.AllClientTime / js.TotalPageEventCount) AS Js_AllClientTime,
      (js.AllTotalTime / js.TotalPageEventCount) AS Js_AllTotalTime,
      js.AffectedUserCount AS Js_AffectedUserCount,
      MAX(COALESCE(js.TotalUserEventCount,0)) OVER(PARTITION BY rt.UserId) AS Js_TotalUserEventCount
FROM
      ResultTemplate AS rt
      LEFT OUTER JOIN ExceptionEvents AS ex ON ex.UserId = rt.UserId AND ex.RowId = rt.RowId
      LEFT OUTER JOIN PageEvents AS pg ON pg.UserId = rt.UserId AND pg.RowId = rt.RowId
      LEFT OUTER JOIN JSandAjaxEvents AS js ON js.UserId = rt.UserId AND js.RowId = rt.RowId
)
SELECT 
    TOP 50 
    res.classType,
    res.OrderData, -- As we have exactly 5 rows for each user, we select the first ten of them.
    res.RowId,
    u.Name,
    res.ProblemCount,
    res.EventCount,
    res.UserAvgSize,
    res.UserAvgTime,
    res.Ex_Description,
    res.Ex_EventCount,
    res.Ex_IEEventCount,
    res.Ex_FireFoxEventCount,
    res.Ex_AllEventCount,
    res.Ex_AllIEEventCount,
    res.Ex_AllFirefoxEventCount,
    res.Ex_AffectedUserCount,
    res.Ex_UserEventCount,
    res.Pg_PageUri,
    res.Pg_MaxTotalTime,
    res.Pg_EventCount,
    res.Pg_NetworkTime,
    res.Pg_ServerTime,
    res.Pg_DOMTime,
    res.Pg_PeripheralTime,
    res.Pg_OnLoadTime,
    res.Pg_TotalTime,
    res.Pg_TotalSize,
    res.Pg_AvgPageNetworkTime,
    res.Pg_AvgPageServerTime,
    res.Pg_AvgPageDOMTime,
    res.Pg_AvgPagePeripheralTime,
    res.Pg_AvgPageOnLoadTime,
    res.Pg_AffectedUserCount,
    res.Pg_AvgUserTime,
    res.Pg_AvgUserSize,
    res.Pg_UserPageEventCount,
    res.Js_PageUri,
    res.Js_Action,
    res.Js_MaxTotalTime,
    res.Js_EventCount,
    res.Js_NetworkTime,
    res.Js_ServerTime,
    res.Js_ClientTime,
    res.Js_TotalTime,
    res.Js_TotalSize,
    res.Js_AllNetworkTime,
    res.Js_AllServerTime,
    res.Js_AllClientTime,
    res.Js_AllTotalTime,
    res.Js_AffectedUserCount,
    res.Js_TotalUserEventCount
FROM
    ResultTable AS res
    JOIN apm.Users AS u ON u.UserId = res.UserId
WHERE   
-- This condition is set as users where not filtered by threshold, and ther could be situations when there is no events at all
-- for some user. Such users should not be selected. It wouldn't have affect on ordering as for such users all other values is 0
    res.EventCount &gt; 0
ORDER BY
    res.OrderData DESC,u.Name,res.Rowid
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PCType_ConfigSync'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PCType_ConfigSync AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: PCType_ConfigSync                                                              */
/* USED IN: transfer routine : task=ConfigSynchronization;action=SyncPerfCountersAction */
/* DESCRIPTION: updates INSTANCEFUNCTION, DATEFUNCTION for counters, that are listed    */
/*  in configuration file                                                               */
/* INPUT PARAMETERS:                                                                    */
/*      @DESCRIPTORS    - List of counters in XML format (aggregation/perfcounterSet    */
/*      @TRACELEVEL     - service variable (error tracing level)                        */
/****************************************************************************************/
alter  PROCEDURE APM.PCType_ConfigSync
   @DESCRIPTORS NTEXT
  ,@TRACELEVEL INT
AS
BEGIN
  SET NOCOUNT ON
  DECLARE 
     @ERRORIND        BIT
    ,@ERRORMESSAGE    NVARCHAR(MAX)
    ,@ERRORNUMBER     INT
    ,@ERRORSEVERITY   INT
    ,@ERRORSTATE      INT
    ,@ERRORLINE       INT
    ,@ERRORPROCEDURE  NVARCHAR(256)
    ,@ERRORMESSAGETEXT NVARCHAR(MAX)
  BEGIN TRY
      DECLARE @EXECRESULT INT
      DECLARE @ROWCOUNT INT
      DECLARE @HANDLER INT
      -- Prepare xml document
      EXEC SP_XML_PREPAREDOCUMENT @HANDLER OUTPUT, @DESCRIPTORS
      IF @EXECRESULT &lt;&gt; 0 
      BEGIN
          SELECT  @ERRORMESSAGE = message FROM APM.messages WHERE id = 50002   
          RAISERROR(@ERRORMESSAGE, 16, 1, 'PCType_ConfigSync', @EXECRESULT)
      END
      -- Create temporary table for counters
      CREATE TABLE #DESCRIPTORSET (
        DESCRIPTOR NVARCHAR(255) collate database_default NOT NULL,
        INSTANCEFUNCTION NVARCHAR(50) collate database_default NOT NULL,
        DATEFUNCTION NVARCHAR(50) collate database_default NOT NULL
      )
      -- Fill table with date from xml
      INSERT INTO #DESCRIPTORSET
        SELECT NAME, COALESCE(INSTANCEFUNC,'AVG'), COALESCE(DATEFUNC,'AVG')
          FROM OPENXML (@HANDLER, '/perfcounterSet/perfcounter', 1)
            WITH (NAME  NVARCHAR(255), INSTANCEFUNC NVARCHAR(50) , DATEFUNC NVARCHAR(50))
      SET @ROWCOUNT = @@ROWCOUNT
      EXEC SP_XML_REMOVEDOCUMENT @HANDLER
      -- Update PCTYPE table with new aggregate function values
      UPDATE T
      SET   T.INSTANCEFUNCTION = sync.INSTANCEFUNCTION,
            T.DATEFUNCTION = sync.DATEFUNCTION
      FROM  apm.PCTYPE T 
            JOIN #DESCRIPTORSET sync ON sync.DESCRIPTOR = T.TYPE
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ERRORNUMBER = ERROR_NUMBER()
      ,@ERRORSEVERITY = ERROR_SEVERITY()
      ,@ERRORSTATE = ERROR_STATE()
      ,@ERRORLINE = ERROR_LINE()
      ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
    SET @ERRORIND = 1
  END CATCH
  -- report error if any
  IF (@ERRORIND = 1)
  BEGIN
    DECLARE @ADJUSTEDERRORSEVERITY int
    SET @ADJUSTEDERRORSEVERITY = CASE
                                   WHEN @ERRORSEVERITY = 2601 OR @ERRORSEVERITY = 2627 THEN 0
                                   WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                   ELSE @ERRORSEVERITY
                                 END
    
    SELECT @ERRORMESSAGE = message FROM APM.Messages WHERE id = 50004
    RAISERROR (@ERRORMESSAGE
      ,@ADJUSTEDERRORSEVERITY
      ,1
      ,@ERRORNUMBER
      ,@ERRORSEVERITY
      ,@ERRORSTATE
      ,@ERRORPROCEDURE
      ,@ERRORLINE
      ,@ERRORMESSAGETEXT
    )
  END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.DeleteEventsOrEventGroups'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.DeleteEventsOrEventGroups AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: DeleteEventsOrEventGroups                                                      */
/* DESCRIPTION:																			*/
/* Delete events using #EVENTGROOM(eventid) table or delete eventgroup that hot have    */				
/* events and older @LASTKEEPDATE. Events will be delete if #EVENTGROOM table is not    */
/* empty otherwise event groups will be deleted											*/
/* INPUT PARAMETERS:																    */
/*   @ROWSPERITERATION - number of records that have been deleted by one delete			*/
/*                       instruction		                                            */  
/*   @CLIENT - 1:client events 0:server events											*/
/*   @LASTKEEPDATE - last keep date. It use for delete event groups						*/
/* OUTPUT PARAMETERS:                                                                   */
/*   @ROWSAFFECTED  - Number of deleted  events or event groups						    */
/****************************************************************************************/
alter PROCEDURE APM.DeleteEventsOrEventGroups 
    @ROWSPERITERATION int
   ,@CLIENT bit
   ,@LASTKEEPDATE datetime
   ,@ROWSAFFECTED int OUTPUT	
AS
    SET @ROWSAFFECTED = 0
    IF @CLIENT = 0  
    BEGIN
        --delete server events
        IF EXISTS(SELECT * FROM #EVENTGROOM)
        BEGIN                
			--- Grooming performance node ---------
			DELETE pn
			FROM APM.PerformanceNode AS pn
				JOIN #EVENTGROOM AS eventFilter ON pn.eventid = eventFilter.EVENTID
			--- Grooming resource group node ---------
			DELETE rgn
			FROM APM.ResourceGroupNode AS rgn
				JOIN #EVENTGROOM AS eventFilter ON rgn.eventid = eventFilter.EVENTID
			--- Grooming exception node ---------
			DELETE en
			FROM APM.ExceptionNode AS en
				JOIN #EVENTGROOM AS eventFilter ON en.eventid = eventFilter.EVENTID
		        
			 -- Grooming server detail events --- 
			 DELETE ed
			 FROM APM.eventdetail AS ed
				JOIN #EVENTGROOM AS eventFilter ON ed.eventid = eventFilter.EVENTID                    
		    
			 DELETE e
			 FROM APM.Event AS e
				JOIN #EVENTGROOM AS eventFilter ON e.eventid = eventFilter.EVENTID
 			 SELECT @ROWSAFFECTED = @@ROWCOUNT
		END
		ELSE 
		BEGIN
		    -- delete server event groups
			WHILE EXISTS (SELECT * FROM APM.EventGroup G
							WHERE G.LASTEVENTDATE &lt; @LASTKEEPDATE
					 AND NOT EXISTS(SELECT * FROM EVENT e WHERE e.eventgroupId = G.EventGroupId)
				)           
			BEGIN
				DELETE TOP (@ROWSPERITERATION) g
					FROM APM.EventGroup AS g
				WHERE G.LASTEVENTDATE &lt; @LASTKEEPDATE
					 AND NOT EXISTS(SELECT * FROM EVENT e WHERE e.eventgroupId = G.EventGroupId)
				SELECT @ROWSAFFECTED = @ROWSAFFECTED + @@ROWCOUNT
			END
        END
	END	
    IF @CLIENT = 1  
    BEGIN
      -- delete client events
      IF EXISTS(SELECT * FROM #EVENTGROOM)
      BEGIN
		  -- Grooming PageEvent-----                  
		  DELETE pe
			 FROM APM.cspageevent AS pe
				JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
		  -- Grooming Peripheral Details -----                
		  DELETE pd
			 FROM APM.csperipheraldetail AS pd
				JOIN APM.csperipheral AS pe ON pe.csperipheralId = pd.csperipheralId
				JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
		  -- Grooming Peripheral ------ 
		  DELETE pe
			 FROM APM.csperipheral AS pe
				JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
		  -- Grooming csHeaviestResource --- 
		  DELETE hr
			 FROM APM.csHeaviestResource AS hr
				JOIN #EVENTGROOM AS eventFilter ON hr.cseventid = eventFilter.EVENTID
		  -- Grooming ajax events --- 
		  DELETE aj
			 FROM APM.csAjax AS aj
				JOIN #EVENTGROOM AS eventFilter ON aj.cseventid = eventFilter.EVENTID
		  -- Grooming async ajax events --- 
		  DELETE aj
			 FROM APM.csAsyncAjax AS aj
				JOIN #EVENTGROOM AS eventFilter ON aj.cseventid = eventFilter.EVENTID
		  -- Grooming async jscript events --- 
		  DELETE js
			 FROM APM.csJScriptEvent AS js
				JOIN #EVENTGROOM AS eventFilter ON js.cseventid = eventFilter.EVENTID
		  -- Grooming client exception events --- 
		  DELETE ex
			 FROM APM.csexevent AS ex
				JOIN #EVENTGROOM AS eventFilter ON ex.cseventid = eventFilter.EVENTID
		  -- Grooming client detail events --- 
		  DELETE ed
			 FROM APM.cseventdetail AS ed
				JOIN #EVENTGROOM AS eventFilter ON ed.cseventid = eventFilter.EVENTID
	            
		  -- Grooming client events --- 
		  DELETE ev 
			 FROM APM.csEvent ev
				JOIN #EVENTGROOM AS eventFilter ON ev.cseventid = eventFilter.EVENTID
	            
		  SELECT @ROWSAFFECTED = @@ROWCOUNT
	  END
	  ELSE 
	  BEGIN
		  --delete client groups
		  WHILE EXISTS (SELECT * FROM APM.csEventGroup g
							WHERE g.lasteventdate &lt; @LASTKEEPDATE
					 AND NOT EXISTS(SELECT * FROM csEvent e WHERE e.cseventgroupId = g.csEventGroupId)
				)           
		  BEGIN
			DELETE TOP (@ROWSPERITERATION) g
				FROM APM.csEventGroup AS g
			WHERE g.lasteventdate &lt; @LASTKEEPDATE
				 AND NOT EXISTS(SELECT * FROM csEVENT e WHERE e.cseventgroupId = g.csEventGroupId)
			SELECT @ROWSAFFECTED = @ROWSAFFECTED + @@ROWCOUNT
		  END		
      END
    END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ExtractEventGroomingRows'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ExtractEventGroomingRows AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ExtractEventGroomingRows                                                       */
/* DESCRIPTION:																			*/
/* It fill #EVENTGROOM(eventid) table from server or client events by date and status   */				
/* INPUT PARAMETERS:																    */
/*   @ROWSPERITERATION - number of records that have been selected from underline table */
/*   @LASTKEEPDATE     - last keep date.												*/
/*	 @DATABASEID       - database primary key from seviewerdb table						*/
/*   @CLIENT           - 1:client events 0:server events								*/
/*   @PMSTATUS	       - problem management												*/
/****************************************************************************************/
alter PROCEDURE [APM].[ExtractEventGroomingRows] 
    @ROWSPERITERATION int
   ,@LASTKEEPDATE datetime
   ,@DATABASEID int
   ,@CLIENT bit
   ,@PMSTATUS tinyint 
AS
	SET NOCOUNT ON
	
	IF @CLIENT = 0 
	BEGIN
	   --server events
	   IF @PMSTATUS IS null
		   INSERT #EVENTGROOM 
			 SELECT TOP(@ROWSPERITERATION) e.EventId
				FROM APM.event (NOLOCK) AS e
				  WHERE 
					 e.SEVIEWERDBID = @DATABASEID AND 
					 e.UTCEVENTDATE &lt; @LASTKEEPDATE
	   ELSE
		   INSERT #EVENTGROOM 
              SELECT TOP(@ROWSPERITERATION)  e.EventId 
                 FROM APM.EVENT (NOLOCK) E 
                     JOIN apm.PMSERVEREVENTTRACE (NOLOCK) ET ON E.EVENTID = ET.EVENTID 
                                       JOIN apm.PMTRACE PT (NOLOCK) ON PT.PMTRACEID = ET.PMTRACEID 
                      WHERE 
						e.PMSTATUS = @PMSTATUS AND 
						e.UTCEVENTDATE &lt; @LASTKEEPDATE AND 
						e.SEVIEWERDBID = @DATABASEID
                      GROUP BY 
						E.EVENTID
                      HAVING 
						MAX(PT.UTCDATE) &lt; @LASTKEEPDATE
                      ORDER BY 
						E.EVENTID ASC
	   	  			 
    END             
	ELSE 	
	BEGIN
	   --client events
	   IF @PMSTATUS IS null
		  INSERT #EVENTGROOM 
            SELECT TOP(@ROWSPERITERATION) e.cseventId
				FROM APM.csevent (NOLOCK) AS e
                  WHERE 
                    e.SEVIEWERDBID = @DATABASEID AND 
                    e.utcDate &lt; @LASTKEEPDATE
       ELSE
		  INSERT #EVENTGROOM 
              SELECT TOP(@ROWSPERITERATION)  e.csEventId 
                 FROM APM.CSEVENT (NOLOCK) E 
                     JOIN apm.PMCLIENTEVENTTRACE (NOLOCK) ET ON E.CSEVENTID = ET.CSEVENTID 
                        JOIN apm.PMTRACE PT (NOLOCK) ON PT.PMTRACEID = ET.PMTRACEID 
                      WHERE 
						e.PMSTATUS = @PMSTATUS AND 
						e.utcDate &lt; @LASTKEEPDATE AND 
						e.SEVIEWERDBID = @DATABASEID
                      GROUP BY 
                        E.CSEVENTID
                      HAVING 
                        MAX(PT.UTCDATE) &lt; @LASTKEEPDATE
                      ORDER BY 
                        E.csEVENTID ASC
    END             
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GroomingWorkTables'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GroomingWorkTables AS RETURN 1')
  END
GO
/* PROCEDURE GROOM SERVER EVENTS, CLIENT EVENTS AND PERFORMANCE COUNTERS.           */  
/* Description: 																    */
/* The stored proc  delete old events and performance counters. It also delete      */
/* events with status 'Deleted' or 'By design' using parameters from config table.  */
/* INPUT PARAMETERS:                                                                */
/*   @TABLENAME:                                                                    */
/*      'Event' - grooming server and client events                                 */
/*      'PerfHourly'- grooming performance counters for the perfhourly table        */
/*      'PerfDaily'- grooming performance counters for the perfDaily table          */
/*   @DATABASEID: database identifier                                               */
/*   @RECORDCOUNT: batch record size                                                */
/*   @TRACELEVEL: trace level                                                       */
alter PROCEDURE [APM].[GroomingWorkTables]
        @TABLENAME nvarchar(255),
        @RECORDCOUNT INT, 
        @DATABASEID INT,
        @POSTGROOMINGPERIOD INT,
        @TRACELEVEL INT 
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @MESSAGE nvarchar(MAX)
    DECLARE @ROWSAFFECTED int
    DECLARE @TMPROWSAFFECTED int
    DECLARE 
         @ERRORIND        bit
        ,@ERRORMESSAGE    nvarchar(4000)
        ,@ERRORNUMBER     int
        ,@ERRORSEVERITY   int
        ,@ERRORSTATE      int
        ,@ERRORLINE       int
        ,@ERRORPROCEDURE  sysname
        ,@ERRORMESSAGETEXT nvarchar(4000)
    SET @ERRORIND = 0
    BEGIN TRY
        IF @TRACELEVEL = 4 
        BEGIN
          DECLARE 
             @PERIODDATESTR nvarchar(20)
          SET @PERIODDATESTR = CONVERT(nvarchar(20), DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE()), 110)
          SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50033
          RAISERROR (@MESSAGE, 0, 1, @RECORDCOUNT, @POSTGROOMINGPERIOD, @PERIODDATESTR) WITH NOWAIT;      
        END 
        
        CREATE TABLE #EVENTGROOM (
            EVENTID BIGINT
        )
        
        --clear old events 
        IF @TABLENAME = N'Event'
        BEGIN
            -- create event groom settings
            DECLARE @EVENTGROOMSETTINGS TABLE 
				    (
				       id int IDENTITY(1,1)
					  ,configName nvarchar(50) -- configuration parameter
				      ,pmstatus tinyint -- problem management status id
					  ,client bit -- client or server event (1- client, 0 - server)
					  ,defaultLifeTime int -- default life time in hours
					)
            INSERT @EVENTGROOMSETTINGS(configName, pmstatus, client, defaultLifeTime) 
				SELECT N'PMLifeTimeInHoursForDeletedEvents' AS configName, 2 AS pmstatus, 0 AS client, 24 AS defaultLifeTime 
					UNION ALL 
				SELECT N'PMLifeTimeInHoursForDeletedEvents', 2, 1, 24 
					UNION ALL 
				SELECT N'PMLifeTimeInHoursForByDesignEvents', 3, 0, 72 
					UNION ALL 
				SELECT N'PMLifeTimeInHoursForByDesignEvents', 3, 1, 72 
					UNION ALL 
				SELECT NULL, NULL, 0, NULL  
					UNION ALL 
				SELECT NULL, NULL, 1, NULL 
				
			DECLARE 
			   @CONFIGNAME nvarchar(50)
			  ,@LASTKEEPDATE datetime
			  ,@CLIENT bit 
			  ,@PMSTATUS tinyint
			  ,@LIFETIMEINHOURS int
			  ,@DISPLAYTABLENAME sysname
			  ,@EVENTGROOMSETTINGSID int
			
			-- cycle by event groomsetting
			WHILE EXISTS(SELECT * FROM @EVENTGROOMSETTINGS) 
			BEGIN
			  --get first settings
			  SELECT TOP (1) 
			    @EVENTGROOMSETTINGSID = id 
			   ,@CONFIGNAME = configName
			   ,@PMSTATUS = pmstatus
			   ,@CLIENT = client
			   ,@LIFETIMEINHOURS = defaultLifeTime
			  FROM 
			    @EVENTGROOMSETTINGS 
			    
			  --calculate last keep date  
			  SELECT @LASTKEEPDATE = DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE())
			  IF @CONFIGNAME IS NOT NULL  
			  BEGIN
			    SELECT @LIFETIMEINHOURS = CAST(CAST(configvalue AS nvarchar(10)) AS int) FROM APM.CONFIG (NOLOCK)
					WHERE configname = @CONFIGNAME
				SELECT @LASTKEEPDATE = DATEADD(hh, -@LIFETIMEINHOURS, GETUTCDATE()) 	   
			  END 								
			  			  
			  --trace grooming settings
			  DECLARE @LASTKEEPDATESTR nvarchar(50)
              SELECT @LASTKEEPDATESTR = CONVERT(nvarchar(50), @LASTKEEPDATE, 100)
              SELECT @MESSAGE = message FROM APM.MESSAGES (NOLOCK)  WHERE id = 50034 
              RAISERROR (@MESSAGE, 0, 1, 
				@PMSTATUS, @LIFETIMEINHOURS, @LASTKEEPDATESTR) WITH NOWAIT;  			  
			 
			  -- execute event grooming 			  
			  SELECT @ROWSAFFECTED = 0
			  WHILE 1 = 1
			  BEGIN
				TRUNCATE TABLE #EVENTGROOM
				--fill #EVENTGROOM
			    EXEC APM.ExtractEventGroomingRows 
			                   @RECORDCOUNT
                              ,@LASTKEEPDATE
                              ,@DATABASEID 
                              ,@CLIENT
                              ,@PMSTATUS
                --delete events if #EVENTGROOM is not empty otherwise delete old event groups              
				EXEC APM.DeleteEventsOrEventGroups 
				          @RECORDCOUNT
						 ,@CLIENT 
						 ,@LASTKEEPDATE
                         ,@TMPROWSAFFECTED OUTPUT	
                
                IF EXISTS(SELECT * FROM #EVENTGROOM)                    
                  -- calculate rows affected   
					SELECT @ROWSAFFECTED = @TMPROWSAFFECTED + @@ROWCOUNT
				ELSE	
                -- break if #EVENTGROOM is empty                       
					BREAK
			  END						  			  	
			  
			  DELETE @EVENTGROOMSETTINGS WHERE 
			    id = @EVENTGROOMSETTINGSID
			   
				----- Trace for events ------
			  IF @TRACELEVEL = 4 
			  BEGIN
 		        SELECT @DISPLAYTABLENAME =  CASE when @CLIENT = 1 THEN N'csEvent' ELSE N'Event' END
				SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50023
				RAISERROR (@MESSAGE, 0, 1, @ROWSAFFECTED, @DISPLAYTABLENAME) WITH NOWAIT;      
		      END 	
		      		      
			  ----- Trace for  groups ------
			  IF @TRACELEVEL = 4 
			  BEGIN
		        SELECT @DISPLAYTABLENAME =  CASE when @CLIENT = 1 THEN N'csEventGroup' ELSE N'EventGroup' END
			    SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50023
			    RAISERROR (@MESSAGE, 0, 1, @ROWSAFFECTED, @DISPLAYTABLENAME) WITH NOWAIT;     
			  END 		      		   					    
			END	
        END
        
        DROP TABLE #EVENTGROOM
        
        --clear PerfHourly table 
        IF @TABLENAME = N'PerfHourly'
        BEGIN 
            WHILE EXISTS (SELECT * FROM APM.PerfHourly 
                            WHERE UTCDate &lt; DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE()))
            BEGIN
                DELETE TOP(@RECORDCOUNT) FROM APM.PerfHourly 
                    WHERE utcdate &lt; DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE())            
                SELECT @ROWSAFFECTED = @ROWSAFFECTED + @@ROWCOUNT
            END
            IF @TRACELEVEL = 4 
            BEGIN
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50023
              RAISERROR (@MESSAGE, 0, 1, @ROWSAFFECTED, @TABLENAME) WITH NOWAIT;      
            END 
        END
        --clear PerfDaily table 
        IF @TABLENAME = N'PerfDaily'
        BEGIN 
            WHILE EXISTS (SELECT * FROM APM.PerfDaily 
                            WHERE UTCDATE &lt; DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE()))
            BEGIN
                DELETE TOP(@RECORDCOUNT) FROM APM.PerfDaily 
                    WHERE UTCDATE &lt; DATEADD(Day, -@POSTGROOMINGPERIOD, GETUTCDATE())        
                SELECT @ROWSAFFECTED = @ROWSAFFECTED + @@ROWCOUNT
            END
            IF @TRACELEVEL = 4 
            BEGIN
              SELECT @MESSAGE = MESSAGE FROM APM.MESSAGES WHERE ID = 50023
              RAISERROR (@MESSAGE, 0, 1, @ROWSAFFECTED, @TABLENAME) WITH NOWAIT;      
            END 
        END
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN
        DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
           ,@ERROR_MESSAGE            nvarchar(max)
        SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
        RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetOldComputersOrSources'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetOldComputersOrSources AS RETURN 1')
  END
GO
alter PROCEDURE APM.GetOldComputersOrSources
        @ISCOMPUTER bit, @DEBUG bit
AS
BEGIN
    SET NOCOUNT ON
    DECLARE 
        @SQL nvarchar(MAX)  
       ,@FROMITEMTABLE nvarchar(1000)
       ,@FROMPCITEMTABLE nvarchar(1000)
       ,@EVENTFIELDS nvarchar(1000)
       ,@PCFIELDS nvarchar(1000)
       ,@WHEREITEM nvarchar(1000)
       ,@WHEREPCITEM nvarchar(1000)
        
    SELECT
         @EVENTFIELDS = CASE @ISCOMPUTER WHEN 1 
                        THEN N'm.MACHINEID AS Id, m.MACHINE AS ItemName, t.utceventdate AS LastRefreshDate' 
                        ELSE N's.SOURCEID AS Id, s.SOURCE AS ItemName, t.utceventdate AS LastRefreshDate' 
                   END
        ,@PCFIELDS = CASE @ISCOMPUTER WHEN 1 
                        THEN N'm.MACHINEID AS Id, m.MACHINE AS ItemName, t.utcdate AS LastRefreshDate' 
                        ELSE N's.SOURCEID AS Id, s.SOURCE AS ItemName, t.utcdate AS LastRefreshDate ' 
                   END      
        ,@FROMITEMTABLE = CASE @ISCOMPUTER WHEN 1 
                        THEN N'APM.MACHINE m (NOLOCK)' 
                        ELSE N'APM.SOURCE s (NOLOCK)' 
                   END
                   
        ,@WHEREITEM = CASE @ISCOMPUTER WHEN 1 
                        THEN N'WHERE t.MACHINEID = m.MACHINEID' 
                        ELSE N'WHERE t.SOURCEID = s.SOURCEID' 
                   END
                   
        ,@SQL = N'
  ;WITH AllItemsSet AS
  (  
        SELECT {0} 
            FROM {2}
                OUTER APPLY (
                    SELECT TOP 1 t.UTCEVENTDATE FROM APM.EVENT t (NOLOCK)
                        {3}
                    ORDER BY t.UTCEVENTDATE DESC
                ) t         
        UNION ALL 
        SELECT {1} 
            FROM {2}
                OUTER APPLY (
                    SELECT TOP 1 t.UTCDATE FROM APM.csEVENT t (NOLOCK)
                        {3}
                    ORDER BY t.UTCDATE DESC
                ) t         
        UNION ALL 
        
        SELECT {1} 
            FROM {2}
                OUTER APPLY (
                    SELECT TOP 1 t.UTCDATE FROM APM.PerfHourly t (NOLOCK)
                        {3}
                    ORDER BY t.UTCDATE DESC 
                ) t         
   )
   SELECT 0 AS Checked, Min(Id) AS Id, ItemName, MAX(LastRefreshDate) AS LastRefreshDate 
      FROM AllItemsSet
            GROUP BY 
              ItemName  
            ORDER BY 
               LastRefreshDate
   '
      SELECT @SQL = REPLACE(@SQL, N'{0}', @EVENTFIELDS)     
      SELECT @SQL = REPLACE(@SQL, N'{1}', @PCFIELDS)    
      SELECT @SQL = REPLACE(@SQL, N'{2}', @FROMITEMTABLE)   
      SELECT @SQL = REPLACE(@SQL, N'{3}', @WHEREITEM)
      IF @DEBUG = 1
        PRINT @SQL  
      EXEC sp_executesql @SQL, N''
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.CalculateOldComputersOrSources'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.CalculateOldComputersOrSources AS RETURN 1')
  END
GO
alter PROCEDURE APM.CalculateOldComputersOrSources
        @ISCOMPUTER bit, @ITEMS nvarchar(MAX), @DEBUG bit, @RECCOUNT int OUTPUT
AS
BEGIN
    SET NOCOUNT ON
    IF LEN(@ITEMS) = 0  
    BEGIN 
      RAISERROR('Parameter @ITEMS is empty.', 16, 1, 'CalculateOldComputersOrSources')
      RETURN
    END
    DECLARE 
        @SQL nvarchar(MAX)  
       ,@JOINITEMTABLE nvarchar(1000)
       ,@JOINFILTER nvarchar(1000)
        
    SELECT
         @JOINITEMTABLE = CASE @ISCOMPUTER WHEN 1 
                        THEN N'JOIN APM.MACHINE m (NOLOCK) ON m.MachineId = t.MachineId' 
                        ELSE N'JOIN APM.SOURCE s (NOLOCK) ON s.SourceId = t.SourceId' 
                   END
        ,@JOINFILTER = CASE @ISCOMPUTER WHEN 1 
                        THEN N'JOIN APM.GetMultiParameters(@ITEMS, @EMPTY) f ON f.VALUE = m.MachineId' 
                        ELSE N'JOIN APM.GetMultiParameters(@ITEMS, @EMPTY) f ON f.VALUE = s.SourceId' 
                   END
        ,@SQL = N'
          ;WITH AllItemsSet AS
          (  
                SELECT COUNT(t.eventId) AS recCount 
                    FROM APM.EVENT t(NOLOCK) 
                        {0}
                        {1}
                UNION ALL 
                SELECT COUNT(t.cseventId) AS recCount 
                    FROM APM.csEVENT t(NOLOCK) 
                        {0}
                        {1}
                UNION ALL 
                
                SELECT COUNT(t.perfhourlyId) AS recCount
                    FROM APM.PERFHOURLY t (NOLOCK)
                        {0}
                        {1}
                UNION ALL 
                
                SELECT COUNT(t.perfdailyId) AS recCount
                    FROM APM.PERFDAILY t (NOLOCK)
                        {0}
                        {1}
           )
           SELECT @RECCOUNT=SUM(recCount) FROM AllItemsSet
       '
  DECLARE @PARAMS nvarchar(MAX)
  SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)   
  SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)  
  IF @DEBUG = 1       
    PRINT @SQL  
  SELECT @PARAMS = N'@ITEMS nvarchar(max), @EMPTY nvarchar(10), @RECCOUNT int OUTPUT'
  EXEC sp_executesql @SQL, @PARAMS, @ITEMS, N'', @RECCOUNT = @RECCOUNT OUTPUT
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GroomingOldComputersOrSources'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GroomingOldComputersOrSources AS RETURN 1')
  END
GO
ALTER PROCEDURE [apm].[GroomingOldComputersOrSources]
        @ISCOMPUTER BIT,
        @DELETEPERITERATION INT,
        @DELETEPERREQUEST int,
        @ITEMS nvarchar(MAX),
        @DEBUG bit,
        @DELETEDCOUNT int OUTPUT,
        @DONE bit OUTPUT 
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE 
        @SERVEREVENTDELETED int
       ,@CLIENTEVENTDELETED int
       ,@COUNTERDELETED int
    
    
    IF @DELETEPERITERATION &lt;= 0  
    BEGIN 
      RAISERROR('Parameter @DELETEPERITERATION is less or it is equal to zero.', 16, 1, 'GroomingOldComputersOrSources')
      RETURN
    END
    IF @DELETEPERREQUEST &lt;= 0  
    BEGIN 
      RAISERROR('Parameter @DELETEPERREQUEST is less or it is equal to zero.', 16, 1, 'GroomingOldComputersOrSources')
      RETURN
    END
    IF @DELETEPERREQUEST &lt; @DELETEPERITERATION 
    BEGIN 
      RAISERROR('Parameter @DELETEPERREQUEST should be greater @DELETEPERITERATION parameter.', 16, 1, 'GroomingOldComputersOrSources')
      RETURN
    END
    
    IF LEN(@ITEMS) = 0  
    BEGIN 
      RAISERROR('Parameter @ITEMS is empty.', 16, 1, 'GroomingOldComputersOrSources')
      RETURN
    END
        
    DECLARE @ROWSAFFECTED INT
    DECLARE 
         @ERRORIND        bit
        ,@ERRORMESSAGE    nvarchar(4000)
        ,@ERRORNUMBER     int
        ,@ERRORSEVERITY   int
        ,@ERRORSTATE      int
        ,@ERRORLINE       int
        ,@ERRORPROCEDURE  sysname
        ,@ERRORMESSAGETEXT nvarchar(4000)
        
	CREATE TABLE #ItemsToDelete
	(
		[Value] NVARCHAR(255) collate database_default
	)
	INSERT INTO #ItemsToDelete
		SELECT [Value]
		FROM APM.GETMULTIPARAMETERS(@ITEMS, N'')        
        
        DECLARE 
            @SQL nvarchar(MAX)  
           ,@JOINITEMTABLE nvarchar(1000)
           ,@JOINFILTER nvarchar(1000)
            
        SELECT
             @JOINITEMTABLE = CASE @ISCOMPUTER WHEN 1 
                            THEN N'JOIN APM.MACHINE m (NOLOCK) ON m.MachineId = t.MachineId' 
                            ELSE N'JOIN APM.SOURCE s (NOLOCK) ON s.SourceId = t.SourceId' 
                       END
            ,@JOINFILTER = CASE @ISCOMPUTER WHEN 1 
                            THEN N'JOIN #ItemsToDelete AS f ON f.VALUE = m.MachineId' 
                            ELSE N'JOIN #ItemsToDelete AS f ON f.VALUE = s.SourceId' 
                       END
    SET @ERRORIND = 0
    BEGIN TRY
    
        DECLARE @DELETEHISTORY TABLE (affected int)
        
        --clear client events events and related referencing tables
        SELECT @ROWSAFFECTED = 0
        
        CREATE TABLE #EVENTGROOM (
            EVENTID INT
        )
        
        CREATE TABLE #TMPPROBINGAPPLICATION (APPLICATIONID int) 
        
        
        SELECT @DELETEDCOUNT = 0
    
        WHILE 1 = 1
        BEGIN       
        
          SELECT @DONE = 1
          -- clear iteration result
          DELETE @DELETEHISTORY
          TRUNCATE TABLE #EVENTGROOM
          
          SELECT @ROWSAFFECTED = 0
        
          SELECT @SQL = N'
            INSERT #EVENTGROOM (EVENTID)
                SELECT TOP(@DELETEPERITERATION) t.cseventId 
                    FROM APM.csevent t (nolock)
                        {0}
                        {1}                     
            '
           SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)  
           SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)     
        
           IF @DEBUG = 1
             PRINT @SQL     
           DECLARE @PARAMS nvarchar(MAX)
           SELECT @PARAMS = N'@DELETEPERITERATION int'
           EXEC sp_executesql @SQL, @PARAMS, @DELETEPERITERATION
           -- Grooming PageEvent-----                  
           DELETE pe
             FROM APM.cspageevent AS pe  
                JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
            -- Grooming Peripheral Details -----                
            DELETE pd
              FROM APM.csperipheraldetail AS pd  
                JOIN APM.csperipheral AS pe ON pe.csperipheralId = pd.csperipheralId
                JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
            -- Grooming Peripheral ------ 
            DELETE pe
              FROM APM.csperipheral AS pe  
                JOIN #EVENTGROOM AS eventFilter ON pe.cseventid = eventFilter.EVENTID
            -- Grooming csHeaviestResource --- 
            DELETE hr
              FROM APM.csHeaviestResource AS hr  
                JOIN #EVENTGROOM AS eventFilter ON hr.cseventid = eventFilter.EVENTID
            -- Grooming ajax events --- 
            DELETE aj
              FROM APM.csAjax AS aj  
                JOIN #EVENTGROOM AS eventFilter ON aj.cseventid = eventFilter.EVENTID
             -- Grooming async ajax events --- 
             DELETE aj
               FROM APM.csAsyncAjax AS aj  
                 JOIN #EVENTGROOM AS eventFilter ON aj.cseventid = eventFilter.EVENTID
             -- Grooming async jscript events --- 
             DELETE js
                FROM APM.csJScriptEvent AS js  
                  JOIN #EVENTGROOM AS eventFilter ON js.cseventid = eventFilter.EVENTID
              -- Grooming client exception events --- 
             DELETE ex
                FROM APM.csexevent AS ex  
                  JOIN #EVENTGROOM AS eventFilter ON ex.cseventid = eventFilter.EVENTID
              -- Grooming client event detail --- 
             DELETE ed
                FROM APM.CSEVENTDETAIL AS ed
                  JOIN #EVENTGROOM AS eventFilter ON ed.cseventid = eventFilter.EVENTID
                  
              -- Grooming client events --- 
             DELETE ev 
                FROM APM.csEvent ev  
                  JOIN #EVENTGROOM AS eventFilter ON ev.cseventid = eventFilter.EVENTID
                
             SELECT @ROWSAFFECTED = @@ROWCOUNT                    
          
             INSERT @DELETEHISTORY(affected) SELECT @ROWSAFFECTED
             
             --- Save deleted client events --      
             SELECT @CLIENTEVENTDELETED = @ROWSAFFECTED
          
             TRUNCATE TABLE #EVENTGROOM              
            
             --clear server events events and related referencing tables
             SELECT @SQL = N'
                INSERT #EVENTGROOM (EVENTID)
                    SELECT TOP(@DELETEPERITERATION) t.eventId 
                        FROM APM.event t (nolock)
                            {0}
                            {1}
                '
        
             SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)    
             SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)   
             IF @DEBUG = 1
                PRINT @SQL  
             SELECT @PARAMS = N'@DELETEPERITERATION int'
             EXEC sp_executesql @SQL, @PARAMS, @DELETEPERITERATION
                    
             --- Grooming performance node ---------
             DELETE pn
               FROM APM.PerformanceNode AS pn  
                 JOIN #EVENTGROOM AS eventFilter ON pn.eventid = eventFilter.EVENTID
             DELETE rgn
               FROM APM.ResourceGroupNode AS rgn  
                JOIN #EVENTGROOM AS eventFilter ON rgn.eventid = eventFilter.EVENTID
             DELETE en
               FROM APM.ExceptionNode AS en  
                JOIN #EVENTGROOM AS eventFilter ON en.eventid = eventFilter.EVENTID
            
             DELETE ed
               FROM APM.EVENTDETAIL AS ed  
                JOIN #EVENTGROOM AS eventFilter ON ed.eventid = eventFilter.EVENTID
                
             DELETE e
               FROM APM.Event AS e  
                JOIN #EVENTGROOM AS eventFilter ON e.eventid = eventFilter.EVENTID
             SELECT @ROWSAFFECTED = @@ROWCOUNT
            
             INSERT @DELETEHISTORY(affected) SELECT @ROWSAFFECTED
             
             -- save deleted server events
             SELECT @SERVEREVENTDELETED = @ROWSAFFECTED
                                    
             --clear PerfHourly table 
            
             SELECT @SQL = N'
                DELETE TOP(@DELETEPERITERATION) t
                    FROM APM.PerfHourly t  
                            {0}
                            {1}
                SELECT @ROWSAFFECTED = @@ROWCOUNT                           
                '
             SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)    
             SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)   
             IF @DEBUG = 1
                PRINT @SQL  
             SELECT @PARAMS = N'@DELETEPERITERATION int, @ROWSAFFECTED int OUTPUT'
             EXEC sp_executesql @SQL, @PARAMS, @DELETEPERITERATION, @ROWSAFFECTED = @ROWSAFFECTED OUTPUT 
            
             INSERT @DELETEHISTORY(affected) SELECT @ROWSAFFECTED
            
             -- save deleted counters
             SELECT @COUNTERDELETED = @ROWSAFFECTED
             --clear PerfDaily table 
            
             SELECT @SQL = N'
                DELETE TOP(@DELETEPERITERATION) t
                    FROM APM.PerfDaily t  
                            {0}
                            {1}
                SELECT @ROWSAFFECTED = @@ROWCOUNT                           
                '
             SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)    
             SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)   
             IF @DEBUG = 1
                PRINT @SQL  
             SELECT @PARAMS = N'@DELETEPERITERATION int, @ROWSAFFECTED int OUTPUT'
             EXEC sp_executesql @SQL, @PARAMS, @DELETEPERITERATION, @ROWSAFFECTED = @ROWSAFFECTED OUTPUT 
            
             INSERT @DELETEHISTORY(affected) SELECT @ROWSAFFECTED
                        
             --clear APPLICATIONSOURCEMACHINE table
             TRUNCATE TABLE #TMPPROBINGAPPLICATION 
             
             SELECT @SQL = N'
                DELETE TOP(@DELETEPERITERATION) t OUTPUT DELETED.ApplicationId INTO #TMPPROBINGAPPLICATION
                    FROM APM.APPLICATIONSOURCEMACHINE t   
                            {0}
                            {1}
                SELECT @ROWSAFFECTED = @@ROWCOUNT                               
                '
             SELECT @SQL = REPLACE(@SQL, N'{0}', @JOINITEMTABLE)    
             SELECT @SQL = REPLACE(@SQL, N'{1}', @JOINFILTER)   
             IF @DEBUG = 1
                PRINT @SQL  
             SELECT @PARAMS = N'@DELETEPERITERATION int, @ROWSAFFECTED int OUTPUT'
             EXEC sp_executesql @SQL, @PARAMS, @DELETEPERITERATION, @ROWSAFFECTED = @ROWSAFFECTED OUTPUT  
            
             INSERT @DELETEHISTORY(affected) SELECT @ROWSAFFECTED
            
             IF EXISTS(SELECT * FROM @DELETEHISTORY WHERE affected = @DELETEPERITERATION)
                SELECT @DONE = 0
                
             SELECT @DELETEDCOUNT = @DELETEDCOUNT + @SERVEREVENTDELETED 
                            + @CLIENTEVENTDELETED + @COUNTERDELETED
             ------------------- try delete applications ----------         
             IF @DONE = 1
             BEGIN
            
             --clear Resource table
                IF @ISCOMPUTER = 0
                    WHILE EXISTS
                    (
                        SELECT * FROM APM.RESOURCE R
                            JOIN #ItemsToDelete AS f ON f.VALUE = r.sourceId
                    )
                    BEGIN
                        DELETE TOP(@DELETEPERITERATION) r 
                            FROM APM.Resource R     
                                JOIN #ItemsToDelete AS f ON f.VALUE = r.sourceId
                    END                             
            
                DELETE A
                    FROM APM.APPLICATION A   
                        WHERE 
                            EXISTS
                            (
                                SELECT * FROM #TMPPROBINGAPPLICATION tmp 
                                    WHERE tmp.APPLICATIONID = A.ApplicationId
                            ) AND 
                            NOT EXISTS
                            (
                                SELECT * FROM APM.APPLICATIONSOURCEMACHINE l WITH (NOLOCK)
                                    WHERE l.ApplicationId = A.ApplicationId
                            )
                
                ------------------- try delete machines ----------          
                IF  @ISCOMPUTER = 1 
                    DELETE m 
                        FROM APM.MACHINE m      
                            JOIN #ItemsToDelete AS f ON f.VALUE = m.MachineId
                ------------------- try delete sources ----------           
                IF  @ISCOMPUTER = 0
                    DELETE s 
                        FROM APM.Source s   
                            JOIN #ItemsToDelete AS f ON f.VALUE = s.SourceId
                BREAK                           
             END
             
             --- Check request result       
             SELECT @DELETEPERREQUEST = @DELETEPERREQUEST - @SERVEREVENTDELETED 
                            - @CLIENTEVENTDELETED - @COUNTERDELETED
        
             IF @DELETEPERREQUEST &lt;= 0 
              BREAK
        END  
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN
        DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
           ,@ERROR_MESSAGE            nvarchar(max)
        SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
        RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GetApplicationGroups'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GetApplicationGroups AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* Procedure return application groups                                                            */
/**************************************************************************************************/
alter PROCEDURE APM.GetApplicationGroups 
AS
BEGIN
    SET NOCOUNT ON
    SELECT 0 AS Checked, a.APPLICATIONID AS Id, a.APPLICATION AS ItemName 
        FROM APM.APPLICATION a (NOLOCK)
            WHERE a.APPLICATION != 'All'    
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.GroomingOldApplicationGroup'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.GroomingOldApplicationGroup AS RETURN 1')
  END
GO
/**************************************************************************************************/
/* Procedure delete unused application groups                                                     */
/* Parameters:                                                                                    */    
/* @ITEM - Application Group                                                                      */
/**************************************************************************************************/
alter PROCEDURE APM.GroomingOldApplicationGroup
        @ITEM int
AS
BEGIN
    SET NOCOUNT ON;
    IF EXISTS(SELECT * FROM APM.APPLICATION (NOLOCK) 
                    WHERE APPLICATIONID = @ITEM  AND APPLICATION = N'All')
    BEGIN    
      RAISERROR('It is forbidden to delete ''All'' aplication group ', 16, 1, 'GroomingOldApplicationGroup')
      RETURN
    END
        
    DECLARE @ROWSAFFECTED INT
    DECLARE 
         @ERRORIND        bit
        ,@ERRORMESSAGE    nvarchar(4000)
        ,@ERRORNUMBER     int
        ,@ERRORSEVERITY   int
        ,@ERRORSTATE      int
        ,@ERRORLINE       int
        ,@ERRORPROCEDURE  sysname
        ,@ERRORMESSAGETEXT nvarchar(4000)
        
    SET @ERRORIND = 0
    BEGIN TRY
    
    DELETE t 
         FROM APM.APPLICATIONSOURCEMACHINE t
              JOIN APM.APPLICATION a (NOLOCK) ON a.APPLICATIONID = T.APPLICATIONID
    WHERE
        a.ApplicationId = @ITEM     
    
    DELETE APM.APPLICATION WHERE APPLICATIONID = @ITEM 
    
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN
        DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
           ,@ERROR_MESSAGE            nvarchar(max)
        SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        SELECT @ERROR_MESSAGE = message FROM APM.Messages WHERE id = 50004
        RAISERROR (@ERROR_MESSAGE, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClient'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClient AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClient                                                        */
/* USED IN: Application Status Client Report                                            */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEIDS      - List of the source id, separated by comma. Exp: '1,2,3'       */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @AVERAGEINTERVAL- This value specifies interval, for which average values will  */
/*                          be calculated. Possible values: 1(1 month), 2(2 month),     */
/*                          3(3 month), 6(6 month), 17 (7 day)                          */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @INCLUDESUBNET - List masks, which should be included                           */
/*      @EXCLUDESUBNET - List masks, which should be excluded                           */
/*      @WARNINGTHRESHOLD - Threshold specified by user to notify about warning     */
/*      @ERRORTHRESHOLD - Threshold specified by user to notify about errors        */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationStatusClient
    @SOURCEIDS NVARCHAR(MAX),
    @COMPUTERIDS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @AVERAGEINTERVAL INT,
    @THRESHOLD INT,
    @PROBLEM NVARCHAR(10),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),
    @ERRORTHRESHOLD INT,
    @WARNINGTHRESHOLD INT,    
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)
WITH RECOMPILE    
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT
      @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
      @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')    
    
/************************************************************************************/
/*  Prepare auxiliary variables for the further calculation                         */
/************************************************************************************/
    DECLARE @CLIENTENDDATE DateTime
    SET @CLIENTENDDATE = @ENDDATE
    
    --Convert End date to UTC
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @CLIENTENDDATE)
    --Used for counting average value for last three months
    DECLARE @PERIODDAYSCOUNT int
    SET @PERIODDAYSCOUNT = (CASE    
                                WHEN @PERIOD = 1 THEN 1
                                WHEN @PERIOD = 2 THEN 7
                                WHEN @PERIOD = 3 THEN 31
                            END)
    DECLARE @STARTDATE DateTime
    SET @STARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @ENDDATE)    
    DECLARE @CLIENTSTARTDATE DateTime
    SET @CLIENTSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @CLIENTENDDATE)    
    
    DECLARE @HOURSCOUNT int
    SET @HOURSCOUNT = (CASE 
                                WHEN @PERIOD = 1 THEN 24
                                WHEN @PERIOD = 2 THEN 24
                                WHEN @PERIOD = 3 THEN 1 -- Every day of the month have one hour - 00:00
                            END)                            
                            
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -@PERIODDAYSCOUNT, @STARTDATE)
    DECLARE @AVERAGEPERIODSTARTDATE DateTime
    SET @AVERAGEPERIODSTARTDATE = (CASE 
                                        WHEN @AVERAGEINTERVAL &lt; 10 THEN DATEADD(month, -@AVERAGEINTERVAL, @STARTDATE)
                                        ELSE DATEADD(day, -(@AVERAGEINTERVAL-10), @STARTDATE)
                                   END)
    
    DECLARE @PROCESSORCOUNTERID INT
    SELECT @PROCESSORCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE type = N'\Process\% Processor Time'
    DECLARE @MEMORYCOUNTERID INT
    SELECT @MEMORYCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE type = N'\Process\Private Bytes'
    DECLARE @IOCOUNTERID INT
    SELECT @IOCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE type = N'\Process\IO Data Bytes/sec'
    DECLARE @MONITOREDREQUESTCOUNTERID INT
    SELECT @MONITOREDREQUESTCOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE type = N'\Apps\Monitored Requests'
    DECLARE @REQUESTTIMECOUNTERID INT
    SELECT @REQUESTTIMECOUNTERID = PCtypeId FROM apm.PCType (NOLOCK) WHERE type = N'\Apps\Avg. Request Time'
/************************************************************************************/
/*                          ASSISTING TEMP TABLES                                   */
/************************************************************************************/
    -- Filter table, which contains machine ids and source ids
    -- typeid defines filter type - 1 for source and 2 for machine
    -- valueId filter value - source id and machine id 
    CREATE TABLE #SOURCEMACHINEFILTERTABLE(
        TYPEID INT, 
        VALUEID INT
    )
    -- Fill table #SOURCEMACHINEFILTERTABLE
    INSERT 
        INTO #SOURCEMACHINEFILTERTABLE
            SELECT 
                p.typeId AS TYPEID,
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@SOURCEIDS, @COMPUTERIDS) AS p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.VALUE AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- Filter table for SubnetC values
    CREATE TABLE #SUBNETCFILTERTABLE
    (
        IPID INT,
        SUBNETC NVARCHAR(50) collate database_default  
    )
    -- Insert into filter id of the SubnetC to increase performance for event table
    INSERT INTO #SUBNETCFILTERTABLE
    SELECT DISTINCT
        ipid,
        SubNetC
    FROM
        apm.IP AS ip (NOLOCK)
        JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
        LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
    WHERE
    --Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
        p2.typeId IS NULL
    
    -- To form application pool with all sources run in it, it is need to get all sources and its process
    CREATE TABLE #PROCESSFORSOURCE
    (
        SOURCEID INT,
        PCPROCESSID INT,
        MACHINEID INT,
        EXTRAINFO NVARCHAR(255) collate database_default,
        PROCESS NVARCHAR(255) collate database_default
    )
    
    INSERT INTO #PROCESSFORSOURCE
        SELECT
            ph.SourceId,
            ph.PCProcessId,
            ph.MachineId,
            COALESCE(p.Extrainfo, N'') AS EXTRAINFO,
            --Select process name till # symbol (w3wp#1 -&gt; w3wp, w3wp -&gt; w3wp)
            APM.RemoveProcessIdFromName(p.Process) AS Process           
        FROM
            (
                SELECT DISTINCT
                    ph.SourceId,
                    ph.pcprocessId,
                    ph.MachineId
                FROM
                    apm.PerfHourly AS ph (NOLOCK)
                WHERE
                    ph.pcprocessId IS NOT NULL
                    AND ph.UTCDate &gt;= @STARTDATE
                    AND ph.UTCDate &lt; @ENDDATE
            ) AS ph
            JOIN apm.PCProcess AS p (NOLOCK) ON p.pcprocessId = ph.pcprocessId 
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 2 AND ph.MachineId = f.VALUEID)
/************************************************************************************/
/*                          Main query                                              */
/************************************************************************************/
-- Report frame. It contains all sources, for which values sould be selected, 
-- and dates for the specified period (StartDate : EndDate)  
;WITH SourcesDates AS
(
    SELECT
        s.SourceId,
        s.source AS source,
        s.RowId,
        s.IsClient,
        -- Select 1, 7 or 31 day from end date in ClientTime zone, without hours. 
        -- After that add appropriate hours
        DATEADD(HOUR, h.n-1, CONVERT(NVARCHAR, DATEADD(d, -d.n, @CLIENTENDDATE), 112)) AS ClientDate
    FROM
        (SELECT
                ROW_NUMBER() OVER(
                                PARTITION BY 
                                        CASE WHEN s.Source like N'%(Client)' THEN 1
                                            ELSE 0
                                        END
                                ORDER BY
                                    S.Source
                                ) AS RowId,
                                
                s.Source,
                S.SourceId,
                (CASE WHEN s.Source like N'%(Client)' THEN 1
                    ELSE 0
                END ) AS IsClient
            FROM
                apm.SOURCE AS s
                JOIN #SOURCEMACHINEFILTERTABLE AS sourceFilter ON s.SourceId = sourceFilter.VALUEID     
            WHERE
                sourceFilter.TYPEID = 1             
        ) AS S 
        CROSS JOIN APM.fn_nums(@PERIODDAYSCOUNT) AS d
        CROSS JOIN APM.fn_nums(@HOURSCOUNT) AS h
),
-- Get sources name, ids list separated by comma per app pool
-- This info should be selected for all sources, even they are in the same application pool
-- as in this report grouping by source is applied not by application pool.
    AppPoolInfo AS 
    (
        SELECT 
            c.SOURCEID,
            c.EXTRAINFO,
            c.PROCESS,
            -- all source names which have the same process name as passed in @SOURCEIDS
            (SELECT A.source AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        N'''' + s.source + N'''' +  N',' AS source
                    FROM 
                        #PROCESSFORSOURCE AS c1
                        JOIN Source AS s ON c1.SOURCEID = s.SourceId
                    WHERE 
                        c1.EXTRAINFO = c.EXTRAINFO 
                        AND c1.PROCESS = c.PROCESS
                        AND c1.MACHINEID = c.MACHINEID
                ) AS A
                FOR XML PATH ('') 
            ) AS AppPoolSources
        FROM
            #PROCESSFORSOURCE AS c
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = c.SOURCEID)
        GROUP BY
            c.SOURCEID, 
            c.MACHINEID,
            c.EXTRAINFO,
            c.PROCESS
    ),
    --Add Pool name in-front of source list, if it is executable application, then app pool countains source name
    PrepareAppPoolInfo AS (
        SELECT DISTINCT
            CASE 
                WHEN COALESCE(info.ExtraInfo,'') = '' THEN CASE info.AppPoolSources WHEN '' THEN '' ELSE LEFT(info.AppPoolSources, LEN(info.AppPoolSources)-1) END
                ELSE info.ExtraInfo + CASE info.AppPoolSources WHEN '' THEN '' ELSE ' (' + LEFT(info.AppPoolSources, LEN(info.AppPoolSources) - 1) + ')' END
            END AppPool,
            info.SourceId,
            info.ExtraInfo
        FROM 
            AppPoolInfo AS info
    ),
-- Forms application pool list for each source
-- Format: AppPool1 ('Source1', 'Source2', Source3), AppPool2 ('Source1', 'Source4')
    SourceAppPools AS (
        SELECT 
            s.SourceId,
            s.Source,
            COALESCE((SELECT a.AppPool AS [data()]
                FROM 
                (
                    SELECT DISTINCT 
                        info.AppPool +  N',' AS AppPool
                    FROM 
                        PrepareAppPoolInfo as info
                    WHERE 
                        info.Sourceid = s.Sourceid 
                ) AS A
                FOR XML PATH ('') 
            ),s.Source +  '-') AS AppPoolInfo
        FROM 
            apm.Source AS s
            JOIN #SOURCEMACHINEFILTERTABLE AS f ON (f.TYPEID = 1 AND f.VALUEID = s.SourceId)
    ),    
    --Prepares and filters server events for further manipulations
    ApplicationStatusClient_EventsFiltered AS
    (
        SELECT
            e.sourceid,
            e.eventid,
            -- this field is need to determine number of days when 
            -- there were some events in DB. If number of days is less than 7, 
            -- then it is supposed that average valu is not correct enought
            DATEDIFF(DAY, DATEADD(mi, @TIMEZONE, e.utceventdate), @CLIENTSTARTDATE) AS EventFillFactor,
            --Removing APM.GetDatePart replacing the execution by the code below. 
            --It boosts the overall performance as it reduces the number of calls of scalar function
            CASE @PERIOD 
                WHEN 3 THEN CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, e.utceventdate), 112)
                ELSE DATEADD(hh, 
                            DATEPART(hh, DATEADD(mi, CAST(@TIMEZONE AS int), e.utceventdate)), 
                    CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, e.utceventdate), 112))
            END as Date,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            (DATEDIFF(hour, e.utceventdate, @ENDDATE)-1) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.Event AS e (NOLOCK)
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.sourceid and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.machineid and f2.TYPEID = 2)
            JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus) 
        WHERE
            ((e.EventClassType = N'Performance' AND e.eventduration/1000000.0 &gt;= @THRESHOLD ) 
            OR e.EventClassType = N'exception')
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utceventdate &lt; @ENDDATE
    ),
    PrepareEventsServerAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.PeriodId,
            -- PeriodId is 0 for the current period, 1 for last and 1..n for average
            -- This manipulation should shift Client date to current period for 
            -- other periods - average and last. Client date is in client time zone
            DATEADD(day, e.PeriodId*@PERIODDAYSCOUNT, e.Date) AS ClientDate,
            MAX(EventFillFactor) AS EventFillFactor,
            COUNT(CASE WHEN e.PeriodId = 0 THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.PeriodId = 1 THEN eventid END) AS LastEventsCount,
            COUNT(CASE WHEN PeriodId &gt; 0 THEN eventid END) AS AvgEventsCount
        FROM
            ApplicationStatusClient_EventsFiltered AS e
        GROUP BY 
            e.SourceId,
            e.PeriodId,
            e.Date
    ),
    EventsServer AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.ClientDate,
            MAX(EventFillFactor) AS EventFillFactor,            
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LastEventsCount) AS LastEventsCount,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgEventsCount*1.0 END) AS AvgEventsCount
        FROM
            PrepareEventsServerAvg AS e
        GROUP BY 
            sourceid,
            e.ClientDate
    ),
    
/****************************************************************************************************************/
/*                          Section selects client events                                                       */  
/****************************************************************************************************************/
    -- Select Client Side events
    ApplicationStatusClient_ClientEventsFiltered AS
    (   
        SELECT
            e.SourceId,
            e.CSEventId AS EventId,
            -- this field is need to determine number of days when 
            -- there were some events in DB. If number of days is less than 7, 
            -- then it is supposed that average value is not correct enought
            DATEDIFF(DAY, DATEADD(mi, @TIMEZONE, e.utcdate), @CLIENTSTARTDATE) AS EventFillFactor,          
            -- If specified period is Month then take only date part
            -- In other cases round date to hours, without minutes and seconds
            CASE @PERIOD 
                WHEN 3 THEN CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, e.utcdate), 112)
                ELSE DATEADD(hh, 
                            DATEPART(hh, DATEADD(mi, CAST(@TIMEZONE AS int), e.utcdate)), 
                    CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, e.utcdate), 112))
            END as Date,
            --hour is taken as DateDifference in day between 05/04/2009 9:00AM and 05/03/2009 9:00PM is one day,
            --despite in case of @PERIOD = 'Day' it can be interpretated as one day (if 05/04/2009 9:00AM is end date), so difference should be taken as 0
            (DATEDIFF(hour, e.utcdate, @ENDDATE)- 1) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.CSEvent AS e (NOLOCK)
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.VALUEID = e.sourceid and f1.TYPEID = 1)          
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.VALUEID = e.machineid and f2.TYPEID = 2)
            JOIN #SUBNETCFILTERTABLE AS f3 ON e.ipid = f3.IPID
			JOIN #PMSTATUSFILTERTABLE AS f4 ON (f4.VALUEID = e.PMStatus)             
        WHERE
            e.utcdate &gt;= @AVERAGEPERIODSTARTDATE
            AND e.utcdate &lt; @ENDDATE
            AND e.PageUri IS NOT NULL
            AND (e.ClassType = N'exception' OR e.TotalTime/1000.0 &gt;= @THRESHOLD)
    ),
    -- Group by date (rounded in previous step) and count events
    PrepareEventsClientAvg AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.PeriodId,
            DATEADD(day, e.PeriodId*@PERIODDAYSCOUNT, e.Date) AS ClientDate,
            MAX(EventFillFactor) AS EventFillFactor,
            COUNT(CASE WHEN e.PeriodId = 0 THEN eventid END) AS CurrentEventsCount,
            COUNT(CASE WHEN e.PeriodId = 1 THEN eventid END) AS LastEventsCount,
            COUNT(CASE WHEN PeriodId &gt; 0 THEN eventid END) AS AvgEventsCount
        FROM
            ApplicationStatusClient_ClientEventsFiltered AS e
        GROUP BY 
            e.SourceId,
            e.PeriodId,
            e.[Date]
    ),
    -- This step is meaningful only for average period AS all events are averaged between "average" period days
    EventsClient AS
    (
        SELECT
            e.sourceid AS sourceid,
            e.ClientDate,
            MAX(EventFillFactor) AS EventFillFactor,
            MAX(CurrentEventsCount) AS CurrentEventsCount,
            MAX(LastEventsCount) AS LastEventsCount,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgEventsCount*1.0 END) AS AvgEventsCount
        FROM
            PrepareEventsClientAvg AS e
        GROUP BY 
            e.SourceId,
            e.ClientDate
    ),
    /*************************************************************************************/
    /*                          Activity pcounter queries                                */
    /************************************************************************************/
    -- Select Pcounters with specified filtering for activity statistics
    ApplicationStatusActivityPerHour AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- this field is need to determine number of days when 
            -- there were some pc in DB. If number of days is less than 7, 
            -- then it is supposed that average valu is not correct enought
            DATEDIFF(DAY, DATEADD(mi, @TIMEZONE, ph.UTCDate), @CLIENTSTARTDATE) AS ActivityPCFillFactor,                    
            CASE @PERIOD 
                WHEN 3 THEN CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, ph.UTCDate), 112)
                ELSE DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate)
            END as ClientDate,
            (CASE WHEN ph.PCTypeId = @MONITOREDREQUESTCOUNTERID THEN ph.SumValue END) AS MonRequest,
            (CASE WHEN ph.PCTypeId = @REQUESTTIMECOUNTERID THEN ph.SumValue / ph.SampleCount END) AS RequestTime,
            (DATEDIFF(hour, ph.utcdate, @ENDDATE) - 1) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.PerfHourly AS ph (NOLOCK)
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@REQUESTTIMECOUNTERID, @MONITOREDREQUESTCOUNTERID)
    ),
    -- Next step aggregates data only then period is one month. 
    -- After this step data are aggregated by days. 
    -- For other periods this step is only pivots data by periods.
    ApplicationStatusActivityByDay AS
    (
         SELECT
            MachineId,
            SourceId,
            PeriodId,
            MAX(ActivityPCFillFactor) AS ActivityPCFillFactor,
            DATEADD(day, PeriodId*@PERIODDAYSCOUNT, ClientDate) AS ClientDate,
            SUM(CASE WHEN PeriodId = 0 THEN MonRequest END) AS CurrentRequestCount,
            SUM(CASE WHEN PeriodId = 1 THEN MonRequest END) AS LastRequestCount,
            SUM(CASE WHEN PeriodId &gt; 0 THEN MonRequest END) AS AvgRequestCount,
            AVG(CASE WHEN PeriodId = 0 THEN RequestTime END) AS CurrentRequestTime,
            AVG(CASE WHEN PeriodId = 1 THEN RequestTime END) AS LastRequestTime,
            AVG(CASE WHEN PeriodId &gt; 0 THEN RequestTime END) AS AvgRequestTime
        FROM
            ApplicationStatusActivityPerHour
        GROUP BY
            MachineId,
            SourceId,
            PeriodId,
            ClientDate
    ),
    -- This step is meaningful only for average period AS all counters are averaged between "average" period dates
    ApplicationStatusActivityByPeriod AS
    (
         SELECT
            MachineId,
            SourceId,
            ClientDate,
            MAX(ActivityPCFillFactor) AS ActivityPCFillFactor,
            MAX(CurrentRequestCount) AS CurrentRequestCount,
            MAX(LastRequestCount) AS LastRequestCount,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgRequestCount*1.0 END) AS AvgRequestCount,
            MAX(CurrentRequestTime) AS CurrentRequestTime,
            MAX(LastRequestTime) AS LastRequestTime,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgRequestTime END) AS AvgRequestTime
        FROM
            ApplicationStatusActivityByDay
        GROUP BY
            MachineId,
            SourceId,
            ClientDate
    ),
    --Aggregate data between machines
    ApplicationStatusActivityBySource AS
    (
         SELECT
            SourceId,
            ClientDate,
