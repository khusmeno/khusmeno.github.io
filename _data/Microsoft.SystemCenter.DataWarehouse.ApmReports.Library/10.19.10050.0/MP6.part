            MAX(ActivityPCFillFactor) AS ActivityPCFillFactor,
            SUM(CurrentRequestCount) AS CurrentRequestCount,
            SUM(LastRequestCount) AS LastRequestCount,
            SUM(AvgRequestCount) AS AvgRequestCount,
            AVG(CurrentRequestTime) AS CurrentRequestTime,
            AVG(LastRequestTime) AS LastRequestTime,
            AVG(AvgRequestTime) AS AvgRequestTime
        FROM
            ApplicationStatusActivityByPeriod
        GROUP BY
            SourceId,
            ClientDate
    ),
    /************************************************************************************/
    /*                          Resources pcounter queries                              */
    /************************************************************************************/
    -- Filter resource counters
    ApplicationStatusResourcesPerHour AS
    (
        SELECT
            ph.MachineId,
            ph.SourceId,
            -- this field is need to determine number of days when 
            -- there were some pc in DB. If number of days is less than 7, 
            -- then it is supposed that average valu is not correct enought
            DATEDIFF(DAY, DATEADD(mi, @TIMEZONE, ph.UTCDate), @CLIENTSTARTDATE) AS ResourcePCFillFactor,            
            CASE @PERIOD 
                WHEN 3 THEN CONVERT(NVARCHAR, DATEADD(mi, @TIMEZONE, ph.UTCDate), 112)
                ELSE DATEADD(mi, CAST(@TIMEZONE AS int), ph.UTCDate)
            END as ClientDate,
            (CASE WHEN ph.PCTypeId = @PROCESSORCOUNTERID THEN SUM(ph.SumValue)/SUM(ph.SampleCount) END) AS CPUUsage,
            (CASE WHEN ph.PCTypeId = @IOCOUNTERID THEN SUM(ph.SumValue)/SUM(ph.SampleCount) END) AS IOUsage,
            (CASE WHEN ph.PCTypeId = @MEMORYCOUNTERID THEN SUM(ph.SumValue)/SUM(ph.SampleCount) END) AS MemoryUsage,
            (DATEDIFF(hour, ph.utcdate, @ENDDATE)-1) / (@PERIODDAYSCOUNT*24) AS PeriodId
        FROM
            apm.PerfHourly AS ph (NOLOCK)
            JOIN #SOURCEMACHINEFILTERTABLE AS f1 ON (f1.TYPEID = 1 AND ph.SourceId = f1.VALUEID)
            JOIN #SOURCEMACHINEFILTERTABLE AS f2 ON (f2.TYPEID = 2 AND f2.VALUEID = ph.MachineId)
        WHERE
            ph.UTCDate &gt;= @AVERAGEPERIODSTARTDATE
            AND ph.UTCDate &lt; @ENDDATE
            AND ph.PCTypeID IN (@PROCESSORCOUNTERID, @IOCOUNTERID, @MEMORYCOUNTERID)
        GROUP BY
            ph.UTCDate,
            ph.PCTypeId,
            ph.MachineId,
            ph.SourceId     
     ),
    -- Group resources by date defined by user. For Period = Week and day this step only devides data by period  
    ApplicationStatusResourcesByDay AS
    (
         SELECT
            MachineId,
            SourceId,
            PeriodId,
            MAX(ResourcePCFillFactor) AS ResourcePCFillFactor,
            DATEADD(day, PeriodId*@PERIODDAYSCOUNT, ClientDate) AS ClientDate,
            AVG(CASE WHEN PeriodId = 0 THEN CPUUsage END) AS CurrentCPUUsage,
            AVG(CASE WHEN PeriodId = 1 THEN CPUUsage END) AS LastCPUUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN CPUUsage END) AS AvgCPUUsage,
            AVG(CASE WHEN PeriodId = 0 THEN IOUsage END) AS CurrentIOUsage,
            AVG(CASE WHEN PeriodId = 1 THEN IOUsage END) AS LastIOUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN IOUsage END) AS AvgIOUsage,     
            AVG(CASE WHEN PeriodId = 0 THEN MemoryUsage END) AS CurrentMemoryUsage,
            AVG(CASE WHEN PeriodId = 1 THEN MemoryUsage END) AS LastMemoryUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN MemoryUsage END) AS AvgMemoryUsage
        FROM
            ApplicationStatusResourcesPerHour
        GROUP BY
            MachineId,
            SourceId,
            PeriodId,
            ClientDate
    ),
    --This step aggregates data for "average" period, for other periods it is meaningful
    ApplicationStatusResourcesByPeriod AS
    (
         SELECT
            SourceId,
            ClientDate,
            MAX(ResourcePCFillFactor) AS ResourcePCFillFactor,
            MAX(CurrentCPUUsage/ COALESCE(m.CPUCount, 1)) AS CurrentCPUUsage,
            MAX(LastCPUUsage/ COALESCE(m.CPUCount, 1)) AS LastCPUUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgCPUUsage/ COALESCE(m.CPUCount, 1) END) AS AvgCPUUsage,
            MAX(CurrentIOUsage) AS CurrentIOUsage,
            MAX(LastIOUsage) AS LastIOUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgIOUsage END) AS AvgIOUsage,
            MAX(CurrentMemoryUsage) AS CurrentMemoryUsage,
            MAX(LastMemoryUsage) AS LastMemoryUsage,
            AVG(CASE WHEN PeriodId &gt; 0 THEN AvgMemoryUsage END) AS AvgMemoryUsage       
        FROM
            ApplicationStatusResourcesByDay AS r
            JOIN apm.Machine AS m ON m.MachineId = r.MachineId
        GROUP BY
            r.MachineId,
            SourceId,
            ClientDate
    ),
    -- Aggregate values between machines    
    ApplicationStatusResourcesBySource AS
    (
         SELECT
            SourceId,
            ClientDate,
            MAX(ResourcePCFillFactor) AS ResourcePCFillFactor,
            AVG(CurrentCPUUsage) AS CurrentCPUUsage,
            AVG(LastCPUUsage) AS LastCPUUsage,
            AVG(AvgCPUUsage) AS AvgCPUUsage,
            AVG(CurrentIOUsage) AS CurrentIOUsage,
            AVG(LastIOUsage) AS LastIOUsage,
            AVG(AvgIOUsage) AS AvgIOUsage,
            AVG(CurrentMemoryUsage) AS CurrentMemoryUsage,
            AVG(LastMemoryUsage) AS LastMemoryUsage,
            AVG(AvgMemoryUsage) AS AvgMemoryUsage
        FROM
            ApplicationStatusResourcesByPeriod
        GROUP BY
            SourceId,
            ClientDate
    ),
    --Check if for some of the machines cpu count is not defined
    MachineCPUUndefinedFlag AS
    (
        SELECT
            sf.SOURCEID,
            MIN(COALESCE(m.CPUCount, -1)) AS CPUUndefinedFlag
        FROM
            #PROCESSFORSOURCE AS sf
            JOIN apm.Machine AS m (NOLOCK) ON sf.MACHINEID = m.MachineId
        GROUP BY
            sf.SOURCEID
    ),
    --Combine all data together
    CombinedData AS
    (
        SELECT
            SourcesDates.RowId AS RowId,
            SourcesDates.IsClient,
            SourcesDates.ClientDate,
            SourcesDates.Source,
            SourcesDates.SourceId,
            AppPool.AppPoolInfo,
            rpc.CurrentCPUUsage,
            rpc.LastCPUUsage,
            rpc.AvgCPUUsage,
            MAX(rpc.ResourcePCFillFactor) OVER(PARTITION BY SourcesDates.SourceId) AS ResourcePCFillFactor,             
            (CASE WHEN COALESCE(rpc.AvgCPUUsage, 0) &gt; 0 
                    THEN
                        ABS(COALESCE(rpc.CurrentCPUUsage,0) - COALESCE(rpc.AvgCPUUsage, 0))*1.0/rpc.AvgCPUUsage
                    ELSE 0
            END) AS CpuStatus,
            rpc.CurrentIOUsage/(1024.0) AS CurrentIOUsage,
            rpc.LastIOUsage/(1024.0) AS LastIOUsage,
            rpc.AvgIOUsage/(1024.0) AS AvgIOUsage,
            (CASE WHEN COALESCE(rpc.AvgIOUsage, 0) &gt; 0 
                    THEN
                        ABS(COALESCE(rpc.CurrentIOUsage,0) - COALESCE(rpc.AvgIOUsage, 0))*1.0/rpc.AvgIOUsage
                    ELSE 0
            END) AS IOStatus,       
            rpc.CurrentMemoryUsage/(1024.0*1024) AS CurrentMemoryUsage,
            rpc.LastMemoryUsage/(1024.0*1024) AS LastMemoryUsage,
            rpc.AvgMemoryUsage/(1024.0*1024) AS AvgMemoryUsage,
            (CASE WHEN COALESCE(rpc.AvgMemoryUsage, 0) &gt; 0 
                    THEN
                        ABS(COALESCE(rpc.CurrentMemoryUsage,0) - COALESCE(rpc.AvgMemoryUsage, 0))*1.0/rpc.AvgMemoryUsage
                    ELSE 0
            END) AS MemoryStatus,       
            MAX(apc.ActivityPCFillFactor) OVER(PARTITION BY SourcesDates.SourceId) AS ActivityPCFillFactor,         
            apc.CurrentRequestCount,
            apc.LastRequestCount,
            apc.AvgRequestCount,
            (CASE WHEN COALESCE(apc.AvgRequestCount, 0) &gt; 0 
                    THEN
                        ABS(COALESCE(apc.CurrentRequestCount,0) - COALESCE(apc.AvgRequestCount, 0))*1.0/apc.AvgRequestCount
                    ELSE 0
            END) AS RequestStatus,      
            apc.CurrentRequestTime/1000.0 AS CurrentRequestTime,
            apc.LastRequestTime/1000.0 AS LastRequestTime,
            apc.AvgRequestTime/1000.0 AS AvgRequestTime,
            (CASE WHEN COALESCE(apc.AvgRequestTime, 0) &gt; 0 
                    THEN
                        ABS(COALESCE(apc.CurrentRequestTime,0) - COALESCE(apc.AvgRequestTime, 0))*1.0/apc.AvgRequestTime
                    ELSE 0
            END) AS RequestTimeStatus,
            MAX(COALESCE(E.EventFillFactor, cs.EventFillFactor)) OVER(PARTITION BY SourcesDates.SourceId) AS EventFillFactor,           
            COALESCE(E.CurrentEventsCount, cs.CurrentEventsCount) AS CurrentEventsCount,
            COALESCE(E.LastEventsCount, cs.LastEventsCount) AS LastEventsCount,     
            COALESCE(E.AvgEventsCount, cs.AvgEventsCount) AS AvgEventsCount,
            (CASE WHEN COALESCE(COALESCE(E.AvgEventsCount, cs.AvgEventsCount), 0) &gt; 0 
                    THEN
                        ABS(COALESCE(COALESCE(E.CurrentEventsCount, cs.CurrentEventsCount),0) - COALESCE(COALESCE(E.AvgEventsCount, cs.AvgEventsCount), 0))*1.0/COALESCE(E.AvgEventsCount, cs.AvgEventsCount)
                    ELSE 0
            END) AS EventStatus
        FROM 
            SourcesDates
            JOIN SourceAppPools AS AppPool ON (AppPool.Sourceid = SourcesDates.Sourceid)        
            LEFT OUTER JOIN MachineCPUUndefinedFlag AS cpuFlag ON SourcesDates.Sourceid = cpuFlag.Sourceid
            LEFT OUTER JOIN ApplicationStatusResourcesBySource AS rpc ON (rpc.ClientDate = SourcesDates.ClientDate AND rpc.SourceId = SourcesDates.Sourceid)
            LEFT OUTER JOIN ApplicationStatusActivityBySource AS apc ON (apc.ClientDate = SourcesDates.ClientDate AND apc.SourceId = SourcesDates.Sourceid)
            LEFT OUTER JOIN EventsServer AS e ON (e.ClientDate = SourcesDates.ClientDate AND e.SourceId = SourcesDates.Sourceid)
            LEFT OUTER JOIN EventsClient AS cs ON (cs.ClientDate = SourcesDates.ClientDate AND cs.SourceId = SourcesDates.Sourceid)     
    )    
    SELECT 
        RowId,
        IsClient,
        ClientDate,
        Source,
        SourceId,
        AppPoolInfo,
        CurrentCPUUsage,
        LastCPUUsage,
        AvgCPUUsage,
        -- If resource counters are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN CpuStatus*100 &gt;= @WARNINGTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS CPUWarningDate,
        (CASE WHEN CpuStatus*100 &gt;= @ERRORTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS CPUErrorDate,         
        CurrentIOUsage,
        LastIOUsage,
        AvgIOUsage,
        -- If resource counters are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN IOStatus*100 &gt;= @WARNINGTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS IOWarningDate,
        (CASE WHEN IOStatus*100 &gt;= @ERRORTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS IOErrorDate,
        CurrentMemoryUsage,
        LastMemoryUsage,
        AvgMemoryUsage,
        -- If resource counters are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN MemoryStatus*100 &gt;= @WARNINGTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS MemoryWarningDate,
        (CASE WHEN MemoryStatus*100 &gt;= @ERRORTHRESHOLD AND ResourcePCFillFactor &gt;= 7 THEN ClientDate END) AS MemoryErrorDate,               
        CurrentRequestCount,
        LastRequestCount,
        AvgRequestCount,
        -- If activity counters are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN RequestStatus*100 &gt;= @WARNINGTHRESHOLD AND ActivityPCFillFactor &gt;= 7 THEN ClientDate END) AS RequestWarningDate,
        (CASE WHEN RequestStatus*100 &gt;= @ERRORTHRESHOLD AND ActivityPCFillFactor &gt;= 7 THEN ClientDate END) AS RequestErrorDate,             
        CurrentRequestTime,
        LastRequestTime,
        AvgRequestTime,
        -- If activity counters are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN RequestTimeStatus*100 &gt;= @WARNINGTHRESHOLD AND ActivityPCFillFactor &gt;= 7 THEN ClientDate END) AS RequestTimeWarningDate,
        (CASE WHEN RequestTimeStatus*100 &gt;= @ERRORTHRESHOLD AND ActivityPCFillFactor &gt;= 7 THEN ClientDate END) AS RequestTimeErrorDate,             
        CurrentEventsCount,
        LastEventsCount,        
        AvgEventsCount,
        -- If events are presents not more than for 7 day, then don't show threshold message
        (CASE WHEN EventStatus*100 &gt;= @WARNINGTHRESHOLD AND EventFillFactor &gt;= 7 THEN ClientDate END) AS EventWarningDate,
        (CASE WHEN EventStatus*100 &gt;= @ERRORTHRESHOLD AND EventFillFactor &gt;= 7 THEN ClientDate END) AS EventErrorDate,
        EventStatus,
        EventFillFactor,
        ActivityPCFillFactor,
        ResourcePCFillFactor        
    FROM
        CombinedData
    ORDER BY
        RowId,
        IsClient,
        ClientDate  
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientFrequentCSMEvents'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientFrequentCSMEvents AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientFrequentCSMEvents                                       */
/* USED IN: Application Status Client Report, top 10 Most frequent events               */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                    */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @INCLUDESUBNET - List masks, which should be included                           */
/*      @EXCLUDESUBNET - List masks, which should be excluded                           */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationStatusClientFrequentCSMEvents
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD DECIMAL(35,0),
    @PROBLEM NVARCHAR(10),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),    
    @TIMEZONE INT,
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;    
    
    SELECT
      @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
      @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')    
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID int
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    -- Filter table for SubnetC values
    CREATE TABLE #SUBNETCFILTERTABLE
    (
        IPID INT,
        SUBNETC NVARCHAR(50) collate database_default
    )
    -- Insert into filter id of the SubnetC to increase performance for event table
    INSERT INTO #SUBNETCFILTERTABLE
    SELECT DISTINCT
        ipid,
        SubNetC
    FROM
        apm.IP AS ip (NOLOCK)
        JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
        LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
    WHERE
    --Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
        p2.typeId IS NULL
    ;WITH BaseDataSet AS
    (
        SELECT 
            eg.[Description],
            e.ClassType,
            COUNT(CASE WHEN e.utcdate &gt;= @STARTDATE THEN e.cseventid END) as IssuesCount,
            COUNT(CASE WHEN e.utcdate &lt; @STARTDATE THEN e.cseventid END) AS LastIssuesCount
        FROM
            apm.CSEvent (NOLOCK) AS e
            JOIN apm.CSEventGroup (NOLOCK) AS eg ON e.csEventGroupId = eg.csEventGroupId
            JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f ON f.MACHINEID = e.MachineId 
            JOIN #SUBNETCFILTERTABLE AS f1 ON e.ipid = f1.IPID 
			JOIN #PMSTATUSFILTERTABLE AS f2 ON (f2.VALUEID = e.PMStatus)                        
        WHERE 
            e.sourceid = @SOURCEID
            AND e.utcdate &gt;= @LASTPERIODSTARTDATE
            AND e.utcdate &lt; @ENDDATE 
            AND e.PageUri IS NOT NULL
            AND (e.ClassType = N'exception' OR e.TotalTime/1000.0 &gt;= @THRESHOLD)                        
        GROUP BY 
            eg.Description,
            e.ClassType
    )
    SELECT TOP(10)
        ROW_NUMBER() OVER (ORDER BY e.IssuesCount DESC, e.description) AS Id,
        e.IssuesCount,
        e.LastIssuesCount,
        e.Description,
        e.ClassType,
        COUNT(CASE WHEN e.IssuesCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS TotalCurrentProblemCount,
        COUNT(CASE WHEN e.LastIssuesCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS TotalLastProblemCount,
        SUM(e.IssuesCount) OVER() AS TotalEventCount,
        SUM(e.LastIssuesCount) OVER() AS LastTotalEventCount
    FROM 
        BaseDataSet AS e
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientFrequentFailure'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientFrequentFailure AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientFrequentFailure                                                     */
/* USED IN: Application Status Client Report, top 10 Most frequent exception events     */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                    */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE APM.ApplicationStatusClientFrequentFailure
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
    @PMSTATUS NVARCHAR(50)    
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID int
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH BaseDataSet AS
    (
        SELECT 
            e.description,
            e.category,
            COUNT(
                    CASE 
                        WHEN e.utceventdate &gt;= @STARTDATE 
                    THEN e.eventid
                    END 
                  ) as EventsCount,  
            COUNT(
                    CASE 
                        WHEN e.utceventdate &lt; @STARTDATE 
                    THEN e.eventid
                    END
                  ) AS LastEventsCount
        FROM
            apm.Event (NOLOCK) AS e
            JOIN apm.EventGroup AS eg ON e.EventGroupId = eg.EventGroupId 
            JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f1 ON e.machineid = f1.MACHINEID
			JOIN #PMSTATUSFILTERTABLE AS f3 ON (f3.VALUEID = e.PMStatus)             
        WHERE 
            e.EventClassType = N'Exception'
            AND (e.category LIKE @PROBLEM)
            AND (e.sourceId = @SOURCEID)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE
        GROUP BY 
            e.description, e.category
    )
SELECT TOP(10)
    ROW_NUMBER() OVER (ORDER BY e.EventsCount DESC, E.description) AS Id,
    e.[Description],
    e.Category,
    e.EventsCount,
    e.LastEventsCount,
    -- This information is selected for event summary table
    SUM(e.EventsCount) OVER() AS TotalEventCount,        
    SUM(e.LastEventsCount) OVER() AS LastTotalEventCount,
    -- Caulculate number of different descriotions (proble, count) in current and last periods
    COUNT(CASE WHEN e.EventsCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS CurrentProblemsCount,
    COUNT(CASE WHEN e.LastEventsCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS LastProblemsCount
FROM
    BaseDataSet AS e
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientFrequentPerformance'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientFrequentPerformance AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientFrequentPerformance                                                     */
/* USED IN: Application Status Client Report, top 10 Most frequent performance events   */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                     */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE [APM].[ApplicationStatusClientFrequentPerformance]
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD DECIMAL(35,0),
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT,
	@PMSTATUS NVARCHAR(50)
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID INT
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
    -- Filter table, which contains PM Statuses of Events
    CREATE TABLE #PMSTATUSFILTERTABLE(
        VALUEID INT
    )
    -- Fill table #PMSTATUSFILTERTABLE
    INSERT 
        INTO #PMSTATUSFILTERTABLE
            SELECT 
                CAST(p.value AS INT) AS VALUEID
            FROM 
                --GetMultiParameters function splits incoming strings. It uses comma as substring delimiter 
                APM.GetMultiParameters(@PMSTATUS, N'') AS p
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    ;WITH BaseDataSet AS
    (
        SELECT 
            COUNT(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventid END) as IssuesCount,
            AVG(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS AvgDuration,
            MAX(CASE WHEN e.utceventdate &gt;= @STARTDATE THEN e.eventduration / 1000000 END) AS MaxDuration,
            COUNT(CASE WHEN e.utceventdate &lt; @STARTDATE THEN e.eventid END) AS LastIssuesCount,
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END) AS PerfNodeDescription
        FROM
            apm.Event (NOLOCK) AS e
            JOIN apm.EventGroup (NOLOCK) AS eg ON e.EventGroupId = eg.EventGroupId
            JOIN apm.PerformanceNode (NOLOCK) AS pn ON pn.EventId = e.EventId
            JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f ON f.MACHINEID = e.MachineId 
			JOIN #PMSTATUSFILTERTABLE AS f1 ON (f1.VALUEID = e.PMStatus)             
        WHERE 
            e.EventClassType = N'Performance' 
            AND e.eventduration / 1000000.0 &gt;= @THRESHOLD
            AND e.sourceid = @SOURCEID
            AND (e.category LIKE @PROBLEM OR e.category IS NULL)
            AND e.utceventdate &gt;= @LASTPERIODSTARTDATE
            AND e.utceventdate &lt; @CURRENTPERIODENDDATE 
            AND (e.HeavyLight &lt;&gt; 0 OR e.HeavyLight IS NULL)
            AND pn.ISHeaviestNode = 1
        GROUP BY 
            e.rootnodename,
            (CASE 
                    WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                    ELSE N''
            END)
    )
    SELECT TOP(10)
        ROW_NUMBER() OVER (ORDER BY e.IssuesCount DESC, e.rootnodename, PerfNodeDescription) AS Id,
        e.IssuesCount,
        e.AvgDuration,
        e.MaxDuration,
        e.LastIssuesCount,
        e.rootnodename,
        e.PerfNodeDescription,
        e.rootnodename + (CASE 
                            WHEN LEN(e.PerfNodeDescription) &gt; 0 
                            THEN ' slow at ' +  e.PerfNodeDescription 
                        ELSE N'' END) AS description,
        COUNT(CASE WHEN e.IssuesCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS TotalCurrentProblemCount,
        COUNT(CASE WHEN e.LastIssuesCount &gt; 0 THEN 1 ELSE NULL END) OVER() AS TotalLastProblemCount,
        SUM(e.IssuesCount) OVER() AS TotalEventCount,
        SUM(e.LastIssuesCount) OVER() AS TotalLastEventCount
    FROM 
        BaseDataSet AS e
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientNewCSMEvents'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientNewCSMEvents AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientNewCSMEvents                                                        */
/* USED IN: Application Status Client Report, top 10 New CSM events                     */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                    */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @INCLUDESUBNET - List masks, which should be included                           */
/*      @EXCLUDESUBNET - List masks, which should be excluded                           */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE [APM].[ApplicationStatusClientNewCSMEvents]
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD DECIMAL(35,0),
    @PROBLEM NVARCHAR(10),
    @INCLUDESUBNET NVARCHAR(MAX),
    @EXCLUDESUBNET NVARCHAR(MAX),    
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT
      @INCLUDESUBNET = REPLACE(@INCLUDESUBNET, N'*', N'%'),
      @EXCLUDESUBNET = REPLACE(@EXCLUDESUBNET, N'*', N'%')    
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID INT
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
    -- Filter table for SubnetC values
    CREATE TABLE #SUBNETCFILTERTABLE
    (
        IPID INT,
        SUBNETC NVARCHAR(50) collate database_default
    )
    -- Insert into filter id of the SubnetC to increase performance for event table
    INSERT INTO #SUBNETCFILTERTABLE
    SELECT DISTINCT
        ipid,
        SubNetC
    FROM
        apm.IP AS ip (NOLOCK)
        JOIN APM.GetMultiParameters(CASE WHEN LEN(@INCLUDESUBNET) &gt; 0 THEN @INCLUDESUBNET ELSE N'%' END, N'') AS p1 ON (ip.SubnetC LIKE p1.Value)
        LEFT OUTER JOIN APM.GetMultiParameters(CASE WHEN LEN(@EXCLUDESUBNET) &gt; 0 THEN @EXCLUDESUBNET ELSE N'Fake' END, N'') AS p2 ON (ip.SubnetC LIKE p2.Value)
    WHERE
    --Exclude subnets which have correspondance in @EXCLUDESUBNET parameter
        p2.typeId IS NULL
        
    DECLARE @LASTPERIODSTARTDATE DateTime
    SET @LASTPERIODSTARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    DECLARE @CURRENTPERIODENDDATE DateTime
    SET @CURRENTPERIODENDDATE = DATEADD(d, APM.GetQueryDateCount(@PERIOD, @STARTDATE), @STARTDATE)
    SELECT TOP(10)
        ROW_NUMBER() OVER (ORDER BY COUNT(e.CSEventId) DESC, eg.description) AS Id,
        COUNT(e.CSEventId) as EventCount,
        eg.Description,
        e.ClassType,
        SUM(COUNT(e.CSEventId)) OVER() AS TotalEventCount,
        COUNT(*) OVER() AS TotalNewProblemsCount
    FROM
        apm.CSEVENT AS e (NOLOCK)
        JOIN apm.CSEVENTGROUP AS eg ON e.CSEventGroupId = eg.CSEventGroupId
        -- Fileter events by machines
        JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f ON f.MACHINEID = e.machineid
        JOIN #SUBNETCFILTERTABLE AS f1 ON e.ipid = f1.IPID        
    WHERE 
        ((e.ClassType = N'Performance' AND e.TotalTime/1000.0 &gt;= @THRESHOLD) 
            OR e.ClassType = N'exception')
        AND e.utcdate &gt;= @STARTDATE
        AND e.utcdate &lt; @ENDDATE 
        AND e.SourceId = @SOURCEID
        AND eg.SourceId = @SOURCEID
        AND eg.firsteventdate &gt;= @STARTDATE
        AND eg.firsteventdate &lt; @ENDDATE
        AND e.PMStatus = 0   
        AND e.PageUri IS NOT NULL
    GROUP BY
        eg.Description,
        e.ClassType
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientNewFailure'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientNewFailure AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientNewFailure                                                      */
/* USED IN: Application Status Client Report, top 10 new exception events              */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                     */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE [APM].[ApplicationStatusClientNewFailure]
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID INT
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
        SELECT TOP(10)
            ROW_NUMBER() OVER (ORDER BY COUNT(e.eventid) DESC, e.description) AS Id,
            e.description,
            e.category,
            COUNT(e.eventid) as EventsCount,
            SUM(COUNT(e.eventid)) OVER() AS TotalEventCount,
            COUNT(*) OVER() AS TotalNewProblemsCount
        FROM
            apm.Event (NOLOCK) AS e
            JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f ON f.MACHINEID = e.machineid
            JOIN apm.eventgroup (NOLOCK) AS eg ON e.eventGroupId = eg.EventGroupId
        WHERE 
            e.EventClassType = N'Exception'
            AND e.SourceId = @SOURCEID
            AND eg.SourceId = @SOURCEID
            AND (e.category LIKE @PROBLEM)
            AND e.utceventdate &gt;= @STARTDATE
            AND e.utceventdate &lt; @ENDDATE
            AND eg.firsteventdate &gt;= @STARTDATE
            AND eg.firsteventdate &lt; @ENDDATE
            AND e.PMStatus = 0
        GROUP BY 
            e.description, e.category
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.ApplicationStatusClientNewPerformance'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.ApplicationStatusClientNewPerformance AS RETURN 1')
  END
GO
/****************************************************************************************/
/* OBJECT: Stored Procedure                                                             */
/* NAME: ApplicationStatusClientNewPerformance                                                      */
/* USED IN: Application Status Client Report, top 10 New performance events             */
/* INPUT PARAMETERS:                                                                    */
/*      @SOURCEID       - Source id                                                     */
/*      @COMPUTERIDS    - List of the computer id, separated by comma. Exp: '1,2,3'     */
/*      @ENDDATE        - End date of the period (in Client timezone)                   */
/*      @PERIOD         - Period type(Day, Week or Month).                              */  
/*                      - Use for the Start Date calculate of the period                */
/*      @TRESHOLD       - Event duration treshold                                       */
/*      @PROBLEM        - Event problem type (all, critical)                            */
/*      @TIMEZONE       - correlate parameter (timezone by min) to return result        */
/*                          in clien timezone                                           */
/****************************************************************************************/
alter PROCEDURE [APM].[ApplicationStatusClientNewPerformance]
    @SOURCEID INT,
    @COMPUTERS NVARCHAR(MAX),
    @ENDDATE DATETIME,
    @PERIOD INT,
    @THRESHOLD DECIMAL(35,0),
    @PROBLEM NVARCHAR(10),
    @TIMEZONE INT
WITH RECOMPILE
AS
BEGIN
    SET NOCOUNT ON;
    SET @ENDDATE = DATEADD(minute, -@TIMEZONE, @ENDDATE) 
    DECLARE @STARTDATE DATETIME
    SET @STARTDATE = DATEADD(d, -APM.GetQueryDateCount(@PERIOD, @ENDDATE), @ENDDATE)
    CREATE TABLE #APPLICATIONSTATUSCLIENT_MACHINE
    (
        MACHINEID INT
    )
    INSERT 
        INTO #APPLICATIONSTATUSCLIENT_MACHINE
            SELECT 
                    p.value
                FROM APM.GetMultiParameters(@COMPUTERS, N'') p
;WITH BaseDatSet AS
(
    SELECT 
        COUNT(e.eventid) as IssuesCount,
        AVG(e.eventduration / 1000000) AS AvgDuration,
        MAX(e.eventduration / 1000000) AS MaxDuration,
        e.rootnodename,
        (CASE 
                WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                ELSE N''
        END) AS PerfNodeDescription
    FROM
        APM.Event (nolock) AS e
        JOIN #APPLICATIONSTATUSCLIENT_MACHINE AS f ON f.MACHINEID = e.machineid
        JOIN APM.PerformanceNode (NOLOCK) AS pn ON pn.EventId = e.EventId
        JOIN APM.eventgroup (NOLOCK) AS eg ON E.EventGroupId = eg.EventGroupId
    WHERE 
        e.EventClassType = N'Performance' AND e.eventduration / 1000000.0  &gt;= @THRESHOLD  
        AND (e.category LIKE @PROBLEM OR e.category IS NULL)
        AND e.utceventdate &gt;= @STARTDATE
        AND e.utceventdate &lt; @ENDDATE 
        AND e.SourceId = @SOURCEID 
        AND eg.SourceId = @SOURCEID
        AND eg.firsteventdate &gt;= @STARTDATE
        AND eg.firsteventdate &lt; @ENDDATE 
        AND pn.IsHeaviestNode = 1        
        AND e.PMStatus = 0
    GROUP BY 
        e.rootnodename,
        (CASE 
                WHEN pn.description IS NOT NULL THEN RIGHT(pn.description, LEN(pn.description) - CHARINDEX(':', pn.description))
                ELSE N''
        END)
)
    SELECT TOP(10)
        ROW_NUMBER() OVER (ORDER BY e.IssuesCount DESC, e.rootnodename, e.PerfNodeDescription) AS Id,
        e.IssuesCount,
        e.AvgDuration,
        e.MaxDuration,
        e.rootnodename, 
        e.PerfNodeDescription,
        e.rootnodename + (CASE 
                            WHEN LEN(e.PerfNodeDescription) &gt; 0 
                            THEN ' slow at ' +  e.PerfNodeDescription 
                        ELSE N'' END) AS description,       
        SUM(IssuesCount) OVER() AS EventsSum,
        COUNT(*) OVER() AS TotalNewProblemsCount
    FROM
        BaseDatSet AS e
    ORDER BY
        IssuesCount DESC
END
GO
-------------------- Rule management --------------------------------
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_EMPTY'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_EMPTY
				AS				
				select clmn=1')
END
GO
alter VIEW [APM].[V_PM_EMPTY] AS
   SELECT N'' AS VAL , -1 AS PMSTATUS, -1 AS SEVIEWERDBID, -1 AS EVENTID
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_CSEVENTSTATUS'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_CSEVENTSTATUS
				AS				
				select clmn=1')
END
GO
alter VIEW [APM].[V_PM_CSEVENTSTATUS] AS
   SELECT E.CSEVENTID AS EVENTID, E.PMSTATUS, E.ROWGUID, E.SEVIEWERDBID  
	FROM APM.CSEVENT AS E (NOLOCK)
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_HEAVIESTNODE'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_HEAVIESTNODE
				AS				
				select clmn=1')
END
GO
alter VIEW [APM].[V_PM_HEAVIESTNODE] AS
SELECT 
  E.EVENTID, 
  E.PMSTATUS, 
  E.SEVIEWERDBID,
  COALESCE(P.DESCRIPTION, N'Internal Execution') AS VAL, 
  COALESCE(P.SELFDURATION, E.EVENTDURATION / 1000.0) AS SELFDURATION  
FROM 
  APM.EVENT (NOLOCK) AS e
  LEFT JOIN APM.PERFORMANCENODE (NOLOCK) p ON p.eventid = e.eventid 
WHERE   
  p.ISHEAVIESTNODE = 1      
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_CSHEAVIESTNODE'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_CSHEAVIESTNODE
				AS				
				select clmn=1')
END
GO 
alter VIEW [APM].[V_PM_CSHEAVIESTNODE] AS
SELECT 
   E.CSEVENTID AS EVENTID, 
   E.PMSTATUS, 
   E.SEVIEWERDBID,
   COALESCE(P.NAME, N'Internal Execution') AS VAL, 
   P.DURATION AS SELFDURATION
FROM 
  APM.CSEVENT (NOLOCK) AS e
  LEFT JOIN APM.CSHEAVIESTRESOURCE (NOLOCK) p ON p.cseventid = e.cseventid 
WHERE   
  p.ISHEAVIESTNODE = 1      
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_EVENT'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_EVENT
				AS				
				select clmn=1')
END
GO 
alter VIEW APM.V_PM_EVENT AS
SELECT 
    E.EVENTID, 
    S.SOURCE, 
    M.MACHINE AS MACHINENAME, 
    U.NAME AS USERNAME, 
        E.EVENTCLASSTYPE, 
    E.ROOTNODENAME, 
    E.DESCRIPTION, 
    E.EXCEPTIONCLASS, 
    E.EVENTDURATION,
        E.SEVIEWEREGID, 
    E.HEAVYLIGHT, 
    E.ASPECT, 
    E.SEVIEWERDBID,
    E.ROWGUID,
    E.CATEGORY, 
    E.PMSTATUS 
 FROM APM.EVENT (NOLOCK) AS E
   JOIN apm.SOURCE S (NOLOCK) ON S.SOURCEID = E.SOURCEID 
   JOIN apm.MACHINE M (NOLOCK) ON M.MACHINEID = E.MACHINEID       
   LEFT JOIN apm.USERS U (NOLOCK) ON U.USERID = E.USERID
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_EVENTDETAIL'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_EVENTDETAIL
				AS				
				select clmn=1')
END
GO 
alter VIEW [APM].[V_PM_EVENTDETAIL] AS
SELECT E.EVENTID, E.PMSTATUS, E.SEVIEWERDBID, D.VALUE, D.NAME 
    FROM APM.EVENT (NOLOCK) AS e
        JOIN APM.EVENTDETAIL (NOLOCK) d ON d.eventid = e.eventid  
    WHERE
       d.ValueType = N'PM'
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_CSEVENTDETAIL'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_CSEVENTDETAIL
				AS				
				select clmn=1')
END
GO 
alter VIEW [APM].[V_PM_CSEVENTDETAIL] AS
SELECT E.CSEVENTID AS EVENTID, E.PMSTATUS, E.SEVIEWERDBID, D.VALUE, D.NAME 
    FROM APM.CSEVENT (NOLOCK) AS e
        JOIN APM.CSEVENTDETAIL (NOLOCK) d ON d.cseventid = e.cseventid  
    WHERE
       d.ValueType = N'PM'
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_RESOURCE'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_RESOURCE
				AS				
				select clmn=1')
END
GO 
  
alter VIEW [APM].[V_PM_RESOURCE] AS
SELECT P.EVENTID, E.SEVIEWERDBID, E.PMSTATUS, P.RESOURCEMETHOD 
    FROM APM.PERFORMANCENODE p (NOLOCK)
    JOIN apm.EVENT e (NOLOCK) ON e.eventid = p.eventid 
WHERE
    p.ISHEAVIESTNODE = 1
UNION ALL   
SELECT E.EVENTID, E.SEVIEWERDBID, E.PMSTATUS, EX.RESOURCEMETHOD 
    FROM APM.EXCEPTIONNODE ex (NOLOCK)
    JOIN apm.EVENT e (NOLOCK) ON e.eventid = EX.eventid 
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.V_PM_CSEVENT'), 'IsView') IS NULL) BEGIN
    EXECUTE('CREATE VIEW APM.V_PM_CSEVENT
				AS				
				select clmn=1')
END
GO 
    
alter VIEW APM.V_PM_CSEVENT AS
SELECT 
    E.CSEVENTID AS EVENTID, 
    S.SOURCE, 
    M.MACHINE AS MACHINENAME,
    U.NAME AS USERNAME,
    E.CLASSTYPE AS EVENTCLASSTYPE, 
    E.DESCRIPTION AS [DESCRIPTION],
    E.TOTALTIME * 1000 AS EVENTDURATION,
    SEVIEWEREGID AS EVENTGROUPID, 
    E.SEVIEWERDBID, 
    2 AS HEAVYLIGHT,
    CASE 
        WHEN CLASSTYPE = N'exception' THEN N'Web Page Client Side Exception'
    END AS EXCEPTIONCLASS,
    N'Unknown' AS COMPONENT, 
    CASE 
        WHEN CLASSTYPE = N'performance' THEN N'performance' 
        WHEN CLASSTYPE = N'exception' THEN N'applicationfailure'
    END AS ASPECT,
    E.ROWGUID,
    PMSTATUS,
    SEVIEWEREGID     
  FROM APM.CSEVENT (NOLOCK) AS E
    JOIN apm.SOURCE S (NOLOCK) ON S.SOURCEID = E.SOURCEID 
    JOIN apm.MACHINE M (NOLOCK) ON M.MACHINEID = E.MACHINEID      
    LEFT JOIN apm.USERS U (NOLOCK) ON U.USERID = E.USERID
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMACTIONQUERY'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMACTIONQUERY AS RETURN 1')
  END
GO
    
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMACTIONQUERY																				  */
/* INPUT PARAMETERS:																				  */
/*      @RULEDESCRIPTION       - rule description													  */
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/*      @LASTPARAMETERINDEX    - last parameter index												  */  
/* OUTPUT PARAMETERS:																				  */
/*      @QUERY_CURSOR          - result cursor														  */
/* DESCRIPTION:																						  */
/* It processed actions and create action parameter description that will be used					  */
/* during call sp_execute. Also database id parameter has been added into the output				  */
/* result cursor @QUERY_CURSOR will be contains paramaters description								  */
/* --------------|------------|-----------------------------------|------------------|-------------|  */
/*  parameter    | field name | action &amp; db paramater descriptions| parameter values | entity name |  */
/* --------------|------------|-----------------------------------|------------------|-------------|  */
/* For example, rule description has following structure:											  */			
/*  &lt;actions&gt;																						  */	
/*    &lt;action alias="EVENT.PMSTATUS" action="Intercept.ActionType.ChangeStatus"&gt;                      */
/*      &lt;params&gt;                                                                                      */
/*        &lt;param name="value" value="3" /&gt;                                                            */
/*      &lt;/params&gt;                                                                                     */
/*    &lt;/action&gt;                                                                                       */
/*  &lt;/actions&gt;                                                                                        */
/*  Output for this action will be following ( @LASTPARAMETERINDEX = 2, @DBID = 1, @CLIENT = 0        */
/* --------------|------------|-----------------------------------|------------------|-------------|  */
/*  @A3          | PMSTATUS   | @A3 tinyint,@DBID int			  | 3,1              | EVENT       |  */
/* --------------|------------|-----------------------------------|------------------|-------------|  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMACTIONQUERY]
  @RULEDESCRIPTION as NVARCHAR(max)
 ,@CLIENT bit
 ,@DBID int
 ,@LASTPARAMETERINDEX int = 0
 ,@QUERY_CURSOR CURSOR VARYING OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)
    SET @ERRORIND = 0
    BEGIN TRY
    
    DECLARE 
        @RULE AS XML
        
    --convert rule description to untyped xml    
    SET @RULE = CAST(@RULEDESCRIPTION AS XML) 
        
    --declare result query    
    DECLARE
        @QUERYSET TABLE 
        (
           entity SYSNAME -- entity name (stored procedure or table/view)
          ,actionParameter nvarchar(50) -- action parameter name corresponding action field
          ,actionField nvarchar(50) -- action field (now "pmstatus")
          ,params NVARCHAR(MAX) -- list of parameter names  (action parameter + database id parameter) 
          ,paramsValues NVARCHAR(MAX) -- parameter values corresponding list of parameter names
          ,lastParameterIndex int -- last index parameter, for stored procedure is always zero
          ,procParameterList NVARCHAR(max) -- list of stored proc parameter names       
        )   
    --------------- actions query ------------   
    DECLARE 
       actions_cursor CURSOR STATIC FOR
          SELECT actions._action.query('.')
               FROM @RULE.nodes('rule/actions/action') actions(_action)
    DECLARE           
       @ACTION AS XML           
        
    OPEN actions_cursor
    FETCH NEXT FROM actions_cursor 
    INTO @ACTION
    -------------- cycle by actions --------------
    WHILE @@FETCH_STATUS = 0
    BEGIN  
      DECLARE 
         @ALIAS nvarchar(50)
      
      -- Get alias name that using for extract entity name
      SELECT @ALIAS = @ACTION.value('(/action/@alias)[1]', 'nvarchar(50)') 
      
      DECLARE 
         @ENTITY nvarchar(50) -- entity name
        ,@FIELD nvarchar(50)  -- field name    
        ,@FIELDTYPE nvarchar(50) -- field type
             
      DECLARE 
        @PARAMS NVARCHAR(MAX) -- list of parameter names
       ,@PARAMSVALUES NVARCHAR(MAX) -- list of parameter values
       ,@CHARCONDITIONFLAG bit -- char condition flag
       ,@PROCPARAMETERLIST NVARCHAR(max) --reserved (parameter name list for call stored procedure) 
       ,@ISPROCEDURE bit --entity is procedure. 0 - not procedure 1 - procedure
       ,@VALUES_CURSOR CURSOR -- cursor for extracting parameter and corresponding values 
      
      -- lookup for field, field type, entity name, procedure flag   
      SELECT 
         @FIELD = field
        ,@FIELDTYPE = fieldType
        ,@ENTITY = entity
        ,@ISPROCEDURE = isprocedure
      FROM 
         APM.PMENTITYMAPPING (NOLOCK) 
      WHERE 
         alias = @ALIAS AND isclient = @CLIENT
         
      IF @@ROWCOUNT = 0 
      BEGIN
        -- alias is not found. raise error
        RAISERROR(N'Alias "%s" is not registered', 16, 1, @ALIAS)
        RETURN  
      END             
      -- clear previos parameter list and check field type.
      SELECT             
           @PARAMS = N''
          ,@PARAMSVALUES = N''  
          --flag char character field(1- char field 0- not char field)
          ,@CHARCONDITIONFLAG = CASE WHEN CHARINDEX(N'char', @FIELDTYPE) &gt; 0 THEN 1 ELSE 0 END  
          
      -- initialize parameter list    
      SELECT 
         @LASTPARAMETERINDEX = CASE WHEN @ISPROCEDURE = 1 THEN 0 ELSE lastParameterIndex END --last prameter index
        ,@PARAMS = N''
        ,@PARAMSVALUES = N'' 
      FROM 
        @QUERYSET
      WHERE
        entity = @ENTITY              
                    
      --------------- values query ------------
      
      --iteration by parameter. Get parameter name and value
      SET @VALUES_CURSOR = CURSOR STATIC FOR
          SELECT 
             valueSet.value.value('(@value)[1]', 'nvarchar(max)'), -- parameter value
             valueSet.value.value('(@name)[1]', 'nvarchar(max)') -- parameter name
          FROM 
             @ACTION.nodes('/action/params/param') valueSet(value) 
      
      -- open cursor         
      OPEN @VALUES_CURSOR
      
      DECLARE
        @VALUE NVARCHAR(MAX) -- parameter value
       ,@NAME nvarchar(max) -- parameter name
       ,@DECORATOR nvarchar(1) -- decorator for value 
          
      SELECT 
        @PROCPARAMETERLIST = N'' -- clear proc parameter list
       ,@DECORATOR = CASE WHEN @CHARCONDITIONFLAG = 1 THEN '''' ELSE '' END -- define value decorator (for example 'value' or value)
      
      -- fetch parameter name and value
      FETCH NEXT FROM @VALUES_CURSOR 
         INTO @VALUE, @NAME
         
      ---------- cycle by values --------       
      WHILE @@FETCH_STATUS = 0
      BEGIN
        -- increment last parameter index
        SELECT @LASTPARAMETERINDEX = @LASTPARAMETERINDEX + 1
        
        DECLARE 
            @PARAMETERNAME nvarchar(MAX) 
           ,@PARAMETERVALUE nvarchar(max)
        
        SELECT
           -- for procedure parameter name equal @NAME otherwise using format "@A{last parameter index}"
           @PARAMETERNAME = 
            CASE
              WHEN @ISPROCEDURE = 1 
                THEN REPLACE(N'@{0}', N'{0}', @NAME)
                ELSE REPLACE(N'@A{0}', N'{0}', @LASTPARAMETERINDEX)
            END  
          -- create proc parameter list    
          IF @ISPROCEDURE = 1
          BEGIN
            -- parameter list divided by ','
            SELECT @PROCPARAMETERLIST = @PROCPARAMETERLIST + 
                        REPLACE(REPLACE(N'{0}{1}',
                                     N'{0}',CASE WHEN LEN(@PROCPARAMETERLIST) &gt; 0 THEN N',' ELSE '' END),
                                     N'{1}',@PARAMETERNAME)
            -- calculate parameter type                                      
            SELECT @FIELDTYPE = APM.GetProcParameterTypeName(@ENTITY, @PARAMETERNAME)
            IF @FIELDTYPE IS NULL
            BEGIN
              -- parameter type is not divided, raise exception
              RAISERROR(N'Parameter "%s" for stored procedure "%s" is not defined.', 16, 1, @PARAMETERNAME, @ENTITY)
              RETURN        
            END
            -- define char condition flag
            SELECT @CHARCONDITIONFLAG = CASE WHEN CHARINDEX(N'char', @FIELDTYPE) &gt; 0 THEN 1 ELSE 0 END
            -- define value decorator (for example 'value' or value)
            SELECT @DECORATOR = CASE WHEN @CHARCONDITIONFLAG = 1 THEN '''' ELSE '' END  
          END
          --create parameter value using decorator
          SELECT @PARAMETERVALUE = REPLACE(REPLACE(REPLACE(
                                      N'{0}{1}{2}', 
                                      N'{0}',@DECORATOR),
                                      N'{1}',@VALUE),
                                      N'{2}',@DECORATOR)    
        SELECT
           -- create parameter list for table/view entity divided by ',' (format - "parameter name parameter type")                                 
           @PARAMS = @PARAMS + REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(max),
                                      N'{0}{1} {2}'), 
                                      N'{0}',CASE WHEN LEN(@PARAMS) &gt; 0 THEN N',' ELSE N'' END), 
                                      N'{1}',@PARAMETERNAME),
                                      N'{2}',@FIELDTYPE)    
          -- param value list divided by ','                                         
          ,@PARAMSVALUES = @PARAMSVALUES + REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}{1}'), 
                                      N'{0}',CASE WHEN LEN(@PARAMSVALUES) &gt; 0 THEN N',' ELSE N'' END), 
                                      N'{1}',@PARAMETERVALUE)                                     
          
        FETCH NEXT FROM @VALUES_CURSOR 
         INTO @VALUE, @NAME
      END
      CLOSE @VALUES_CURSOR
      DEALLOCATE @VALUES_CURSOR 
      
      --------------- end values query ------------
      
      SELECT
        --- Add database id parameter name ----      
        @PARAMS = @PARAMS + REPLACE(REPLACE(CONVERT(nvarchar(max),N',{0} {1}'), 
                                  N'{0}',N'@DBID'),
                                  N'{1}',N'int')    
                                    
        --- Add database id parameter value ----      
       ,@PARAMSVALUES = @PARAMSVALUES + REPLACE(CONVERT(nvarchar(max),N',{0}'),N'{0}',@DBID)                                           
                          
      -- insert into result set                                                    
      INSERT @QUERYSET (actionField, actionParameter, entity, lastParameterIndex, params, paramsValues, procParameterList)  
         VALUES(@FIELD, @PARAMETERNAME, @ENTITY, @LASTPARAMETERINDEX, @PARAMS, @PARAMSVALUES, @PROCPARAMETERLIST)       
      
      --- Get next expression ----------
      FETCH NEXT FROM actions_cursor 
      INTO @ACTION
    END 
    CLOSE actions_cursor
    DEALLOCATE actions_cursor   
    -- create result cursor for action parameter, action field, parameter list, parameter values
    SET @QUERY_CURSOR = CURSOR STATIC FORWARD_ONLY FOR
         SELECT
             actionParameter
            ,actionField
            ,params
            ,paramsValues
            ,entity
         FROM 
            @QUERYSET   
            
    OPEN @QUERY_CURSOR
    
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN                 
       IF CURSOR_STATUS('global', 'actions_cursor') IN (0,1)
          CLOSE actions_cursor
       IF CURSOR_STATUS('global', 'actions_cursor') = -1
          DEALLOCATE actions_cursor 
                  
       DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
       SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        
       RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMEXPRESSIONQUERY'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMEXPRESSIONQUERY AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMEXPRESSIONQUERY																			  */
/* INPUT PARAMETERS:																				  */
/*      @RULEDESCRIPTION       - rule description													  */
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/* OUTPUT PARAMETERS:																				  */
/*      @QUERY_CURSOR          - result cursor														  */
/* DESCRIPTION:																						  */
/* It processed expressions and create for each entity "where" sql conditions using list of parameters*/
/* Sql condition also contains action and database id parameters.									  */
/* If entity is stored procedure then will be create only proc parameter list.						  */
/* For entity "V_PM_EVENTDETAIL" the column "fieldType" of table PMENTITYMAPPING contains value that  */
/* will be used for additional  sql condition {Name = {value}}.( See example below for expression     */
/* &lt;expression alias="EVENT.COMPONENT"&gt;)															  */
/* Result cursor will be contains next fields														  */
/* --------|---------------|------------|------------------|----------------------|-----------------  */
/*  entity | sql condition | parameters | parameter values | last parameter index | proc parameters   */
/* --------|---------------|------------|------------------|----------------------|-----------------  */
/* For example, rule description has following structure:											  */			
/*&lt;rule name="Event Type" id="1" dbid="7D7A57B2-32C8-4520-9DA8-1A771BBCC7C8"&gt;						  */
/*  &lt;expressions&gt;																					  */
/*    &lt;expression alias="EVENT.EVENTCLASSTYPE" variable="Intercept.Variable.EventClassType"&gt;		  */
/*      &lt;params&gt;																					  */
/*        &lt;param name="operation" value="IN" /&gt;														  */
/*        &lt;param name="value" value="performance" /&gt;												  */
/*      &lt;/params&gt;																					  */
/*    &lt;/expression&gt;																		              */
/*    &lt;expression alias="EVENT.SOURCE" variable="Intercept.Variable.Source"&gt;						  */
/*      &lt;params&gt;																					  */
/*        &lt;param name="operation" value="IN" /&gt;														  */
/*        &lt;param name="value" value="Duwamish7" /&gt;                                                    */
/*        &lt;param name="value" value="Default Web Site/WebService1" /&gt;                                 */
/*      &lt;/params&gt;                                                                                     */
/*    &lt;/expression&gt;																					  */
/*    &lt;expression alias="EVENT.COMPONENT" variable="Intercept.Variable.EventClassType"&gt;               */
/*      &lt;params&gt;                                                                                      */
/*        &lt;param name="operation" value="IN" /&gt;                                                       */
/*        &lt;param name="value" value="performance" /&gt;                                                  */
/*      &lt;/params&gt;                                                                                     */
/*    &lt;/expression&gt;																					  */
/*  &lt;/expressions&gt;																					  */
/*  &lt;actions&gt;																						  */
/*    &lt;action alias="EVENT.PMSTATUS" action="Intercept.ActionType.ChangeStatus"&gt;					  */
/*      &lt;params&gt;																					  */
/*        &lt;param name="value" value="0" /&gt;															  */
/*      &lt;/params&gt;																					  */
/*    &lt;/action&gt;																						  */
/*  &lt;/actions&gt;																						  */
/*&lt;/rule&gt;																							  */
/*  Output for this rule will be following ( @CLIENT = 0, @DBID = 1)								  */
/*  Note: action parameter value and database identifier are not included in parameter value list     */
/* -----------|-------------------------|------------------|-------------------------------|-|--|     */
/* V_PM_EVENT |(EVENTCLASSTYPE like @P1 | @P1 nvarchar(50) |'performance',				   |3|	|	  */	
/*			  |					   	    |,@P2 nvarchar(255)|'Default Web Site/WebService1',| |  |     */
/*            |    ESCAPE N''~''  ) AND |,@P3 nvarchar(255)|'Duwamish7'					   | |	|	  */
/*            |   (SOURCE like @P2	    |				   |							   | |	|     */
/*            |    ESCAPE N''~'' OR		|				   |							   | |	|     */
/*            |    SOURCE like @P3		|				   |	 						   | |	|	  */
/*            |    ESCAPE N''~'') AND   |				   |							   | |	|	  */
/*			  |   (PMSTATUS != @A1 AND  |				   |							   | |	|     */
/*			  |	  SEVIEWERDBID = @DBID)	|				   |						       | |	|	  */
/*			  |							|				   |						       | |	|     */
/* -----------|-------------------------|------------------|-------------------------------|-|--|     */
/* V_PM_EVENT |(VALUE like @P4			|@P4 nvarchar(255) |'performance','COMPONENT'      |5|	|	  */
/*	DETAIL	  |	    ESCAPE N''~''  ) AND|@P5 nvarchar(50)  |							   | |	|	  */
/*			  |  NAME=@P5 AND           |			       |							   | |	|	  */
/*			  |  ( PMSTATUS != @A1 AND  |				   |							   | |	|	  */
/*			  |    SEVIEWERDBID = @DBID |				   |							   | |	|	  */
/*			  |  )                      |				   |							   | |	|	  */
/*            |                         |			       |							   | |	|	  */
/*************|****************************************************************************************/
alter PROCEDURE [APM].[PMEXPRESSIONQUERY]
  @RULEDESCRIPTION as NVARCHAR(max)
 ,@CLIENT bit
 ,@DBID int
 ,@QUERY_CURSOR CURSOR VARYING OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
        
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)
    SET @ERRORIND = 0
    BEGIN TRY
    
    DECLARE 
        @RULE AS XML
       ,@EVENTDETAILENTITY sysname  
       ,@CSEVENTDETAILENTITY sysname    
        
    SELECT 
        -- convert rule to untyped xml
        @RULE = CAST(@RULEDESCRIPTION AS XML)
        -- server entity name that need processed separate
       ,@EVENTDETAILENTITY = N'V_PM_EVENTDETAIL'  
        -- client entity name that need processed separate
       ,@CSEVENTDETAILENTITY = N'V_PM_CSEVENTDETAIL'
    
    -- Result Set
    DECLARE
      @QUERYSET TABLE 
      (
        id int IDENTITY (1,1) -- identity . Unique identifier
       ,entity SYSNAME -- entity name. For eventdetail entity can be several row with the same entity name. 
       ,condition NVARCHAR(MAX) -- sql condition that will be used for 'where' clause
       ,params NVARCHAR(MAX) -- parameter list that will be used for 'where' clause
       ,paramsValues NVARCHAR(MAX) --parameter value list that will be used for 'where' clause
       ,lastParameterIndex int -- last parameter index that used for paramater list
       ,procParameterList NVARCHAR(max) -- proc parameters if entity is stored proc. Reserved.
      )   
      --------------- expressions query ------------    
      DECLARE 
         expressions_cursor CURSOR STATIC FOR
            SELECT expressions.expression.query('.') AS expr
               FROM @RULE.nodes('rule/expressions/expression') expressions(expression)
      DECLARE           
       @EXPRESSION AS XML           
        
      OPEN expressions_cursor
      FETCH NEXT FROM expressions_cursor INTO @EXPRESSION
      
      DECLARE
         @LASTPARAMETERINDEX int
   
      SELECT @LASTPARAMETERINDEX = 0
      -------------- cycle by expressions --------------
      WHILE @@FETCH_STATUS = 0
      BEGIN  
        DECLARE 
            @ALIAS nvarchar(50)
  
        -- Get alias name
        SELECT @ALIAS = @EXPRESSION.value('(/expression/@alias)[1]', 'nvarchar(50)') 
  
        DECLARE 
          @ENTITY nvarchar(50) -- entity name
         ,@FIELD nvarchar(50) -- field name that used in condition        
         ,@OPERATION NVARCHAR(50) -- operation
         ,@FIELDTYPE nvarchar(50) -- field type
         ,@NOTEXPRESSION bit -- expression contains 'not' ( 0 - not contains 1 - contains)
         ,@ISPROCEDURE bit -- entity is procedure ( 0 - table/view 1-procedure)
    
         -- Get operation  
         SELECT 
           @OPERATION = @EXPRESSION.value('(/expression/params/param[@name=''operation'']/@value)[1]', 'nvarchar(50)')   
         SELECT 
           -- expression contains "not" clause (1-contains, 0-not contains) 
           @NOTEXPRESSION = CASE WHEN CHARINDEX(N'not', @OPERATION) &gt; 0 THEN 1 ELSE 0 END
           -- operation
          ,@OPERATION = REPLACE(@OPERATION, N'not', N'')     
     
         DECLARE 
           @CONDITION NVARCHAR(MAX) -- sql condition
          ,@PARAMS NVARCHAR(MAX) -- parameter list divided by ','
          ,@PARAMSVALUES NVARCHAR(MAX) -- param value list divided by ','
          ,@PARAMTYPE sysname -- parameter type
          ,@CHARCONDITIONFLAG bit -- flag char character field(1- char field 0- not char field) 
          ,@PREFIX nvarchar(10) -- for "not" expression use "NOT" clause otherwise use empty prefix
          ,@PROCPARAMETERLIST NVARCHAR(max) -- proc parameter list
          ,@VALUES_CURSOR CURSOR -- cursor for extracting parameter and corresponding values 
          -- seach mapping for alias     
          SELECT 
             --use 'rowguid' instead 'eventid' field 
             @FIELD = CASE field WHEN N'EVENTID' THEN N'ROWGUID' ELSE field END
             --user nvarchar(50) for rowguid field
            ,@FIELDTYPE = CASE field WHEN N'EVENTID' THEN N'nvarchar(50)' ELSE fieldType END
             --entity name 
            ,@ENTITY = entity
            --stored proc flag
            ,@ISPROCEDURE = isprocedure
          FROM 
             APM.PMENTITYMAPPING (NOLOCK) 
          WHERE 
             alias = @ALIAS AND isclient = @CLIENT
          IF @@ROWCOUNT = 0
          BEGIN
            -- mapping for alias not found, raise exception
            RAISERROR(N'Alias "%s" is not registered', 16, 1, @ALIAS)
            RETURN  
          END    
          
          -- initialize 
          SELECT  @CONDITION = N''
                 ,@PARAMS = N''
                 ,@PARAMSVALUES = N'' 
                 -- use always char condition for eventdetail table or for 'rowguid' field  
                 ,@CHARCONDITIONFLAG = 
                    CASE 
                      WHEN (CHARINDEX(N'char', @FIELDTYPE) &gt; 0) OR (@ENTITY = @CSEVENTDETAILENTITY) OR
                           (@ENTITY = @EVENTDETAILENTITY) OR (@FIELD = N'ROWGUID')
                        THEN 1 
                        ELSE 0 
                    END  
          -- initialize prefix. For not char fields use empty prefix
          SELECT @PREFIX = CASE WHEN @NOTEXPRESSION = 1 AND @CHARCONDITIONFLAG = 1 THEN N'NOT' ELSE N'' END  
          
          -- for not eventdetail entity sql conditions and parameters will be united for the same entity
          -- for eventdetail always use new sql condition and parameters
          IF (@ENTITY != @CSEVENTDETAILENTITY) AND (@ENTITY != @EVENTDETAILENTITY) 
			  SELECT 
				 @CONDITION = CASE WHEN @ISPROCEDURE = 1 THEN N'' ELSE condition END 
				,@PARAMS = CASE WHEN @ISPROCEDURE = 1 THEN N'' ELSE params END 
				,@PARAMSVALUES = CASE WHEN @ISPROCEDURE = 1 THEN N'' ELSE paramsValues END
			  FROM 
				@QUERYSET
			  WHERE
				entity = @ENTITY    
    
          -- begin create sql condition. The first prefix will be added
          SELECT @CONDITION = @CONDITION + 
                CASE WHEN LEN(@CONDITION) &gt; 0 
                    THEN REPLACE(CONVERT(nvarchar(MAX),N' AND {0} ('), N'{0}', @PREFIX) 
                    ELSE REPLACE(CONVERT(nvarchar(MAX),N' {0} ('), N'{0}', @PREFIX) 
                END
        
          --------------- values query ------------
          -- prepare cursor for select parameter names and values
          if @ISPROCEDURE = 1 
             SET @VALUES_CURSOR = CURSOR STATIC FOR
                SELECT valueSet.value.value('(@value)[1]', 'nvarchar(max)'),valueSet.value.value('(@name)[1]', 'nvarchar(max)')
                   FROM @EXPRESSION.nodes('/expression/params/param') valueSet(value)
          ELSE          
             SET @VALUES_CURSOR = CURSOR STATIC FOR    
                SELECT valueSet.value.value('(@value)[1]', 'nvarchar(max)'), N''
                    FROM @EXPRESSION.nodes('/expression/params/param[@name=''value'']') valueSet(value)
             
          -- open values cursor   
          OPEN @VALUES_CURSOR
  
          DECLARE
            @VALUE NVARCHAR(MAX) -- parameter value
           ,@NAME nvarchar(max) -- parameter name
           ,@CHARCONDITION nvarchar(max) -- sql condition for char values
           ,@NUMBERCONDITION nvarchar(max) -- sql condition for non char values 
           ,@DECORATOR nvarchar(1) -- decorator. (Use ''' or empty decorator for values)
           ,@POSTFIX nvarchar(50) -- postfix
      
          -- calculate operation. use "like" operation instead "IN" for "char" field 
          SELECT @OPERATION = CASE WHEN LTRIM(@OPERATION) = N'IN' AND @CHARCONDITIONFLAG = 1 THEN N'like' ELSE @OPERATION END
    
          -- initialize sql conditions and parameters
          SELECT 
            @CHARCONDITION = N'' 
           ,@NUMBERCONDITION = N''
           ,@PROCPARAMETERLIST = N''
           ,@DECORATOR = CASE WHEN @CHARCONDITIONFLAG = 1 THEN '''' ELSE '' END  
           ,@POSTFIX = CASE WHEN CHARINDEX(N'like', @OPERATION) &gt; 0 THEN N' ESCAPE N''''~'''' ' ELSE N'' END                                                                       
  
          FETCH NEXT FROM @VALUES_CURSOR INTO @VALUE, @NAME
     
          ---------- cycle by values --------       
          WHILE @@FETCH_STATUS = 0
          BEGIN
            --increment parameter index
            SELECT @LASTPARAMETERINDEX = @LASTPARAMETERINDEX + 1                        
            
            DECLARE 
                @PARAMETERNAME nvarchar(MAX) -- sql parameter name
               ,@PARAMETERVALUE nvarchar(max) -- parameter value 
               ,@SQ  nvarchar(1) -- char constant 
            
            SELECT
               @PARAMETERNAME = 
                CASE
                  WHEN @ISPROCEDURE = 1 
                    THEN REPLACE(N'@{0}', N'{0}', @NAME)
                    ELSE REPLACE(N'@P{0}', N'{0}', @LASTPARAMETERINDEX)
                END  
              ,@SQ = N''''       
                  
              IF @ISPROCEDURE = 1
              BEGIN
                -- procedure. create parameter list
                SELECT @PROCPARAMETERLIST = @PROCPARAMETERLIST + 
                            REPLACE(REPLACE(N'{0}{1}',
                                         N'{0}',CASE WHEN LEN(@PROCPARAMETERLIST) &gt; 0 THEN N',' ELSE '' END),
                                         N'{1}',@PARAMETERNAME)
				-- get parameter type                                         
                SELECT @FIELDTYPE = APM.GetProcParameterTypeName(@ENTITY, @PARAMETERNAME)                
                IF @FIELDTYPE IS NULL
                BEGIN
                  -- parameter type is not found, raise exception
                  RAISERROR(N'Parameter "%s" for stored procedure "%s" is not defined.', 16, 1, @PARAMETERNAME, @ENTITY)
                  RETURN
                END
                -- setup char condition flag if parameter type is char type
                SELECT @CHARCONDITIONFLAG = CASE WHEN CHARINDEX(N'char', @FIELDTYPE) &gt; 0 THEN 1 ELSE 0 END
                --decorator value
                SELECT @DECORATOR = CASE WHEN @CHARCONDITIONFLAG = 1 THEN '''' ELSE '' END  
              END
              
              -- calcualte parameter value as  decorator + value + decorator
              -- use calculate expression 'dbId-value' as value for 'rowguid' field
              -- for char parameter value use encoding for char '''
              SELECT @PARAMETERVALUE = REPLACE(REPLACE(REPLACE(
                                          N'{0}{1}{2}', 
                                          N'{0}',@DECORATOR),
                                          N'{1}',
                                             CASE @FIELD 
                                                WHEN N'ROWGUID' 
                                                  THEN 
                                                    REPLACE(REPLACE(N'{0}-{1}', 
                                                         N'{0}', @DBID) 
                                                        ,N'{1}', @VALUE) 
                                                  ELSE 
                                                    CASE 
                                                    WHEN @CHARCONDITIONFLAG = 1 
                                                        THEN  replace(@VALUE, @SQ, @SQ + @SQ) 
                                                        ELSE @VALUE 
                                                    END
                                             END     
                                                ),
                                          N'{2}',@DECORATOR)    
                                             
              -- create char sql condition or non char sql condition ([field] operator [parameter]) ('where' clause)
              -- for char condition using 'or' otherwise ','                           
              SELECT 
                   @CHARCONDITION = @CHARCONDITION + REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(MAX),
                                         N' {0} {1} {2} {3} {4}'),
                                         N'{0}',CASE WHEN LEN(@CHARCONDITION) &gt; 0 THEN N' OR ' ELSE N'' END), 
                                         N'{1}',@FIELD),
                                         N'{2}',@OPERATION),
                                         N'{3}',@PARAMETERNAME),
                                         N'{4}',@POSTFIX)
                  ,@NUMBERCONDITION = @NUMBERCONDITION + REPLACE(REPLACE(CONVERT(nvarchar(MAX),
                                         N'{0}{1}'),
                                         N'{0}',CASE WHEN LEN(@NUMBERCONDITION) &gt; 0 THEN N',' ELSE '' END), 
              
                                         N'{1}',@PARAMETERNAME)
              SELECT 
              -- create parameter list ([parameter] [parameter type],[parameter] [parameter type],etc) 
              --use nvarchar(255) for 'eventdetail' entity because field type is not defined for this entity                                        
                  @PARAMS = @PARAMS + REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(MAX),
                                          N'{0}{1} {2}'), 
                                          N'{0}',CASE WHEN LEN(@PARAMS) &gt; 0 THEN N',' ELSE N'' END), 
                                          N'{1}',@PARAMETERNAME),
                                          N'{2}',CASE WHEN @ENTITY=@EVENTDETAILENTITY OR @ENTITY=@CSEVENTDETAILENTITY THEN N'nvarchar(255)' ELSE @FIELDTYPE END)    
                                            
              -- create parameter value list ([parameter value], [parameter value],etc) 
                 ,@PARAMSVALUES = @PARAMSVALUES + REPLACE(REPLACE(CONVERT(nvarchar(MAX),
                                          N'{0}{1}'), 
                                          N'{0}',CASE WHEN LEN(@PARAMSVALUES) &gt; 0 
                                          THEN 
											CASE 
											  WHEN @CHARCONDITIONFLAG = 1 
											    THEN N',N' 
											    ELSE N','
											  END																						 
                                          ELSE 
                                            CASE 
											  WHEN @CHARCONDITIONFLAG = 1 
												THEN N'N' 
												ELSE N'' 
											  END																						 												
                                          END
                                          ), 
                                          N'{1}',@PARAMETERVALUE)                                     
              
            FETCH NEXT FROM @VALUES_CURSOR INTO @VALUE, @NAME
          END
          CLOSE @VALUES_CURSOR
          DEALLOCATE @VALUES_CURSOR 
    
          -- finished create sql condition for non char field
          -- ([field] [NOT] @OPERATION [(number condition)])
          SELECT @NUMBERCONDITION = REPLACE(REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(MAX),
                                        N'{0} {1} {2} ({3})'),
                                        N'{0}', @FIELD),
                                        N'{1}', CASE WHEN @NOTEXPRESSION = 1 THEN N'NOT' ELSE N'' END),
                                        N'{2}', @OPERATION),
                                        N'{3}', @NUMBERCONDITION)
          
          --user numeric or char sql condition or non char condition. it depends on field type
          SELECT @CONDITION = @CONDITION + REPLACE(CONVERT(nvarchar(MAX),N'{0} )'), 
                                        N'{0}', CASE WHEN @CHARCONDITIONFLAG = 1 THEN @CHARCONDITION ELSE @NUMBERCONDITION END)
          --finished processes current expression
          --it is need to joined together the same entity except 'eventdetail' entity and stored proc
          --for each row from @QUERYSET will be create separate query. All these query will be intersected.                            
          IF EXISTS(
            SELECT * FROM @QUERYSET WHERE entity = @ENTITY AND entity != @EVENTDETAILENTITY 
                        AND entity != @CSEVENTDETAILENTITY  
          ) AND (@ISPROCEDURE = 0)
          BEGIN
            UPDATE @QUERYSET
              SET   
               condition = @CONDITION -- sql condition
              ,lastParameterIndex = @LASTPARAMETERINDEX -- last parameter index
              ,params = @PARAMS -- parameter list
              ,paramsValues = @PARAMSVALUES -- parameter value list
            WHERE
              entity = @ENTITY                        
          END         
          ELSE
          BEGIN
             -- additional processing for 'eventdetail' entity
             --The field 'fieldType' of entity mapping table contains filter value 
             --for field 'name' of 'eventdetail' entity. Therefore for this entity sql condition will be shown as 
             -- ['name' = 'fieldType' and 'field' operator 'value']  
             IF @ENTITY = @EVENTDETAILENTITY OR @ENTITY = @CSEVENTDETAILENTITY
             BEGIN
                -- increment last parameter index
                SELECT @LASTPARAMETERINDEX = @LASTPARAMETERINDEX + 1
                --calculate parameter name
                SELECT @PARAMETERNAME = REPLACE(N'@P{0}', N'{0}', @LASTPARAMETERINDEX)
                
                --add additional filter by 'name' field
                SELECT @CONDITION = @CONDITION + 
                        REPLACE(CONVERT(nvarchar(MAX),N' AND NAME={0}'), N'{0}', @PARAMETERNAME)
                --field type is not registered. Use nvarchar(50).        
                SELECT @PARAMS = @PARAMS + 
                        REPLACE(CONVERT(nvarchar(MAX),N',{0} nvarchar(50)'), N'{0}', @PARAMETERNAME)
                -- field type from mapping table contains filter value. It always is char value. Use char decorator.        
                SELECT @PARAMSVALUES = @PARAMSVALUES + 
                        REPLACE(CONVERT(nvarchar(MAX),N',{0}'), N'{0}',QUOTENAME(@FIELDTYPE, ''''))                                     
             END
             -- for 'eventdetail' entity always use new query. 
             INSERT @QUERYSET (entity, condition, lastParameterIndex, params, paramsValues, procParameterList)  
             VALUES(@ENTITY, @CONDITION, @LASTPARAMETERINDEX, @PARAMS, @PARAMSVALUES, @PROCPARAMETERLIST)       
          END                   
          
          --- Get next expression ----
          FETCH NEXT FROM expressions_cursor 
          INTO @EXPRESSION
    END 
    CLOSE expressions_cursor
    DEALLOCATE expressions_cursor
    
    -- It is need to add action filter and seviewer database filter to sql condition for each query
    ---------- added action fields ------
          
      DECLARE 
         @RESULT_CURSOR CURSOR 
        ,@ID int -- unique identifier for current query. It use because entity can be not unique
       
      -- prepare iteration by each query  
      SET @RESULT_CURSOR = CURSOR STATIC FOR
        SELECT id, entity, condition, params, paramsValues FROM @QUERYSET   
        
      OPEN @RESULT_CURSOR
      
      --get current query (unique identifier, entity name, sql condition ('where' clause, parameter list, parameter value list)
      FETCH NEXT FROM @RESULT_CURSOR INTO @ID, @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES 
      
      WHILE @@FETCH_STATUS = 0 
      BEGIN
          
          DECLARE
            @ACTIONPARAMS nvarchar(max) --action parameters
           ,@ACTIONPARAMSVALUES nvarchar(max) --action parameter value
           ,@ACTIONPARAMETER nvarchar(50) --action parameter name 
           ,@ACTIONFIELD nvarchar(50) -- action field
           ,@ACTIONENTITY nvarchar(max) -- action entity
           ,@ACTIONCONDITION nvarchar(MAX) -- action sql condition
           ,@ACTION_CURSOR CURSOR --It is need for several actions
           
          -- prepare condition for adding action filter                                
          SELECT @ACTIONCONDITION = N'', @CONDITION = @CONDITION + CONVERT(nvarchar(MAX),N' AND (') 
          --Get action filters. Now there is one action filter
          EXEC APM.PMActionQuery @RULEDESCRIPTION, @CLIENT, @DBID, 0, @ACTION_CURSOR OUTPUT
          
          FETCH NEXT FROM @ACTION_CURSOR 
             INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES,@ACTIONENTITY
          
          WHILE @@FETCH_STATUS = 0
          BEGIN
            -- create action sql condition ([actionField] != [actionParameter]) 
            --It is need to add filter by seviewer database (SEVIEWERDBID = [seviewer database identifier])
            SELECT 
              @ACTIONCONDITION = @ACTIONCONDITION + 
                        REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(MAX),N' {0} {1} != {2} AND SEVIEWERDBID = @DBID'),
                            N'{0}', CASE WHEN LEN(@ACTIONCONDITION) &gt; 0 THEN N'OR' ELSE N'' END),               
                            N'{1}', @ACTIONFIELD),              
                            N'{2}', @ACTIONPARAMETER)   
                                  
            --Get next action condition. Now it will be return empty row because use only one action                               
            FETCH NEXT FROM @ACTION_CURSOR 
                INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES, @ACTIONENTITY
          END
          CLOSE @ACTION_CURSOR
          DEALLOCATE @ACTION_CURSOR
          
          -- join expression sql condition and action sql condition
          -- Now action parameter value and database identifier are not included in parameter value list
          -- These parameter values (action value and database identifier) will be added to parameter values during execution 
          -- intersect command 
          SELECT @CONDITION = @CONDITION + @ACTIONCONDITION + CONVERT(nvarchar(MAX),N')')        
        
          --update condition for current query by unique identifier
          UPDATE @QUERYSET 
             SET condition = @CONDITION
          WHERE 
            id = @ID  
        
          -- get next query
          FETCH NEXT FROM @RESULT_CURSOR INTO @ID, @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES 
      END
        
      -- create result cursor  
      SET @QUERY_CURSOR = CURSOR STATIC FORWARD_ONLY FOR 
      
      SELECT 
         entity -- entity name
        ,condition -- sql condition
        ,params -- parameter list  
        ,paramsValues -- parameter value list
        ,lastParameterIndex -- last parameter index
        ,procParameterList --proc parameter list
      FROM 
        @QUERYSET    
        
      -- open result query   
      OPEN @QUERY_CURSOR      
          
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN
       IF CURSOR_STATUS('global', 'expressions_cursor') IN (0,1)
          CLOSE expressions_cursor
       IF CURSOR_STATUS('global', 'expressions_cursor') = -1
          DEALLOCATE expressions_cursor     
          
       IF CURSOR_STATUS('variable', '@ACTION_CURSOR') IN (0,1)          
          CLOSE @ACTION_CURSOR
       IF CURSOR_STATUS('variable', '@ACTION_CURSOR') = -1
          DEALLOCATE @ACTION_CURSOR     
          
       IF CURSOR_STATUS('global', 'expressions_cursor') IN (0,1)
          CLOSE result_cursor
       IF CURSOR_STATUS('global', 'expressions_cursor') = -1
          DEALLOCATE result_cursor      
          
        DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
        SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        			
        RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMIntersectExpressionQuery'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMIntersectExpressionQuery AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMIntersectExpressionQuery																	  */
/* INPUT PARAMETERS:																				  */
/*      @RULEDESCRIPTION       - rule description													  */
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/* OUTPUT PARAMETERS:																				  */
/*      @QUERY_CURSOR          - result cursor														  */
/* DESCRIPTION:																						  */
/* It create full sql query for rule. This query intersect all rule expression. Stored procedure are  */
/* not supported. It partial implemented.														      */
/* Result cursor will be contains next fields														  */
/* --------|---------------|------------|------------------|----------------------|-----------------  */
/*  entity | sql query     | parameters | parameter values | last parameter index | proc parameters   */
/* --------|---------------|------------|------------------|----------------------|-----------------  */
/* table/  | parameter     |  parameter | parameter value  |					  |	  	reserved      */
/*   view/ | query         |  name		|   list           |					  |					  */
/*   stored|			   |  parameter |				   |					  |                   */
/*   proc  | 			   |  type      |				   |					  |					  */
/* --------|---------------|------------|------------------|----------------------|-----------------  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMIntersectExpressionQuery]
  @RULEDESCRIPTION nvarchar(max)
 ,@CLIENT bit
 ,@DBID int
 ,@QUERY_CURSOR CURSOR VARYING OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)
    SET @ERRORIND = 0
    BEGIN TRY      
                                                    
    DECLARE
       @ENTITY sysname  -- entity name
      ,@CONDITION nvarchar(MAX) -- current sql condition
      ,@PARAMS nvarchar(MAX) -- parameter list 
      ,@PARAMSVALUES nvarchar(MAX) --parameter value list
      ,@PROCPARAMETERLIST NVARCHAR(MAX) --reserved
      ,@LASTPARAMETERINDEX int -- last parameter index
      ,@QUERY_CUR CURSOR 
    
    -- Get queries that will be intercected    
    EXEC APM.PMExpressionQuery @RULEDESCRIPTION, @CLIENT, @DBID, @QUERY_CUR OUTPUT
    
    --iteration by expression query
    FETCH NEXT FROM @QUERY_CUR INTO 
         @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES, @LASTPARAMETERINDEX, @PROCPARAMETERLIST
         
    DECLARE
       @SQL nvarchar(MAX) -- intersect sql query
      ,@INTERSECTPARAMS nvarchar(MAX) -- sql parameters for intersect query
      ,@INTERSECTPARAMSVALUES nvarchar(MAX) -- intersect parameter values
       
    --initialize intersect variables
    SELECT @SQL = N'', @INTERSECTPARAMS = N'', @INTERSECTPARAMSVALUES = N'' 
    
    WHILE @@FETCH_STATUS = 0
    BEGIN
   
      IF @CONDITION IS NOT NULL 
      BEGIN
        --create intersect sql query using current expression sql query 
        SELECT @SQL = @SQL +  
            REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0} SELECT EVENTID FROM APM.{1} WHERE {2}'),
                     N'{0}', CASE WHEN LEN(@SQL) &gt; 0 THEN N' INTERSECT' ELSE '' END)
                    ,N'{1}', QUOTENAME(@ENTITY))
                    ,N'{2}', @CONDITION)
        --create intercept parameters using current expression sql parameters                     
        SELECT @INTERSECTPARAMS = @INTERSECTPARAMS +
            REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}{1}'),
                     N'{0}', CASE WHEN LEN(@INTERSECTPARAMS) &gt; 0 THEN N',' ELSE '' END)
                    ,N'{1}', @PARAMS)
                        
        --create intersect sql parameter values using current expression parameter values                
        SELECT @INTERSECTPARAMSVALUES = @INTERSECTPARAMSVALUES +  
            REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}{1}'),
                     N'{0}', CASE WHEN LEN(@INTERSECTPARAMSVALUES) &gt; 0 THEN N',' ELSE '' END)
                    ,N'{1}', @PARAMSVALUES)
      END               
      ELSE
      BEGIN
         -- stored proc is used if condition is null, now it is not supported, raise exception   
         RAISERROR (N'The execution of stored procedure is not supported', 16, 1)
         RETURN
      END           
      
      --get next expression query
      FETCH NEXT FROM @QUERY_CUR INTO 
         @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES, @LASTPARAMETERINDEX, @PROCPARAMETERLIST
    END                 
    CLOSE @QUERY_CUR
    DEALLOCATE @QUERY_CUR 
    
    -- intersect query is created. It is need to add action and database id parameters  
    DECLARE
        @ACTIONPARAMS nvarchar(max) -- action parameters including database id parameter.
       ,@ACTIONPARAMSVALUES nvarchar(max) -- action parameter values including database id parameter
       ,@ACTIONPARAMETER nvarchar(50) -- action parameter name. Use only for fetch operation. Don't remove 
                                      -- from fetch expression   
       ,@ACTIONFIELD nvarchar(50) -- action field. Use only for fetch operation. Don't remove 
									-- from fetch expression   
       ,@ACTIONENTITY nvarchar(max) -- action entity. Use only for fetch operation. Don't remove 
									-- from fetch expression   
       ,@ACTION_CURSOR CURSOR -- action query. It is only one record now.
                            
      -- Get action and database id parameters                            
      EXEC APM.PMActionQuery @RULEDESCRIPTION, @CLIENT, @DBID, 0, @ACTION_CURSOR OUTPUT
      
      -- fetch action and database id parameters                            
      FETCH NEXT FROM @ACTION_CURSOR 
         INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES,@ACTIONENTITY
      
      WHILE @@FETCH_STATUS = 0
      BEGIN
        SELECT 
          -- added to intersect parameters 
          @INTERSECTPARAMS = @INTERSECTPARAMS + REPLACE(CONVERT(nvarchar(max),N',{0}'), N'{0}',@ACTIONPARAMS)  
          -- added to intersect parameter values 
         ,@INTERSECTPARAMSVALUES = @INTERSECTPARAMSVALUES + REPLACE(CONVERT(nvarchar(max),N',{0}'), N'{0}',@ACTIONPARAMSVALUES)    
              
      -- fetch next action and database id parameters.                             
        FETCH NEXT FROM @ACTION_CURSOR 
            INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES, @ACTIONENTITY
      END
      CLOSE @ACTION_CURSOR
      DEALLOCATE @ACTION_CURSOR             
         
    --create result sql query       
    DECLARE
      @QUERYSET TABLE 
      (
        entity SYSNAME --view/table or stored proc. reserved
       ,condition NVARCHAR(MAX) --sql query
       ,params NVARCHAR(MAX) -- sql parameter list
       ,paramsValues NVARCHAR(MAX) -- sql parameter values
       ,lastParameterIndex int -- reserved
       ,procParameterList NVARCHAR(max) -- reserved
      )   
    
    INSERT @QUERYSET
           (
            entity, 
            condition, 
            params, 
            paramsValues, 
            lastParameterIndex, 
            procParameterList
           ) 
    SELECT
        @ENTITY --view/table or stored proc. reserved
       ,@SQL --sql query
       ,@INTERSECTPARAMS -- sql parameter list
       ,@INTERSECTPARAMSVALUES -- sql parameter values
       ,@LASTPARAMETERINDEX -- reserved
       ,@PROCPARAMETERLIST -- reserved
       
    --create result cursor   
    SET @QUERY_CURSOR = CURSOR STATIC FOR SELECT * FROM @QUERYSET   
    --open cursor
    OPEN @QUERY_CURSOR
    
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
          @ERRORNUMBER = ERROR_NUMBER()
         ,@ERRORSEVERITY = ERROR_SEVERITY()
         ,@ERRORSTATE = ERROR_STATE()
         ,@ERRORLINE = ERROR_LINE()
         ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
         ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN        
       IF CURSOR_STATUS('variable', '@QUERY_CUR') IN (0,1)
          CLOSE @QUERY_CUR  
       IF CURSOR_STATUS('variable', '@QUERY_CUR') = -1
          DEALLOCATE @QUERY_CUR 
              
       DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
       SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        
       RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMQueryForRule'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMQueryForRule AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMQueryForRule																				  */
/* INPUT PARAMETERS:																				  */
/*      @RULEDESCRIPTION       - rule description													  */
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/*      @CALCULATETOTAL        - calculate total flag (1- it is need to calculate count of records	  */												      
/*														0- it is need to fetch records)				  */												      
/*		@ROWSPERITERATION      - number of records that is need to fetch                              */
/*		@DEBUG				   - 0-trace information will be not print								  */	
/*                                 1-trace information will be print  								  */
/* DESCRIPTION:																						  */
/* Calculate total records or fetch records that will be apply by rule.								  */
/* It is need external temporary tables #QUERYTEXT and #RESULTTABLE for execute.					  */
/* #QUERYTEXT table is used for cache sql query (decrease execution count of xml operations).		  */
/* Total count or records will be inserted into the #RESULT table									  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMQueryForRule]
   @RULEDESCRIPTION nvarchar(max)
  ,@CLIENT bit
  ,@DBID int
  ,@CALCULATETOTAL bit  
  ,@ROWSPERITERATION int
  ,@DEBUG bit = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)
        
    SET @ERRORIND = 0
    BEGIN TRY      
                                                
    DECLARE
       @ENTITY sysname -- entity name or stored proc name
      ,@CONDITION nvarchar(MAX) -- sql query for execution
      ,@PARAMS nvarchar(MAX) -- sql query parameter list
      ,@PARAMSVALUES nvarchar(MAX) -- sql query parameter values
      ,@PROCPARAMETERLIST NVARCHAR(MAX) -- reserved
      ,@LASTPARAMETERINDEX int -- reserved
      ,@QUERY_CUR CURSOR -- query cursor
    DECLARE
       @SQL nvarchar(MAX)
                 
     -- cache is empty ?    
    IF NOT EXISTS(SELECT * FROM #QUERYTEXT WHERE UPDATESQL = 0) 
    BEGIN        
      ---create intersect query that will be execute    
    EXEC APM.PMIntersectExpressionQuery @RULEDESCRIPTION, @CLIENT, @DBID, @QUERY_CUR OUTPUT
    
      -- get intersect query
    FETCH NEXT FROM @QUERY_CUR INTO 
         @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES, @LASTPARAMETERINDEX, @PROCPARAMETERLIST
         
    WHILE @@FETCH_STATUS = 0
    BEGIN
      DECLARE
        @COMMAND nvarchar(MAX)
   
      --stored proc ?
      IF @CONDITION IS NOT NULL  
        -- create sql for extract (calculate total) event id corresponding rule 
        SELECT @COMMAND = 
            REPLACE(REPLACE(CONVERT(nvarchar(max),N'SELECT {0} FROM ({1}) AS A'), 
                     N'{0}', CASE 
                               WHEN @CALCULATETOTAL = 0 THEN REPLACE(N'TOP({0}) A.EVENTID', N'{0}', @ROWSPERITERATION) 
                               ELSE N'COUNT(*)' 
                             END)  
                    ,N'{1}', @CONDITION)
      ELSE  -- stored proc
        SELECT @COMMAND = 
            REPLACE(REPLACE(N'EXEC APM.{0} {1}', 
                    N'{0}', @ENTITY), 
                    N'{1}', @PROCPARAMETERLIST)
      -- create sql for call sp_execute that will execute intersect query           
      SELECT @SQL = REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(max),N'sp_executesql N''{0}'', N''{1}'', {2}'),
                        N'{0}',@COMMAND),
                        N'{1}',@PARAMS),
                        N'{2}',@PARAMSVALUES)
      -- save result query to cache                        
      INSERT #QUERYTEXT(SQLTEXT, UPDATESQL) SELECT @SQL, 0
                        
      IF @DEBUG = 1
      BEGIN                     
        PRINT @SQL                      
      END   
      
      --fetch next intersect query             
      FETCH NEXT FROM @QUERY_CUR INTO 
           @ENTITY, @CONDITION, @PARAMS, @PARAMSVALUES, @LASTPARAMETERINDEX, @PROCPARAMETERLIST;
      -- There is additional query only if it contains stored proc. Now stored proc is not supported      
      IF @@FETCH_STATUS = 0         
      BEGIN
         -- query contains stored proc, raise exception
         RAISERROR (N'The execution of stored procedure is not supported', 16, 1)
         RETURN
      END    
         
    END                 
    CLOSE @QUERY_CUR
    DEALLOCATE @QUERY_CUR
    
    END
    
    --get result query from cache
    SELECT TOP (1) @SQL = SQLTEXT FROM #QUERYTEXT WHERE UPDATESQL = 0
    
    --save result of query execution to external temporary table
    INSERT #RESULTTABLE EXEC sp_executesql @SQL         
        
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH
    IF (@ERRORIND = 1)
    BEGIN        
       IF CURSOR_STATUS('variable', '@QUERY_CUR') IN (0,1)
          CLOSE @QUERY_CUR  
       IF CURSOR_STATUS('variable', '@QUERY_CUR') = -1
          DEALLOCATE @QUERY_CUR 
              
       DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
       SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
                                      
        IF @DEBUG = 0
			PRINT @SQL 
        
       RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMApplyActionsToDb'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMApplyActionsToDb AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMApplyActionsToDb																			  */
/* INPUT PARAMETERS:																				  */
/*      @RULEDESCRIPTION       - rule description													  */
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/*		@DEBUG				   - 0-trace information will be not print								  */	
/*                                 1-trace information will be print  								  */
/* OUTPUT PARAMETERS:																				  */
/*      @PROGRESS			   - rows affected														  */
/* DESCRIPTION:																						  */
/* Update records corresponding rule.															      */
/* It is need external temporary tables #QUERYTEXT and #RESULTTABLE for execute.					  */
/* #QUERYTEXT table is used for cache sql query (decrease execution count of xml operations).		  */
/* #RESULT table contains event id of records of event table that will be updated					  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMApplyActionsToDb]
   @RULEDESCRIPTION nvarchar(max) 
  ,@CLIENT bit  
  ,@DBID int
  ,@DEBUG bit = 0
  ,@PROGRESS int OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)
        
    SET @ERRORIND = 0
    BEGIN TRY
    
     DECLARE
       @SQL nvarchar(max) -- update sql 
    
     -- check cache
     IF NOT EXISTS(SELECT * FROM #QUERYTEXT WHERE UPDATESQL = 1)
     BEGIN
      -- update query not found
      -- create update query
    
      DECLARE
        @ACTIONPARAMS nvarchar(max) -- action parameter and database id parameter
       ,@ACTIONPARAMSVALUES nvarchar(max) -- action parameter value and database id parameter value
       ,@ACTIONPARAMETER nvarchar(50) -- action parameter
       ,@ACTIONFIELD nvarchar(50) -- action field
       ,@ACTIONENTITY nvarchar(max) -- action entity (table/view or stored proc)
       ,@ACTION_CURSOR CURSOR -- action cursor for fetching action parameters, etc
       
      DECLARE 
        @SETEXPRESSION nvarchar(max)       
       ,@PARAMS nvarchar(MAX)
       ,@PARAMSVALUES nvarchar(max)    
                            
      -- get action cursor corresponding rule                             
      EXEC APM.PMActionQuery @RULEDESCRIPTION, @CLIENT, @DBID, 0, @ACTION_CURSOR OUTPUT
      
      -- initialize action parameters
      SELECT @SETEXPRESSION = N'', @PARAMS = N'', @PARAMSVALUES = N''
      
      -- fetch action parameters
      FETCH NEXT FROM @ACTION_CURSOR 
        INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES, @ACTIONENTITY
      
      WHILE @@FETCH_STATUS = 0
      BEGIN
        SELECT 
         
         --create 'set' clause for update sql ([action field] = [action parameter])                                  
          @SETEXPRESSION = @SETEXPRESSION + REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}e.{1}={2}'), 
                                          N'{0}',CASE WHEN LEN(@SETEXPRESSION) &gt; 0 THEN N',' ELSE N'' END), 
                                          N'{1}',@ACTIONFIELD),                                   
                                          N'{2}',@ACTIONPARAMETER)                                  
                
         --create parameters for update sql                                 
         ,@PARAMS = @PARAMS + 
                    REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}{1}'),
                        N'{0}',CASE WHEN LEN(@PARAMS) &gt; 0 THEN N',' ELSE N'' END), 
                        N'{1}', @ACTIONPARAMS)              
         --create parameter values for update sql                                 
         ,@PARAMSVALUES = @PARAMSVALUES + REPLACE(REPLACE(CONVERT(nvarchar(max),N'{0}{1}'), 
                                          N'{0}',CASE WHEN LEN(@PARAMSVALUES) &gt; 0 THEN N',' ELSE N'' END), 
                                          N'{1}',@ACTIONPARAMSVALUES)                                     
          --fetch next action parameters. Now should be empty because use only one action.     
          FETCH NEXT FROM @ACTION_CURSOR 
            INTO @ACTIONPARAMETER, @ACTIONFIELD, @ACTIONPARAMS, @ACTIONPARAMSVALUES, @ACTIONENTITY
      END
      CLOSE @ACTION_CURSOR
      DEALLOCATE @ACTION_CURSOR
          
      DECLARE
        @COMMAND nvarchar(max) -- update command 
       ,@ROWSAFFECTED int -- rows affected 
     
      -- create update command using external temporary table
      SELECT @COMMAND = 
         REPLACE(REPLACE(CONVERT(nvarchar(max),
             N'UPDATE  e  
                    SET {0} 
                    OUTPUT INSERTED.EventId, INSERTED.pmstatus INTO #STATUSTABLE
                FROM APM.{1} e   
                JOIN #RESULTTABLE r ON r.EVENTID = e.EVENTID
              SET @ROWSAFFECTED = @@ROWCOUNT        
             '), 
             N'{0}', @SETEXPRESSION),
             N'{1}', @ACTIONENTITY) 
      -- add sp_execute call for execution update command       
      SELECT @SQL = REPLACE(REPLACE(REPLACE(CONVERT(nvarchar(max),N'exec sp_executesql N''{0}'', N''{1}'', {2}'),
                    N'{0}',@COMMAND),
                    N'{1}',@PARAMS + N',@ROWSAFFECTED int OUTPUT'),
                    N'{2}',@PARAMSVALUES + N',@ROWSAFFECTED=@ROWSAFFECTED OUTPUT')
                    
      IF @DEBUG = 1                  
        PRINT @SQL
        
      -- insert sql command into cache
      INSERT #QUERYTEXT(SQLTEXT, UPDATESQL, PMSTATUS) SELECT @SQL, 1, @ACTIONPARAMSVALUES                         
    END  
    
    DECLARE 
	  @PMSTATUS nvarchar(MAX)
    
    -- get query from cache
    SELECT TOP (1) @SQL = SQLTEXT, @PMSTATUS = PMSTATUS FROM #QUERYTEXT WHERE UPDATESQL = 1 
    
    CREATE TABLE #STATUSTABLE (EVENTID int, PMSTATUS tinyint)
    
    -- execute update events corresponding rule      
    EXEC sp_executesql @SQL,N'@ROWSAFFECTED int OUTPUT',@ROWSAFFECTED = @ROWSAFFECTED OUTPUT        
    
    IF @DEBUG = 1                
        PRINT N'Rows affected: ' + CAST(@ROWSAFFECTED AS nvarchar(10))
        
    IF @ROWSAFFECTED &gt; 0 
    BEGIN
      --create event trace
       EXEC APM.PMCREATEEVENTTRACES @CLIENT = @CLIENT, @DATA = @RULEDESCRIPTION
    END    
    --save rows affected    
    SELECT @PROGRESS = @ROWSAFFECTED
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH   
    IF (@ERRORIND = 1)
    BEGIN                 
       IF CURSOR_STATUS('variable', '@ACTION_CURSOR') IN (0,1)          
          CLOSE @ACTION_CURSOR
       IF CURSOR_STATUS('variable', '@ACTION_CURSOR') = -1
          DEALLOCATE @ACTION_CURSOR     
       DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
       SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
       IF @DEBUG = 0
			PRINT @SQL 
        
       RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMApplyToDbForEventType'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMApplyToDbForEventType AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMApplyToDbForEventType																	  */
/* INPUT PARAMETERS:																				  */
/*      @CALCULATETOTAL        - calculate total flag (1- it is need to calculate count of records	  */												      
/*														0- it is need to fetch records)				  */												      
/*      @CLIENT                - client event flag : 0 - server event 1 - client event				  */
/*      @DBID                  - seviewer database id. SEviewerDb primary key 						  */
/*      @RULEDESCRIPTION       - rule description													  */
/*		@ROWSPERITERATION      - number of records that is need to fetch                              */
/*		@ROWSPERREQUEST        - number of records that is need to process for one call of stored	  */
/*	                           - procedure															  */
/*		@DEBUG				   - 0-trace information will be not print								  */	
/*                               1-trace information will be print  								  */
/* OUTPUT PARAMETERS:																				  */
/*	    @ROWSAFFECTED          - rows affected if calculate total flag equal zero					  */
/*		@TOTAL                 - calculate row count if calculate total flag equal one				  */
/* DESCRIPTION:																						  */
/* Calculate total records or update records that will be apply by rule.							  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMApplyToDbForEventType]
   @CALCULATETOTAL bit  
  ,@CLIENT bit
  ,@DBID int
  ,@RULEDESCRIPTION nvarchar(MAX)
  ,@ROWSPERITERATION int
  ,@ROWSPERREQUEST int
  ,@DEBUG  bit
  ,@ROWSAFFECTED int OUTPUT
  ,@TOTAL int OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE 
         @ERRORIND        BIT
        ,@ERRORMESSAGE    NVARCHAR(4000)
        ,@ERRORNUMBER     INT
        ,@ERRORSEVERITY   INT
        ,@ERRORSTATE      INT
        ,@ERRORLINE       INT
        ,@ERRORPROCEDURE  SYSNAME
        ,@ERRORMESSAGETEXT NVARCHAR(4000)               
              
    SET @ERRORIND = 0
    BEGIN TRY
    
     -- Initialize output parameters
     SELECT @TOTAL = 0, @ROWSAFFECTED = 0 
    
     -- It is need external temporary tables for execute.
     --It is need for saving results
     CREATE TABLE #RESULTTABLE  (EVENTID int)
     --It is need for cache sql query
     CREATE TABLE #QUERYTEXT (SQLTEXT nvarchar(max), UPDATESQL bit, PMSTATUS nvarchar(MAX))
                   
     IF @CALCULATETOTAL = 1 
     BEGIN
       --Calculate total
       EXEC APM.PMQueryForRule 
                @RULEDESCRIPTION = @RULEDESCRIPTION 
               ,@CLIENT = @CLIENT
               ,@DBID = @DBID
               ,@CALCULATETOTAL = @CALCULATETOTAL 
               ,@ROWSPERITERATION = @ROWSPERITERATION 
               ,@DEBUG = @DEBUG
       --EventId contains result  
       SELECT @TOTAL = EVENTID FROM #RESULTTABLE  
     END    
     IF @CALCULATETOTAL = 0
     BEGIN
       --Update records
       DECLARE @CURRENTAFFECTED int
       --Iteration by "rows per iteration"
       WHILE @ROWSAFFECTED &lt; @ROWSPERREQUEST
       BEGIN
           --Fill #RESULT table 
           EXEC APM.PMQueryForRule 
                    @RULEDESCRIPTION = @RULEDESCRIPTION 
                   ,@CLIENT = @CLIENT
                   ,@DBID = @DBID
                   ,@CALCULATETOTAL = @CALCULATETOTAL 
                   ,@ROWSPERITERATION = @ROWSPERITERATION 
                   ,@DEBUG = @DEBUG
           -- #RESULT table contains set of eventId referencing to the event records that will be updated 
           EXEC APM.PMApplyActionsToDb 
                @RULEDESCRIPTION = @RULEDESCRIPTION
               ,@CLIENT = @CLIENT
               ,@DBID = @DBID
               ,@DEBUG = @DEBUG
               ,@PROGRESS = @CURRENTAFFECTED OUTPUT
           
           -- update rows affected counter    
           SELECT @ROWSAFFECTED = @ROWSAFFECTED + @CURRENTAFFECTED  
           
           --get out if current rows affected less rows per iteration because rows per iteration records should be updated
           IF @CURRENTAFFECTED &lt; @ROWSPERITERATION
             BREAK  
           -- truncate temporary table for next iteration              
           TRUNCATE TABLE #RESULTTABLE    
       END     
     END    
    END TRY
    BEGIN CATCH
        IF (@@TRANCOUNT &gt; 0)
            ROLLBACK TRAN
        SELECT 
            @ERRORNUMBER = ERROR_NUMBER()
            ,@ERRORSEVERITY = ERROR_SEVERITY()
            ,@ERRORSTATE = ERROR_STATE()
            ,@ERRORLINE = ERROR_LINE()
            ,@ERRORPROCEDURE = ISNULL(ERROR_PROCEDURE(), '-')
            ,@ERRORMESSAGETEXT = ERROR_MESSAGE()
        
        SET @ERRORIND = 1
    END CATCH   
    IF (@ERRORIND = 1)
    BEGIN            
       DECLARE 
            @ADJUSTEDERRORSEVERITY   INT
       SET @ADJUSTEDERRORSEVERITY = CASE
                                        WHEN @ERRORSEVERITY &gt; 18 THEN 18
                                        ELSE @ERRORSEVERITY
                                      END
        
        
       RAISERROR (@ERRORMESSAGETEXT, @ADJUSTEDERRORSEVERITY, 1
          ,@ERRORNUMBER
          ,@ERRORSEVERITY
          ,@ERRORSTATE
          ,@ERRORPROCEDURE
          ,@ERRORLINE
          ,@ERRORMESSAGETEXT
    )
    END
END
GO
IF (OBJECTPROPERTY(OBJECT_ID('APM.PMApplyToDb'), 'IsProcedure') IS NULL)
  BEGIN
    EXECUTE ('CREATE PROCEDURE APM.PMApplyToDb AS RETURN 1')
  END
GO
/******************************************************************************************************/
/* OBJECT: Stored Procedure																			  */
/* NAME: PMApplyToDb																				  */
/* INPUT PARAMETERS:																				  */
/*      @CALCULATETOTAL        - calculate total flag (1- it is need to calculate count of records	  */												      
/*														0- it is need to fetch records)				  */												      
/*      @RULEDESCRIPTION       - rule description													  */
/*		@ROWSPERITERATION      - number of records that is need to fetch                              */
/*		@ROWSPERREQUEST        - number of records that is need to process for one call of stored	  */
/*      @TRACELEVEL            - trace level (4 - detail trace, other - reserved)					  */
/* OUTPUT PARAMETERS:																				  */
/*	    @ROWSAFFECTED          - rows affected if calculate total flag equal zero					  */
/*		@TOTAL                 - calculate row count if calculate total flag equal one				  */
/* DESCRIPTION:																						  */
/* Calculate total records or update records that will be apply by rule. It call internal stored	  */
/* procedure for server and client events.															  */
/******************************************************************************************************/
alter PROCEDURE [APM].[PMApplyToDb]
   @CALCULATETOTAL bit  
  ,@RULEDESCRIPTION nvarchar(MAX)
  ,@ROWSPERITERATION int
  ,@ROWSPERREQUEST int
  ,@TRACELEVEL  int
  ,@ROWSAFFECTED int OUTPUT
  ,@TOTAL int OUTPUT
AS
BEGIN
    SET NOCOUNT ON
    
    DECLARE 
        @DEBUG bit -- debug flag (1 - debug, 0 - without debug)
       ,@SERVERROWSAFFECTED int -- server event records affected 
       ,@SERVERTOTAL int -- server total events (when calculate flag equal one)
       ,@CLIENTROWSAFFECTED int -- client event records affected
       ,@CLIENTTOTAL int -- client total events (when calculate flag equal one)
       ,@DBID int -- seviewer database primary key (seviewerdb table)
       ,@DBGUID uniqueidentifier -- seviewer database identifier (only records from this seviewer database will be calculated or updated)
       ,@RULE xml -- untype xml contains rule description
    
    -- implicit conversion to xml   
    SET @RULE = @RULEDESCRIPTION
    
    --get seviewer database unique identifier
    SELECT @DBGUID = @RULE.value('(/rule/@dbid)[1]', 'uniqueidentifier')
    --get corresponding seviewer db primary key
    SELECT @DBID = SEVIEWERDBID from APM.SEVIEWERDB (NOLOCK)
        WHERE DATABASEID = @DBGUID
    --database id is exist?   
    IF @@ROWCOUNT = 0
    BEGIN
     --No, raise exception 
     DECLARE       
        @DATABASEGUIDSTR nvarchar(50)
      SELECT @DATABASEGUIDSTR = CAST(@DBGUID as nvarchar(50))   
      RAISERROR (N'DATABASE Id=''%s'' is not found', 16, 1, @DATABASEGUIDSTR)   
      RETURN    
    END 
    
    -- debug mode ? (trace level should be equal 4)
    SELECT @DEBUG = 
        CASE
            WHEN  @TRACELEVEL = 4 THEN 1 ELSE 0
        END
    
    -- calculate or update server events     
    EXECUTE APM.PMApplyToDbForEventType @CALCULATETOTAL = @CALCULATETOTAL, -- bit
        @CLIENT = 0, -- bit
        @DBID = @DBID, -- int
        @RULEDESCRIPTION = @RULEDESCRIPTION, -- nvarchar(max)
        @ROWSPERITERATION = @ROWSPERITERATION, -- int
        @ROWSPERREQUEST = @ROWSPERREQUEST, -- int
        @DEBUG = @DEBUG, -- bit
        @ROWSAFFECTED = @SERVERROWSAFFECTED OUTPUT, -- rows affected
        @TOTAL = @SERVERTOTAL OUTPUT --total count (if calculate total flag equal 1)
       
    -- calculate or update client events        
    EXECUTE APM.PMApplyToDbForEventType @CALCULATETOTAL = @CALCULATETOTAL, -- bit
        @CLIENT = 1, -- bit
        @DBID = @DBID, -- int
        @RULEDESCRIPTION = @RULEDESCRIPTION, -- nvarchar(max)
        @ROWSPERITERATION = @ROWSPERITERATION, -- int
        @ROWSPERREQUEST = @ROWSPERREQUEST, -- int
        @DEBUG = @DEBUG, -- bit
        @ROWSAFFECTED = @CLIENTROWSAFFECTED OUTPUT, -- rows affected
        @TOTAL = @CLIENTTOTAL OUTPUT --total count (if calculate total flag equal 1)
    -- update counters
    SELECT 
        @TOTAL = COALESCE(@CLIENTTOTAL,0) + COALESCE(@SERVERTOTAL,0)       
       ,@ROWSAFFECTED = COALESCE(@CLIENTROWSAFFECTED,0) + COALESCE(@SERVERROWSAFFECTED,0)       
END
GO
</Upgrade></DataWarehouseDataSet></DataWarehouseDataSets></Reporting><LanguagePacks><LanguagePack ID="ENU" IsDefault="true"><DisplayStrings><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ApmReports.Library"><Name>Operations Manager APM Reports Library</Name><Description>Operations Manager APM Reports Library</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.APM"><Name>APM data set</Name><Description>Defines storage and aggregation for APM</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.APM.DefaultConfiguration"><Name>State data set APM configuration</Name><Description>&lt;Configuration /&gt;</Description></DisplayString></DisplayStrings><KnowledgeArticles><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.ApmReports.Library" Visible="true"><MamlContent><section xmlns="http://schemas.microsoft.com/maml/2004/10"><title>Summary</title><para>This management
pack contains the definitions of APM reports that are available via Operations Manager Application Advisor.</para></section></MamlContent></KnowledgeArticle></KnowledgeArticles></LanguagePack></LanguagePacks></ManagementPack>
