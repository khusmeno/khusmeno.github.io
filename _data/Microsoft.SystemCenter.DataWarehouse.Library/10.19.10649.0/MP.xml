<ManagementPack xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.0"><Manifest><Identity><ID>Microsoft.SystemCenter.DataWarehouse.Library</ID><Version>10.19.10649.0</Version></Identity><Name>Microsoft System Center Data Warehouse Library</Name><References><Reference Alias="SystemCenter"><ID>Microsoft.SystemCenter.Library</ID><Version>7.0.8443.6</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="Windows"><ID>Microsoft.Windows.Library</ID><Version>7.5.8500.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="Health"><ID>System.Health.Library</ID><Version>7.0.8443.6</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="System"><ID>System.Library</ID><Version>7.5.8500.0</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference><Reference Alias="Performance"><ID>System.Performance.Library</ID><Version>7.0.8443.6</Version><PublicKeyToken>31bf3856ad364e35</PublicKeyToken></Reference></References></Manifest><TypeDefinitions><EntityTypes><ClassTypes><ClassType ID="Microsoft.SystemCenter.DataWarehouse" Accessibility="Public" Abstract="false" Base="System!System.LogicalEntity" Hosted="false" Singleton="true" Extension="false"><Property ID="ReportingServerUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/><Property ID="ReportRootFolderName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/><Property ID="MyReportsFolderName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/><Property ID="MainDatabaseServerName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/><Property ID="MainDatabaseName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/></ClassType><ClassType ID="Microsoft.SystemCenter.DataWarehouse.DataSet" Accessibility="Public" Abstract="false" Base="System!System.LogicalEntity" Hosted="false" Singleton="false" Extension="false"><Property ID="InstanceGuid" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="40" MinLength="0" Required="false" Scale="0"/><Property ID="Description" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="255" MinLength="0" Required="false" Scale="0"/></ClassType><ClassType ID="Microsoft.SystemCenter.DataWarehouse.StandardDataSet" Accessibility="Public" Abstract="false" Base="Microsoft.SystemCenter.DataWarehouse.DataSet" Hosted="false" Singleton="false" Extension="false"/><ClassType ID="Microsoft.SystemCenter.DataWarehouseConnectorServer" Accessibility="Public" Abstract="false" Base="SystemCenter!Microsoft.SystemCenter.ManagementServer" Hosted="true" Singleton="false" Extension="false"/><ClassType ID="Microsoft.SystemCenter.DataWarehouse.AppMonitoring" Accessibility="Public" Abstract="false" Base="SystemCenter!Microsoft.SystemCenter.Database.AppMonitoring" Hosted="false" Singleton="true" Extension="false"/></ClassTypes><RelationshipTypes><RelationshipType ID="Microsoft.SystemCenter.DataWarehouse.DataWarehouseContainsDataSet" Accessibility="Public" Abstract="false" Base="System!System.Containment"><Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SystemCenter.DataWarehouse"/><Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SystemCenter.DataWarehouse.DataSet"/></RelationshipType><RelationshipType ID="Microsoft.SystemCenter.OpsMgrDWWatchers.ReferenceDWConnectorServer" Accessibility="Public" Abstract="false" Base="System!System.Reference"><Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="SystemCenter!Microsoft.SystemCenter.OpsMgrDWWatcher"/><Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SystemCenter.DataWarehouseConnectorServer"/></RelationshipType></RelationshipTypes></EntityTypes><SchemaTypes><SchemaType ID="Microsoft.SystemCenter.DataWarehouse.BulkDataWriterSchema" Accessibility="Public"><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RegularExpressionQueryType"><xsd:simpleContent><xsd:extension base="xsd:string"><xsd:attribute name="MatchNumber" type="xsd:nonNegativeInteger" use="optional"/><xsd:attribute name="GroupNumber" type="xsd:nonNegativeInteger" use="optional"/><xsd:attribute name="CaptureNumber" type="xsd:nonNegativeInteger" use="optional"/></xsd:extension></xsd:simpleContent></xsd:complexType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TargetAttributeType"><xsd:restriction base="xsd:string"><xsd:enumeration value="DataItem"/><xsd:enumeration value="Iterator"/></xsd:restriction></xsd:simpleType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TargetedXPathExpressionType"><xsd:simpleContent><xsd:extension base="xsd:string"><xsd:attribute name="Target" type="TargetAttributeType"/></xsd:extension></xsd:simpleContent></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AdditionalProcessingType"><xsd:choice><xsd:element name="Hash" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element name="DateTimeToSqlFormat" type="xsd:string" minOccurs="1" maxOccurs="1"/></xsd:choice></xsd:complexType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ValuePropertyType"><xsd:restriction base="xsd:string"><xsd:enumeration value="InnerXml"/><xsd:enumeration value="OuterXml"/><xsd:enumeration value="Value"/></xsd:restriction></xsd:simpleType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="XmlElementDefinitionType"><xsd:sequence><xsd:element name="Name" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element name="XPathExpression" type="TargetedXPathExpressionType" minOccurs="1" maxOccurs="1"/><xsd:element name="ValueProperty" type="ValuePropertyType" minOccurs="1" maxOccurs="1"/><xsd:element name="RegularExpression" type="RegularExpressionQueryType" minOccurs="0" maxOccurs="1"/><xsd:element name="AdditionalProcessing" type="AdditionalProcessingType" minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="XmlElementsType"><xsd:sequence><xsd:element name="XmlElement" type="XmlElementDefinitionType" minOccurs="1" maxOccurs="unbounded"/></xsd:sequence></xsd:complexType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="OutputColumnTypeType"><xsd:restriction base="xsd:string"><xsd:enumeration value="Boolean"/><xsd:enumeration value="DateTime"/><xsd:enumeration value="Guid"/><xsd:enumeration value="String"/><xsd:enumeration value="Int"/><xsd:enumeration value="Long"/><xsd:enumeration value="Double"/></xsd:restriction></xsd:simpleType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ColumnDefinitionType"><xsd:sequence><xsd:element name="Name" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element name="Type" type="OutputColumnTypeType" minOccurs="1" maxOccurs="1"/><xsd:element name="XPathExpression" type="TargetedXPathExpressionType" minOccurs="1" maxOccurs="1"/><xsd:element name="ValueProperty" type="ValuePropertyType" minOccurs="1" maxOccurs="1"/><xsd:element name="RegularExpression" type="RegularExpressionQueryType" minOccurs="0" maxOccurs="1"/><xsd:element name="AdditionalProcessing" type="AdditionalProcessingType" minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ColumnDefinitionsType"><xsd:sequence><xsd:element name="Column" type="ColumnDefinitionType" minOccurs="1" maxOccurs="unbounded"/></xsd:sequence></xsd:complexType></SchemaType><SchemaType ID="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema" Accessibility="Public"><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthenticationType"><xsd:sequence><xsd:element name="Login" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element name="Password" type="xsd:string" minOccurs="1" maxOccurs="1"/></xsd:sequence></xsd:complexType></SchemaType><SchemaType ID="Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema" Accessibility="Public"><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlIdentifierType"><xsd:restriction base="xsd:string"><xsd:minLength value="1"/><xsd:maxLength value="128"/><xsd:pattern value="[a-zA-Z][0-9_a-zA-Z]*"/></xsd:restriction></xsd:simpleType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeOfDayType"><xsd:restriction base="xsd:string"><xsd:minLength value="5"/><xsd:maxLength value="5"/><xsd:pattern value="[0-9][0-9]:[0-9][0-9]"/></xsd:restriction></xsd:simpleType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AggregationTypeType"><xsd:restriction base="xsd:string"><xsd:enumeration value="Raw"/><xsd:enumeration value="Subhourly"/><xsd:enumeration value="Hourly"/><xsd:enumeration value="Daily"/></xsd:restriction></xsd:simpleType><xsd:simpleType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AggregationIntervalDurationMinutesType"><xsd:restriction base="xsd:int"><xsd:enumeration value="1"/><xsd:enumeration value="2"/><xsd:enumeration value="3"/><xsd:enumeration value="4"/><xsd:enumeration value="5"/><xsd:enumeration value="6"/><xsd:enumeration value="10"/><xsd:enumeration value="12"/><xsd:enumeration value="15"/><xsd:enumeration value="20"/><xsd:enumeration value="30"/></xsd:restriction></xsd:simpleType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AggregationSettingsType"><xsd:sequence><xsd:element name="BaseTableName" type="SqlIdentifierType"/><xsd:element name="MaxTableRowCount" type="xsd:positiveInteger"/><xsd:element name="MaxTableSizeKb" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element name="DataFileGroupName" type="SqlIdentifierType" minOccurs="0" maxOccurs="1"/><xsd:element name="IndexFileGroupName" type="SqlIdentifierType" minOccurs="0" maxOccurs="1"/><xsd:element name="MaxDataAgeDays" type="xsd:positiveInteger"/><xsd:element name="GroomingIntervalMinutes" type="xsd:positiveInteger"/><xsd:element name="MaxRowsToGroom" type="xsd:positiveInteger"/><xsd:element name="IndexOptimizationIntervalMinutes" type="xsd:positiveInteger"/></xsd:sequence></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="NonRawAggregationSettingsType"><xsd:complexContent><xsd:extension base="AggregationSettingsType"><xsd:sequence><xsd:element name="AggregationStartDelayMinutes" type="xsd:positiveInteger"/></xsd:sequence></xsd:extension></xsd:complexContent></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SubhourlyAggregationSettingsType"><xsd:complexContent><xsd:extension base="NonRawAggregationSettingsType"><xsd:sequence><xsd:element name="AggregationIntervalDurationMinutes" type="AggregationIntervalDurationMinutesType"/></xsd:sequence></xsd:extension></xsd:complexContent></xsd:complexType><xsd:complexType xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AggregationsType"><xsd:sequence><xsd:element name="Raw" type="AggregationSettingsType"/><xsd:element name="Subhourly" type="SubhourlyAggregationSettingsType" minOccurs="0" maxOccurs="1"/><xsd:element name="Hourly" type="NonRawAggregationSettingsType" minOccurs="0" maxOccurs="1"/><xsd:element name="Daily" type="NonRawAggregationSettingsType" minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></SchemaType></SchemaTypes><SecureReferences><SecureReference ID="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Accessibility="Public" Context="System!System.Entity"/><SecureReference ID="Microsoft.SystemCenter.DataWarehouse.ConfigSynchronizationReaderAccount" Accessibility="Public" Context="System!System.Entity"/><SecureReference ID="Microsoft.SystemCenter.DataWarehouse.ReportDeploymentActionAccount" Accessibility="Public" Context="System!System.Entity"/><SecureReference ID="Microsoft.SystemCenter.DataWarehouse.SdkSqlAuthenticationActionAccount" Accessibility="Public" Context="System!System.Entity"/><SecureReference ID="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount" Accessibility="Public" Context="System!System.Entity"/></SecureReferences><ModuleTypes><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProvider" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/></Configuration><OverrideableParameters><OverrideableParameter ID="DropItems" Selector="$Config/DropItems$" ParameterType="bool"/><OverrideableParameter ID="QueueDataOnStall" Selector="$Config/QueueDataOnStall$" ParameterType="bool"/><OverrideableParameter ID="QueueDataStallInterval" Selector="$Config/QueueDataStallInterval$" ParameterType="string"/><OverrideableParameter ID="StalledDataQueueSizeMB" Selector="$Config/StalledDataQueueSizeMB$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>A91E7510-80F4-4da4-AC6E-58587F2E70B1</ChannelId><DropItems>$Config/DropItems$</DropItems><QueueDataOnStall>$Config/QueueDataOnStall$</QueueDataOnStall><QueueDataStallInterval>$Config/QueueDataStallInterval$</QueueDataStallInterval><StalledDataQueueSizeMB>$Config/StalledDataQueueSizeMB$</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>Health!System.Health.EntityStateChangeData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId><DropItems>false</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>Health!System.Health.EntityStateChangeData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderInternal" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueMaximumAge" type="xsd:duration"/></Configuration><ModuleImplementation Isolation="Any"><Native><ClassID>8DB8C3B0-3AB0-494a-A09B-5F3643CC27A7</ClassID></Native></ModuleImplementation><OutputType>Health!System.Health.EntityStateChangeData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProvider" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/></Configuration><OverrideableParameters><OverrideableParameter ID="DropItems" Selector="$Config/DropItems$" ParameterType="bool"/><OverrideableParameter ID="QueueDataOnStall" Selector="$Config/QueueDataOnStall$" ParameterType="bool"/><OverrideableParameter ID="QueueDataStallInterval" Selector="$Config/QueueDataStallInterval$" ParameterType="string"/><OverrideableParameter ID="StalledDataQueueSizeMB" Selector="$Config/StalledDataQueueSizeMB$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>0F4C0747-D344-4880-9EE3-A726BFC1D79A</ChannelId><DropItems>$Config/DropItems$</DropItems><QueueDataOnStall>$Config/QueueDataOnStall$</QueueDataOnStall><QueueDataStallInterval>$Config/QueueDataStallInterval$</QueueDataStallInterval><StalledDataQueueSizeMB>$Config/StalledDataQueueSizeMB$</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string" minOccurs="1" maxOccurs="1"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId><DropItems>false</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderInternal" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueMaximumAge" type="xsd:duration"/></Configuration><ModuleImplementation Isolation="Any"><Native><ClassID>8DB8C3B0-3AB0-494a-A09B-5F3643CC27A7</ClassID></Native></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProvider" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/></Configuration><OverrideableParameters><OverrideableParameter ID="DropItems" Selector="$Config/DropItems$" ParameterType="bool"/><OverrideableParameter ID="QueueDataOnStall" Selector="$Config/QueueDataOnStall$" ParameterType="bool"/><OverrideableParameter ID="QueueDataStallInterval" Selector="$Config/QueueDataStallInterval$" ParameterType="string"/><OverrideableParameter ID="StalledDataQueueSizeMB" Selector="$Config/StalledDataQueueSizeMB$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>63AFB62D-3376-4102-B6EE-9E88EA49AC46</ChannelId><DropItems>$Config/DropItems$</DropItems><QueueDataOnStall>$Config/QueueDataOnStall$</QueueDataOnStall><QueueDataStallInterval>$Config/QueueDataStallInterval$</QueueDataStallInterval><StalledDataQueueSizeMB>$Config/StalledDataQueueSizeMB$</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><DataSource ID="DS1" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId><DropItems>false</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB><StalledDataQueueMaximumAge>P14D</StalledDataQueueMaximumAge></DataSource></MemberModules><Composition><Node ID="DS1"/></Composition></Composite></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</OutputType></DataSourceModuleType><DataSourceModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderInternal" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DropItems" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataOnStall" type="xsd:boolean"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="QueueDataStallInterval" type="xsd:duration"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueSizeMB" type="xsd:integer"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StalledDataQueueMaximumAge" type="xsd:duration"/></Configuration><ModuleImplementation Isolation="Any"><Native><ClassID>8DB8C3B0-3AB0-494a-A09B-5F3643CC27A7</ClassID></Native></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</OutputType></DataSourceModuleType><ConditionDetectionModuleType ID="Microsoft.SystemCenter.DataWarehouse.Event.LinkedDataMapper" Accessibility="Internal" Batching="false" Stateful="false" PassThrough="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagedEntityId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RuleId" type="xsd:string"/></Configuration><ModuleImplementation Isolation="Any"><Native><ClassID>eae677d0-9d4f-11d9-9669-0800200c9a66</ClassID></Native></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</OutputType><InputTypes><InputType>System!System.Event.Data</InputType></InputTypes></ConditionDetectionModuleType><ConditionDetectionModuleType ID="Microsoft.SystemCenter.DataWarehouse.Performance.LinkedDataMapper" Accessibility="Internal" Batching="false" Stateful="false" PassThrough="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagedEntityId" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RuleId" type="xsd:string"/></Configuration><ModuleImplementation Isolation="Any"><Native><ClassID>2566BCEB-BF6B-45D6-BA1A-F99E5CACB8B2</ClassID></Native></ModuleImplementation><OutputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</OutputType><InputTypes><InputType>Performance!System.Performance.Data</InputType></InputTypes></ConditionDetectionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><DataSetId>$MPElement[Name="Microsoft.SystemCenter.DataWarehouse.DataSet.Alert"]$</DataSetId><DataRoutingKey>$Config/DataRoutingKey$</DataRoutingKey><TableName>Alert.AlertStage</TableName><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds><SqlAuthentication><Login>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/UserName$</Login><Password>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/Password$</Password></SqlAuthentication></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.DataItemAlertSubscription</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter"><DataRoutingKey/><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.DataItemAlertSubscription</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" Accessibility="Internal" RunAs="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Batching="false"><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataSetId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TableName" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthentication" type="SqlAuthenticationType" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Managed><Assembly>Res.Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal</Assembly><Type>Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse.AlertBulkInsertModule</Type></Managed></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.DataItemAlertSubscription</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" Accessibility="Public" RunAs="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Batching="false"><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.BulkDataWriterSchema</SchemaType><SchemaType>Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataSetId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TableName" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataItemXPathIteratorExpression" type="xsd:string" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TableColumns" type="ColumnDefinitionsType" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthentication" type="SqlAuthenticationType" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Managed><Assembly>Res.Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter</Assembly><Type>Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse.BulkInsertModule</Type></Managed></ModuleImplementation><InputType>System!System.BaseData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriter" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><DataSetId>$MPElement[Name="Microsoft.SystemCenter.DataWarehouse.DataSet.State"]$</DataSetId><DataRoutingKey>$Config/DataRoutingKey$</DataRoutingKey><BulkInsertBatchSize>5000</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>50</MaxBatchesToProcessBeforeMaintenanceCount><TableName>State.StateStage</TableName><MaxExecutionAttemptCount>0</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>0</ExecutionAttemptTimeoutIntervalSeconds><DataItemXPathIteratorExpression>DataItem/Changes/Change</DataItemXPathIteratorExpression><TableColumns><Column><Name>EventOriginId</Name><Type>Guid</Type><XPathExpression Target="DataItem">DataItem/ManagedEntity</XPathExpression><ValueProperty>Value</ValueProperty></Column><Column><Name>DateTime</Name><Type>DateTime</Type><XPathExpression Target="Iterator">TimeChanged</XPathExpression><ValueProperty>Value</ValueProperty><AdditionalProcessing><DateTimeToSqlFormat/></AdditionalProcessing></Column><Column><Name>ManagedEntityGuid</Name><Type>Guid</Type><XPathExpression Target="DataItem">DataItem/ManagedEntity</XPathExpression><ValueProperty>Value</ValueProperty></Column><Column><Name>MonitorGuid</Name><Type>Guid</Type><XPathExpression Target="Iterator">MonitorId</XPathExpression><ValueProperty>Value</ValueProperty></Column><Column><Name>OldHealthState</Name><Type>Int</Type><XPathExpression Target="Iterator">OldHealthState</XPathExpression><ValueProperty>Value</ValueProperty></Column><Column><Name>NewHealthState</Name><Type>Int</Type><XPathExpression Target="Iterator">NewHealthState</XPathExpression><ValueProperty>Value</ValueProperty></Column></TableColumns><SqlAuthentication><Login>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/UserName$</Login><Password>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/Password$</Password></SqlAuthentication></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>System!System.BaseData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriterDefaultRouting" Accessibility="Public" Batching="false"><Configuration/><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriter"><DataRoutingKey/></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>System!System.BaseData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><DataSetId>$MPElement[Name="Microsoft.SystemCenter.DataWarehouse.DataSet.Event"]$</DataSetId><DataRoutingKey>$Config/DataRoutingKey$</DataRoutingKey><TableName>Event.EventStage</TableName><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds><SqlAuthentication><Login>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/UserName$</Login><Password>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/Password$</Password></SqlAuthentication></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter"><DataRoutingKey/><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" Accessibility="Internal" RunAs="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Batching="false"><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataSetId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TableName" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthentication" type="SqlAuthenticationType" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Managed><Assembly>Res.Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal</Assembly><Type>Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse.EventBulkInsertModule</Type></Managed></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><DataSetId>$MPElement[Name="Microsoft.SystemCenter.DataWarehouse.DataSet.Performance"]$</DataSetId><DataRoutingKey>$Config/DataRoutingKey$</DataRoutingKey><TableName>Perf.PerformanceStage</TableName><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds><SqlAuthentication><Login>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/UserName$</Login><Password>$RunAs[Name="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"]/Password$</Password></SqlAuthentication></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" Accessibility="Internal" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter"><DataRoutingKey/><BulkInsertBatchSize>$Config/BulkInsertBatchSize$</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>$Config/MaxBatchesToProcessBeforeMaintenanceCount$</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>$Config/MaxExecutionAttemptCount$</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>$Config/ExecutionAttemptTimeoutIntervalSeconds$</ExecutionAttemptTimeoutIntervalSeconds></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" Accessibility="Internal" RunAs="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Batching="false"><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataSetId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TableName" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BulkInsertBatchSize" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxBatchesToProcessBeforeMaintenanceCount" type="xsd:positiveInteger" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthentication" type="SqlAuthenticationType" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/><OverrideableParameter ID="BulkInsertBatchSize" Selector="$Config/BulkInsertBatchSize$" ParameterType="int"/><OverrideableParameter ID="MaxBatchesToProcessBeforeMaintenanceCount" Selector="$Config/MaxBatchesToProcessBeforeMaintenanceCount$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Managed><Assembly>Res.Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal</Assembly><Type>Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse.PerformanceBulkInsertModule</Type></Managed></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChange" Accessibility="Internal" Batching="false"><Configuration/><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeCustomChannel"><ChannelId>A91E7510-80F4-4da4-AC6E-58587F2E70B1</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>Health!System.Health.EntityStateChangeData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string" minOccurs="1" maxOccurs="1"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="System!System.PublishData"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>Health!System.Health.EntityStateChangeData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishEventData" Accessibility="Public" Batching="false"><Configuration/><ModuleImplementation Isolation="Any"><Composite><MemberModules><ConditionDetection ID="Mapper" TypeID="Microsoft.SystemCenter.DataWarehouse.Event.LinkedDataMapper"><ManagedEntityId>$Target/Id$</ManagedEntityId><RuleId>$MPElement$</RuleId></ConditionDetection><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishEventDataCustomChannel"><ChannelId>0F4C0747-D344-4880-9EE3-A726BFC1D79A</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"><Node ID="Mapper"/></Node></Composition></Composite></ModuleImplementation><InputType>System!System.Event.Data</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishEventDataCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string" minOccurs="1" maxOccurs="1"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="System!System.PublishData"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Event.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" Accessibility="Public" Batching="false"><Configuration/><ModuleImplementation Isolation="Any"><Composite><MemberModules><ConditionDetection ID="Mapper" TypeID="Microsoft.SystemCenter.DataWarehouse.Performance.LinkedDataMapper"><ManagedEntityId>$Target/Id$</ManagedEntityId><RuleId>$MPElement$</RuleId></ConditionDetection><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishPerformanceDataCustomChannel"><ChannelId>63AFB62D-3376-4102-B6EE-9E88EA49AC46</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"><Node ID="Mapper"/></Node></Composition></Composite></ModuleImplementation><InputType>Performance!System.Performance.Data</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.PublishPerformanceDataCustomChannel" Accessibility="Public" Batching="false"><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ChannelId" type="xsd:string" minOccurs="1" maxOccurs="1"/></Configuration><ModuleImplementation Isolation="Any"><Composite><MemberModules><WriteAction ID="WA" TypeID="System!System.PublishData"><ManagementGroupId>$Target/ManagementGroup/Id$</ManagementGroupId><ChannelId>$Config/ChannelId$</ChannelId></WriteAction></MemberModules><Composition><Node ID="WA"/></Composition></Composite></ModuleImplementation><InputType>SystemCenter!Microsoft.SystemCenter.Performance.LinkedData</InputType></WriteActionModuleType><WriteActionModuleType ID="Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter" Accessibility="Public" RunAs="Microsoft.SystemCenter.DataWarehouse.ActionAccount" Batching="false"><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.BulkDataWriterSchema</SchemaType><SchemaType>Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ManagementGroupId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataSetId" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataRoutingKey" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="StoredProcedureName" type="xsd:string" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="MaxExecutionAttemptCount" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ExecutionAttemptTimeoutIntervalSeconds" type="xsd:int" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DataItemXPathIteratorExpression" type="xsd:string" minOccurs="0" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="XmlElements" type="XmlElementsType" minOccurs="1" maxOccurs="1"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SqlAuthentication" type="SqlAuthenticationType" minOccurs="0" maxOccurs="1"/></Configuration><OverrideableParameters><OverrideableParameter ID="MaxExecutionAttemptCount" Selector="$Config/MaxExecutionAttemptCount$" ParameterType="int"/><OverrideableParameter ID="ExecutionAttemptTimeoutIntervalSeconds" Selector="$Config/ExecutionAttemptTimeoutIntervalSeconds$" ParameterType="int"/></OverrideableParameters><ModuleImplementation Isolation="Any"><Managed><Assembly>Res.Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter</Assembly><Type>Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse.XmlBulkWriterModule</Type></Managed></ModuleImplementation><InputType>System!System.BaseData</InputType></WriteActionModuleType></ModuleTypes><MonitorTypes><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLog2StateUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="FirstEventRaised" NoDetection="false"/><MonitorTypeState ID="SecondEventRaised" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="FirstEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SecondEventId" type="xsd:int"/></Configuration><MonitorImplementation><MemberModules><DataSource ID="FirstDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="SecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="FirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/FirstEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="FirstEventRaised"><Node ID="FirstFilterCondition"><Node ID="FirstDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="SecondEventRaised"><Node ID="SecondFilterCondition"><Node ID="SecondDataSource"/></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLogTimed2StateUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="SecondEventRaised" NoDetection="false"/><MonitorTypeState ID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="FirstEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SecondEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeIntervalSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="TimeIntervalSeconds" Selector="$Config/TimeIntervalSeconds$" ParameterType="int"/></OverrideableParameters><MonitorImplementation><MemberModules><DataSource ID="SecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="CorrelatorFirstDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="CorrelatorSecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="CorrelatorFirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/FirstEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="CorrelatorSecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="MissingEventCorrelator" TypeID="System!System.CorrelatorAutoMissingCondition"><Correlator><CorrelationExpression/><Count>1</Count><Interval>$Config/TimeIntervalSeconds$</Interval><CorrelationOrder>InSequence</CorrelationOrder><CorrelationItemPolicy>First</CorrelationItemPolicy></Correlator></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="SecondEventRaised"><Node ID="SecondFilterCondition"><Node ID="SecondDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval"><Node ID="MissingEventCorrelator"><Node ID="CorrelatorFirstFilterCondition"><Node ID="CorrelatorFirstDataSource"/></Node><Node ID="CorrelatorSecondFilterCondition"><Node ID="CorrelatorSecondDataSource"/></Node></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.3SingleEventLog3StateUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="FirstEventRaised" NoDetection="false"/><MonitorTypeState ID="SecondEventRaised" NoDetection="false"/><MonitorTypeState ID="ThirdEventRaised" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="FirstEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SecondEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="ThirdEventId" type="xsd:int"/></Configuration><MonitorImplementation><MemberModules><DataSource ID="FirstDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="SecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="ThirdDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="FirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/FirstEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="ThirdFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/ThirdEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="FirstEventRaised"><Node ID="FirstFilterCondition"><Node ID="FirstDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="SecondEventRaised"><Node ID="SecondFilterCondition"><Node ID="SecondDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="ThirdEventRaised"><Node ID="ThirdFilterCondition"><Node ID="ThirdDataSource"/></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="CollectionUpToSpeed" NoDetection="false"/><MonitorTypeState ID="CollectionSlow" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="AllowedProcessingDelaySeconds" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WatchWindowSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="AllowedProcessingDelaySeconds" Selector="$Config/AllowedProcessingDelaySeconds$" ParameterType="int"/><OverrideableParameter ID="WatchWindowSeconds" Selector="$Config/WatchWindowSeconds$" ParameterType="int"/></OverrideableParameters><MonitorImplementation><MemberModules><DataSource ID="DataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ProbeAction ID="OnDemandReset" TypeID="System!System.PassThroughProbe"/><ConditionDetection ID="FilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">2115</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">Params/Param[5]</XPathQuery></ValueExpression><Operator>GreaterEqual</Operator><ValueExpression><Value Type="Integer">$Config/AllowedProcessingDelaySeconds$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="TimerCondition" TypeID="System!System.TimerCondition"><TimerWaitInSeconds>$Config/WatchWindowSeconds$</TimerWaitInSeconds></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="CollectionSlow"><Node ID="FilterCondition"><Node ID="DataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="CollectionUpToSpeed"><Node ID="TimerCondition"><Node ID="FilterCondition"><Node ID="DataSource"/></Node></Node></RegularDetection></RegularDetections><OnDemandDetections><OnDemandDetection MonitorTypeStateID="CollectionUpToSpeed"><Node ID="OnDemandReset"/></OnDemandDetection></OnDemandDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.WorkflowSqlServerAuthUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="ConfigReloadRequested" NoDetection="false"/><MonitorTypeState ID="SqlAuthProfileEmptyEventRaised" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/></Configuration><MonitorImplementation><MemberModules><DataSource ID="EventDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="FirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><Or><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">1205</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">21025</Value></ValueExpression></SimpleExpression></Expression></Or></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">1107</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[4]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="ConfigReloadRequested"><Node ID="FirstFilterCondition"><Node ID="EventDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="SqlAuthProfileEmptyEventRaised"><Node ID="SecondFilterCondition"><Node ID="EventDataSource"/></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedFirstChanceUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="FirstEventRaised" NoDetection="false"/><MonitorTypeState ID="SecondEventRaised" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DatasetName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="FirstEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SecondEventId" type="xsd:int"/></Configuration><MonitorImplementation><MemberModules><DataSource ID="FirstDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="SecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="FirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/FirstEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[3]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/DatasetName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[3]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/DatasetName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="FirstEventRaised"><Node ID="FirstFilterCondition"><Node ID="FirstDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="SecondEventRaised"><Node ID="SecondFilterCondition"><Node ID="SecondDataSource"/></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType><UnitMonitorType ID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedRecoveryUnitMonitorType" Accessibility="Public"><MonitorTypeStates><MonitorTypeState ID="SecondEventRaised" NoDetection="false"/><MonitorTypeState ID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval" NoDetection="false"/></MonitorTypeStates><Configuration><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="WorkflowName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DatasetName" type="xsd:string"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="FirstEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="SecondEventId" type="xsd:int"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="TimeIntervalSeconds" type="xsd:int"/></Configuration><OverrideableParameters><OverrideableParameter ID="TimeIntervalSeconds" Selector="$Config/TimeIntervalSeconds$" ParameterType="int"/></OverrideableParameters><MonitorImplementation><MemberModules><DataSource ID="SecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="CorrelatorFirstDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><DataSource ID="CorrelatorSecondDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider"><ComputerName>.</ComputerName><LogName>Operations Manager</LogName></DataSource><ConditionDetection ID="CorrelatorFirstFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/FirstEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[3]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/DatasetName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="CorrelatorSecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[3]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/DatasetName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="SecondFilterCondition" TypeID="System!System.ExpressionFilter"><Expression><And><Expression><SimpleExpression><ValueExpression><XPathQuery Type="Integer">EventDisplayNumber</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="Integer">$Config/SecondEventId$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[1]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Target/ManagementGroup/Name$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[2]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/WorkflowName$</Value></ValueExpression></SimpleExpression></Expression><Expression><SimpleExpression><ValueExpression><XPathQuery Type="String">Params/Param[3]</XPathQuery></ValueExpression><Operator>Equal</Operator><ValueExpression><Value Type="String">$Config/DatasetName$</Value></ValueExpression></SimpleExpression></Expression></And></Expression></ConditionDetection><ConditionDetection ID="MissingEventCorrelator" TypeID="System!System.CorrelatorAutoMissingCondition"><Correlator><CorrelationExpression/><Count>1</Count><Interval>$Config/TimeIntervalSeconds$</Interval><CorrelationOrder>InSequence</CorrelationOrder><CorrelationItemPolicy>First</CorrelationItemPolicy></Correlator></ConditionDetection></MemberModules><RegularDetections><RegularDetection MonitorTypeStateID="SecondEventRaised"><Node ID="SecondFilterCondition"><Node ID="SecondDataSource"/></Node></RegularDetection><RegularDetection MonitorTypeStateID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval"><Node ID="MissingEventCorrelator"><Node ID="CorrelatorFirstFilterCondition"><Node ID="CorrelatorFirstDataSource"/></Node><Node ID="CorrelatorSecondFilterCondition"><Node ID="CorrelatorSecondDataSource"/></Node></Node></RegularDetection></RegularDetections></MonitorImplementation></UnitMonitorType></MonitorTypes></TypeDefinitions><Monitoring><Rules><Rule ID="Microsoft.SystemCenter.DataWarehouse.CollectEntityHealthStateChange" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.HealthService" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="30"><Category>System</Category><DataSources><DataSource ID="DS" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProvider"><DropItems>true</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB></DataSource></DataSources><WriteActions><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriterDefaultRouting" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer"/></WriteActions></Rule><Rule ID="Microsoft.SystemCenter.DataWarehouse.CollectEventData" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.HealthService" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="60"><Category>System</Category><DataSources><DataSource ID="DS" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProvider"><DropItems>true</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB></DataSource></DataSources><WriteActions><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer"><BulkInsertBatchSize>1000</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>50</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>0</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>0</ExecutionAttemptTimeoutIntervalSeconds></WriteAction></WriteActions></Rule><Rule ID="Microsoft.SystemCenter.DataWarehouse.CollectPerformanceData" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.HealthService" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="90"><Category>System</Category><DataSources><DataSource ID="DS" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProvider"><DropItems>true</DropItems><QueueDataOnStall>false</QueueDataOnStall><QueueDataStallInterval>PT2M</QueueDataStallInterval><StalledDataQueueSizeMB>100</StalledDataQueueSizeMB></DataSource></DataSources><WriteActions><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer"><BulkInsertBatchSize>5000</BulkInsertBatchSize><MaxBatchesToProcessBeforeMaintenanceCount>200</MaxBatchesToProcessBeforeMaintenanceCount><MaxExecutionAttemptCount>0</MaxExecutionAttemptCount><ExecutionAttemptTimeoutIntervalSeconds>0</ExecutionAttemptTimeoutIntervalSeconds></WriteAction></WriteActions></Rule><Rule ID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeForCollection" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.HealthService" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100"><Category>System</Category><DataSources><DataSource ID="DS" TypeID="Health!System.Health.TargetGroupEntityStateChangeProvider"/></DataSources><WriteActions><WriteAction ID="WA" TypeID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChange"/></WriteActions></Rule></Rules><Monitors><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Collection.Performance.Rollup" Accessibility="Public" Enabled="true" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer" ParentMonitorID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Performance.Rollup" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Collection.Rollup" Accessibility="Public" Enabled="true" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer" ParentMonitorID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Rollup" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Maintenance.Rollup" Accessibility="Public" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.ManagementServer" ParentMonitorID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Rollup" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.DedicatedMaintenance.Rollup" Accessibility="Public" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.ManagementServer" ParentMonitorID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Maintenance.Rollup" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.WriterMaintenance.Rollup" Accessibility="Public" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.ManagementServer" ParentMonitorID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Maintenance.Rollup" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Performance.Rollup" Accessibility="Public" Enabled="true" Target="Microsoft.SystemCenter.DataWarehouseConnectorServer" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor><AggregateMonitor ID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Rollup" Accessibility="Public" Enabled="true" Target="SystemCenter!Microsoft.SystemCenter.ManagementServer" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal"><Category>StateCollection</Category><Algorithm>WorstOf</Algorithm></AggregateMonitor></Monitors><Overrides><RuleConfigurationOverride ID="Microsoft.SystemCenter.DataWarehouse.EnableServerEntityHealthStateDataStallHandling" Context="Microsoft.SystemCenter.DataWarehouseConnectorServer" Enforced="false" Rule="Microsoft.SystemCenter.DataWarehouse.CollectEntityHealthStateChange" Parameter="QueueDataOnStall" Module="DS"><Value>true</Value></RuleConfigurationOverride><RuleConfigurationOverride ID="Microsoft.SystemCenter.DataWarehouse.EnableServerEventDataStallHandling" Context="Microsoft.SystemCenter.DataWarehouseConnectorServer" Enforced="false" Rule="Microsoft.SystemCenter.DataWarehouse.CollectEventData" Parameter="QueueDataOnStall" Module="DS"><Value>true</Value></RuleConfigurationOverride><RuleConfigurationOverride ID="Microsoft.SystemCenter.DataWarehouse.EnableServerPerformanceDataStallHandling" Context="Microsoft.SystemCenter.DataWarehouseConnectorServer" Enforced="false" Rule="Microsoft.SystemCenter.DataWarehouse.CollectPerformanceData" Parameter="QueueDataOnStall" Module="DS"><Value>true</Value></RuleConfigurationOverride></Overrides></Monitoring><Presentation><StringResources><StringResource ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Alert.DefaultConfiguration"/><StringResource ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Event.DefaultConfiguration"/><StringResource ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Performance.DefaultConfiguration"/><StringResource ID="Microsoft.SystemCenter.DataWarehouse.DataSet.State.DefaultConfiguration"/></StringResources></Presentation><Reporting><DataWarehouseScripts><DataWarehouseScript ID="Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport" Accessibility="Public"><InstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Install</InstallScript><UninstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Uninstall</UninstallScript><UpgradeScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Upgrade</UpgradeScript></DataWarehouseScript><DataWarehouseScript ID="Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase" Accessibility="Internal"><InstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Install</InstallScript><UninstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Uninstall</UninstallScript><UpgradeScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Upgrade</UpgradeScript></DataWarehouseScript><DataWarehouseScript ID="Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport" Accessibility="Public"><InstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Install</InstallScript><UninstallScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Uninstall</UninstallScript><UpgradeScript>Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Upgrade</UpgradeScript></DataWarehouseScript></DataWarehouseScripts><DataWarehouseDataSets><DataWarehouseDataSet ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Alert" Accessibility="Public"><Dependencies><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Storage" type="AggregationSettingsType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime" type="TimeOfDayType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger"/></Configuration><Install> 
                    SET NOCOUNT ON

EXEC StandardDatasetDelete @DatasetId = '$Config/DatasetId$'
GO

INSERT StandardDataset (
   DatasetId 
  ,SchemaName
  ,DefaultAggregationIntervalCount
  ,RawInsertTableCount
  ,StagingProcessorStoredProcedureName
  ,BlockingMaintenanceDailyStartTime
  ,BlockingMaintenanceDurationMinutes
)
VALUES
(
   '$Config/DatasetId$'
  ,'Alert'
  ,0
  ,$Config/RawInsertTableCount$
  ,'AlertProcessStaging'
  ,'$Config/BlockingMaintenanceDailyStartTime$'
  ,$Config/BlockingMaintenanceDurationMinutes$
)
GO
 
                    SET NOCOUNT ON

INSERT StandardDatasetAggregation
(                               
   DatasetId
  ,AggregationTypeId
  ,AggregationIntervalDurationMinutes
  ,AggregationStartDelayMinutes
  ,BuildAggregationStoredProcedureName
  ,DeleteAggregationStoredProcedureName
  ,GroomStoredProcedureName
  ,IndexOptimizationIntervalMinutes
  ,MaxDataAgeDays
  ,GroomingIntervalMinutes
  ,MaxRowsToGroom
  ,LastGroomingDateTime
  ,DataFileGroupName
  ,IndexFileGroupName
)
VALUES (
   '$Config/DatasetId$'
  ,0
  ,NULL
  ,NULL
  ,NULL
  ,NULL
  ,'AlertGroom'
  ,$Config/Storage/IndexOptimizationIntervalMinutes$
  ,$Config/Storage/MaxDataAgeDays$
  ,$Config/Storage/GroomingIntervalMinutes$
  ,$Config/Storage/MaxRowsToGroom$
  ,GETUTCDATE()
  ,ISNULL(CAST(NULLIF('$Config/Storage/DataFileGroupName$', '') AS sysname), 'default')
  ,ISNULL(CAST(NULLIF('$Config/Storage/IndexFileGroupName$', '') AS sysname), 'default')
)
GO

                    SET NOCOUNT ON

DECLARE
   @MaxTableRowCount    int
  ,@MaxTableSizeKb      int
  
SELECT
   @MaxTableSizeKb = NULLIF('$Config/Storage/MaxTableSizeKb$', '')
  ,@MaxTableRowCount = NULLIF('$Config/Storage/MaxTableRowCount$', '')
  
INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'Alert'
  ,0
  ,'
        CREATE TABLE [Alert].[Alert_$Guid$]
        (
             AlertRowId                 int               NOT NULL  IDENTITY(1, 1)
            ,AlertGuid                  uniqueidentifier  NOT NULL
            ,AlertProblemGuid           uniqueidentifier  NOT NULL
            ,ManagedEntityRowId         int               NOT NULL
            ,AlertName                  nvarchar(256)     NOT NULL
            ,AlertDescription           nvarchar(max)     NULL
            ,Severity                   tinyint           NOT NULL
            ,Priority                   tinyint           NOT NULL
            ,Category                   nvarchar(256)     NOT NULL
            ,WorkflowRowId              int               NULL
            ,MonitorAlertInd            bit               NOT NULL
            ,[DateTime]                 datetime          NOT NULL
            ,RaisedDateTime             AS ([DateTime])
            ,SiteName                   nvarchar(256)     NULL
            ,RepeatCount                int               NOT NULL
            ,AlertStringGuid            uniqueidentifier  NULL
            ,ParameterHash              uniqueidentifier  NULL
            ,DBCreatedDateTime          datetime          NOT NULL
            ,DWCreatedDateTime          datetime          NOT NULL   DEFAULT(GETUTCDATE())
            ,DWLastModifiedDateTime     datetime          NOT NULL   DEFAULT(GETUTCDATE())
            
            ,CONSTRAINT [PK_Alert_$Guid$] PRIMARY KEY CLUSTERED (AlertRowId) ON $DataFileGroupName$
        ) ON $DataFileGroupName$
  '
  ,'SELECT
       AlertGuid
      ,AlertProblemGuid
      ,AlertName
      ,AlertDescription
      ,Severity
      ,Priority
      ,Category
      ,ManagedEntityRowId
      ,WorkflowRowId
      ,MonitorAlertInd
      ,RaisedDateTime
      ,SiteName
      ,RepeatCount
      ,AlertStringGuid
      ,ParameterHash
      ,DBCreatedDateTime
      ,DWCreatedDateTime
      ,DWLastModifiedDateTime
   '
  ,@MaxTableRowCount
  ,@MaxTableSizeKb
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'AlertResolutionState'
  ,'state'
  ,1
  ,'
        CREATE TABLE [Alert].[AlertResolutionState_$Guid$]
        (
             AlertResolutionStateRowId    int           NOT NULL  IDENTITY(1, 1)
            ,AlertGuid                    uniqueidentifier  NOT NULL
            ,ResolutionState              tinyint       NOT NULL
            ,TimeInStateSeconds           int           NOT NULL  DEFAULT (-1)
            ,TimeFromRaisedSeconds        int           NOT NULL
            ,StateSetDateTime             datetime      NOT NULL
            ,StateSetByUserId             nvarchar(256) NULL
            ,DWCreatedDateTime            datetime NOT  NULL   DEFAULT(GETUTCDATE())
            
            ,CONSTRAINT [PK_AlertResolutionState_$Guid$] PRIMARY KEY CLUSTERED (AlertResolutionStateRowId) ON $DataFileGroupName$

        ) ON $DataFileGroupName$
  '
  ,'SELECT
       AlertGuid
      ,ResolutionState
      ,TimeInStateSeconds
      ,TimeFromRaisedSeconds
      ,StateSetDateTime
      ,StateSetByUserId
      ,DWCreatedDateTime
   '
  ,$Config/Storage/MaxTableRowCount$
  ,NULL
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'AlertDetail'
  ,'detail'
  ,1
  ,'
        CREATE TABLE [Alert].[AlertDetail_$Guid$]
        (
             AlertDetailRowId           int  NOT NULL  IDENTITY(1, 1)
            ,AlertGuid                  uniqueidentifier NOT NULL
            ,Owner                      nvarchar(256) NULL
            ,TicketId                   nvarchar(256) NULL
            ,CustomField1               nvarchar(256) NULL
            ,CustomField2               nvarchar(256) NULL
            ,CustomField3               nvarchar(256) NULL
            ,CustomField4               nvarchar(256) NULL
            ,CustomField5               nvarchar(256) NULL
            ,CustomField6               nvarchar(256) NULL
            ,CustomField7               nvarchar(256) NULL
            ,CustomField8               nvarchar(256) NULL
            ,CustomField9               nvarchar(256) NULL
            ,CustomField10              nvarchar(256) NULL
            ,DBLastModifiedDateTime     datetime  NOT NULL
            ,DBLastModifiedByUserId     nvarchar(256) NULL
            ,DWCreatedDateTime          datetime NOT  NULL   DEFAULT(GETUTCDATE())
            ,TfsWorkItemId              nvarchar(256) NULL
            ,TfsWorkItemOwner           nvarchar(256) NULL
            
            ,CONSTRAINT [PK_AlertDetail_$Guid$] PRIMARY KEY CLUSTERED (AlertDetailRowId) ON $DataFileGroupName$
        ) ON $DataFileGroupName$
  '
  ,'SELECT
       AlertGuid
      ,Owner
      ,TicketId
      ,CustomField1
      ,CustomField2
      ,CustomField3
      ,CustomField4
      ,CustomField5
      ,CustomField6
      ,CustomField7
      ,CustomField8
      ,CustomField9
      ,CustomField10
      ,DBLastModifiedDateTime
      ,DBLastModifiedByUserId
      ,DWCreatedDateTime
      ,TfsWorkItemId
      ,TfsWorkItemOwner
   '
  ,$Config/Storage/MaxTableRowCount$
  ,NULL
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'AlertParameter'
  ,'parameter'
  ,1
  ,'
        CREATE TABLE [Alert].[AlertParameter_$Guid$]
        (
             AlertParameterRowId    int               NOT NULL  IDENTITY(1, 1)
            ,AlertGuid              uniqueidentifier  NOT NULL
            ,ParameterIndex         tinyint           NOT NULL
            ,ParameterValue         nvarchar(max)     NULL
            
            ,CONSTRAINT [PK_AlertParameter_$Guid$] PRIMARY KEY CLUSTERED (AlertParameterRowId) ON $DataFileGroupName$

        ) ON $DataFileGroupName$
  '
  ,'SELECT
       AlertGuid
      ,ParameterIndex
      ,ParameterValue
   '
  ,$Config/Storage/MaxTableRowCount$
  ,NULL
)
GO

                    -- main event table indexes

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '6973521E-D4EC-4612-9A01-422DD56DEE12'
	,@DeleteIndexOnExistingTablesInd = 0
	
EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '6973521E-D4EC-4612-9A01-422DD56DEE12'
  ,@IndexDefinition = '([DateTime])'
  ,@CreateIndexOnExistingTablesInd = 0


EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '8B2F5444-58E6-450b-9432-9EE85866F8DA'
	,@DeleteIndexOnExistingTablesInd = 0
	
EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 1
  ,@IndexGuid = '8B2F5444-58E6-450b-9432-9EE85866F8DA'
  ,@IndexDefinition = '(AlertGuid)'
  ,@CreateIndexOnExistingTablesInd = 0
 
-- alert resolution state indexes 

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = 'A6059CE4-1DED-41ee-B7BA-4B99DB7F734C'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 1
  ,@TableTag = 'state'
  ,@UniqueInd = 0
  ,@IndexGuid = 'A6059CE4-1DED-41ee-B7BA-4B99DB7F734C'
  ,@IndexDefinition = '(AlertGuid)'
  ,@CreateIndexOnExistingTablesInd = 0

-- alert detail indexes
 
EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = 'D4967801-2F91-4b04-ADC3-7A64C805A16A'
	,@DeleteIndexOnExistingTablesInd = 0

 EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 1
  ,@TableTag = 'detail'
  ,@UniqueInd = 0
  ,@IndexGuid = 'D4967801-2F91-4b04-ADC3-7A64C805A16A'
  ,@IndexDefinition = '(AlertGuid)'
  ,@CreateIndexOnExistingTablesInd = 0

-- alert parameter indexes
 
EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = 'A953E9C0-8936-4e13-ADE2-F28285EC4B2B'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 1
  ,@TableTag = 'parameter'
  ,@UniqueInd = 1
  ,@IndexGuid = 'A953E9C0-8936-4e13-ADE2-F28285EC4B2B'
  ,@IndexDefinition = '(AlertGuid, ParameterIndex)'
  ,@CreateIndexOnExistingTablesInd = 0

                    IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = 'Alert')
BEGIN
  EXECUTE('CREATE SCHEMA Alert')
END
GO

-- change schema ownership to allow index rebuild and reorganize
ALTER AUTHORIZATION ON SCHEMA::Alert TO OpsMgrWriter
GO

-- change schema alter to allow domain table index rebuild
GRANT ALTER ON SCHEMA::dbo TO OpsMgrWriter
GO

-- grant create table permissions
GRANT CREATE TABLE TO OpsMgrWriter
GO

EXEC StandardDatasetAllocateStorage @DatasetId = '$Config/DatasetId$', @AggregationTypeId = 0
GO
 
                    
                    -- insert staging definition into StandardDatasetStagingArea
BEGIN TRAN

IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
BEGIN
  DELETE StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'
END

INSERT StandardDatasetStagingArea
(
   DatasetId
  ,StagingTableColumnDefinition
  ,BatchedProcessingSupportedInd
  ,MaxRowsToProcessPerTransactionCount
)
VALUES
(
   '$Config/DatasetId$'
  ,'
       DatasetId                  uniqueidentifier  NOT NULL
      ,ManagementGroupGuid        uniqueidentifier  NOT NULL
      ,AlertGuid                  uniqueidentifier  NOT NULL
      ,AlertProblemGuid           uniqueidentifier  NOT NULL
      ,ManagedEntityGuid          uniqueidentifier  NOT NULL
      ,AlertName                  nvarchar(256)     NOT NULL
      ,AlertDescription           nvarchar(max)     NULL
      ,Severity                   tinyint           NOT NULL
      ,Priority                   tinyint           NOT NULL
      ,Category                   nvarchar(256)     NOT NULL
      ,MonitorAlertInd            bit               NOT NULL
      ,WorkflowGuid               uniqueidentifier  NOT NULL
      ,RaisedDateTime             datetime          NOT NULL
      ,CreatedDateTime            datetime          NOT NULL
      ,ResolutionState            tinyint           NOT NULL
      ,Owner                      nvarchar(256)     NULL
      ,TicketId                   nvarchar(256)     NULL
      ,CustomField1               nvarchar(256)     NULL
      ,CustomField2               nvarchar(256)     NULL
      ,CustomField3               nvarchar(256)     NULL
      ,CustomField4               nvarchar(256)     NULL
      ,CustomField5               nvarchar(256)     NULL
      ,CustomField6               nvarchar(256)     NULL
      ,CustomField7               nvarchar(256)     NULL
      ,CustomField8               nvarchar(256)     NULL
      ,CustomField9               nvarchar(256)     NULL
      ,CustomField10              nvarchar(256)     NULL
      ,SiteName                   nvarchar(256)     NULL
      ,AlertParams                xml               NULL
      ,ParameterHash              uniqueidentifier  NULL
      ,RepeatCount                int               NOT NULL
      ,AlertStringGuid            uniqueidentifier  NULL
      ,DBLastModifiedDateTime     datetime          NOT NULL
      ,DBLastModifiedByUserId     nvarchar(256)     NULL
      ,TfsWorkItemId              nvarchar(256)     NULL
      ,TfsWorkItemOwner           nvarchar(256)     NULL
      
      ,AlertStageRowId            int               NOT NULL IDENTITY(1, 1)
      ,AlertRowId                 int               NULL
      ,TableGuid                  uniqueidentifier  NULL
      ,ManagedEntityRowId         int               NULL
      ,WorkflowRowId              int               NULL
      ,InsertReadyInd             AS (ISNULL(ManagedEntityRowId + WorkflowRowId, 0))
      ,DWCreatedDateTime          datetime          NOT NULL DEFAULT(GETUTCDATE())
  '
 ,1
 ,10000
)

COMMIT

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage' AND TABLE_SCHEMA = 'Alert')
BEGIN
  DECLARE @Statement nvarchar(max)

  SELECT @Statement = 'CREATE TABLE Alert.AlertStage (' + StagingTableColumnDefinition + ')'
  FROM StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'

  EXECUTE (@Statement)
END
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_AlertStage_AlertGuidDBLastModifiedDateTimeResolutionStateAlertStageRowId')
BEGIN
  CREATE INDEX IX_AlertStage_AlertGuidDBLastModifiedDateTimeResolutionStateAlertStageRowId ON Alert.AlertStage (AlertGuid, DBLastModifiedDateTime, ResolutionState, AlertStageRowId)
END
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'AlertStage'
      ,@SchemaName = 'Alert'
      ,@DatasetId = '$Config/DatasetId$'
GO
  
GRANT SELECT, INSERT, UPDATE, DELETE ON Alert.AlertStage TO OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage2Process' AND TABLE_SCHEMA = 'Alert')
BEGIN
  CREATE TABLE Alert.AlertStage2Process (
       DatasetId                  uniqueidentifier  NOT NULL
      ,ManagementGroupGuid        uniqueidentifier  NOT NULL
      ,AlertGuid                  uniqueidentifier  NOT NULL
      ,AlertProblemGuid           uniqueidentifier  NOT NULL
      ,ManagedEntityGuid          uniqueidentifier  NOT NULL
      ,AlertName                  nvarchar(256)     NOT NULL
      ,AlertDescription           nvarchar(max)     NULL
      ,Severity                   tinyint           NOT NULL
      ,Priority                   tinyint           NOT NULL
      ,Category                   nvarchar(256)     NOT NULL
      ,MonitorAlertInd            bit               NOT NULL
      ,WorkflowGuid               uniqueidentifier  NOT NULL
      ,RaisedDateTime             datetime          NOT NULL
      ,CreatedDateTime            datetime          NOT NULL
      ,ResolutionState            tinyint           NOT NULL
      ,Owner                      nvarchar(256)     NULL
      ,TicketId                   nvarchar(256)     NULL
      ,CustomField1               nvarchar(256)     NULL
      ,CustomField2               nvarchar(256)     NULL
      ,CustomField3               nvarchar(256)     NULL
      ,CustomField4               nvarchar(256)     NULL
      ,CustomField5               nvarchar(256)     NULL
      ,CustomField6               nvarchar(256)     NULL
      ,CustomField7               nvarchar(256)     NULL
      ,CustomField8               nvarchar(256)     NULL
      ,CustomField9               nvarchar(256)     NULL
      ,CustomField10              nvarchar(256)     NULL
      ,SiteName                   nvarchar(256)     NULL
      ,AlertParams                xml               NULL
      ,ParameterHash              uniqueidentifier  NULL
      ,RepeatCount                int               NOT NULL
      ,AlertStringGuid            uniqueidentifier  NULL
      ,DBLastModifiedDateTime     datetime          NOT NULL
      ,DBLastModifiedByUserId     nvarchar(256)     NULL
      ,TfsWorkItemId              nvarchar(256)     NULL
      ,TfsWorkItemOwner           nvarchar(256)     NULL
      
      ,AlertStageRowId            int               NOT NULL
      ,AlertRowId                 int               NULL
      ,TableGuid                  uniqueidentifier  NULL
      ,ManagedEntityRowId         int               NULL
      ,WorkflowRowId              int               NULL
      ,DWCreatedDateTime          datetime          NOT NULL
  )
END
ELSE
BEGIN
    -- Table already exists, ensure TFS columns exist

    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'AlertStage2Process' AND TABLE_SCHEMA = 'Alert'
        AND COLUMN_NAME = N'TfsWorkItemId')
    ALTER TABLE [Alert].[AlertStage2Process] ADD [TfsWorkItemId] nvarchar(256) NULL

    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'AlertStage2Process' AND TABLE_SCHEMA = 'Alert'
        AND COLUMN_NAME = N'TfsWorkItemOwner')
    ALTER TABLE [Alert].[AlertStage2Process] ADD [TfsWorkItemOwner] nvarchar(256) NULL
END
GO

                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.AlertGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.AlertGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @MainTableName varchar(255)
    ,@TableName varchar(255)
    ,@Statement varchar(max)
    ,@DebugLevel tinyint
    ,@StandardDatasetAggregationStorageRowId int
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    BEGIN TRAN
    
    CREATE TABLE #AlertGroom (
      AlertGuid uniqueidentifier NOT NULL
    )
    
    SELECT @MainTableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'INSERT #AlertGroom (AlertGuid)'
                   + ' SELECT TOP ' + CAST(@MaxRowsToGroom AS varchar(15)) + ' AlertGuid'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'
                   
    EXECUTE (@Statement)

    SET @StandardDatasetAggregationStorageRowId = 0
    
    WHILE EXISTS (SELECT *
                  FROM StandardDatasetAggregationStorage
                  WHERE (DatasetId = @DatasetId)
                    AND (AggregationTypeId = @AggregationTypeId)
                    AND (DependentTableInd = 1)
                    AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
                 )
    BEGIN
      SELECT TOP 1
         @StandardDatasetAggregationStorageRowId = StandardDatasetAggregationStorageRowId
        ,@TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
      FROM StandardDatasetAggregationStorage
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @AggregationTypeId)
        AND (DependentTableInd = 1)
        AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
		Order By StandardDatasetAggregationStorageRowId Asc
        
      SET @Statement = 'DELETE d'
                     + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' d'
                     + '   JOIN #AlertGroom a ON (d.AlertGuid = a.AlertGuid)'
      EXECUTE (@Statement)
    END
    
    SET @Statement = 'DELETE d'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName) + ' d'
                   + '   JOIN #AlertGroom a ON (d.AlertGuid = a.AlertGuid)'
    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    DROP TABLE #AlertGroom
    
    COMMIT

    -- groom staging of data for rejected MGs
    DELETE Alert.AlertStage
    WHERE ManagementGroupGuid NOT IN (SELECT ManagementGroupGuid
                                      FROM ManagementGroup mg
                                      WHERE (ConnectConfirmedDateTime IS NOT NULL)
                                        AND (ConnectRejectedInd = 0)
                                     )
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for Alert data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.AlertProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.AlertProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText nvarchar(max)
      ,@OperationDurationMs bigint
      ,@ExecResult int
      ,@DebugLevel int
      ,@LockResourceName sysname
      ,@TableGuid uniqueidentifier
      ,@SchemaName sysname
      ,@MaxRowsToProcessCount int
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    -- get max # of rows to process in one shot
    SELECT @MaxRowsToProcessCount = MaxRowsToProcessPerTransactionCount
    FROM StandardDatasetStagingArea
    WHERE (DatasetId = @DatasetId)
    
    IF (@MaxRowsToProcessCount IS NULL)
    BEGIN
      -- if max row count calue is not set default to 5000
      SET @MaxRowsToProcessCount = 5000
    END
    
    -- delete old entries
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      
    DELETE TOP (@MaxRowsToProcessCount)
    FROM Alert.AlertStage
    WHERE (DatasetId = @DatasetId)
      AND (DWCreatedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()))

    -- update managed entity ids
    UPDATE s
    SET ManagedEntityRowId = me.ManagedEntityRowId
    FROM Alert.AlertStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((s.ManagedEntityGuid = me.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
    WHERE (s.ManagedEntityRowId IS NULL)
      
    -- update workflow ids
    UPDATE s
    SET WorkflowRowId = m.MonitorRowId
    FROM Alert.AlertStage s
          JOIN vMonitor m ON (s.WorkflowGuid = m.MonitorGuid)
    WHERE (s.MonitorAlertInd  = 1)
      AND (s.WorkflowRowId IS NULL)
      
    UPDATE s
    SET WorkflowRowId = r.RuleRowId
    FROM Alert.AlertStage s
          JOIN vRule r ON (s.WorkflowGuid = r.RuleGuid)
    WHERE (s.MonitorAlertInd  = 0)
      AND (s.WorkflowRowId IS NULL)
      
    BEGIN TRAN
    
    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert alert(s) into ' + @InsertTableName
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
     
    -- calculate alert tables and row ids
    DECLARE @VisitedPartition TABLE (
      PartitionGuid uniqueidentifier
    )
    
    WHILE EXISTS (SELECT *
                  FROM Alert.AlertStage s
                        CROSS JOIN StandardDatasetTableMap m
                  WHERE (s.AlertRowId IS NULL)
                    AND (m.DatasetId = @DatasetId)
                    AND (m.AggregationTypeId = 0)
                    AND ((s.RaisedDateTime BETWEEN m.StartDateTime and m.EndDateTime) OR (m.InsertInd = 1))
                    AND (NOT EXISTS (SELECT * FROM @VisitedPartition WHERE (PartitionGuid = m.TableGuid)))
                 )
    BEGIN
      SELECT TOP 1
         @TableGuid = m.TableGuid
      FROM Alert.AlertStage s
            CROSS JOIN StandardDatasetTableMap m
      WHERE (s.AlertRowId IS NULL)
        AND (m.DatasetId = @DatasetId)
        AND (m.AggregationTypeId = 0)
        AND (s.RaisedDateTime BETWEEN ISNULL(m.StartDateTime, '19000101') AND ISNULL(m.EndDateTime, '99991231'))
        AND (NOT EXISTS (SELECT * FROM @VisitedPartition WHERE (PartitionGuid = m.TableGuid)))
      ORDER BY m.StandardDatasetTableMapRowId
      
      INSERT @VisitedPartition VALUES (@TableGuid)
      
      SET @Statement =
            'UPDATE s'
          + ' SET AlertRowId = a.AlertRowId'
          + '    ,TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''''
          + ' FROM Alert.AlertStage s'
          + '      JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('Alert_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' a ON (s.AlertGuid = a.AlertGuid)'
          + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
    END

    -- check to see if AlertStage2Process table is not empty
    DECLARE @AlertStage2ProcessRowCount int
    DECLARE @SpaceUsedInfo TABLE (
               [name]       sysname
              ,[rows]       int
              ,reserved     nvarchar(100)
              ,data         nvarchar(100)
              ,index_size   nvarchar(100)
              ,unused       nvarchar(100)
            )
            
    INSERT @SpaceUsedInfo
    EXEC sp_spaceused 'Alert.AlertStage2Process'
    
    SELECT @AlertStage2ProcessRowCount = [rows]
    FROM @SpaceUsedInfo

    IF (@AlertStage2ProcessRowCount = 0)
    BEGIN
      -- move some rows to processing table if it is empty
      
      BEGIN TRAN
      
      INSERT Alert.AlertStage2Process (
         DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId
        
        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid 
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
        ,TfsWorkItemId
        ,TfsWorkItemOwner
      )
      SELECT TOP (@MaxRowsToProcessCount)
         DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId
        
        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid 
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
        ,TfsWorkItemId
        ,TfsWorkItemOwner
      FROM Alert.AlertStage s
      WHERE (s.AlertStageRowId = (SELECT TOP 1 AlertStageRowId
                                  FROM Alert.AlertStage
                                  WHERE (AlertGuid = s.AlertGuid)
                                  ORDER BY DBLastModifiedDateTime, ResolutionState, AlertStageRowId)
                                 )
        AND (s.InsertReadyInd &gt; 0)

      DELETE s
      FROM Alert.AlertStage s
            JOIN Alert.AlertStage2Process s2p ON (s2p.AlertStageRowId = s.AlertStageRowId)

      COMMIT
    END

    -- work only with rows in processing table

    IF (EXISTS (SELECT * FROM Alert.AlertStage2Process WHERE (AlertRowId IS NULL)))
    BEGIN
      -- we have new alerts in the staging area
      -- process only the first "change" since there
      -- may be multiple changes stored in staging at
      -- the same time, if that's the case - we'll pick
      -- up all other changes next time we process staging
      SET @Statement = 
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
        + '   AlertGuid'
        + '  ,AlertProblemGuid'
        + '  ,ManagedEntityRowId'
        + '  ,AlertName'
        + '  ,AlertDescription'
        + '  ,Severity'
        + '  ,Priority'
        + '  ,Category'
        + '  ,WorkflowRowId'
        + '  ,MonitorAlertInd'
        + '  ,[DateTime]'
        + '  ,SiteName'
        + '  ,RepeatCount'
        + '  ,AlertStringGuid'
        + '  ,ParameterHash'
        + '  ,DBCreatedDateTime'
        + ' )'
        + ' SELECT'
        + '   s.AlertGuid'
        + '  ,s.AlertProblemGuid'
        + '  ,s.ManagedEntityRowId'
        + '  ,s.AlertName'
        + '  ,s.AlertDescription'
        + '  ,s.Severity'
        + '  ,s.Priority'
        + '  ,s.Category'
        + '  ,s.WorkflowRowId'
        + '  ,s.MonitorAlertInd'
        + '  ,s.RaisedDateTime'
        + '  ,s.SiteName'
        + '  ,s.RepeatCount'
        + '  ,NULLIF(s.AlertStringGuid, ''00000000-0000-0000-0000-000000000000'')'
        + '  ,NULLIF(s.ParameterHash, ''00000000-0000-0000-0000-000000000000'')'
        + '  ,s.CreatedDateTime'
        + ' FROM Alert.AlertStage2Process s'
        + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
      
      -- insert alert parameters
      CREATE TABLE #AlertParameter
      (
         AlertParameterRowId            int IDENTITY(1, 1)
        ,AlertGuid                      uniqueidentifier  NOT NULL
        ,ParameterIndex                 tinyint NULL
        ,ParameterValue                 nvarchar(255) NULL
      )
      
      INSERT #AlertParameter (
         AlertGuid
        ,ParameterValue
      )
      SELECT
         s.AlertGuid
        ,xml.ParameterValue.value('.', 'nvarchar(255)')
      FROM Alert.AlertStage2Process s
            CROSS APPLY s.AlertParams.nodes('AlertParameters/*') as xml(ParameterValue)
      WHERE (s.AlertRowId IS NULL)
      
      -- set parameter indexes
    
      UPDATE ap
      SET ap.ParameterIndex = ap.AlertParameterRowId - ap1.AlertParameterRowId + 1
      FROM #AlertParameter ap
            JOIN #AlertParameter ap1 ON (ap.AlertGuid = ap1.AlertGuid)
      WHERE NOT EXISTS (SELECT *
                        FROM #AlertParameter
                        WHERE (AlertGuid = ap1.AlertGuid)
                          AND (AlertParameterRowId &lt; ap1.AlertParameterRowId)
                       )

      SET @Statement = 
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + 'AlertParameter_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '') + '('
        + '    AlertGuid'
        + '   ,ParameterIndex'
        + '   ,ParameterValue'
        + ' )'
        + ' SELECT '
        + '    AlertGuid'
        + '   ,ParameterIndex'
        + '   ,ParameterValue'
        + ' FROM #AlertParameter'
      EXECUTE (@Statement)

      DROP TABLE #AlertParameter
      
      -- retrieve created alert ids
      SET @Statement = 
          'UPDATE s'
        + ' SET AlertRowId = a.AlertRowId'
        + '    ,TableGuid = ''' + CAST(@InsertTableGuid AS varchar(50)) + ''''
        + ' FROM Alert.AlertStage2Process s'
        + '   JOIN  ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' a ON (s.AlertGuid = a.AlertGuid)'
        + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
    END

    IF (EXISTS (SELECT * FROM Alert.AlertStage2Process WHERE (AlertRowId IS NOT NULL)))
    BEGIN
      -- process alert updates
      
      -- build unique list of tables affected
      DECLARE @AffectedPartition TABLE (
         PartitionRowId int IDENTITY(1, 1)
        ,TableGuid uniqueidentifier
      )
      
      INSERT @AffectedPartition(TableGuid)
      SELECT DISTINCT TableGuid
      FROM Alert.AlertStage2Process
      WHERE (AlertRowId IS NOT NULL)
      
      DECLARE @PartitionRowId int
      
      SET @PartitionRowId = 0
      
      WHILE (EXISTS (SELECT * FROM @AffectedPartition WHERE (PartitionRowId &gt; @PartitionRowId)))
      BEGIN
        SELECT TOP 1
           @PartitionRowId = PartitionRowId
          ,@TableGuid = TableGuid
        FROM @AffectedPartition
        WHERE (PartitionRowId &gt; @PartitionRowId)
        
        -- update alert repeat count
        SET @Statement = 
            'UPDATE a'
          + ' SET RepeatCount = s.RepeatCount'
          + '    ,DWLastModifiedDateTime = GETUTCDATE()'
          + ' FROM Alert.AlertStage2Process s'
          + '       JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('Alert_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' a'
          + '             ON (s.AlertRowId = a.AlertRowId)'
          + ' WHERE (s.RepeatCount &gt; a.RepeatCount)'
        EXECUTE (@Statement)
        
        -- check which alerts have resolution state changed
        CREATE TABLE #ResolutionState (
           AlertStageRowId        int               NOT NULL
          ,AlertGuid              uniqueidentifier  NOT NULL
          ,LastResolutionState    tinyint           NULL
        )
        
        SET @Statement = 
            'INSERT #ResolutionState ('
          + '    AlertStageRowId'
          + '   ,AlertGuid'
          + '   ,LastResolutionState'
          + ')'
          + ' SELECT'
          + '    s.AlertStageRowId'
          + '   ,s.AlertGuid'
          + '   ,r.ResolutionState'
          + ' FROM Alert.AlertStage2Process s'
          + '       LEFT JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' r'
          + '             ON (s.AlertGuid = r.AlertGuid) AND (r.AlertResolutionStateRowId = (SELECT TOP 1 AlertResolutionStateRowId FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' WHERE (AlertGuid = s.AlertGuid) AND (StateSetDateTime &lt;= s.DBLastModifiedDateTime) ORDER BY StateSetDateTime DESC, ResolutionState DESC))'
          + ' WHERE (s.AlertRowId IS NOT NULL)'
          + '   AND (s.TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''')'
        EXECUTE (@Statement)
        
        -- insert resolution state changes
        SET @Statement =
            'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ('
          + '    AlertGuid'
          + '   ,ResolutionState'
          + '   ,TimeFromRaisedSeconds'
          + '   ,StateSetDateTime'
          + '   ,StateSetByUserId'
          + ' )'
          + ' SELECT'
          + '    s.AlertGuid'
          + '   ,s.ResolutionState'
          + '   ,CASE ' -- check to see if alert was raised way in the past/future
          + '      WHEN ISNULL(ABS(DATEDIFF(year, s.DBLastModifiedDateTime, s.RaisedDateTime)), 0) &gt; 3 THEN 3*365*24*60*60 '
          + '      ELSE ISNULL(ABS(DATEDIFF(second, s.DBLastModifiedDateTime, s.RaisedDateTime)), 0) '
          + '    END '
          + '   ,s.DBLastModifiedDateTime'
          + '   ,s.DBLastModifiedByUserId'
          + ' FROM #ResolutionState r'
          + '      JOIN Alert.AlertStage2Process s ON (r.AlertStageRowId = s.AlertStageRowId)'
          + ' WHERE (s.ResolutionState &lt;&gt; r.LastResolutionState) OR (r.LastResolutionState IS NULL)'
        EXECUTE (@Statement)
        
        -- update all "time in state" columns since
        -- we've added some state transitions potentially "in the middle"
        SET @Statement =
            'UPDATE ars'
          + '    SET TimeInStateSeconds = ISNULL(ABS(DATEDIFF(second, ars.StateSetDateTime, ars2.StateSetDateTime)), -1)'
          + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ars'
          + '     JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ars2'
          + '        ON (ars.AlertGuid = ars2.AlertGuid)'
          + '     JOIN (SELECT DISTINCT AlertGuid = s.AlertGuid'
          + '           FROM #ResolutionState r'
          + '             JOIN Alert.AlertStage2Process s ON (r.AlertStageRowId = s.AlertStageRowId)'
          + '           WHERE (s.ResolutionState &lt;&gt; r.LastResolutionState) OR (r.LastResolutionState IS NULL)'
          + '          ) AS al ON (ars.AlertGuid = al.AlertGuid)'
          + ' WHERE (ars2.AlertResolutionStateRowId = (SELECT TOP 1 AlertResolutionStateRowId'
          + '                                          FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', ''))
          + '                                          WHERE (AlertGuid = ars.AlertGuid)'
          + '                                            AND (StateSetDateTime &gt;= ars.StateSetDateTime)'
          + '                                            AND (AlertResolutionStateRowId &lt;&gt; ars.AlertResolutionStateRowId)'
          + '                                          ORDER BY StateSetDateTime, ResolutionState DESC'
          + '                                         ))'
        EXECUTE (@Statement)
        
        DROP TABLE #ResolutionState
        
        -- check to see if alert properties were updated
        CREATE TABLE #AlertDetail (
           AlertStageRowId            int           NOT NULL
          ,DetailRecordExistedInd     bit           NOT NULL
          ,Owner                      nvarchar(256) NULL
          ,TicketId                   nvarchar(256) NULL
          ,CustomField1               nvarchar(256) NULL
          ,CustomField2               nvarchar(256) NULL
          ,CustomField3               nvarchar(256) NULL
          ,CustomField4               nvarchar(256) NULL
          ,CustomField5               nvarchar(256) NULL
          ,CustomField6               nvarchar(256) NULL
          ,CustomField7               nvarchar(256) NULL
          ,CustomField8               nvarchar(256) NULL
          ,CustomField9               nvarchar(256) NULL
          ,CustomField10              nvarchar(256) NULL
          ,TfsWorkItemId              nvarchar(256) NULL
          ,TfsWorkItemOwner           nvarchar(256) NULL
        )
        
        SET @Statement = 
            'INSERT #AlertDetail ('
          + '    AlertStageRowId'
          + '   ,DetailRecordExistedInd'
          + '   ,Owner'
          + '   ,TicketId'
          + '   ,CustomField1'
          + '   ,CustomField2'
          + '   ,CustomField3'
          + '   ,CustomField4'
          + '   ,CustomField5'
          + '   ,CustomField6'
          + '   ,CustomField7'
          + '   ,CustomField8'
          + '   ,CustomField9'
          + '   ,CustomField10'
          + '   ,TfsWorkItemId'
          + '   ,TfsWorkItemOwner'
          + ')'
          + ' SELECT'
          + '    s.AlertStageRowId'
          + '   ,CASE WHEN d.AlertGuid IS NULL THEN 0 ELSE 1 END'
          + '   ,d.Owner'
          + '   ,d.TicketId'
          + '   ,d.CustomField1'
          + '   ,d.CustomField2'
          + '   ,d.CustomField3'
          + '   ,d.CustomField4'
          + '   ,d.CustomField5'
          + '   ,d.CustomField6'
          + '   ,d.CustomField7'
          + '   ,d.CustomField8'
          + '   ,d.CustomField9'
          + '   ,d.CustomField10'
          + '   ,d.TfsWorkItemId'
          + '   ,d.TfsWorkItemOwner'
          + ' FROM Alert.AlertStage2Process s'
          + '       LEFT JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' d ON (s.AlertGuid = d.AlertGuid)'
          + ' WHERE (s.AlertRowId IS NOT NULL)'
          + '   AND (s.TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''')'
          + '   AND (NOT EXISTS (SELECT * FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' WHERE (AlertGuid = s.AlertGuid) AND (DBLastModifiedDateTime &lt;= s.DBLastModifiedDateTime) AND (AlertDetailRowId &gt; d.AlertDetailRowId)))'
        EXECUTE (@Statement)
        
        -- insert alert detail changes
        SET @Statement =
            'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ('
          + '    AlertGuid'
          + '   ,Owner'
          + '   ,TicketId'
          + '   ,CustomField1'
          + '   ,CustomField2'
          + '   ,CustomField3'
          + '   ,CustomField4'
          + '   ,CustomField5'
          + '   ,CustomField6'
          + '   ,CustomField7'
          + '   ,CustomField8'
          + '   ,CustomField9'
          + '   ,CustomField10'
          + '   ,DBLastModifiedDateTime'
          + '   ,DBLastModifiedByUserId'
          + '   ,TfsWorkItemId'
          + '   ,TfsWorkItemOwner'
          + ' )'
          + ' SELECT'
          + '    s.AlertGuid'
          + '   ,s.Owner'
          + '   ,s.TicketId'
          + '   ,s.CustomField1'
          + '   ,s.CustomField2'
          + '   ,s.CustomField3'
          + '   ,s.CustomField4'
          + '   ,s.CustomField5'
          + '   ,s.CustomField6'
          + '   ,s.CustomField7'
          + '   ,s.CustomField8'
          + '   ,s.CustomField9'
          + '   ,s.CustomField10'
          + '   ,s.DBLastModifiedDateTime'
          + '   ,s.DBLastModifiedByUserId'
          + '   ,s.TfsWorkItemId'
          + '   ,s.TfsWorkItemOwner'
          + ' FROM #AlertDetail d'
          + '      JOIN Alert.AlertStage2Process s ON (d.AlertStageRowId = s.AlertStageRowId)'
          + ' WHERE (ISNULL(s.Owner, '''') &lt;&gt; ISNULL(d.Owner, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TicketId, '''') &lt;&gt; ISNULL(d.TicketId, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField1, '''') &lt;&gt; ISNULL(d.CustomField1, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField2, '''') &lt;&gt; ISNULL(d.CustomField2, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField3, '''') &lt;&gt; ISNULL(d.CustomField3, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField4, '''') &lt;&gt; ISNULL(d.CustomField4, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField5, '''') &lt;&gt; ISNULL(d.CustomField5, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField6, '''') &lt;&gt; ISNULL(d.CustomField6, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField7, '''') &lt;&gt; ISNULL(d.CustomField7, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField8, '''') &lt;&gt; ISNULL(d.CustomField8, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField9, '''') &lt;&gt; ISNULL(d.CustomField9, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField10, '''') &lt;&gt; ISNULL(d.CustomField10, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TfsWorkItemId, '''') &lt;&gt; ISNULL(d.TfsWorkItemId, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TfsWorkItemOwner, '''') &lt;&gt; ISNULL(d.TfsWorkItemOwner, '''') COLLATE database_default)'
          + '    OR (d.DetailRecordExistedInd = 0)'
        EXECUTE (@Statement)
        
        DROP TABLE #AlertDetail
        
        -- mark affected table as non-optimized
        UPDATE StandardDatasetTableMap
        SET OptimizedInd = 0
        WHERE (DatasetId = @DatasetId)
          AND (AggregationTypeId = 0)
          AND (TableGuid = @TableGuid)
          AND (InsertInd = 0)
      END
    END
  
    TRUNCATE TABLE Alert.AlertStage2Process
  
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting alert(s) into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process alert staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

                    </Install><Uninstall>
                    -- drop SPs
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertGroom')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.AlertGroom')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertInsert')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.AlertInsert')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertProcessStaging')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.AlertProcessStaging')
END

-- drop tables
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage' AND TABLE_SCHEMA = 'Alert')
BEGIN
  EXECUTE('DROP TABLE Alert.AlertStage')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage2Process' AND TABLE_SCHEMA = 'Alert')
BEGIN
  EXECUTE('DROP TABLE Alert.AlertStage2Process')
END

-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
   
                    </Uninstall><Upgrade>
                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage2Process' AND TABLE_SCHEMA = 'Alert')
BEGIN
  CREATE TABLE Alert.AlertStage2Process (
       DatasetId                  uniqueidentifier  NOT NULL
      ,ManagementGroupGuid        uniqueidentifier  NOT NULL
      ,AlertGuid                  uniqueidentifier  NOT NULL
      ,AlertProblemGuid           uniqueidentifier  NOT NULL
      ,ManagedEntityGuid          uniqueidentifier  NOT NULL
      ,AlertName                  nvarchar(256)     NOT NULL
      ,AlertDescription           nvarchar(max)     NULL
      ,Severity                   tinyint           NOT NULL
      ,Priority                   tinyint           NOT NULL
      ,Category                   nvarchar(256)     NOT NULL
      ,MonitorAlertInd            bit               NOT NULL
      ,WorkflowGuid               uniqueidentifier  NOT NULL
      ,RaisedDateTime             datetime          NOT NULL
      ,CreatedDateTime            datetime          NOT NULL
      ,ResolutionState            tinyint           NOT NULL
      ,Owner                      nvarchar(256)     NULL
      ,TicketId                   nvarchar(256)     NULL
      ,CustomField1               nvarchar(256)     NULL
      ,CustomField2               nvarchar(256)     NULL
      ,CustomField3               nvarchar(256)     NULL
      ,CustomField4               nvarchar(256)     NULL
      ,CustomField5               nvarchar(256)     NULL
      ,CustomField6               nvarchar(256)     NULL
      ,CustomField7               nvarchar(256)     NULL
      ,CustomField8               nvarchar(256)     NULL
      ,CustomField9               nvarchar(256)     NULL
      ,CustomField10              nvarchar(256)     NULL
      ,SiteName                   nvarchar(256)     NULL
      ,AlertParams                xml               NULL
      ,ParameterHash              uniqueidentifier  NULL
      ,RepeatCount                int               NOT NULL
      ,AlertStringGuid            uniqueidentifier  NULL
      ,DBLastModifiedDateTime     datetime          NOT NULL
      ,DBLastModifiedByUserId     nvarchar(256)     NULL
      ,TfsWorkItemId              nvarchar(256)     NULL
      ,TfsWorkItemOwner           nvarchar(256)     NULL
      
      ,AlertStageRowId            int               NOT NULL
      ,AlertRowId                 int               NULL
      ,TableGuid                  uniqueidentifier  NULL
      ,ManagedEntityRowId         int               NULL
      ,WorkflowRowId              int               NULL
      ,DWCreatedDateTime          datetime          NOT NULL
  )
END
ELSE
BEGIN
    -- Table already exists, ensure TFS columns exist

    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'AlertStage2Process' AND TABLE_SCHEMA = 'Alert'
        AND COLUMN_NAME = N'TfsWorkItemId')
    ALTER TABLE [Alert].[AlertStage2Process] ADD [TfsWorkItemId] nvarchar(256) NULL

    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'AlertStage2Process' AND TABLE_SCHEMA = 'Alert'
        AND COLUMN_NAME = N'TfsWorkItemOwner')
    ALTER TABLE [Alert].[AlertStage2Process] ADD [TfsWorkItemOwner] nvarchar(256) NULL
END
GO

                    
                    -- Update Alert staging definition in StandardDatasetStagingArea
BEGIN TRAN

IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
BEGIN
  DELETE StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'
END

INSERT StandardDatasetStagingArea
(
   DatasetId
  ,StagingTableColumnDefinition
  ,BatchedProcessingSupportedInd
  ,MaxRowsToProcessPerTransactionCount
)
VALUES
(
   '$Config/DatasetId$'
  ,'
       DatasetId                  uniqueidentifier  NOT NULL
      ,ManagementGroupGuid        uniqueidentifier  NOT NULL
      ,AlertGuid                  uniqueidentifier  NOT NULL
      ,AlertProblemGuid           uniqueidentifier  NOT NULL
      ,ManagedEntityGuid          uniqueidentifier  NOT NULL
      ,AlertName                  nvarchar(256)     NOT NULL
      ,AlertDescription           nvarchar(max)     NULL
      ,Severity                   tinyint           NOT NULL
      ,Priority                   tinyint           NOT NULL
      ,Category                   nvarchar(256)     NOT NULL
      ,MonitorAlertInd            bit               NOT NULL
      ,WorkflowGuid               uniqueidentifier  NOT NULL
      ,RaisedDateTime             datetime          NOT NULL
      ,CreatedDateTime            datetime          NOT NULL
      ,ResolutionState            tinyint           NOT NULL
      ,Owner                      nvarchar(256)     NULL
      ,TicketId                   nvarchar(256)     NULL
      ,CustomField1               nvarchar(256)     NULL
      ,CustomField2               nvarchar(256)     NULL
      ,CustomField3               nvarchar(256)     NULL
      ,CustomField4               nvarchar(256)     NULL
      ,CustomField5               nvarchar(256)     NULL
      ,CustomField6               nvarchar(256)     NULL
      ,CustomField7               nvarchar(256)     NULL
      ,CustomField8               nvarchar(256)     NULL
      ,CustomField9               nvarchar(256)     NULL
      ,CustomField10              nvarchar(256)     NULL
      ,SiteName                   nvarchar(256)     NULL
      ,AlertParams                xml               NULL
      ,ParameterHash              uniqueidentifier  NULL
      ,RepeatCount                int               NOT NULL
      ,AlertStringGuid            uniqueidentifier  NULL
      ,DBLastModifiedDateTime     datetime          NOT NULL
      ,DBLastModifiedByUserId     nvarchar(256)     NULL
      ,TfsWorkItemId              nvarchar(256)     NULL
      ,TfsWorkItemOwner           nvarchar(256)     NULL
      
      ,AlertStageRowId            int               NOT NULL IDENTITY(1, 1)
      ,AlertRowId                 int               NULL
      ,TableGuid                  uniqueidentifier  NULL
      ,ManagedEntityRowId         int               NULL
      ,WorkflowRowId              int               NULL
      ,InsertReadyInd             AS (ISNULL(ManagedEntityRowId + WorkflowRowId, 0))
      ,DWCreatedDateTime          datetime          NOT NULL DEFAULT(GETUTCDATE())
  '
 ,1
 ,10000
)

COMMIT

BEGIN TRAN
SET NOCOUNT ON

-- Need to place new columns above the standard columns, requires creation of a new table, copying data, then dropping old table
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AlertStage' AND TABLE_SCHEMA = 'Alert')
BEGIN
    -- Create the new table
    DECLARE @Statement nvarchar(max)

    SELECT @Statement = 'CREATE TABLE Alert.Tmp_AlertStage (' + StagingTableColumnDefinition + ')'
    FROM StandardDatasetStagingArea
    WHERE DatasetId = '$Config/DatasetId$'

    EXECUTE (@Statement)

    -- Copy over the data from the existing AlertStage
    SET IDENTITY_INSERT Alert.Tmp_AlertStage ON
    INSERT Alert.Tmp_AlertStage
    (
        DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId

        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
    )
    SELECT
        DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId
      
        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
    FROM Alert.AlertStage
    SET IDENTITY_INSERT Alert.Tmp_AlertStage OFF

    -- Remove the old table
    DROP TABLE Alert.AlertStage

    -- Rename the temp table to the real name
    EXECUTE sp_rename N'Alert.Tmp_AlertStage', N'AlertStage', 'OBJECT'

    -- Apply indexes and permissions
    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_AlertStage_AlertGuidDBLastModifiedDateTimeResolutionStateAlertStageRowId')
    BEGIN
      CREATE INDEX IX_AlertStage_AlertGuidDBLastModifiedDateTimeResolutionStateAlertStageRowId ON Alert.AlertStage (AlertGuid, DBLastModifiedDateTime, ResolutionState, AlertStageRowId)
    END

    EXEC DomainTableRegisterIndexOptimization
           @TableName = 'AlertStage'
          ,@SchemaName = 'Alert'
          ,@DatasetId = '$Config/DatasetId$'
  
    GRANT SELECT, INSERT, UPDATE, DELETE ON Alert.AlertStage TO OpsMgrWriter
END

COMMIT

                    SET NOCOUNT ON

-- update AlertDetail table definition templates
UPDATE sdas
SET TableTemplate = 
   '
        CREATE TABLE [Alert].[AlertDetail_$Guid$]
        (
             AlertDetailRowId           int  NOT NULL  IDENTITY(1, 1)
            ,AlertGuid                  uniqueidentifier NOT NULL
            ,Owner                      nvarchar(256) NULL
            ,TicketId                   nvarchar(256) NULL
            ,CustomField1               nvarchar(256) NULL
            ,CustomField2               nvarchar(256) NULL
            ,CustomField3               nvarchar(256) NULL
            ,CustomField4               nvarchar(256) NULL
            ,CustomField5               nvarchar(256) NULL
            ,CustomField6               nvarchar(256) NULL
            ,CustomField7               nvarchar(256) NULL
            ,CustomField8               nvarchar(256) NULL
            ,CustomField9               nvarchar(256) NULL
            ,CustomField10              nvarchar(256) NULL
            ,DBLastModifiedDateTime     datetime  NOT NULL
            ,DBLastModifiedByUserId     nvarchar(256) NULL
            ,DWCreatedDateTime          datetime NOT  NULL   DEFAULT(GETUTCDATE())
            ,TfsWorkItemId              nvarchar(256) NULL
            ,TfsWorkItemOwner           nvarchar(256) NULL
            
            ,CONSTRAINT [PK_AlertDetail_$Guid$] PRIMARY KEY CLUSTERED (AlertDetailRowId) ON $DataFileGroupName$
        ) ON $DataFileGroupName$
  '
  ,CoverViewSelectClause =
  'SELECT
       AlertGuid
      ,Owner
      ,TicketId
      ,CustomField1
      ,CustomField2
      ,CustomField3
      ,CustomField4
      ,CustomField5
      ,CustomField6
      ,CustomField7
      ,CustomField8
      ,CustomField9
      ,CustomField10
      ,DBLastModifiedDateTime
      ,DBLastModifiedByUserId
      ,DWCreatedDateTime
      ,TfsWorkItemId
      ,TfsWorkItemOwner
   '
FROM StandardDatasetAggregationStorage sdas
        JOIN StandardDataset sd ON (sdas.DatasetId = sd.DatasetId)
WHERE (sd.DatasetId = '$Config/DatasetId$')
  AND (sdas.TableTag = 'detail')
  AND (sdas.DependentTableInd = 1)
GO
 
-- update all tables that were already created
DECLARE 
   @StandardDatasetTableMapRowId int
  ,@Statement nvarchar(max)
  ,@SchemaName sysname
  ,@TableNameSuffix sysname
  ,@BaseTableName sysname
  ,@FullTableName sysname

SET @StandardDatasetTableMapRowId = 0

WHILE EXISTS (SELECT *
              FROM StandardDatasetTableMap tm
              WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
                AND (tm.DatasetId = '$Config/DatasetId$')
                AND (tm.InsertInd = 1)
             )
BEGIN
  SELECT TOP 1
     @StandardDatasetTableMapRowId = tm.StandardDatasetTableMapRowId
    ,@SchemaName = sd.SchemaName
    ,@TableNameSuffix = tm.TableNameSuffix
    ,@BaseTableName = sdas.BaseTableName
  FROM StandardDatasetTableMap tm
          JOIN StandardDataset sd ON (tm.DatasetId = sd.DatasetId)
          JOIN StandardDatasetAggregationStorage sdas ON (sdas.DatasetId = tm.DatasetId) AND (sdas.AggregationTypeId = tm.AggregationTypeId)
  WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
    AND (tm.DatasetId = '$Config/DatasetId$')
    AND (tm.InsertInd = 1)
    AND (sdas.TableTag = 'detail')
    AND (sdas.DependentTableInd = 1)
  ORDER BY tm.StandardDatasetTableMapRowId

  SET @FullTableName = @BaseTableName + '_' + @TableNameSuffix
  
  IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = @FullTableName AND TABLE_SCHEMA = @SchemaName
    AND COLUMN_NAME = N'TfsWorkItemId')
  BEGIN
    SET @Statement = 'ALTER TABLE ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@FullTableName) + ' ADD TfsWorkItemId nvarchar(256) NULL'
    EXECUTE (@Statement)
  END

  IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = @FullTableName AND TABLE_SCHEMA = @SchemaName
    AND COLUMN_NAME = N'TfsWorkItemOwner')
  BEGIN
    SET @Statement = 'ALTER TABLE ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@FullTableName) + ' ADD TfsWorkItemOwner nvarchar(256) NULL'
    EXECUTE (@Statement)
  END
END
GO

-- alter cover views
EXEC StandardDatasetBuildCoverView '$Config/DatasetId$', 0
GO

  
                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'AlertProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.AlertProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.AlertProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText nvarchar(max)
      ,@OperationDurationMs bigint
      ,@ExecResult int
      ,@DebugLevel int
      ,@LockResourceName sysname
      ,@TableGuid uniqueidentifier
      ,@SchemaName sysname
      ,@MaxRowsToProcessCount int
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    -- get max # of rows to process in one shot
    SELECT @MaxRowsToProcessCount = MaxRowsToProcessPerTransactionCount
    FROM StandardDatasetStagingArea
    WHERE (DatasetId = @DatasetId)
    
    IF (@MaxRowsToProcessCount IS NULL)
    BEGIN
      -- if max row count calue is not set default to 5000
      SET @MaxRowsToProcessCount = 5000
    END
    
    -- delete old entries
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      
    DELETE TOP (@MaxRowsToProcessCount)
    FROM Alert.AlertStage
    WHERE (DatasetId = @DatasetId)
      AND (DWCreatedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()))

    -- update managed entity ids
    UPDATE s
    SET ManagedEntityRowId = me.ManagedEntityRowId
    FROM Alert.AlertStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((s.ManagedEntityGuid = me.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
    WHERE (s.ManagedEntityRowId IS NULL)
      
    -- update workflow ids
    UPDATE s
    SET WorkflowRowId = m.MonitorRowId
    FROM Alert.AlertStage s
          JOIN vMonitor m ON (s.WorkflowGuid = m.MonitorGuid)
    WHERE (s.MonitorAlertInd  = 1)
      AND (s.WorkflowRowId IS NULL)
      
    UPDATE s
    SET WorkflowRowId = r.RuleRowId
    FROM Alert.AlertStage s
          JOIN vRule r ON (s.WorkflowGuid = r.RuleGuid)
    WHERE (s.MonitorAlertInd  = 0)
      AND (s.WorkflowRowId IS NULL)
      
    BEGIN TRAN
    
    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert alert(s) into ' + @InsertTableName
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
     
    -- calculate alert tables and row ids
    DECLARE @VisitedPartition TABLE (
      PartitionGuid uniqueidentifier
    )
    
    WHILE EXISTS (SELECT *
                  FROM Alert.AlertStage s
                        CROSS JOIN StandardDatasetTableMap m
                  WHERE (s.AlertRowId IS NULL)
                    AND (m.DatasetId = @DatasetId)
                    AND (m.AggregationTypeId = 0)
                    AND ((s.RaisedDateTime BETWEEN m.StartDateTime and m.EndDateTime) OR (m.InsertInd = 1))
                    AND (NOT EXISTS (SELECT * FROM @VisitedPartition WHERE (PartitionGuid = m.TableGuid)))
                 )
    BEGIN
      SELECT TOP 1
         @TableGuid = m.TableGuid
      FROM Alert.AlertStage s
            CROSS JOIN StandardDatasetTableMap m
      WHERE (s.AlertRowId IS NULL)
        AND (m.DatasetId = @DatasetId)
        AND (m.AggregationTypeId = 0)
        AND (s.RaisedDateTime BETWEEN ISNULL(m.StartDateTime, '19000101') AND ISNULL(m.EndDateTime, '99991231'))
        AND (NOT EXISTS (SELECT * FROM @VisitedPartition WHERE (PartitionGuid = m.TableGuid)))
      ORDER BY m.StandardDatasetTableMapRowId
      
      INSERT @VisitedPartition VALUES (@TableGuid)
      
      SET @Statement =
            'UPDATE s'
          + ' SET AlertRowId = a.AlertRowId'
          + '    ,TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''''
          + ' FROM Alert.AlertStage s'
          + '      JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('Alert_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' a ON (s.AlertGuid = a.AlertGuid)'
          + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
    END

    -- check to see if AlertStage2Process table is not empty
    DECLARE @AlertStage2ProcessRowCount int
    DECLARE @SpaceUsedInfo TABLE (
               [name]       sysname
              ,[rows]       int
              ,reserved     nvarchar(100)
              ,data         nvarchar(100)
              ,index_size   nvarchar(100)
              ,unused       nvarchar(100)
            )
            
    INSERT @SpaceUsedInfo
    EXEC sp_spaceused 'Alert.AlertStage2Process'
    
    SELECT @AlertStage2ProcessRowCount = [rows]
    FROM @SpaceUsedInfo

    IF (@AlertStage2ProcessRowCount = 0)
    BEGIN
      -- move some rows to processing table if it is empty
      
      BEGIN TRAN
      
      INSERT Alert.AlertStage2Process (
         DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId
        
        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid 
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
        ,TfsWorkItemId
        ,TfsWorkItemOwner
      )
      SELECT TOP (@MaxRowsToProcessCount)
         DatasetId
        ,ManagementGroupGuid
        ,AlertGuid
        ,AlertProblemGuid
        ,ManagedEntityGuid
        ,AlertName
        ,AlertDescription
        ,Severity
        ,Priority
        ,Category
        ,MonitorAlertInd
        ,WorkflowGuid
        ,RaisedDateTime
        ,CreatedDateTime
        ,ResolutionState
        ,Owner
        ,TicketId
        ,CustomField1
        ,CustomField2
        ,CustomField3
        ,CustomField4
        ,CustomField5
        ,CustomField6
        ,CustomField7
        ,CustomField8
        ,CustomField9
        ,CustomField10
        ,SiteName
        ,AlertParams
        ,ParameterHash
        ,RepeatCount
        ,AlertStringGuid
        ,DBLastModifiedDateTime
        ,DBLastModifiedByUserId
        
        ,AlertStageRowId
        ,AlertRowId
        ,TableGuid 
        ,ManagedEntityRowId
        ,WorkflowRowId
        ,DWCreatedDateTime
        ,TfsWorkItemId
        ,TfsWorkItemOwner
      FROM Alert.AlertStage s
      WHERE (s.AlertStageRowId = (SELECT TOP 1 AlertStageRowId
                                  FROM Alert.AlertStage
                                  WHERE (AlertGuid = s.AlertGuid)
                                  ORDER BY DBLastModifiedDateTime, ResolutionState, AlertStageRowId)
                                 )
        AND (s.InsertReadyInd &gt; 0)

      DELETE s
      FROM Alert.AlertStage s
            JOIN Alert.AlertStage2Process s2p ON (s2p.AlertStageRowId = s.AlertStageRowId)

      COMMIT
    END

    -- work only with rows in processing table

    IF (EXISTS (SELECT * FROM Alert.AlertStage2Process WHERE (AlertRowId IS NULL)))
    BEGIN
      -- we have new alerts in the staging area
      -- process only the first "change" since there
      -- may be multiple changes stored in staging at
      -- the same time, if that's the case - we'll pick
      -- up all other changes next time we process staging
      SET @Statement = 
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
        + '   AlertGuid'
        + '  ,AlertProblemGuid'
        + '  ,ManagedEntityRowId'
        + '  ,AlertName'
        + '  ,AlertDescription'
        + '  ,Severity'
        + '  ,Priority'
        + '  ,Category'
        + '  ,WorkflowRowId'
        + '  ,MonitorAlertInd'
        + '  ,[DateTime]'
        + '  ,SiteName'
        + '  ,RepeatCount'
        + '  ,AlertStringGuid'
        + '  ,ParameterHash'
        + '  ,DBCreatedDateTime'
        + ' )'
        + ' SELECT'
        + '   s.AlertGuid'
        + '  ,s.AlertProblemGuid'
        + '  ,s.ManagedEntityRowId'
        + '  ,s.AlertName'
        + '  ,s.AlertDescription'
        + '  ,s.Severity'
        + '  ,s.Priority'
        + '  ,s.Category'
        + '  ,s.WorkflowRowId'
        + '  ,s.MonitorAlertInd'
        + '  ,s.RaisedDateTime'
        + '  ,s.SiteName'
        + '  ,s.RepeatCount'
        + '  ,NULLIF(s.AlertStringGuid, ''00000000-0000-0000-0000-000000000000'')'
        + '  ,NULLIF(s.ParameterHash, ''00000000-0000-0000-0000-000000000000'')'
        + '  ,s.CreatedDateTime'
        + ' FROM Alert.AlertStage2Process s'
        + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
      
      -- insert alert parameters
      CREATE TABLE #AlertParameter
      (
         AlertParameterRowId            int IDENTITY(1, 1)
        ,AlertGuid                      uniqueidentifier  NOT NULL
        ,ParameterIndex                 tinyint NULL
        ,ParameterValue                 nvarchar(255) NULL
      )
      
      INSERT #AlertParameter (
         AlertGuid
        ,ParameterValue
      )
      SELECT
         s.AlertGuid
        ,xml.ParameterValue.value('.', 'nvarchar(255)')
      FROM Alert.AlertStage2Process s
            CROSS APPLY s.AlertParams.nodes('AlertParameters/*') as xml(ParameterValue)
      WHERE (s.AlertRowId IS NULL)
      
      -- set parameter indexes
    
      UPDATE ap
      SET ap.ParameterIndex = ap.AlertParameterRowId - ap1.AlertParameterRowId + 1
      FROM #AlertParameter ap
            JOIN #AlertParameter ap1 ON (ap.AlertGuid = ap1.AlertGuid)
      WHERE NOT EXISTS (SELECT *
                        FROM #AlertParameter
                        WHERE (AlertGuid = ap1.AlertGuid)
                          AND (AlertParameterRowId &lt; ap1.AlertParameterRowId)
                       )

      SET @Statement = 
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + 'AlertParameter_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '') + '('
        + '    AlertGuid'
        + '   ,ParameterIndex'
        + '   ,ParameterValue'
        + ' )'
        + ' SELECT '
        + '    AlertGuid'
        + '   ,ParameterIndex'
        + '   ,ParameterValue'
        + ' FROM #AlertParameter'
      EXECUTE (@Statement)

      DROP TABLE #AlertParameter
      
      -- retrieve created alert ids
      SET @Statement = 
          'UPDATE s'
        + ' SET AlertRowId = a.AlertRowId'
        + '    ,TableGuid = ''' + CAST(@InsertTableGuid AS varchar(50)) + ''''
        + ' FROM Alert.AlertStage2Process s'
        + '   JOIN  ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' a ON (s.AlertGuid = a.AlertGuid)'
        + ' WHERE (s.AlertRowId IS NULL)'
      EXECUTE (@Statement)
    END

    IF (EXISTS (SELECT * FROM Alert.AlertStage2Process WHERE (AlertRowId IS NOT NULL)))
    BEGIN
      -- process alert updates
      
      -- build unique list of tables affected
      DECLARE @AffectedPartition TABLE (
         PartitionRowId int IDENTITY(1, 1)
        ,TableGuid uniqueidentifier
      )
      
      INSERT @AffectedPartition(TableGuid)
      SELECT DISTINCT TableGuid
      FROM Alert.AlertStage2Process
      WHERE (AlertRowId IS NOT NULL)
      
      DECLARE @PartitionRowId int
      
      SET @PartitionRowId = 0
      
      WHILE (EXISTS (SELECT * FROM @AffectedPartition WHERE (PartitionRowId &gt; @PartitionRowId)))
      BEGIN
        SELECT TOP 1
           @PartitionRowId = PartitionRowId
          ,@TableGuid = TableGuid
        FROM @AffectedPartition
        WHERE (PartitionRowId &gt; @PartitionRowId)
        
        -- update alert repeat count
        SET @Statement = 
            'UPDATE a'
          + ' SET RepeatCount = s.RepeatCount'
          + '    ,DWLastModifiedDateTime = GETUTCDATE()'
          + ' FROM Alert.AlertStage2Process s'
          + '       JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('Alert_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' a'
          + '             ON (s.AlertRowId = a.AlertRowId)'
          + ' WHERE (s.RepeatCount &gt; a.RepeatCount)'
        EXECUTE (@Statement)
        
        -- check which alerts have resolution state changed
        CREATE TABLE #ResolutionState (
           AlertStageRowId        int               NOT NULL
          ,AlertGuid              uniqueidentifier  NOT NULL
          ,LastResolutionState    tinyint           NULL
        )
        
        SET @Statement = 
            'INSERT #ResolutionState ('
          + '    AlertStageRowId'
          + '   ,AlertGuid'
          + '   ,LastResolutionState'
          + ')'
          + ' SELECT'
          + '    s.AlertStageRowId'
          + '   ,s.AlertGuid'
          + '   ,r.ResolutionState'
          + ' FROM Alert.AlertStage2Process s'
          + '       LEFT JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' r'
          + '             ON (s.AlertGuid = r.AlertGuid) AND (r.AlertResolutionStateRowId = (SELECT TOP 1 AlertResolutionStateRowId FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' WHERE (AlertGuid = s.AlertGuid) AND (StateSetDateTime &lt;= s.DBLastModifiedDateTime) ORDER BY StateSetDateTime DESC, ResolutionState DESC))'
          + ' WHERE (s.AlertRowId IS NOT NULL)'
          + '   AND (s.TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''')'
        EXECUTE (@Statement)
        
        -- insert resolution state changes
        SET @Statement =
            'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ('
          + '    AlertGuid'
          + '   ,ResolutionState'
          + '   ,TimeFromRaisedSeconds'
          + '   ,StateSetDateTime'
          + '   ,StateSetByUserId'
          + ' )'
          + ' SELECT'
          + '    s.AlertGuid'
          + '   ,s.ResolutionState'
          + '   ,CASE ' -- check to see if alert was raised way in the past/future
          + '      WHEN ISNULL(ABS(DATEDIFF(year, s.DBLastModifiedDateTime, s.RaisedDateTime)), 0) &gt; 3 THEN 3*365*24*60*60 '
          + '      ELSE ISNULL(ABS(DATEDIFF(second, s.DBLastModifiedDateTime, s.RaisedDateTime)), 0) '
          + '    END '
          + '   ,s.DBLastModifiedDateTime'
          + '   ,s.DBLastModifiedByUserId'
          + ' FROM #ResolutionState r'
          + '      JOIN Alert.AlertStage2Process s ON (r.AlertStageRowId = s.AlertStageRowId)'
          + ' WHERE (s.ResolutionState &lt;&gt; r.LastResolutionState) OR (r.LastResolutionState IS NULL)'
        EXECUTE (@Statement)
        
        -- update all "time in state" columns since
        -- we've added some state transitions potentially "in the middle"
        SET @Statement =
            'UPDATE ars'
          + '    SET TimeInStateSeconds = ISNULL(ABS(DATEDIFF(second, ars.StateSetDateTime, ars2.StateSetDateTime)), -1)'
          + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ars'
          + '     JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ars2'
          + '        ON (ars.AlertGuid = ars2.AlertGuid)'
          + '     JOIN (SELECT DISTINCT AlertGuid = s.AlertGuid'
          + '           FROM #ResolutionState r'
          + '             JOIN Alert.AlertStage2Process s ON (r.AlertStageRowId = s.AlertStageRowId)'
          + '           WHERE (s.ResolutionState &lt;&gt; r.LastResolutionState) OR (r.LastResolutionState IS NULL)'
          + '          ) AS al ON (ars.AlertGuid = al.AlertGuid)'
          + ' WHERE (ars2.AlertResolutionStateRowId = (SELECT TOP 1 AlertResolutionStateRowId'
          + '                                          FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertResolutionState_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', ''))
          + '                                          WHERE (AlertGuid = ars.AlertGuid)'
          + '                                            AND (StateSetDateTime &gt;= ars.StateSetDateTime)'
          + '                                            AND (AlertResolutionStateRowId &lt;&gt; ars.AlertResolutionStateRowId)'
          + '                                          ORDER BY StateSetDateTime, ResolutionState DESC'
          + '                                         ))'
        EXECUTE (@Statement)
        
        DROP TABLE #ResolutionState
        
        -- check to see if alert properties were updated
        CREATE TABLE #AlertDetail (
           AlertStageRowId            int           NOT NULL
          ,DetailRecordExistedInd     bit           NOT NULL
          ,Owner                      nvarchar(256) NULL
          ,TicketId                   nvarchar(256) NULL
          ,CustomField1               nvarchar(256) NULL
          ,CustomField2               nvarchar(256) NULL
          ,CustomField3               nvarchar(256) NULL
          ,CustomField4               nvarchar(256) NULL
          ,CustomField5               nvarchar(256) NULL
          ,CustomField6               nvarchar(256) NULL
          ,CustomField7               nvarchar(256) NULL
          ,CustomField8               nvarchar(256) NULL
          ,CustomField9               nvarchar(256) NULL
          ,CustomField10              nvarchar(256) NULL
          ,TfsWorkItemId              nvarchar(256) NULL
          ,TfsWorkItemOwner           nvarchar(256) NULL
        )
        
        SET @Statement = 
            'INSERT #AlertDetail ('
          + '    AlertStageRowId'
          + '   ,DetailRecordExistedInd'
          + '   ,Owner'
          + '   ,TicketId'
          + '   ,CustomField1'
          + '   ,CustomField2'
          + '   ,CustomField3'
          + '   ,CustomField4'
          + '   ,CustomField5'
          + '   ,CustomField6'
          + '   ,CustomField7'
          + '   ,CustomField8'
          + '   ,CustomField9'
          + '   ,CustomField10'
          + '   ,TfsWorkItemId'
          + '   ,TfsWorkItemOwner'
          + ')'
          + ' SELECT'
          + '    s.AlertStageRowId'
          + '   ,CASE WHEN d.AlertGuid IS NULL THEN 0 ELSE 1 END'
          + '   ,d.Owner'
          + '   ,d.TicketId'
          + '   ,d.CustomField1'
          + '   ,d.CustomField2'
          + '   ,d.CustomField3'
          + '   ,d.CustomField4'
          + '   ,d.CustomField5'
          + '   ,d.CustomField6'
          + '   ,d.CustomField7'
          + '   ,d.CustomField8'
          + '   ,d.CustomField9'
          + '   ,d.CustomField10'
          + '   ,d.TfsWorkItemId'
          + '   ,d.TfsWorkItemOwner'
          + ' FROM Alert.AlertStage2Process s'
          + '       LEFT JOIN ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' d ON (s.AlertGuid = d.AlertGuid)'
          + ' WHERE (s.AlertRowId IS NOT NULL)'
          + '   AND (s.TableGuid = ''' + CAST(@TableGuid AS varchar(50)) + ''')'
          + '   AND (NOT EXISTS (SELECT * FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' WHERE (AlertGuid = s.AlertGuid) AND (DBLastModifiedDateTime &lt;= s.DBLastModifiedDateTime) AND (AlertDetailRowId &gt; d.AlertDetailRowId)))'
        EXECUTE (@Statement)
        
        -- insert alert detail changes
        SET @Statement =
            'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME('AlertDetail_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')) + ' ('
          + '    AlertGuid'
          + '   ,Owner'
          + '   ,TicketId'
          + '   ,CustomField1'
          + '   ,CustomField2'
          + '   ,CustomField3'
          + '   ,CustomField4'
          + '   ,CustomField5'
          + '   ,CustomField6'
          + '   ,CustomField7'
          + '   ,CustomField8'
          + '   ,CustomField9'
          + '   ,CustomField10'
          + '   ,DBLastModifiedDateTime'
          + '   ,DBLastModifiedByUserId'
          + '   ,TfsWorkItemId'
          + '   ,TfsWorkItemOwner'
          + ' )'
          + ' SELECT'
          + '    s.AlertGuid'
          + '   ,s.Owner'
          + '   ,s.TicketId'
          + '   ,s.CustomField1'
          + '   ,s.CustomField2'
          + '   ,s.CustomField3'
          + '   ,s.CustomField4'
          + '   ,s.CustomField5'
          + '   ,s.CustomField6'
          + '   ,s.CustomField7'
          + '   ,s.CustomField8'
          + '   ,s.CustomField9'
          + '   ,s.CustomField10'
          + '   ,s.DBLastModifiedDateTime'
          + '   ,s.DBLastModifiedByUserId'
          + '   ,s.TfsWorkItemId'
          + '   ,s.TfsWorkItemOwner'
          + ' FROM #AlertDetail d'
          + '      JOIN Alert.AlertStage2Process s ON (d.AlertStageRowId = s.AlertStageRowId)'
          + ' WHERE (ISNULL(s.Owner, '''') &lt;&gt; ISNULL(d.Owner, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TicketId, '''') &lt;&gt; ISNULL(d.TicketId, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField1, '''') &lt;&gt; ISNULL(d.CustomField1, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField2, '''') &lt;&gt; ISNULL(d.CustomField2, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField3, '''') &lt;&gt; ISNULL(d.CustomField3, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField4, '''') &lt;&gt; ISNULL(d.CustomField4, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField5, '''') &lt;&gt; ISNULL(d.CustomField5, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField6, '''') &lt;&gt; ISNULL(d.CustomField6, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField7, '''') &lt;&gt; ISNULL(d.CustomField7, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField8, '''') &lt;&gt; ISNULL(d.CustomField8, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField9, '''') &lt;&gt; ISNULL(d.CustomField9, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.CustomField10, '''') &lt;&gt; ISNULL(d.CustomField10, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TfsWorkItemId, '''') &lt;&gt; ISNULL(d.TfsWorkItemId, '''') COLLATE database_default)'
          + '    OR (ISNULL(s.TfsWorkItemOwner, '''') &lt;&gt; ISNULL(d.TfsWorkItemOwner, '''') COLLATE database_default)'
          + '    OR (d.DetailRecordExistedInd = 0)'
        EXECUTE (@Statement)
        
        DROP TABLE #AlertDetail
        
        -- mark affected table as non-optimized
        UPDATE StandardDatasetTableMap
        SET OptimizedInd = 0
        WHERE (DatasetId = @DatasetId)
          AND (AggregationTypeId = 0)
          AND (TableGuid = @TableGuid)
          AND (InsertInd = 0)
      END
    END
  
    TRUNCATE TABLE Alert.AlertStage2Process
  
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting alert(s) into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process alert staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

            </Upgrade></DataWarehouseDataSet><DataWarehouseDataSet ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Event" Accessibility="Public"><Dependencies><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Storage" type="AggregationSettingsType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime" type="TimeOfDayType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger"/></Configuration><Install> 
                    SET NOCOUNT ON

EXEC StandardDatasetDelete @DatasetId = '$Config/DatasetId$'
GO

INSERT StandardDataset (
   DatasetId 
  ,SchemaName
  ,DefaultAggregationIntervalCount
  ,RawInsertTableCount
  ,StagingProcessorStoredProcedureName
  ,BlockingMaintenanceDailyStartTime
  ,BlockingMaintenanceDurationMinutes
)
VALUES
(
   '$Config/DatasetId$'
  ,'Event'
  ,0
  ,$Config/RawInsertTableCount$
  ,'EventProcessStaging'
  ,'$Config/BlockingMaintenanceDailyStartTime$'
  ,$Config/BlockingMaintenanceDurationMinutes$
)
GO

                    SET NOCOUNT ON

INSERT StandardDatasetAggregation
(                               
   DatasetId
  ,AggregationTypeId
  ,AggregationIntervalDurationMinutes
  ,AggregationStartDelayMinutes
  ,BuildAggregationStoredProcedureName
  ,DeleteAggregationStoredProcedureName
  ,GroomStoredProcedureName
  ,IndexOptimizationIntervalMinutes
  ,MaxDataAgeDays
  ,GroomingIntervalMinutes
  ,MaxRowsToGroom
  ,LastGroomingDateTime
  ,DataFileGroupName
  ,IndexFileGroupName
)
VALUES (
   '$Config/DatasetId$'
  ,0
  ,NULL
  ,NULL
  ,NULL
  ,NULL
  ,'EventGroom'
  ,$Config/Storage/IndexOptimizationIntervalMinutes$
  ,$Config/Storage/MaxDataAgeDays$
  ,$Config/Storage/GroomingIntervalMinutes$
  ,$Config/Storage/MaxRowsToGroom$
  ,GETUTCDATE()
  ,ISNULL(CAST(NULLIF('$Config/Storage/DataFileGroupName$', '') AS sysname), 'default')
  ,ISNULL(CAST(NULLIF('$Config/Storage/IndexFileGroupName$', '') AS sysname), 'default')
)
GO

                    SET NOCOUNT ON

DECLARE
   @MaxTableRowCount    int
  ,@MaxTableSizeKb      int
  
SELECT
   @MaxTableSizeKb = NULLIF('$Config/Storage/MaxTableSizeKb$', '')
  ,@MaxTableRowCount = NULLIF('$Config/Storage/MaxTableRowCount$', '')
  
INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'Event'
  ,0
  ,'
        CREATE TABLE [Event].[Event_$Guid$]
        (
             EventRowId int  NOT NULL  IDENTITY(1, 1)
            ,EventOriginId                  uniqueidentifier  NOT NULL
            ,[DateTime]                     datetime          NOT NULL
            ,EventPublisherRowId            int               NOT NULL
            ,EventChannelRowId              smallint          NOT NULL
            ,EventCategoryRowId             int               NOT NULL
            ,EventLevelId                   tinyint           NOT NULL
            ,LoggingComputerRowId           int               NOT NULL
            ,EventNumber                    bigint            NOT NULL
            ,EventDisplayNumber             int               NOT NULL
            ,UserNameRowId                  int               NOT NULL
            ,RawDescriptionHash             uniqueidentifier  NULL
            ,ParameterHash                  uniqueidentifier  NULL
            ,EventDataHash                  uniqueidentifier  NULL
            
            ,CONSTRAINT [PK_Event_$Guid$] PRIMARY KEY CLUSTERED (EventRowId) ON $DataFileGroupName$
        ) ON $DataFileGroupName$
  '
  ,'SELECT
       EventOriginId
      ,[DateTime]
      ,EventPublisherRowId
      ,EventChannelRowId
      ,EventCategoryRowId
      ,EventLevelId
      ,LoggingComputerRowId
      ,EventNumber
      ,EventDisplayNumber
      ,UserNameRowId
      ,RawDescriptionHash
      ,ParameterHash
      ,EventDataHash
   '
  ,@MaxTableRowCount
  ,@MaxTableSizeKb
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'EventRule'
  ,'rule'
  ,1
  ,'
        CREATE TABLE [Event].[EventRule_$Guid$]
        (
             EventRuleRowId       int               NOT NULL  IDENTITY(1, 1)
            ,EventOriginId        uniqueidentifier  NOT NULL
            ,RuleRowId            int               NOT NULL
            ,ManagedEntityRowId   int               NOT NULL
            
            ,CONSTRAINT [PK_EventRule_$Guid$] PRIMARY KEY CLUSTERED (EventRuleRowId) ON $DataFileGroupName$

        ) ON $DataFileGroupName$
  '
  ,'SELECT
       EventOriginId
      ,RuleRowId
      ,ManagedEntityRowId
   '
  ,@MaxTableRowCount
  ,@MaxTableSizeKb
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'EventParameter'
  ,'parameter'
  ,1
  ,'
        CREATE TABLE [Event].[EventParameter_$Guid$]
        (
             EventParameterRowId int  NOT NULL  IDENTITY(1, 1)
            ,EventOriginId                  uniqueidentifier  NOT NULL
            ,ParameterIndex                 tinyint NOT NULL
            ,ParameterValue                 nvarchar(max) NULL
            
            ,CONSTRAINT [PK_EventParameter_$Guid$] PRIMARY KEY CLUSTERED (EventParameterRowId) ON $DataFileGroupName$

        ) ON $DataFileGroupName$
  '
  ,'SELECT
       EventOriginId
      ,ParameterIndex
      ,ParameterValue
   '
  ,@MaxTableRowCount
  ,@MaxTableSizeKb
)

INSERT StandardDatasetAggregationStorage
(                               
   DatasetId
  ,AggregationTypeId
  ,BaseTableName
  ,TableTag
  ,DependentTableInd
  ,TableTemplate
  ,CoverViewSelectClause
  ,MaxTableRowCount
  ,MaxTableSizeKb 
)
VALUES
(
   '$Config/DatasetId$'
  ,0
  ,'EventDetail'
  ,'detail'
  ,1
  ,'
        CREATE TABLE [Event].[EventDetail_$Guid$]
        (
             EventDetailRowId int  NOT NULL  IDENTITY(1, 1)
            ,EventOriginId                  uniqueidentifier  NOT NULL
            ,RawDescription                 nvarchar(max)     NULL
            ,RenderedDescription            nvarchar(max)     NULL
            ,EventData                      xml               NULL
            
            ,CONSTRAINT [PK_EventDetail_$Guid$] PRIMARY KEY CLUSTERED (EventDetailRowId) ON $DataFileGroupName$
        ) ON $DataFileGroupName$
  '
  ,'SELECT
       EventOriginId
      ,RawDescription
      ,RenderedDescription
      ,EventData
   '
  ,@MaxTableRowCount
  ,@MaxTableSizeKb
)
GO

                    -- main event table indexes

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = 'FADEE782-6397-4D34-B0C9-10DD260C7D76'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = 'FADEE782-6397-4D34-B0C9-10DD260C7D76'
  ,@IndexDefinition = '([DateTime])'
  ,@CreateIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '4CFFAA7E-9B6C-432C-B90C-0A28994FAE6F'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 1
  ,@IndexGuid = '4CFFAA7E-9B6C-432C-B90C-0A28994FAE6F'
  ,@IndexDefinition = '(EventOriginId)'
  ,@CreateIndexOnExistingTablesInd = 0

-- parameter table indexes

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '2E308EFB-5FFB-48ac-8A55-A43751F569F5'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 1
  ,@TableTag = 'parameter'
  ,@UniqueInd = 1
  ,@IndexGuid = '2E308EFB-5FFB-48ac-8A55-A43751F569F5'
  ,@IndexDefinition = '(EventOriginId, ParameterIndex)'
  ,@CreateIndexOnExistingTablesInd = 0

-- detail table indexes

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '04937270-50DE-49b8-AB6F-0E214749914A'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 1
  ,@TableTag = 'detail'
  ,@UniqueInd = 1
  ,@IndexGuid = '04937270-50DE-49b8-AB6F-0E214749914A'
  ,@IndexDefinition = '(EventOriginId)'
  ,@CreateIndexOnExistingTablesInd = 0

                    IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = 'Event')
BEGIN
  EXECUTE('CREATE SCHEMA Event')
END
GO

-- change schema ownership to allow index rebuild and reorganize
ALTER AUTHORIZATION ON SCHEMA::Event TO OpsMgrWriter
GO

-- change schema alter to allow domain table index rebuild
GRANT ALTER ON SCHEMA::dbo TO OpsMgrWriter
GO

-- grant create table permissions
GRANT CREATE TABLE TO OpsMgrWriter
GO

EXEC StandardDatasetAllocateStorage @DatasetId = '$Config/DatasetId$', @AggregationTypeId = 0
GO

                    
                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventCategory' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventCategory
END
GO

CREATE TABLE dbo.EventCategory
(                               
     EventCategoryRowId     int             NOT NULL    IDENTITY(1,1)
    ,EventPublisherRowId    int             NOT NULL
    ,EventCategoryId        int             NOT NULL
    ,EventCategoryTitle     nvarchar(255)   NOT NULL
    ,LastReceivedDateTime   smalldatetime   NOT NULL    DEFAULT (GETUTCDATE())
 
    ,CONSTRAINT PK_EventCategory PRIMARY KEY CLUSTERED (EventCategoryRowId)
    ,CONSTRAINT UN_EventCategory_PublisherIdEventCategoryId UNIQUE (EventPublisherRowId, EventCategoryId)
)
GO
 
CREATE INDEX IX_EventCategory_LastReceivedDateTime ON EventCategory (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EventCategory'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventChannel' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventChannel
END
GO

CREATE TABLE dbo.EventChannel
(                               
     EventChannelRowId      smallint        NOT NULL    IDENTITY(1,1)
    ,EventChannelTitle      nvarchar(255)   NOT NULL
    ,LastReceivedDateTime   smalldatetime   NOT NULL    DEFAULT (GETUTCDATE())
 
    ,CONSTRAINT PK_EventChannel PRIMARY KEY CLUSTERED (EventChannelRowId)
    ,CONSTRAINT UN_EventChannel_EventChannelTitle UNIQUE (EventChannelTitle)
)
GO

CREATE INDEX IX_EventChannel_LastReceivedDateTime ON EventChannel (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EventChannel'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventLevel' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventLevel
END
GO

CREATE TABLE dbo.EventLevel
(                               
     EventLevelId       tinyint         NOT NULL
    ,EventLevelTitle    nvarchar(255)   NOT NULL
 
    ,CONSTRAINT PK_EventLevel PRIMARY KEY CLUSTERED (EventLevelId)
)
GO
 
                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventLoggingComputer' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventLoggingComputer
END
GO

CREATE TABLE dbo.EventLoggingComputer
(                               
     EventLoggingComputerRowId  int             NOT NULL    IDENTITY(1,1)
    ,ComputerName               nvarchar(255)   NOT NULL
    ,LastReceivedDateTime       smalldatetime   NOT NULL    DEFAULT (GETUTCDATE())
 
    ,CONSTRAINT PK_EventLoggingComputer PRIMARY KEY CLUSTERED (EventLoggingComputerRowId)
    ,CONSTRAINT UN_EventLoggingComputer_ComputerName UNIQUE (ComputerName)
)
GO

CREATE INDEX IX_EventLoggingComputer_LastReceivedDateTime ON EventLoggingComputer (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EventLoggingComputer'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventPublisher' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventPublisher
END
GO

CREATE TABLE dbo.EventPublisher
(                               
     EventPublisherRowId      int             NOT NULL    IDENTITY(1,1)
    ,EventPublisherGuid       uniqueidentifier NOT NULL
    ,EventPublisherName       nvarchar(255)   NOT NULL
    ,LastReceivedDateTime     smalldatetime   NOT NULL    DEFAULT (GETUTCDATE())
 
    ,CONSTRAINT PK_EventPublisher PRIMARY KEY CLUSTERED (EventPublisherRowId)
    ,CONSTRAINT UN_EventPublisher_PublisherGuid UNIQUE (EventPublisherGuid)
)
GO

CREATE INDEX IX_EventPublisher_LastReceivedDateTime ON EventPublisher (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EventPublisher'
      ,@DatasetId = '$Config/DatasetId$'
GO



                    -- insert staging definition into StandardDatasetStagingArea
BEGIN TRAN

IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
BEGIN
  DELETE StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'
END

INSERT StandardDatasetStagingArea
(
   DatasetId
  ,StagingTableColumnDefinition
  ,MaxRowsToProcessPerTransactionCount
  ,BatchedProcessingSupportedInd
)
VALUES
(
   '$Config/DatasetId$'
  ,'
   DatasetId                      uniqueidentifier  NOT NULL
  ,ManagementGroupGuid            uniqueidentifier  NOT NULL
  ,EventOriginId                  uniqueidentifier  NOT NULL
  ,[DateTime]                     datetime          NOT NULL
  ,RuleRowId                      int               NOT NULL
  ,ManagedEntityRowId             int               NOT NULL
  ,EventPublisherRowId            int               NOT NULL
  ,EventChannelRowId              smallint          NOT NULL
  ,EventCategoryRowId             int               NOT NULL
  ,EventLevelId                   tinyint           NOT NULL
  ,LoggingComputerRowId           int               NOT NULL
  ,EventDisplayNumber             int               NOT NULL
  ,EventNumber                    bigint            NOT NULL
  ,UserNameRowId                  int               NOT NULL
  ,RawDescription                 nvarchar(max)     NULL
  ,RenderedDescription            nvarchar(max)     NULL
  ,EventParameters                xml               NULL
  ,EventData                      xml               NULL
  ,RawDescriptionHash             uniqueidentifier  NULL
  ,ParameterHash                  uniqueidentifier  NULL
  ,EventDataHash                  uniqueidentifier  NULL
  
  ,EventStageRowId                bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
  '
 ,20000
 ,1
)

COMMIT

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventStage' AND TABLE_SCHEMA = 'Event')
BEGIN
  DECLARE @Statement nvarchar(max)

  SELECT @Statement = 'CREATE TABLE Event.EventStage (' + StagingTableColumnDefinition + ')'
  FROM StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'

  EXECUTE (@Statement)
END
GO

GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Event.EventStage TO OpsMgrWriter
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventUserName' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.EventUserName
END
GO

CREATE TABLE dbo.EventUserName
(                               
     EventUserNameRowId     int             NOT NULL    IDENTITY(1,1)
    ,UserName               nvarchar(255)   NOT NULL
    ,LastReceivedDateTime   smalldatetime   NOT NULL    DEFAULT (GETUTCDATE())
 
    ,CONSTRAINT PK_EventUserName PRIMARY KEY CLUSTERED (EventUserNameRowId)
    ,CONSTRAINT UN_EventUserName_UserName UNIQUE (UserName)
)
GO

CREATE INDEX IX_EventUserName_LastReceivedDateTime ON EventUserName (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'EventUserName'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    
                    SET NOCOUNT ON

DELETE EventLevel

INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES ( 0, N'Undefined')
INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES ( 1, N'Error')
INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES ( 2, N'Warning')
INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES ( 4, N'Information')
INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES ( 8, N'Success Audit')
INSERT EventLevel(EventLevelId, EventLevelTitle) VALUES (16, N'Failure Audit')
GO
 
                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventCategory')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventCategory AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventCategory
AS
  SELECT *
  FROM dbo.EventCategory (NOLOCK)
GO

GRANT SELECT ON dbo.vEventCategory TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventChannel')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventChannel AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventChannel
AS
  SELECT *
  FROM dbo.EventChannel (NOLOCK)
GO

GRANT SELECT ON dbo.vEventChannel TO OpsMgrReader, OpsMgrWriter
GO

                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventLevel')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventLevel AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventLevel
AS
  SELECT *
  FROM dbo.EventLevel (NOLOCK)
GO

GRANT SELECT ON dbo.vEventLevel TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventLoggingComputer')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventLoggingComputer AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventLoggingComputer
AS
  SELECT *
  FROM dbo.EventLoggingComputer (NOLOCK)
GO

GRANT SELECT ON dbo.vEventLoggingComputer TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventPublisher')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventPublisher AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventPublisher
AS
  SELECT *
  FROM dbo.EventPublisher (NOLOCK)
GO

GRANT SELECT ON dbo.vEventPublisher TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventUserName')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vEventUserName AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vEventUserName
AS
  SELECT *
  FROM dbo.EventUserName (NOLOCK)
GO

GRANT SELECT ON dbo.vEventUserName TO OpsMgrReader, OpsMgrWriter
GO


                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventCategoryRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventCategoryRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventCategoryRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventCategoryKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventCategory') IS NOT NULL)
      DROP TABLE #EventCategory
    
    CREATE TABLE #EventCategory (
       NodeOrdinal    int               NOT NULL
      ,PublisherGuid  uniqueidentifier  NOT NULL
      ,PublisherName  nvarchar(256)     NOT NULL
      ,CategoryId     int               NOT NULL
      ,CategoryTitle  nvarchar(256)     NOT NULL
    )
    
    INSERT #EventCategory (
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
      ,CategoryId
      ,CategoryTitle
    )
    SELECT
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
      ,CategoryId
      ,CategoryTitle
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,PublisherGuid    uniqueidentifier  'PublisherGuid'
                    ,PublisherName    nvarchar(256)     'PublisherName'
                    ,CategoryId       int               'CategoryId'
                    ,CategoryTitle    nvarchar(256)     'CategoryTitle') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    -- work with publisher domain first
    
    UPDATE ep
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventPublisher ep
          JOIN #EventCategory e ON (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ep.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventPublisher (EventPublisherGuid, EventPublisherName)
    SELECT DISTINCT e.PublisherGuid, e.PublisherName
    FROM #EventCategory e
    WHERE NOT EXISTS (SELECT * FROM EventPublisher WHERE (EventPublisherGuid = e.PublisherGuid))
    
    -- update category domain
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventCategory ec
          JOIN EventPublisher ep ON (ec.EventPublisherRowId = ep.EventPublisherRowId)
          JOIN #EventCategory e ON (ec.EventCategoryId = e.CategoryId) AND (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventCategory (
       EventPublisherRowId
      ,EventCategoryId
      ,EventCategoryTitle
    )
    SELECT DISTINCT
       ep.EventPublisherRowId
      ,e.CategoryId
      ,e.CategoryTitle
    FROM #EventCategory e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
    WHERE NOT EXISTS (SELECT *
                      FROM EventCategory
                      WHERE (EventCategoryId = e.CategoryId)
                        AND (EventPublisherRowId = ep.EventPublisherRowId)
                     )

    SELECT
       ec.EventCategoryRowId
    FROM #EventCategory e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
            JOIN EventCategory ec ON (e.CategoryId = ec.EventCategoryId) AND (ec.EventPublisherRowId = ep.EventPublisherRowId)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventCategory') IS NOT NULL)
    DROP TABLE #EventCategory
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventCategoryRowIdResolve TO OpsMgrWriter
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventChannelRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventChannelRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventChannelRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventChannelKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventChannel') IS NOT NULL)
      DROP TABLE #EventChannel
      
    CREATE TABLE #EventChannel (
       NodeOrdinal    int               NOT NULL
      ,ChannelName    nvarchar(256)     NOT NULL
    )
    
    INSERT #EventChannel (
       NodeOrdinal
      ,ChannelName
    )
    SELECT
       NodeOrdinal
      ,ChannelName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,ChannelName      nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventChannel ec
          JOIN #EventChannel e ON (ec.EventChannelTitle = e.ChannelName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventChannel (EventChannelTitle)
    SELECT DISTINCT e.ChannelName
    FROM #EventChannel e
    WHERE NOT EXISTS (SELECT * FROM EventChannel WHERE (EventChannelTitle = e.ChannelName COLLATE database_default))

    SELECT
       CAST(ec.EventChannelRowId AS int)
    FROM #EventChannel e
            JOIN EventChannel ec ON (e.ChannelName = ec.EventChannelTitle COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventChannel') IS NOT NULL)
    DROP TABLE #EventChannel

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventChannelRowIdResolve TO OpsMgrWriter
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  sysname
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @MainTableName sysname
    ,@TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@StandardDatasetAggregationStorageRowId int
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    BEGIN TRAN
    
    CREATE TABLE #EventGroom (
      EventOriginId uniqueidentifier NOT NULL
    )
    
    SELECT @MainTableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'INSERT #EventGroom (EventOriginId)'
                   + ' SELECT TOP ' + CAST(@MaxRowsToGroom AS varchar(15)) + ' EventOriginId'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'
                   
    EXECUTE (@Statement)

    SET @StandardDatasetAggregationStorageRowId = 0
    
    WHILE EXISTS (SELECT *
                  FROM StandardDatasetAggregationStorage
                  WHERE (DatasetId = @DatasetId)
                    AND (AggregationTypeId = @AggregationTypeId)
                    AND (DependentTableInd = 1)
                    AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
                 )
    BEGIN
      SELECT TOP 1
         @StandardDatasetAggregationStorageRowId = StandardDatasetAggregationStorageRowId
        ,@TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
      FROM StandardDatasetAggregationStorage
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @AggregationTypeId)
        AND (DependentTableInd = 1)
        AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
		Order By StandardDatasetAggregationStorageRowId Asc
        
      SET @Statement = 'DELETE d'
                     + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' d'
                     + '  JOIN #EventGroom e ON (d.EventOriginId = e.EventOriginId)'
      EXECUTE (@Statement)
    END
    
    SET @Statement = 'DELETE d'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName) +' d'
                   + '   JOIN #EventGroom e ON (d.EventOriginId = e.EventOriginId)'
    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    DROP TABLE #EventGroom
    
    COMMIT
    
    -- groom dynamic dimentions
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MAX(MaxDataAgeDays)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
    
    DELETE e
    FROM EventCategory e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE())
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventChannel e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventLoggingComputer e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventPublisher e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventUserName e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for event data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventLoggingComputerRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventLoggingComputerRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventLoggingComputerRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventLoggingComputerKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventLoggingComputer') IS NOT NULL)
      DROP TABLE #EventLoggingComputer
      
    CREATE TABLE #EventLoggingComputer (
       NodeOrdinal          int               NOT NULL
      ,ComputerName         nvarchar(256)     NOT NULL
    )
    
    INSERT #EventLoggingComputer (
       NodeOrdinal
      ,ComputerName
    )
    SELECT
       NodeOrdinal
      ,LoggingComputerName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal            int               '@mp:id'
                    ,LoggingComputerName    nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventLoggingComputer ec
          JOIN #EventLoggingComputer e ON (ec.ComputerName = e.ComputerName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventLoggingComputer (ComputerName)
    SELECT DISTINCT e.ComputerName
    FROM #EventLoggingComputer e
    WHERE NOT EXISTS (SELECT * FROM EventLoggingComputer WHERE (ComputerName = e.ComputerName COLLATE database_default))

    SELECT
       ec.EventLoggingComputerRowId
    FROM #EventLoggingComputer e
            JOIN EventLoggingComputer ec ON (e.ComputerName = ec.ComputerName COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventLoggingComputer') IS NOT NULL)
    DROP TABLE #EventLoggingComputer

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventLoggingComputerRowIdResolve TO OpsMgrWriter
GO
   
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  DECLARE
     @DebugLevel int
    ,@SchemaName sysname
    ,@ExecResult int
    ,@LockResourceName sysname
    ,@InsertTableName sysname
    ,@InsertTableGuid uniqueidentifier
    ,@InsertStartedDateTime datetime
    ,@Statement nvarchar(max)
    ,@MessageText varchar(max)
    ,@OperationDurationMs bigint
    ,@MaxStagingRowsToProcess int

  BEGIN TRY
  
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventStage2Process' AND TABLE_SCHEMA = 'Event')
    BEGIN
      BEGIN TRAN
      
      DECLARE @ProcessAllRowsInd bit
      SET @ProcessAllRowsInd = 1
      
      -- figure out what we need to do with staging area
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = MaxRowsToProcessPerTransactionCount
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
      
      IF (@MaxStagingRowsToProcess IS NOT NULL)
      BEGIN
        DECLARE @EventStageRowCount int
        DECLARE @SpaceUsedInfo TABLE (
                   [name]       sysname
                  ,[rows]       int
                  ,reserved     nvarchar(100)
                  ,data         nvarchar(100)
                  ,index_size   nvarchar(100)
                  ,unused       nvarchar(100)
                )
                
        INSERT @SpaceUsedInfo
        EXEC sp_spaceused 'Event.EventStage'
        
        SELECT @EventStageRowCount = [rows]
        FROM @SpaceUsedInfo
        
        IF (@EventStageRowCount &gt;= @MaxStagingRowsToProcess)
        BEGIN
          SET @ProcessAllRowsInd = 0
        END
      END
      
      IF (@ProcessAllRowsInd = 1)
      BEGIN
        -- no limit set for the number of rows to process
        -- rename and re-create staging table

        -- lock, rename EventStage table and re-create it
        EXEC @ExecResult = sp_rename 'Event.EventStage', 'EventStage2Process'
        
        IF (@ExecResult &lt; 0)
        BEGIN
          RAISERROR(777971003, 16, 1, @ExecResult)
        END

        SELECT @Statement = 'CREATE TABLE Event.EventStage (' + @Statement + ')'
        EXECUTE (@Statement)        
      END
      ELSE
      BEGIN
        -- need to process subset of rows
        -- create extra column to store original row id
        SELECT @Statement =
              'CREATE TABLE Event.EventStage2Process (' 
            + @Statement
            + ',OriginalEventStageRowId  int  NOT NULL'
            + ')'
        EXECUTE (@Statement)
        
        SELECT @Statement =
          ' INSERT Event.EventStage2Process'
        + '  ('
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,EventOriginId'
        + '    ,[DateTime]'
        + '    ,RuleRowId'
        + '    ,ManagedEntityRowId'
        + '    ,EventPublisherRowId'
        + '    ,EventChannelRowId'
        + '    ,EventCategoryRowId'
        + '    ,EventLevelId'
        + '    ,LoggingComputerRowId'
        + '    ,EventDisplayNumber'
        + '    ,EventNumber'
        + '    ,UserNameRowId'
        + '    ,RawDescription'
        + '    ,RenderedDescription'
        + '    ,EventParameters'
        + '    ,EventData'
        + '    ,RawDescriptionHash'
        + '    ,ParameterHash'
        + '    ,EventDataHash'
        + '    ,OriginalEventStageRowId'
        + '  )'
        + '  SELECT TOP (' + CAST(@MaxStagingRowsToProcess AS varchar(15)) + ')'
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,EventOriginId'
        + '    ,[DateTime]'
        + '    ,RuleRowId'
        + '    ,ManagedEntityRowId'
        + '    ,EventPublisherRowId'
        + '    ,EventChannelRowId'
        + '    ,EventCategoryRowId'
        + '    ,EventLevelId'
        + '    ,LoggingComputerRowId'
        + '    ,EventDisplayNumber'
        + '    ,EventNumber'
        + '    ,UserNameRowId'
        + '    ,RawDescription'
        + '    ,RenderedDescription'
        + '    ,EventParameters'
        + '    ,EventData'
        + '    ,RawDescriptionHash'
        + '    ,ParameterHash'
        + '    ,EventDataHash'
        + '    ,EventStageRowId'
        + '  FROM Event.EventStage'
        + '  ORDER BY EventStageRowId'
        EXECUTE(@Statement)

        SELECT @Statement = 
          ' CREATE INDEX IX_EventStage2Process_EventOriginId ON Event.EventStage2Process (EventOriginId)'
        EXECUTE(@Statement)
        
        SELECT @Statement =
          'DELETE es'
        + ' FROM Event.EventStage es'
        + '        JOIN Event.EventStage2Process esp ON (es.EventStageRowId = esp.OriginalEventStageRowId)'
        EXECUTE(@Statement)
      END
      
      GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Event.EventStage TO OpsMgrWriter
      
      GRANT CONTROL ON Event.EventStage2Process TO OpsMgrWriter

      COMMIT
    END
    
    BEGIN TRAN

    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert ' + CAST(COUNT(*) AS varchar(30)) + ' events into ' + @InsertTableName
      FROM Event.EventStage2Process
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END

    -- insert event &lt;-&gt; rule/me relationships
    -- NOTE: We do not check for event-rule-ME uniqueness
    --       to save time (can produce dupes if event was delivered twice
    --       in two different staging processing windows)
    --       We also saw Sql having troubles coming up with a good plan
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'rule')
      
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,RuleRowId'
      + '   ,ManagedEntityRowId'
      + ' )'
      + ' SELECT'
      + '    s.EventOriginId'
      + '   ,s.RuleRowId'
      + '   ,s.ManagedEntityRowId'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)

    -- delete events collected more then once - leave latest collected only
    DELETE s
    FROM Event.EventStage2Process s
    WHERE EXISTS (SELECT *
                  FROM Event.EventStage2Process s_later
                  WHERE (s.EventOriginId = s_later.EventOriginId)
                    AND (s_later.EventStageRowId &gt; s.EventStageRowId)
                 )

    -- insert events
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    -- first delete events that were already delivered

    SELECT @Statement = 'DELETE s'
                        + ' FROM Event.EventStage2Process s, ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' e'
                        + ' WHERE (s.EventOriginId = e.EventOriginId)'
    EXECUTE (@Statement)

    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,[DateTime]'
      + '   ,EventPublisherRowId'
      + '   ,EventChannelRowId'
      + '   ,EventCategoryRowId'
      + '   ,EventLevelId'
      + '   ,LoggingComputerRowId'
      + '   ,EventNumber'
      + '   ,EventDisplayNumber'
      + '   ,UserNameRowId'
      + '   ,RawDescriptionHash'
      + '   ,ParameterHash'
      + '   ,EventDataHash'
      + ' )'
      + ' SELECT '
      + '    s.EventOriginId'
      + '   ,s.[DateTime]'
      + '   ,s.EventPublisherRowId'
      + '   ,s.EventChannelRowId'
      + '   ,s.EventCategoryRowId'
      + '   ,s.EventLevelId'
      + '   ,s.LoggingComputerRowId'
      + '   ,s.EventNumber'
      + '   ,s.EventDisplayNumber'
      + '   ,s.UserNameRowId'
      + '   ,s.RawDescriptionHash'
      + '   ,s.ParameterHash'
      + '   ,s.EventDataHash'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)
    
    -- insert parameters
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'parameter')
    
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   EventOriginId'
      + '  ,ParameterIndex'
      + '  ,ParameterValue'
      + ' )'
      + ' SELECT '
      + '   s.EventOriginId'
      + '  ,ROW_NUMBER() OVER(PARTITION BY s.EventOriginId ORDER BY s.EventOriginId)'
      + '  ,p.ParameterValue.value(''.'', ''nvarchar(max)'')'
      + ' FROM Event.EventStage2Process s'
      + '       CROSS APPLY s.EventParameters.nodes(''Params/Param'') as p(ParameterValue)'

    EXECUTE(@Statement)

    -- insert event details

    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'detail')
    
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   EventOriginId'
      + '  ,RawDescription'
      + '  ,RenderedDescription'
      + '  ,EventData'
      + ' )'
      + ' SELECT '
      + '   s.EventOriginId'
      + '  ,s.RawDescription'
      + '  ,s.RenderedDescription'
      + '  ,s.EventData'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)

    -- delete all inserted data from staging
    DROP TABLE Event.EventStage2Process
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting events into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END

    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the event data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON dbo.EventProcessStaging TO OpsMgrWriter
GO


                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventPublisherRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventPublisherRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventPublisherRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventPublisherKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventPublisher') IS NOT NULL)
      DROP TABLE #EventPublisher

    CREATE TABLE #EventPublisher (
       NodeOrdinal    int               NOT NULL
      ,PublisherGuid  uniqueidentifier  NOT NULL
      ,PublisherName  nvarchar(256)     NOT NULL
    )
    
    INSERT #EventPublisher (
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
    )
    SELECT
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal          int               '@mp:id'
                    ,PublisherGuid        uniqueidentifier  'PublisherGuid'
                    ,PublisherName        nvarchar(256)     'PublisherName') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ep
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventPublisher ep
          JOIN #EventPublisher e ON (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ep.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventPublisher (EventPublisherGuid, EventPublisherName)
    SELECT DISTINCT e.PublisherGuid, e.PublisherName
    FROM #EventPublisher e
    WHERE NOT EXISTS (SELECT * FROM EventPublisher WHERE (EventPublisherGuid = e.PublisherGuid))

    SELECT
       ep.EventPublisherRowId
    FROM #EventPublisher e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventPublisher') IS NOT NULL)
    DROP TABLE #EventPublisher

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventPublisherRowIdResolve TO OpsMgrWriter
GO
  
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventUserNameRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventUserNameRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventUserNameRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventUserNameKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventUserName') IS NOT NULL)
      DROP TABLE #EventUserName

    CREATE TABLE #EventUserName (
       NodeOrdinal    int               NOT NULL
      ,UserName       nvarchar(256)     NOT NULL
    )
    
    INSERT #EventUserName (
       NodeOrdinal
      ,UserName
    )
    SELECT
       NodeOrdinal
      ,UserName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,UserName         nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventUserName ec
          JOIN #EventUserName e ON (ec.UserName = e.UserName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventUserName (UserName)
    SELECT DISTINCT e.UserName
    FROM #EventUserName e
    WHERE NOT EXISTS (SELECT * FROM EventUserName WHERE (UserName = e.UserName COLLATE database_default))

    SELECT
       ec.EventUserNameRowId
    FROM #EventUserName e
            JOIN EventUserName ec ON (e.UserName = ec.UserName COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventUserName') IS NOT NULL)
    DROP TABLE #EventUserName

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventUserNameRowIdResolve TO OpsMgrWriter
GO
   
                    </Install><Uninstall>
                    -- drop SPs
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventGroom')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventGroom')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventProcessStaging')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventProcessStaging')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventCategoryRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventCategoryRowIdResolve')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventChannelRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventChannelRowIdResolve')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventLoggingComputerRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventLoggingComputerRowIdResolve')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventPublisherRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventPublisherRowIdResolve')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventUserNameRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.EventUserNameRowIdResolve')
END

-- drop views
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventCategory')
BEGIN
  EXECUTE ('DROP VIEW vEventCategory')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventChannel')
BEGIN
  EXECUTE ('DROP VIEW vEventChannel')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventLevel')
BEGIN
  EXECUTE ('DROP VIEW vEventLevel')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventLoggingComputer')
BEGIN
  EXECUTE ('DROP VIEW vEventLoggingComputer')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventPublisher')
BEGIN
  EXECUTE ('DROP VIEW vEventPublisher')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vEventUserName')
BEGIN
  EXECUTE ('DROP VIEW vEventUserName')
END

-- drop tables
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventCategory' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventCategory')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventChannel' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventChannel')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventLevel' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventLevel')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventLoggingComputer' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventLoggingComputer')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventPublisher' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventPublisher')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventUserName' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.EventUserName')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventStage' AND TABLE_SCHEMA = 'Event')
BEGIN
  EXECUTE('DROP TABLE Event.EventStage')
END

-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
  
                    </Uninstall><Upgrade>
										SET NOCOUNT ON

-- update table definition templates
UPDATE sdas
SET TableTemplate = '
        CREATE TABLE [Event].[EventParameter_$Guid$]
        (
             EventParameterRowId int  NOT NULL  IDENTITY(1, 1)
            ,EventOriginId                  uniqueidentifier  NOT NULL
            ,ParameterIndex                 tinyint NOT NULL
            ,ParameterValue                 nvarchar(max) NULL
            
            ,CONSTRAINT [PK_EventParameter_$Guid$] PRIMARY KEY CLUSTERED (EventParameterRowId) ON $DataFileGroupName$

        ) ON $DataFileGroupName$
     '
FROM StandardDatasetAggregationStorage sdas
        JOIN StandardDataset sd ON (sdas.DatasetId = sd.DatasetId)
WHERE (sd.DatasetId = '$Config/DatasetId$')
  AND (sdas.TableTag = 'parameter')
  AND (sdas.DependentTableInd = 1)
GO
 
-- update all tables that were already created
DECLARE 
   @StandardDatasetTableMapRowId int
  ,@Statement nvarchar(max)
  ,@SchemaName sysname
  ,@TableNameSuffix sysname
  ,@BaseTableName sysname

SET @StandardDatasetTableMapRowId = 0

WHILE EXISTS (SELECT *
              FROM StandardDatasetTableMap tm
              WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
                AND (tm.DatasetId = '$Config/DatasetId$')
                AND (tm.InsertInd = 1)
             )
BEGIN
  SELECT TOP 1
     @StandardDatasetTableMapRowId = tm.StandardDatasetTableMapRowId
    ,@SchemaName = sd.SchemaName
    ,@TableNameSuffix = tm.TableNameSuffix
    ,@BaseTableName = sdas.BaseTableName
  FROM StandardDatasetTableMap tm
          JOIN StandardDataset sd ON (tm.DatasetId = sd.DatasetId)
          JOIN StandardDatasetAggregationStorage sdas ON (sdas.DatasetId = tm.DatasetId) AND (sdas.AggregationTypeId = tm.AggregationTypeId)
  WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
    AND (tm.DatasetId = '$Config/DatasetId$')
    AND (tm.InsertInd = 1)
    AND (sdas.TableTag = 'parameter')
    AND (sdas.DependentTableInd = 1)
  ORDER BY tm.StandardDatasetTableMapRowId
  
  SET @Statement = 'ALTER TABLE ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@BaseTableName + '_' + @TableNameSuffix)
                 + ' ALTER COLUMN ParameterValue nvarchar(max) NULL'
                 
  EXECUTE (@Statement)
END
GO

-- alter cover views
EXEC StandardDatasetBuildCoverView '$Config/DatasetId$', 0
GO

 

                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventCategoryRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventCategoryRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventCategoryRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventCategoryKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventCategory') IS NOT NULL)
      DROP TABLE #EventCategory
    
    CREATE TABLE #EventCategory (
       NodeOrdinal    int               NOT NULL
      ,PublisherGuid  uniqueidentifier  NOT NULL
      ,PublisherName  nvarchar(256)     NOT NULL
      ,CategoryId     int               NOT NULL
      ,CategoryTitle  nvarchar(256)     NOT NULL
    )
    
    INSERT #EventCategory (
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
      ,CategoryId
      ,CategoryTitle
    )
    SELECT
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
      ,CategoryId
      ,CategoryTitle
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,PublisherGuid    uniqueidentifier  'PublisherGuid'
                    ,PublisherName    nvarchar(256)     'PublisherName'
                    ,CategoryId       int               'CategoryId'
                    ,CategoryTitle    nvarchar(256)     'CategoryTitle') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    -- work with publisher domain first
    
    UPDATE ep
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventPublisher ep
          JOIN #EventCategory e ON (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ep.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventPublisher (EventPublisherGuid, EventPublisherName)
    SELECT DISTINCT e.PublisherGuid, e.PublisherName
    FROM #EventCategory e
    WHERE NOT EXISTS (SELECT * FROM EventPublisher WHERE (EventPublisherGuid = e.PublisherGuid))
    
    -- update category domain
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventCategory ec
          JOIN EventPublisher ep ON (ec.EventPublisherRowId = ep.EventPublisherRowId)
          JOIN #EventCategory e ON (ec.EventCategoryId = e.CategoryId) AND (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventCategory (
       EventPublisherRowId
      ,EventCategoryId
      ,EventCategoryTitle
    )
    SELECT DISTINCT
       ep.EventPublisherRowId
      ,e.CategoryId
      ,e.CategoryTitle
    FROM #EventCategory e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
    WHERE NOT EXISTS (SELECT *
                      FROM EventCategory
                      WHERE (EventCategoryId = e.CategoryId)
                        AND (EventPublisherRowId = ep.EventPublisherRowId)
                     )

    SELECT
       ec.EventCategoryRowId
    FROM #EventCategory e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
            JOIN EventCategory ec ON (e.CategoryId = ec.EventCategoryId) AND (ec.EventPublisherRowId = ep.EventPublisherRowId)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventCategory') IS NOT NULL)
    DROP TABLE #EventCategory
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventCategoryRowIdResolve TO OpsMgrWriter
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventChannelRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventChannelRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventChannelRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventChannelKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventChannel') IS NOT NULL)
      DROP TABLE #EventChannel
      
    CREATE TABLE #EventChannel (
       NodeOrdinal    int               NOT NULL
      ,ChannelName    nvarchar(256)     NOT NULL
    )
    
    INSERT #EventChannel (
       NodeOrdinal
      ,ChannelName
    )
    SELECT
       NodeOrdinal
      ,ChannelName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,ChannelName      nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventChannel ec
          JOIN #EventChannel e ON (ec.EventChannelTitle = e.ChannelName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventChannel (EventChannelTitle)
    SELECT DISTINCT e.ChannelName
    FROM #EventChannel e
    WHERE NOT EXISTS (SELECT * FROM EventChannel WHERE (EventChannelTitle = e.ChannelName COLLATE database_default))

    SELECT
       CAST(ec.EventChannelRowId AS int)
    FROM #EventChannel e
            JOIN EventChannel ec ON (e.ChannelName = ec.EventChannelTitle COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventChannel') IS NOT NULL)
    DROP TABLE #EventChannel

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventChannelRowIdResolve TO OpsMgrWriter
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  sysname
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @MainTableName sysname
    ,@TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@StandardDatasetAggregationStorageRowId int
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    BEGIN TRAN
    
    CREATE TABLE #EventGroom (
      EventOriginId uniqueidentifier NOT NULL
    )
    
    SELECT @MainTableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'INSERT #EventGroom (EventOriginId)'
                   + ' SELECT TOP ' + CAST(@MaxRowsToGroom AS varchar(15)) + ' EventOriginId'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'
                   
    EXECUTE (@Statement)

    SET @StandardDatasetAggregationStorageRowId = 0
    
    WHILE EXISTS (SELECT *
                  FROM StandardDatasetAggregationStorage
                  WHERE (DatasetId = @DatasetId)
                    AND (AggregationTypeId = @AggregationTypeId)
                    AND (DependentTableInd = 1)
                    AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
                 )
    BEGIN
      SELECT TOP 1
         @StandardDatasetAggregationStorageRowId = StandardDatasetAggregationStorageRowId
        ,@TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
      FROM StandardDatasetAggregationStorage
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @AggregationTypeId)
        AND (DependentTableInd = 1)
        AND (StandardDatasetAggregationStorageRowId &gt; @StandardDatasetAggregationStorageRowId)
		Order By StandardDatasetAggregationStorageRowId Asc
        
      SET @Statement = 'DELETE d'
                     + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' d'
                     + '  JOIN #EventGroom e ON (d.EventOriginId = e.EventOriginId)'
      EXECUTE (@Statement)
    END
    
    SET @Statement = 'DELETE d'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@MainTableName) +' d'
                   + '   JOIN #EventGroom e ON (d.EventOriginId = e.EventOriginId)'
    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    DROP TABLE #EventGroom
    
    COMMIT
    
    -- groom dynamic dimentions
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MAX(MaxDataAgeDays)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
    
    DELETE e
    FROM EventCategory e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE())
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventChannel e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventLoggingComputer e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventPublisher e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE e
    FROM EventUserName e
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for event data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventLoggingComputerRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventLoggingComputerRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventLoggingComputerRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventLoggingComputerKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventLoggingComputer') IS NOT NULL)
      DROP TABLE #EventLoggingComputer
      
    CREATE TABLE #EventLoggingComputer (
       NodeOrdinal          int               NOT NULL
      ,ComputerName         nvarchar(256)     NOT NULL
    )
    
    INSERT #EventLoggingComputer (
       NodeOrdinal
      ,ComputerName
    )
    SELECT
       NodeOrdinal
      ,LoggingComputerName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal            int               '@mp:id'
                    ,LoggingComputerName    nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventLoggingComputer ec
          JOIN #EventLoggingComputer e ON (ec.ComputerName = e.ComputerName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventLoggingComputer (ComputerName)
    SELECT DISTINCT e.ComputerName
    FROM #EventLoggingComputer e
    WHERE NOT EXISTS (SELECT * FROM EventLoggingComputer WHERE (ComputerName = e.ComputerName COLLATE database_default))

    SELECT
       ec.EventLoggingComputerRowId
    FROM #EventLoggingComputer e
            JOIN EventLoggingComputer ec ON (e.ComputerName = ec.ComputerName COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventLoggingComputer') IS NOT NULL)
    DROP TABLE #EventLoggingComputer

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventLoggingComputerRowIdResolve TO OpsMgrWriter
GO
   
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  DECLARE
     @DebugLevel int
    ,@SchemaName sysname
    ,@ExecResult int
    ,@LockResourceName sysname
    ,@InsertTableName sysname
    ,@InsertTableGuid uniqueidentifier
    ,@InsertStartedDateTime datetime
    ,@Statement nvarchar(max)
    ,@MessageText varchar(max)
    ,@OperationDurationMs bigint
    ,@MaxStagingRowsToProcess int

  BEGIN TRY
  
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'EventStage2Process' AND TABLE_SCHEMA = 'Event')
    BEGIN
      BEGIN TRAN
      
      DECLARE @ProcessAllRowsInd bit
      SET @ProcessAllRowsInd = 1
      
      -- figure out what we need to do with staging area
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = MaxRowsToProcessPerTransactionCount
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
      
      IF (@MaxStagingRowsToProcess IS NOT NULL)
      BEGIN
        DECLARE @EventStageRowCount int
        DECLARE @SpaceUsedInfo TABLE (
                   [name]       sysname
                  ,[rows]       int
                  ,reserved     nvarchar(100)
                  ,data         nvarchar(100)
                  ,index_size   nvarchar(100)
                  ,unused       nvarchar(100)
                )
                
        INSERT @SpaceUsedInfo
        EXEC sp_spaceused 'Event.EventStage'
        
        SELECT @EventStageRowCount = [rows]
        FROM @SpaceUsedInfo
        
        IF (@EventStageRowCount &gt;= @MaxStagingRowsToProcess)
        BEGIN
          SET @ProcessAllRowsInd = 0
        END
      END
      
      IF (@ProcessAllRowsInd = 1)
      BEGIN
        -- no limit set for the number of rows to process
        -- rename and re-create staging table

        -- lock, rename EventStage table and re-create it
        EXEC @ExecResult = sp_rename 'Event.EventStage', 'EventStage2Process'
        
        IF (@ExecResult &lt; 0)
        BEGIN
          RAISERROR(777971003, 16, 1, @ExecResult)
        END

        SELECT @Statement = 'CREATE TABLE Event.EventStage (' + @Statement + ')'
        EXECUTE (@Statement)        
      END
      ELSE
      BEGIN
        -- need to process subset of rows
        -- create extra column to store original row id
        SELECT @Statement =
              'CREATE TABLE Event.EventStage2Process (' 
            + @Statement
            + ',OriginalEventStageRowId  int  NOT NULL'
            + ')'
        EXECUTE (@Statement)
        
        SELECT @Statement =
          ' INSERT Event.EventStage2Process'
        + '  ('
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,EventOriginId'
        + '    ,[DateTime]'
        + '    ,RuleRowId'
        + '    ,ManagedEntityRowId'
        + '    ,EventPublisherRowId'
        + '    ,EventChannelRowId'
        + '    ,EventCategoryRowId'
        + '    ,EventLevelId'
        + '    ,LoggingComputerRowId'
        + '    ,EventDisplayNumber'
        + '    ,EventNumber'
        + '    ,UserNameRowId'
        + '    ,RawDescription'
        + '    ,RenderedDescription'
        + '    ,EventParameters'
        + '    ,EventData'
        + '    ,RawDescriptionHash'
        + '    ,ParameterHash'
        + '    ,EventDataHash'
        + '    ,OriginalEventStageRowId'
        + '  )'
        + '  SELECT TOP (' + CAST(@MaxStagingRowsToProcess AS varchar(15)) + ')'
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,EventOriginId'
        + '    ,[DateTime]'
        + '    ,RuleRowId'
        + '    ,ManagedEntityRowId'
        + '    ,EventPublisherRowId'
        + '    ,EventChannelRowId'
        + '    ,EventCategoryRowId'
        + '    ,EventLevelId'
        + '    ,LoggingComputerRowId'
        + '    ,EventDisplayNumber'
        + '    ,EventNumber'
        + '    ,UserNameRowId'
        + '    ,RawDescription'
        + '    ,RenderedDescription'
        + '    ,EventParameters'
        + '    ,EventData'
        + '    ,RawDescriptionHash'
        + '    ,ParameterHash'
        + '    ,EventDataHash'
        + '    ,EventStageRowId'
        + '  FROM Event.EventStage'
        + '  ORDER BY EventStageRowId'
        EXECUTE(@Statement)

        SELECT @Statement = 
          ' CREATE INDEX IX_EventStage2Process_EventOriginId ON Event.EventStage2Process (EventOriginId)'
        EXECUTE(@Statement)
        
        SELECT @Statement =
          'DELETE es'
        + ' FROM Event.EventStage es'
        + '        JOIN Event.EventStage2Process esp ON (es.EventStageRowId = esp.OriginalEventStageRowId)'
        EXECUTE(@Statement)
      END
      
      GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Event.EventStage TO OpsMgrWriter
      
      GRANT CONTROL ON Event.EventStage2Process TO OpsMgrWriter

      COMMIT
    END
    
    BEGIN TRAN

    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert ' + CAST(COUNT(*) AS varchar(30)) + ' events into ' + @InsertTableName
      FROM Event.EventStage2Process
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END

    -- insert event &lt;-&gt; rule/me relationships
    -- NOTE: We do not check for event-rule-ME uniqueness
    --       to save time (can produce dupes if event was delivered twice
    --       in two different staging processing windows)
    --       We also saw Sql having troubles coming up with a good plan
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'rule')
      
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,RuleRowId'
      + '   ,ManagedEntityRowId'
      + ' )'
      + ' SELECT'
      + '    s.EventOriginId'
      + '   ,s.RuleRowId'
      + '   ,s.ManagedEntityRowId'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)

    -- delete events collected more then once - leave latest collected only
    DELETE s
    FROM Event.EventStage2Process s
    WHERE EXISTS (SELECT *
                  FROM Event.EventStage2Process s_later
                  WHERE (s.EventOriginId = s_later.EventOriginId)
                    AND (s_later.EventStageRowId &gt; s.EventStageRowId)
                 )

    -- insert events
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    -- first delete events that were already delivered

    SELECT @Statement = 'DELETE s'
                        + ' FROM Event.EventStage2Process s, ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' e'
                        + ' WHERE (s.EventOriginId = e.EventOriginId)'
    EXECUTE (@Statement)

    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,[DateTime]'
      + '   ,EventPublisherRowId'
      + '   ,EventChannelRowId'
      + '   ,EventCategoryRowId'
      + '   ,EventLevelId'
      + '   ,LoggingComputerRowId'
      + '   ,EventNumber'
      + '   ,EventDisplayNumber'
      + '   ,UserNameRowId'
      + '   ,RawDescriptionHash'
      + '   ,ParameterHash'
      + '   ,EventDataHash'
      + ' )'
      + ' SELECT '
      + '    s.EventOriginId'
      + '   ,s.[DateTime]'
      + '   ,s.EventPublisherRowId'
      + '   ,s.EventChannelRowId'
      + '   ,s.EventCategoryRowId'
      + '   ,s.EventLevelId'
      + '   ,s.LoggingComputerRowId'
      + '   ,s.EventNumber'
      + '   ,s.EventDisplayNumber'
      + '   ,s.UserNameRowId'
      + '   ,s.RawDescriptionHash'
      + '   ,s.ParameterHash'
      + '   ,s.EventDataHash'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)
    
    -- insert parameters
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'parameter')
    
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   EventOriginId'
      + '  ,ParameterIndex'
      + '  ,ParameterValue'
      + ' )'
      + ' SELECT '
      + '   s.EventOriginId'
      + '  ,ROW_NUMBER() OVER(PARTITION BY s.EventOriginId ORDER BY s.EventOriginId)'
      + '  ,p.ParameterValue.value(''.'', ''nvarchar(max)'')'
      + ' FROM Event.EventStage2Process s'
      + '       CROSS APPLY s.EventParameters.nodes(''Params/Param'') as p(ParameterValue)'

    EXECUTE(@Statement)

    -- insert event details

    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 1)
      AND (TableTag = 'detail')
    
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   EventOriginId'
      + '  ,RawDescription'
      + '  ,RenderedDescription'
      + '  ,EventData'
      + ' )'
      + ' SELECT '
      + '   s.EventOriginId'
      + '  ,s.RawDescription'
      + '  ,s.RenderedDescription'
      + '  ,s.EventData'
      + ' FROM Event.EventStage2Process s'

    EXECUTE(@Statement)

    -- delete all inserted data from staging
    DROP TABLE Event.EventStage2Process
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting events into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END

    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the event data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON dbo.EventProcessStaging TO OpsMgrWriter
GO


                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventPublisherRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventPublisherRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventPublisherRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventPublisherKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventPublisher') IS NOT NULL)
      DROP TABLE #EventPublisher

    CREATE TABLE #EventPublisher (
       NodeOrdinal    int               NOT NULL
      ,PublisherGuid  uniqueidentifier  NOT NULL
      ,PublisherName  nvarchar(256)     NOT NULL
    )
    
    INSERT #EventPublisher (
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
    )
    SELECT
       NodeOrdinal
      ,PublisherGuid
      ,PublisherName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal          int               '@mp:id'
                    ,PublisherGuid        uniqueidentifier  'PublisherGuid'
                    ,PublisherName        nvarchar(256)     'PublisherName') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ep
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventPublisher ep
          JOIN #EventPublisher e ON (ep.EventPublisherGuid = e.PublisherGuid)
    WHERE (ep.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventPublisher (EventPublisherGuid, EventPublisherName)
    SELECT DISTINCT e.PublisherGuid, e.PublisherName
    FROM #EventPublisher e
    WHERE NOT EXISTS (SELECT * FROM EventPublisher WHERE (EventPublisherGuid = e.PublisherGuid))

    SELECT
       ep.EventPublisherRowId
    FROM #EventPublisher e
            JOIN EventPublisher ep ON (e.PublisherGuid = ep.EventPublisherGuid)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventPublisher') IS NOT NULL)
    DROP TABLE #EventPublisher

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventPublisherRowIdResolve TO OpsMgrWriter
GO
  
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'EventUserNameRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.EventUserNameRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.EventUserNameRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'EventUserNameKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#EventUserName') IS NOT NULL)
      DROP TABLE #EventUserName

    CREATE TABLE #EventUserName (
       NodeOrdinal    int               NOT NULL
      ,UserName       nvarchar(256)     NOT NULL
    )
    
    INSERT #EventUserName (
       NodeOrdinal
      ,UserName
    )
    SELECT
       NodeOrdinal
      ,UserName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal      int               '@mp:id'
                    ,UserName         nvarchar(256)     '.') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    UPDATE ec
    SET LastReceivedDateTime = GETUTCDATE()
    FROM EventUserName ec
          JOIN #EventUserName e ON (ec.UserName = e.UserName COLLATE database_default)
    WHERE (ec.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT EventUserName (UserName)
    SELECT DISTINCT e.UserName
    FROM #EventUserName e
    WHERE NOT EXISTS (SELECT * FROM EventUserName WHERE (UserName = e.UserName COLLATE database_default))

    SELECT
       ec.EventUserNameRowId
    FROM #EventUserName e
            JOIN EventUserName ec ON (e.UserName = ec.UserName COLLATE database_default)
    ORDER BY e.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#EventUserName') IS NOT NULL)
    DROP TABLE #EventUserName

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON EventUserNameRowIdResolve TO OpsMgrWriter
GO
   

                    SET NOCOUNT ON

UPDATE StandardDatasetStagingArea
SET StagingTableColumnDefinition = 
  'DatasetId                      uniqueidentifier  NOT NULL
  ,ManagementGroupGuid            uniqueidentifier  NOT NULL
  ,EventOriginId                  uniqueidentifier  NOT NULL
  ,[DateTime]                     datetime          NOT NULL
  ,RuleRowId                      int               NOT NULL
  ,ManagedEntityRowId             int               NOT NULL
  ,EventPublisherRowId            int               NOT NULL
  ,EventChannelRowId              smallint          NOT NULL
  ,EventCategoryRowId             int               NOT NULL
  ,EventLevelId                   tinyint           NOT NULL
  ,LoggingComputerRowId           int               NOT NULL
  ,EventDisplayNumber             int               NOT NULL
  ,EventNumber                    bigint            NOT NULL
  ,UserNameRowId                  int               NOT NULL
  ,RawDescription                 nvarchar(max)     NULL
  ,RenderedDescription            nvarchar(max)     NULL
  ,EventParameters                xml               NULL
  ,EventData                      xml               NULL
  ,RawDescriptionHash             uniqueidentifier  NULL
  ,ParameterHash                  uniqueidentifier  NULL
  ,EventDataHash                  uniqueidentifier  NULL
  
  ,EventStageRowId                bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
  '
,MaxRowsToProcessPerTransactionCount = CASE WHEN MaxRowsToProcessPerTransactionCount &lt; 20000 THEN MaxRowsToProcessPerTransactionCount ELSE 20000 END
WHERE DatasetId = '$Config/DatasetId$'

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
               WHERE (TABLE_NAME = 'EventStage')
                 AND (TABLE_SCHEMA = 'Event')
                 AND (CONSTRAINT_TYPE = 'PRIMARY KEY')
)
BEGIN
  ALTER TABLE Event.EventStage
    ADD CONSTRAINT PK_EventStage PRIMARY KEY NONCLUSTERED (EventStageRowId)
END
GO

                    </Upgrade></DataWarehouseDataSet><DataWarehouseDataSet ID="Microsoft.SystemCenter.DataWarehouse.DataSet.Performance" Accessibility="Public"><Dependencies><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Aggregations" type="AggregationsType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DefaultAggregationIntervalCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime" type="TimeOfDayType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger"/></Configuration><Install> 
                    SET NOCOUNT ON

EXEC StandardDatasetDelete @DatasetId = '$Config/DatasetId$'
GO

INSERT StandardDataset (
   DatasetId 
  ,SchemaName
  ,DefaultAggregationIntervalCount
  ,RawInsertTableCount
  ,StagingProcessorStoredProcedureName
  ,BlockingMaintenanceDailyStartTime
  ,BlockingMaintenanceDurationMinutes
)
VALUES
(
   '$Config/DatasetId$'
  ,'Perf'
  ,$Config/DefaultAggregationIntervalCount$
  ,$Config/RawInsertTableCount$
  ,'PerformanceProcessStaging'
  ,'$Config/BlockingMaintenanceDailyStartTime$'
  ,$Config/BlockingMaintenanceDurationMinutes$
)

                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText varchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'PerfAggregation', @ExecResult)

  INSERT StandardDatasetAggregation
  (                               
     DatasetId
    ,AggregationTypeId
    ,AggregationIntervalDurationMinutes
    ,AggregationStartDelayMinutes
    ,BuildAggregationStoredProcedureName
    ,DeleteAggregationStoredProcedureName
    ,GroomStoredProcedureName
    ,IndexOptimizationIntervalMinutes
    ,MaxDataAgeDays
    ,GroomingIntervalMinutes
    ,MaxRowsToGroom
    ,LastGroomingDateTime
    ,DataFileGroupName
    ,IndexFileGroupName
  )
  SELECT
     '$Config/DatasetId$'
    ,CASE AggregationType
       WHEN 'Raw' THEN 0
       WHEN 'Subhourly' THEN 10
       WHEN 'Hourly' THEN 20
       WHEN 'Daily' THEN 30
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       WHEN 'Subhourly' THEN AggregationIntervalDurationMinutes
       WHEN 'Hourly' THEN 60
       WHEN 'Daily' THEN 24*60
     END
    ,AggregationStartDelayMinutes
    ,'PerformanceAggregate'
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       ELSE 'PerformanceAggregationDelete'
     END
    ,'PerformanceGroom'
    ,IndexOptimizationIntervalMinutes
    ,MaxDataAgeDays
    ,GroomingIntervalMinutes
    ,MaxRowsToGroom
    ,GETUTCDATE()
    ,DataFileGroupName
    ,IndexFileGroupName
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
       AggregationType                    varchar(50)   '@mp:localname'
      ,MaxTableRowCount                   int
      ,MaxTableSizeKb                     int
      ,AggregationStartDelayMinutes       int
      ,MaxDataAgeDays                     int
      ,GroomingIntervalMinutes            int
      ,MaxRowsToGroom                     int
      ,IndexOptimizationIntervalMinutes   int
      ,DataFileGroupName                  nvarchar(256)
      ,IndexFileGroupName                 nvarchar(256)
      ,AggregationIntervalDurationMinutes int
  )
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO
 
                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'PerfAggregation', @ExecResult)

  INSERT StandardDatasetAggregationStorage
  (                               
     DatasetId
    ,AggregationTypeId
    ,BaseTableName
    ,DependentTableInd
    ,TableTemplate
    ,CoverViewSelectClause
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  )
  SELECT
     '$Config/DatasetId$'
    ,CASE AggregationType
       WHEN 'Raw' THEN 0
       WHEN 'Subhourly' THEN 10
       WHEN 'Hourly' THEN 20
       WHEN 'Daily' THEN 30
     END
    ,BaseTableName
    ,0
    ,CASE AggregationType
       WHEN 'Raw' THEN '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(BaseTableName + 'RowId') + ' bigint  NOT NULL  IDENTITY(1, 1)
                    ,[DateTime]                     datetime  NOT NULL
                    ,PerformanceRuleInstanceRowId   int       NOT NULL
                    ,ManagedEntityRowId             int       NOT NULL
                    ,SampleValue                    float(53) NULL
                    
                    ,CONSTRAINT ' + QUOTENAME('PK_' + BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       '
       ELSE '
                CREATE TABLE '  + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(BaseTableName + 'RowId') + ' bigint  NOT NULL  IDENTITY(1, 1)
                    ,[DateTime]                     datetime  NOT NULL
                    ,PerformanceRuleInstanceRowId   int       NOT NULL
                    ,ManagedEntityRowId             int       NOT NULL
                    ,SampleCount                    int       NOT NULL
                    ,AverageValue                   float(53) NOT NULL
                    ,MinValue                       float(53) NOT NULL
                    ,MaxValue                       float(53) NOT NULL
                    ,StandardDeviation              float(53) NOT NULL
                    
                    ,CONSTRAINT ' + QUOTENAME('PK_' + BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       '
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN '
          SELECT
             [DateTime]
            ,PerformanceRuleInstanceRowId
            ,ManagedEntityRowId
            ,SampleValue
       '
       ELSE '
          SELECT
             [DateTime]
            ,PerformanceRuleInstanceRowId
            ,ManagedEntityRowId
            ,SampleCount
            ,AverageValue
            ,MinValue
            ,MaxValue
            ,StandardDeviation
       '
     END
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
       AggregationType      varchar(50)   '@mp:localname'
      ,BaseTableName        varchar(256)
      ,MaxTableRowCount     int
      ,MaxTableSizeKb       int
      ,DataFileGroupName    varchar(256)
      ,IndexFileGroupName    varchar(256)
  )
      CROSS JOIN StandardDataset d
  WHERE (d.DatasetId = '$Config/DatasetId$')
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO
  
                    SET NOCOUNT ON
GO

-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@IndeGuid uniqueidentifier

SET @AggregationTypeId = -1

WHILE EXISTS (SELECT *
              FROM StandardDatasetAggregation
              WHERE (DatasetId = '$Config/DatasetId$')
                AND (AggregationTypeId &gt; @AggregationTypeId)
             )
BEGIN
  SELECT @IndeGuid = NEWID()
  
  SELECT TOP 1 
     @AggregationTypeId = AggregationTypeId
    ,@Statement = 
      ' EXEC StandardDatasetIndexDelete'
    + '    @DatasetId = ''$Config/DatasetId$'''
    + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
	  + '   ,@DeleteIndexOnExistingTablesInd = 0'
    + ' EXEC StandardDatasetIndexInsert'
    + '    @DatasetId = ''$Config/DatasetId$'''
    + '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
    + '   ,@DependentTableInd = 0'
    + '   ,@TableTag = NULL'
    + '   ,@UniqueInd = 0'
    + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
    + '   ,@IndexDefinition = ''([DateTime])'''
    + '   ,@CreateIndexOnExistingTablesInd = 0'
  FROM StandardDatasetAggregation
  WHERE (DatasetId = '$Config/DatasetId$')
    AND (AggregationTypeId &gt; @AggregationTypeId)
  ORDER BY AggregationTypeId
  
  EXECUTE (@Statement)
END
GO

/* raw indexes for UI perf widget perf */

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = 'A136E27D-A83E-4F38-B9A3-35EAAFBFCBE8'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 0
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = 'A136E27D-A83E-4F38-B9A3-35EAAFBFCBE8'
  ,@IndexDefinition = '(
	[ManagedEntityRowId],
	[PerformanceRuleInstanceRowId],
	[DateTime]
)
INCLUDE
(
	[SampleValue]
)
'
  ,@CreateIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '7A6FE25B-785D-463b-AA56-98D36511DDDD'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 20
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '7A6FE25B-785D-463b-AA56-98D36511DDDD'
  ,@IndexDefinition = '(
	[ManagedEntityRowId],
	[PerformanceRuleInstanceRowId],
	[DateTime]
)
INCLUDE
(
	[SampleCount],
	[AverageValue],
	[MinValue],
	[MaxValue],
	[StandardDeviation]
)
'
  ,@CreateIndexOnExistingTablesInd = 0




/* hourly indexes for report perf */

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '7A6FE25B-785D-463b-AA56-98D36511DDDD'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 20
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '7A6FE25B-785D-463b-AA56-98D36511DDDD'
  ,@IndexDefinition = '(
	[ManagedEntityRowId],
	[PerformanceRuleInstanceRowId],
	[DateTime]
)
INCLUDE
(
	[SampleCount],
	[AverageValue],
	[MinValue],
	[MaxValue],
	[StandardDeviation]
)
'
  ,@CreateIndexOnExistingTablesInd = 0

/* daily indexes for report perf */

EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '0DF81F2E-FB92-4451-8716-DCF777EDFA45'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
   @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 30
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '0DF81F2E-FB92-4451-8716-DCF777EDFA45'
  ,@IndexDefinition = '(
	[ManagedEntityRowId],
	[PerformanceRuleInstanceRowId],
	[DateTime]
)
INCLUDE
(
	[SampleCount],
	[AverageValue],
	[MinValue],
	[MaxValue],
	[StandardDeviation]
)
'
  ,@CreateIndexOnExistingTablesInd = 0

-- Hourly data index to support Top N reports and dashboards
EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '04DE2C08-6203-4DA1-8EED-A0984463C46E'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
    @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 20
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '04DE2C08-6203-4DA1-8EED-A0984463C46E'
  ,@IndexDefinition = '(
        [PerformanceRuleInstanceRowId]
        ,[DateTime]
      )
      INCLUDE
      (
        [ManagedEntityRowId]
        ,[SampleCount]
        ,[AverageValue]
      )
  '
,@CreateIndexOnExistingTablesInd = 0

-- Daily data index to support Top N reports and dashboards
EXEC StandardDatasetIndexDelete
   @DatasetId = '$Config/DatasetId$'
  ,@IndexGuid = '110C2981-0D21-4C6E-8185-49997A2BA0B5'
	,@DeleteIndexOnExistingTablesInd = 0

EXEC StandardDatasetIndexInsert
    @DatasetId = '$Config/DatasetId$'
  ,@AggregationTypeId = 30
  ,@DependentTableInd = 0
  ,@TableTag = NULL
  ,@UniqueInd = 0
  ,@IndexGuid = '110C2981-0D21-4C6E-8185-49997A2BA0B5'
  ,@IndexDefinition = '(
        [PerformanceRuleInstanceRowId]
        ,[DateTime]
      )
      INCLUDE
      (
        [ManagedEntityRowId]
        ,[SampleCount]
        ,[AverageValue]
      )
  '
,@CreateIndexOnExistingTablesInd = 0

                    IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = 'Perf')
BEGIN
  EXECUTE('CREATE SCHEMA Perf')
END
GO

-- change schema ownership to allow index rebuild and reorganize
ALTER AUTHORIZATION ON SCHEMA::Perf TO OpsMgrWriter
GO

-- change schema alter to allow domain table index rebuild
GRANT ALTER ON SCHEMA::dbo TO OpsMgrWriter
GO

-- grant create table permissions
GRANT CREATE TABLE TO OpsMgrWriter
GO

SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  
SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'PerfAggregation', @ExecResult)

  DECLARE
     @AggregationType varchar(50)
    ,@Statement nvarchar(max)
     
  SET @AggregationType = ''

  WHILE EXISTS (SELECT *
                FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
                      AggregationType      varchar(50)   '@mp:localname')
                WHERE AggregationType &gt; @AggregationType
               )
  BEGIN
    SELECT TOP 1 @AggregationType = AggregationType
    FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
          AggregationType      varchar(50)   '@mp:localname')
    WHERE AggregationType &gt; @AggregationType
    ORDER BY AggregationType
    
    SET @Statement = 'EXEC StandardDatasetAllocateStorage @DatasetId = ''$Config/DatasetId$'', @AggregationTypeId='
                    + CASE @AggregationType
                        WHEN 'Raw' THEN '0'
                        WHEN 'Subhourly' THEN '10'
                        WHEN 'Hourly' THEN '20'
                        WHEN 'Daily' THEN '30'
                      END
    EXECUTE (@Statement)
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO

                    
                    -- insert staging definition into StandardDatasetStagingArea
BEGIN TRAN

IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
BEGIN
  DELETE StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'
END

INSERT StandardDatasetStagingArea
(
   DatasetId
  ,StagingTableColumnDefinition
  ,BatchedProcessingSupportedInd
  ,MaxRowsToProcessPerTransactionCount
)
VALUES
(
   '$Config/DatasetId$'
  ,'
   DatasetId					            uniqueidentifier  NOT NULL
  ,ManagementGroupGuid            uniqueidentifier  NOT NULL
  ,[DateTime]                     datetime          NOT NULL
  ,ManagedEntityRowId			        int               NOT NULL
  ,PerformanceRuleInstanceRowId   int               NOT NULL
  ,SampleValue                    float(53)         NOT NULL
  
  ,PerformanceStageRowId          bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
  '
  ,1
  ,500000
)

COMMIT

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceStage' AND TABLE_SCHEMA = 'Perf')
BEGIN
  DECLARE @Statement nvarchar(max)

  SELECT @Statement = 'CREATE TABLE Perf.PerformanceStage (' + StagingTableColumnDefinition + ')'
  FROM StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'

  EXECUTE (@Statement)
END
GO

GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Perf.PerformanceStage TO OpsMgrWriter
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceRule' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.PerformanceRule
END
GO

CREATE TABLE dbo.PerformanceRule
(                               
      RuleRowId                 int           NOT NULL
     ,ObjectName                nvarchar(256) NOT NULL
     ,CounterName               nvarchar(256) NOT NULL
     ,MultiInstanceInd          bit           NOT NULL    DEFAULT (0)
     ,LastReceivedDateTime      smalldatetime NOT NULL    DEFAULT (GETUTCDATE())
 
     ,CONSTRAINT PK_PerformanceRule PRIMARY KEY CLUSTERED (RuleRowId)
)
GO

CREATE INDEX IX_PerformanceRule_LastReceivedDateTime ON PerformanceRule (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PerformanceRule'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceRuleInstance' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.PerformanceRuleInstance
END
GO

CREATE TABLE dbo.PerformanceRuleInstance
(                               
      PerformanceRuleInstanceRowId      int           NOT NULL    IDENTITY(1, 1)
     ,RuleRowId                         int           NOT NULL
     ,InstanceName                      nvarchar(256) NOT NULL
     ,LastReceivedDateTime              smalldatetime NOT NULL    DEFAULT (GETUTCDATE())
 
     ,CONSTRAINT PK_PerformanceRuleInstance PRIMARY KEY CLUSTERED (PerformanceRuleInstanceRowId)
     ,CONSTRAINT UN_PerformanceRuleInstance_Ruleinstance UNIQUE (RuleRowId, InstanceName)
)
GO

CREATE INDEX IX_PerformanceRuleInstance_RuleRowId ON PerformanceRuleInstance (RuleRowId)
GO

CREATE INDEX IX_PerformanceRuleInstance_LastReceivedDateTime ON PerformanceRuleInstance (LastReceivedDateTime)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'PerformanceRuleInstance'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vPerformanceRule')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vPerformanceRule AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vPerformanceRule
AS
  SELECT *
  FROM dbo.PerformanceRule (NOLOCK)
GO

GRANT SELECT ON dbo.vPerformanceRule TO OpsMgrReader, OpsMgrWriter
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vPerformanceRuleInstance')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vPerformanceRuleInstance AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vPerformanceRuleInstance
AS
  SELECT *
  FROM dbo.PerformanceRuleInstance (NOLOCK)
GO

GRANT SELECT ON dbo.vPerformanceRuleInstance TO OpsMgrReader, OpsMgrWriter
GO


                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregate')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceAggregate AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceAggregate
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId int
  ,@InsertTableGuid varchar(256)
  ,@IntervalStartDateTime datetime
  ,@IntervalEndDateTime datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY
    DECLARE
       @Statement nvarchar(max)
      ,@DebugLevel tinyint
      ,@InsertTableName sysname
      ,@DebugMessage nvarchar(max)
      ,@AggregationStartDateTime datetime
      ,@CoverViewName sysname
      ,@SchemaName sysname
      
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    SELECT @CoverViewName = 'v' + BaseTableName
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar(10)) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      SET @AggregationStartDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
    
    SET @Statement =
        'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '  [DateTime]'
      + ' ,PerformanceRuleInstanceRowId'
      + ' ,ManagedEntityRowId'
      + ' ,SampleCount'
      + ' ,AverageValue'
      + ' ,MinValue'
      + ' ,MaxValue'
      + ' ,StandardDeviation'
      + ')'
      + ' SELECT'
      + '    CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalStartDateTime, 120) + ''', 120)'
      + '   ,PerformanceRuleInstanceRowId'
      + '   ,ManagedEntityRowId'
      + '   ,COUNT(*)'
      + '   ,AVG(SampleValue)'
      + '   ,MIN(SampleValue)'
      + '   ,MAX(SampleValue)'
      + '   ,ISNULL(STDEV(SampleValue), 0)'
      + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@CoverViewName)
      + ' WHERE ([DateTime] &gt;= CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalStartDateTime, 120) + ''', 120))'
      + '   AND ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalEndDateTime, 120) + ''', 120))'
      + '   AND SampleValue BETWEEN -1E145 AND 1E145'  -- Prevent arithmetic overflow in STDEV
      + ' GROUP BY PerformanceRuleInstanceRowId, ManagedEntityRowId'
      
    EXECUTE (@Statement)

    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Finished aggregation of type ' + CAST(@AggregationTypeId AS varchar(10)) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      
      DECLARE @OperationDurationMs bigint
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @AggregationStartDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to build aggregates for performance data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregationDelete')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceAggregationDelete AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceAggregationDelete
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@AggregationDateTime datetime
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugMessage nvarchar(max)
    ,@DeleteStartedDateTime datetime
    ,@OperationDurationMs bigint
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)

    -- Index hint in the query below ensures that SQL won't
    -- consider index on DateTime field to be a good source
    -- to find rows to delete - it may happen periodically
    -- if SQL thinks there's no rows to delete due to
    -- lack of [recently updated] statistics    
    SET @Statement = 'DELETE t' + 
				   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' t WITH (INDEX(1))'
                   + ' WHERE (t.[DateTime] = CONVERT(datetime, ''' + CONVERT(varchar(50), @AggregationDateTime, 120) + ''', 120))'

    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Starting delete of existing performance aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      
      SET @DeleteStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
   
    EXECUTE(@Statement)
    
    SET @RowsDeleted = @@ROWCOUNT
  
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Finished delete of existing performance aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @DeleteStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to delete aggregated data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @ErrorMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in perf data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'DELETE TOP (' + CAST(@MaxRowsToGroom AS varchar(15)) + ')'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'

    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    -- groom dynamic dimentions
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MAX(MaxDataAgeDays)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
    
    DELETE pri
    FROM PerformanceRuleInstance pri
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE pr
    FROM PerformanceRule pr
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for performance data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceObjectCounterInstanceRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceObjectCounterInstanceRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceObjectCounterInstanceRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'PerformanceObjectCounterInstanceKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#PerformanceObjectCounterInstance') IS NOT NULL)
      DROP TABLE #PerformanceObjectCounterInstance

    CREATE TABLE #PerformanceObjectCounterInstance (
       NodeOrdinal    int               NOT NULL
      ,RuleGuid       uniqueidentifier  NOT NULL
      ,ObjectName     nvarchar(256)     NOT NULL
      ,CounterName    nvarchar(256)     NOT NULL
      ,InstanceName   nvarchar(256)     NOT NULL
    )
    
    INSERT #PerformanceObjectCounterInstance (
       NodeOrdinal
      ,RuleGuid
      ,ObjectName
      ,CounterName
      ,InstanceName
    )
    SELECT
       NodeOrdinal
      ,RuleGuid
      ,ObjectName
      ,CounterName
      ,InstanceName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal          int               '@mp:id'
                    ,RuleGuid             uniqueidentifier  'RuleGuid'
                    ,ObjectName           nvarchar(256)     'ObjectName'
                    ,CounterName          nvarchar(256)     'CounterName'
                    ,InstanceName         nvarchar(256)     'InstanceName') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    -- update PerformanceRule domain
    INSERT PerformanceRule (
       RuleRowId
      ,ObjectName
      ,CounterName
    )
    SELECT DISTINCT 
       r.RuleRowId
      ,'' -- set object/counter to empty string in case
      ,'' -- we have more then one rule-o/c mapping in keys collection
    FROM #PerformanceObjectCounterInstance p
          JOIN vRule r ON (p.RuleGuid = r.RuleGuid)
    WHERE NOT EXISTS (SELECT * FROM PerformanceRule WHERE RuleRowId = r.RuleRowId)

    UPDATE pr
    SET ObjectName = p.ObjectName
       ,CounterName = p.CounterName
       ,LastReceivedDateTime = GETUTCDATE()
    FROM PerformanceRule pr (TABLOCK)
          JOIN vRule r ON (pr.RuleRowId = r.RuleRowId)
          JOIN #PerformanceObjectCounterInstance p ON (r.RuleGuid = p.RuleGuid)
    WHERE (pr.ObjectName &lt;&gt; p.ObjectName COLLATE database_default)
       OR (pr.CounterName &lt;&gt; p.CounterName COLLATE database_default)
       OR (pr.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    -- update Rule &lt;-&gt; Instance domain
    
    UPDATE pri
    SET LastReceivedDateTime = GETUTCDATE()
    FROM PerformanceRuleInstance pri
          JOIN vRule r ON (r.RuleRowId = pri.RuleRowId)
          JOIN #PerformanceObjectCounterInstance p ON (r.RuleGuid = p.RuleGuid) AND (pri.InstanceName = p.InstanceName COLLATE database_default)
    WHERE (pri.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT PerformanceRuleInstance (RuleRowId, InstanceName)
    SELECT DISTINCT r.RuleRowId, p.InstanceName
    FROM #PerformanceObjectCounterInstance p
          JOIN vRule r ON (r.RuleGuid = p.RuleGuid)
    WHERE NOT EXISTS (SELECT *
                      FROM PerformanceRuleInstance pri (TABLOCK)
                            JOIN vRule r ON (r.RuleRowId = pri.RuleRowId)
                      WHERE (r.RuleGuid = p.RuleGuid)
                        AND (pri.InstanceName = p.InstanceName COLLATE database_default))
    
    -- figure out which rules are multi-instance
    UPDATE pr
    SET MultiInstanceInd = 1
    FROM PerformanceRule pr (TABLOCK)
          JOIN (SELECT RuleRowId
                FROM PerformanceRuleInstance
                GROUP BY RuleRowId
                HAVING count(*) &gt; 1) ic ON (ic.RuleRowId = pr.RuleRowId)
    WHERE MultiInstanceInd = 0
    
    SELECT
       ISNULL(pri.PerformanceRuleInstanceRowId, 0)
    FROM #PerformanceObjectCounterInstance p
            LEFT JOIN vRule r ON (r.RuleGuid = p.RuleGuid)
            LEFT JOIN PerformanceRuleInstance pri ON (pri.RuleRowId = r.RuleRowId) AND (pri.InstanceName = p.InstanceName COLLATE database_default)
    ORDER BY p.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#PerformanceObjectCounterInstance') IS NOT NULL)
    DROP TABLE #PerformanceObjectCounterInstance

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON PerformanceObjectCounterInstanceRowIdResolve TO OpsMgrWriter
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
      ,@RawDataMaxAgeDays int
      ,@MaxStagingRowsToProcess int
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceStage2Process' AND TABLE_SCHEMA = 'Perf')
    BEGIN
      DECLARE @ProcessAllRowsInd bit
      SET @ProcessAllRowsInd = 1
      
      -- figure out what we need to do with staging area
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = MaxRowsToProcessPerTransactionCount
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
      
      IF (@MaxStagingRowsToProcess IS NOT NULL)
      BEGIN
        DECLARE @PerfStageRowCount int
        DECLARE @SpaceUsedInfo TABLE (
                   [name]       sysname
                  ,[rows]       int
                  ,reserved     nvarchar(100)
                  ,data         nvarchar(100)
                  ,index_size   nvarchar(100)
                  ,unused       nvarchar(100)
                )
                
        INSERT @SpaceUsedInfo
        EXEC sp_spaceused 'Perf.PerformanceStage'
        
        SELECT @PerfStageRowCount = [rows]
        FROM @SpaceUsedInfo
        
        IF (@PerfStageRowCount &gt;= @MaxStagingRowsToProcess)
        BEGIN
          SET @ProcessAllRowsInd = 0
        END
      END

      BEGIN TRAN
      
      IF (@ProcessAllRowsInd = 1)
      BEGIN
        -- no limit set for the number of rows to process
        -- rename and re-create staging table

        EXEC @ExecResult = sp_rename 'Perf.PerformanceStage', 'PerformanceStage2Process'
        
        IF (@ExecResult &lt; 0)
        BEGIN
          RAISERROR(777971003, 16, 1, @ExecResult)
        END
        
        SELECT
           @Statement = 'CREATE TABLE Perf.PerformanceStage (' + StagingTableColumnDefinition + ')'
        FROM StandardDatasetStagingArea
        WHERE DatasetId = @DatasetId

        EXECUTE (@Statement)        
      END
      ELSE
      BEGIN
        -- need to process subset of rows
        -- create extra column to store original row id
        SELECT @Statement =
              'CREATE TABLE Perf.PerformanceStage2Process (' 
            + @Statement
            + ',OriginalPerformanceStageRowId  int  NOT NULL'
            + ')'
        EXECUTE (@Statement)
      
        SELECT @Statement =
          ' INSERT Perf.PerformanceStage2Process'
        + '  ('
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,[DateTime]'
        + '    ,ManagedEntityRowId'
        + '    ,PerformanceRuleInstanceRowId'
        + '    ,SampleValue'
        + '    ,OriginalPerformanceStageRowId'
        + '  )'
        + '  SELECT TOP (' + CAST(@MaxStagingRowsToProcess AS varchar(15)) + ')'
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,[DateTime]'
        + '    ,ManagedEntityRowId'
        + '    ,PerformanceRuleInstanceRowId'
        + '    ,SampleValue'
        + '    ,PerformanceStageRowId'
        + '  FROM Perf.PerformanceStage'
        + '  ORDER BY PerformanceStageRowId'
        EXECUTE(@Statement)

        SELECT @Statement =
          'DELETE ps'
        + ' FROM Perf.PerformanceStage ps'
        + '        JOIN Perf.PerformanceStage2Process psp ON (ps.PerformanceStageRowId = psp.OriginalPerformanceStageRowId)'
        EXECUTE(@Statement)
      END

      GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Perf.PerformanceStage TO OpsMgrWriter
      GRANT CONTROL ON Perf.PerformanceStage2Process TO OpsMgrWriter
      
      COMMIT
    END -- IF NOT EXISTS Perf.PerformanceStage2Process
    
    -- create index on datetime field
    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_PerformanceStage2Process_DateTime')
    BEGIN
      CREATE INDEX IX_PerformanceStage2Process_DateTime ON Perf.PerformanceStage2Process(DateTime)
    END

    BEGIN TRAN

    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
    
    -- get the minimum data retention period
    -- to make sure we do not re-aggregate something
    -- that is too old and all raw data is gone
    
    SELECT @RawDataMaxAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   [DateTime]'
      + '  ,ManagedEntityRowId'
      + '  ,PerformanceRuleInstanceRowId'
      + '  ,SampleValue'
      + ' )'
      + ' SELECT '
      + '   p.[DateTime]'
      + '  ,p.ManagedEntityRowId'
      + '  ,p.PerformanceRuleInstanceRowId'
      + '  ,p.SampleValue'
      + ' FROM Perf.PerformanceStage2Process p'
      + ' WHERE (p.[DateTime] &gt; DATEADD(day, -' + CAST(@RawDataMaxAgeDays AS varchar(10)) + ', GETUTCDATE()))'

    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert ' + CAST(COUNT(*) AS varchar(30)) + ' performance samples into ' + @InsertTableName
      FROM Perf.PerformanceStage2Process
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
    
    EXECUTE(@Statement)

    -- mark existing affected aggregations as dirty
    UPDATE ah
    SET DirtyInd = 1
       ,DataLastReceivedDateTime = GETUTCDATE()
    FROM StandardDatasetAggregationHistory ah
          JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
          CROSS JOIN Perf.PerformanceStage2Process p
    WHERE (ah.DatasetId = @DatasetId)
      AND (ah.AggregationDateTime &gt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()))
      AND (p.[DateTime] &gt;= ah.AggregationDateTime)
      AND (p.[DateTime] &lt; DATEADD(minute, a.AggregationIntervalDurationMinutes, ah.AggregationDateTime))
    
    -- delete all inserted data from staging
    DROP TABLE Perf.PerformanceStage2Process
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting performance samples into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the performance data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON dbo.PerformanceProcessStaging TO OpsMgrWriter
GO

                    </Install><Uninstall>
                    -- drop SPs
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregate')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.PerformanceAggregate')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregationDelete')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.PerformanceAggregationDelete')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceGroom')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.PerformanceGroom')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceObjectCounterInstanceRowIdResolve')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.PerformanceObjectCounterInstanceRowIdResolve')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceProcessStaging')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.PerformanceProcessStaging')
END

-- drop views
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vPerformanceRule')
BEGIN
  EXECUTE ('DROP VIEW vPerformanceRule')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vPerformanceRuleInstance')
BEGIN
  EXECUTE ('DROP VIEW vPerformanceRuleInstance')
END

-- drop tables
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceStage' AND TABLE_SCHEMA = 'Perf')
BEGIN
  EXECUTE('DROP TABLE Perf.PerformanceStage')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceRule' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.PerformanceRule')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceRuleInstance' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.PerformanceRuleInstance')
END

-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO
 
                    </Uninstall><Upgrade>
                    SET NOCOUNT ON

UPDATE StandardDatasetAggregationStorage
SET TableTemplate = REPLACE(TableTemplate, ' int  NOT NULL  IDENTITY(1, 1)', ' bigint  NOT NULL  IDENTITY(1, 1)')
WHERE DatasetId = '$Config/DatasetId$'

GO


                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregate')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceAggregate AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceAggregate
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId int
  ,@InsertTableGuid varchar(256)
  ,@IntervalStartDateTime datetime
  ,@IntervalEndDateTime datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY
    DECLARE
       @Statement nvarchar(max)
      ,@DebugLevel tinyint
      ,@InsertTableName sysname
      ,@DebugMessage nvarchar(max)
      ,@AggregationStartDateTime datetime
      ,@CoverViewName sysname
      ,@SchemaName sysname
      
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    SELECT @CoverViewName = 'v' + BaseTableName
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar(10)) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      SET @AggregationStartDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
    
    SET @Statement =
        'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '  [DateTime]'
      + ' ,PerformanceRuleInstanceRowId'
      + ' ,ManagedEntityRowId'
      + ' ,SampleCount'
      + ' ,AverageValue'
      + ' ,MinValue'
      + ' ,MaxValue'
      + ' ,StandardDeviation'
      + ')'
      + ' SELECT'
      + '    CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalStartDateTime, 120) + ''', 120)'
      + '   ,PerformanceRuleInstanceRowId'
      + '   ,ManagedEntityRowId'
      + '   ,COUNT(*)'
      + '   ,AVG(SampleValue)'
      + '   ,MIN(SampleValue)'
      + '   ,MAX(SampleValue)'
      + '   ,ISNULL(STDEV(SampleValue), 0)'
      + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@CoverViewName)
      + ' WHERE ([DateTime] &gt;= CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalStartDateTime, 120) + ''', 120))'
      + '   AND ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @IntervalEndDateTime, 120) + ''', 120))'
      + '   AND SampleValue BETWEEN -1E145 AND 1E145'  -- Prevent arithmetic overflow in STDEV
      + ' GROUP BY PerformanceRuleInstanceRowId, ManagedEntityRowId'
      
    EXECUTE (@Statement)

    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Finished aggregation of type ' + CAST(@AggregationTypeId AS varchar(10)) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      
      DECLARE @OperationDurationMs bigint
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @AggregationStartDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to build aggregates for performance data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceAggregationDelete')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceAggregationDelete AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceAggregationDelete
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@AggregationDateTime datetime
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugMessage nvarchar(max)
    ,@DeleteStartedDateTime datetime
    ,@OperationDurationMs bigint
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)

    -- Index hint in the query below ensures that SQL won't
    -- consider index on DateTime field to be a good source
    -- to find rows to delete - it may happen periodically
    -- if SQL thinks there's no rows to delete due to
    -- lack of [recently updated] statistics    
    SET @Statement = 'DELETE t' + 
				   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' t WITH (INDEX(1))'
                   + ' WHERE (t.[DateTime] = CONVERT(datetime, ''' + CONVERT(varchar(50), @AggregationDateTime, 120) + ''', 120))'

    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Starting delete of existing performance aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      
      SET @DeleteStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
   
    EXECUTE(@Statement)
    
    SET @RowsDeleted = @@ROWCOUNT
  
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Finished delete of existing performance aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @DeleteStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to delete aggregated data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @ErrorMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in perf data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'DELETE TOP (' + CAST(@MaxRowsToGroom AS varchar(15)) + ')'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'

    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    -- groom dynamic dimentions
    DECLARE @MaxDataAgeDays int
    
    SELECT @MaxDataAgeDays = MAX(MaxDataAgeDays)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
    
    DELETE pri
    FROM PerformanceRuleInstance pri
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
    DELETE pr
    FROM PerformanceRule pr
    WHERE LastReceivedDateTime &lt; DATEADD(day, -@MaxDataAgeDays, GETUTCDATE()) 
    OPTION (RECOMPILE)
    
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for performance data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END

    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
   
                     IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceObjectCounterInstanceRowIdResolve')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceObjectCounterInstanceRowIdResolve AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceObjectCounterInstanceRowIdResolve
   @ManagementGroupGuid         uniqueidentifier
  ,@ObjectKeyXml                ntext
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE @ManagementGroupRowId int

  -- check management group is connected to this DW
  DECLARE @CheckExecResult int
  
  EXEC @CheckExecResult = ManagementGroupAccessCheck @ManagementGroupGuid, @ManagementGroupRowId OUTPUT
  IF (@CheckExecResult &lt;&gt; 0) RETURN @CheckExecResult
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY

    DECLARE 
       @ExecResult      int
      ,@XmlDocHandle    int

    EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @ObjectKeyXml
    IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'PerformanceObjectCounterInstanceKeys', @ExecResult)
    
    IF (OBJECT_ID('tempdb..#PerformanceObjectCounterInstance') IS NOT NULL)
      DROP TABLE #PerformanceObjectCounterInstance

    CREATE TABLE #PerformanceObjectCounterInstance (
       NodeOrdinal    int               NOT NULL
      ,RuleGuid       uniqueidentifier  NOT NULL
      ,ObjectName     nvarchar(256)     NOT NULL
      ,CounterName    nvarchar(256)     NOT NULL
      ,InstanceName   nvarchar(256)     NOT NULL
    )
    
    INSERT #PerformanceObjectCounterInstance (
       NodeOrdinal
      ,RuleGuid
      ,ObjectName
      ,CounterName
      ,InstanceName
    )
    SELECT
       NodeOrdinal
      ,RuleGuid
      ,ObjectName
      ,CounterName
      ,InstanceName
    FROM OPENXML(@XmlDocHandle, 'Keys/Key', 2) WITH (
                     NodeOrdinal          int               '@mp:id'
                    ,RuleGuid             uniqueidentifier  'RuleGuid'
                    ,ObjectName           nvarchar(256)     'ObjectName'
                    ,CounterName          nvarchar(256)     'CounterName'
                    ,InstanceName         nvarchar(256)     'InstanceName') xml

    EXEC sp_xml_removedocument @XmlDocHandle
    SET @XmlDocHandle = NULL
    
    -- update PerformanceRule domain
    INSERT PerformanceRule (
       RuleRowId
      ,ObjectName
      ,CounterName
    )
    SELECT DISTINCT 
       r.RuleRowId
      ,'' -- set object/counter to empty string in case
      ,'' -- we have more then one rule-o/c mapping in keys collection
    FROM #PerformanceObjectCounterInstance p
          JOIN vRule r ON (p.RuleGuid = r.RuleGuid)
    WHERE NOT EXISTS (SELECT * FROM PerformanceRule WHERE RuleRowId = r.RuleRowId)

    UPDATE pr
    SET ObjectName = p.ObjectName
       ,CounterName = p.CounterName
       ,LastReceivedDateTime = GETUTCDATE()
    FROM PerformanceRule pr (TABLOCK)
          JOIN vRule r ON (pr.RuleRowId = r.RuleRowId)
          JOIN #PerformanceObjectCounterInstance p ON (r.RuleGuid = p.RuleGuid)
    WHERE (pr.ObjectName &lt;&gt; p.ObjectName COLLATE database_default)
       OR (pr.CounterName &lt;&gt; p.CounterName COLLATE database_default)
       OR (pr.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    -- update Rule &lt;-&gt; Instance domain
    
    UPDATE pri
    SET LastReceivedDateTime = GETUTCDATE()
    FROM PerformanceRuleInstance pri
          JOIN vRule r ON (r.RuleRowId = pri.RuleRowId)
          JOIN #PerformanceObjectCounterInstance p ON (r.RuleGuid = p.RuleGuid) AND (pri.InstanceName = p.InstanceName COLLATE database_default)
    WHERE (pri.LastReceivedDateTime &lt; DATEADD(day, -1, GETUTCDATE()))
    
    INSERT PerformanceRuleInstance (RuleRowId, InstanceName)
    SELECT DISTINCT r.RuleRowId, p.InstanceName
    FROM #PerformanceObjectCounterInstance p
          JOIN vRule r ON (r.RuleGuid = p.RuleGuid)
    WHERE NOT EXISTS (SELECT *
                      FROM PerformanceRuleInstance pri (TABLOCK)
                            JOIN vRule r ON (r.RuleRowId = pri.RuleRowId)
                      WHERE (r.RuleGuid = p.RuleGuid)
                        AND (pri.InstanceName = p.InstanceName COLLATE database_default))
    
    -- figure out which rules are multi-instance
    UPDATE pr
    SET MultiInstanceInd = 1
    FROM PerformanceRule pr (TABLOCK)
          JOIN (SELECT RuleRowId
                FROM PerformanceRuleInstance
                GROUP BY RuleRowId
                HAVING count(*) &gt; 1) ic ON (ic.RuleRowId = pr.RuleRowId)
    WHERE MultiInstanceInd = 0
    
    SELECT
       ISNULL(pri.PerformanceRuleInstanceRowId, 0)
    FROM #PerformanceObjectCounterInstance p
            LEFT JOIN vRule r ON (r.RuleGuid = p.RuleGuid)
            LEFT JOIN PerformanceRuleInstance pri ON (pri.RuleRowId = r.RuleRowId) AND (pri.InstanceName = p.InstanceName COLLATE database_default)
    ORDER BY p.NodeOrdinal
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  IF (@XmlDocHandle IS NOT NULL)
    EXEC sp_xml_removedocument @XmlDocHandle

  IF (OBJECT_ID('tempdb..#PerformanceObjectCounterInstance') IS NOT NULL)
    DROP TABLE #PerformanceObjectCounterInstance

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON PerformanceObjectCounterInstanceRowIdResolve TO OpsMgrWriter
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'PerformanceProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.PerformanceProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.PerformanceProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
      ,@RawDataMaxAgeDays int
      ,@MaxStagingRowsToProcess int
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE (DatasetId = @DatasetId)
    
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'PerformanceStage2Process' AND TABLE_SCHEMA = 'Perf')
    BEGIN
      DECLARE @ProcessAllRowsInd bit
      SET @ProcessAllRowsInd = 1
      
      -- figure out what we need to do with staging area
      SELECT
         @Statement = StagingTableColumnDefinition
        ,@MaxStagingRowsToProcess = MaxRowsToProcessPerTransactionCount
      FROM StandardDatasetStagingArea
      WHERE DatasetId = @DatasetId
      
      IF (@MaxStagingRowsToProcess IS NOT NULL)
      BEGIN
        DECLARE @PerfStageRowCount int
        DECLARE @SpaceUsedInfo TABLE (
                   [name]       sysname
                  ,[rows]       int
                  ,reserved     nvarchar(100)
                  ,data         nvarchar(100)
                  ,index_size   nvarchar(100)
                  ,unused       nvarchar(100)
                )
                
        INSERT @SpaceUsedInfo
        EXEC sp_spaceused 'Perf.PerformanceStage'
        
        SELECT @PerfStageRowCount = [rows]
        FROM @SpaceUsedInfo
        
        IF (@PerfStageRowCount &gt;= @MaxStagingRowsToProcess)
        BEGIN
          SET @ProcessAllRowsInd = 0
        END
      END

      BEGIN TRAN
      
      IF (@ProcessAllRowsInd = 1)
      BEGIN
        -- no limit set for the number of rows to process
        -- rename and re-create staging table

        EXEC @ExecResult = sp_rename 'Perf.PerformanceStage', 'PerformanceStage2Process'
        
        IF (@ExecResult &lt; 0)
        BEGIN
          RAISERROR(777971003, 16, 1, @ExecResult)
        END
        
        SELECT
           @Statement = 'CREATE TABLE Perf.PerformanceStage (' + StagingTableColumnDefinition + ')'
        FROM StandardDatasetStagingArea
        WHERE DatasetId = @DatasetId

        EXECUTE (@Statement)        
      END
      ELSE
      BEGIN
        -- need to process subset of rows
        -- create extra column to store original row id
        SELECT @Statement =
              'CREATE TABLE Perf.PerformanceStage2Process (' 
            + @Statement
            + ',OriginalPerformanceStageRowId  int  NOT NULL'
            + ')'
        EXECUTE (@Statement)
      
        SELECT @Statement =
          ' INSERT Perf.PerformanceStage2Process'
        + '  ('
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,[DateTime]'
        + '    ,ManagedEntityRowId'
        + '    ,PerformanceRuleInstanceRowId'
        + '    ,SampleValue'
        + '    ,OriginalPerformanceStageRowId'
        + '  )'
        + '  SELECT TOP (' + CAST(@MaxStagingRowsToProcess AS varchar(15)) + ')'
        + '     DatasetId'
        + '    ,ManagementGroupGuid'
        + '    ,[DateTime]'
        + '    ,ManagedEntityRowId'
        + '    ,PerformanceRuleInstanceRowId'
        + '    ,SampleValue'
        + '    ,PerformanceStageRowId'
        + '  FROM Perf.PerformanceStage'
        + '  ORDER BY PerformanceStageRowId'
        EXECUTE(@Statement)

        SELECT @Statement =
          'DELETE ps'
        + ' FROM Perf.PerformanceStage ps'
        + '        JOIN Perf.PerformanceStage2Process psp ON (ps.PerformanceStageRowId = psp.OriginalPerformanceStageRowId)'
        EXECUTE(@Statement)
      END

      GRANT ALTER, SELECT, INSERT, UPDATE, DELETE ON Perf.PerformanceStage TO OpsMgrWriter
      GRANT CONTROL ON Perf.PerformanceStage2Process TO OpsMgrWriter
      
      COMMIT
    END -- IF NOT EXISTS Perf.PerformanceStage2Process
    
    -- create index on datetime field
    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_PerformanceStage2Process_DateTime')
    BEGIN
      CREATE INDEX IX_PerformanceStage2Process_DateTime ON Perf.PerformanceStage2Process(DateTime)
    END

    BEGIN TRAN

    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
    
    -- get the minimum data retention period
    -- to make sure we do not re-aggregate something
    -- that is too old and all raw data is gone
    
    SELECT @RawDataMaxAgeDays = MaxDataAgeDays
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
      
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '   [DateTime]'
      + '  ,ManagedEntityRowId'
      + '  ,PerformanceRuleInstanceRowId'
      + '  ,SampleValue'
      + ' )'
      + ' SELECT '
      + '   p.[DateTime]'
      + '  ,p.ManagedEntityRowId'
      + '  ,p.PerformanceRuleInstanceRowId'
      + '  ,p.SampleValue'
      + ' FROM Perf.PerformanceStage2Process p'
      + ' WHERE (p.[DateTime] &gt; DATEADD(day, -' + CAST(@RawDataMaxAgeDays AS varchar(10)) + ', GETUTCDATE()))'

    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert ' + CAST(COUNT(*) AS varchar(30)) + ' performance samples into ' + @InsertTableName
      FROM Perf.PerformanceStage2Process
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
    
    EXECUTE(@Statement)

    -- mark existing affected aggregations as dirty
    UPDATE ah
    SET DirtyInd = 1
       ,DataLastReceivedDateTime = GETUTCDATE()
    FROM StandardDatasetAggregationHistory ah
          JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
          CROSS JOIN Perf.PerformanceStage2Process p
    WHERE (ah.DatasetId = @DatasetId)
      AND (ah.AggregationDateTime &gt; DATEADD(day, -@RawDataMaxAgeDays, GETUTCDATE()))
      AND (p.[DateTime] &gt;= ah.AggregationDateTime)
      AND (p.[DateTime] &lt; DATEADD(minute, a.AggregationIntervalDurationMinutes, ah.AggregationDateTime))
    
    -- delete all inserted data from staging
    DROP TABLE Perf.PerformanceStage2Process
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting performance samples into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the performance data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON dbo.PerformanceProcessStaging TO OpsMgrWriter
GO

                    
                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessage    nvarchar(max)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  ,@ErrorMessageText nvarchar(max)

SET @ErrorInd = 0

DECLARE
   @StagingLockSetInd bit
  ,@StagingLockResourceName sysname
  ,@ExecResult int

BEGIN TRY

  -- lock staging
  SET @StagingLockResourceName = '$Config/DatasetId$' + '_Staging'

  EXEC @ExecResult = sp_getapplock
         @Resource = @StagingLockResourceName
        ,@LockMode = 'Exclusive'
        ,@LockOwner = 'Session'
        ,@LockTimeout = 600000

  IF (@ExecResult = -1)
  BEGIN
    RAISERROR(777971001, 16, 1, 'StageArea', @ExecResult)
  END
  
  SET @StagingLockSetInd = 1

  IF (@ExecResult &lt; 0)
  BEGIN
    RAISERROR(777971001, 16, 1, 'StageArea', @ExecResult)
  END

  UPDATE StandardDatasetStagingArea
  SET StagingTableColumnDefinition = 
    'DatasetId                      uniqueidentifier  NOT NULL
    ,ManagementGroupGuid            uniqueidentifier  NOT NULL
    ,[DateTime]                     datetime          NOT NULL
    ,ManagedEntityRowId			        int               NOT NULL
    ,PerformanceRuleInstanceRowId   int               NOT NULL
    ,SampleValue                    float(53)         NOT NULL
    
    ,PerformanceStageRowId          bigint            NOT NULL    IDENTITY(1, 1)  PRIMARY KEY
    '
  ,MaxRowsToProcessPerTransactionCount = CASE WHEN MaxRowsToProcessPerTransactionCount &lt; 500000 THEN MaxRowsToProcessPerTransactionCount ELSE 500000 END
  ,BatchedProcessingSupportedInd = 1
  WHERE DatasetId = '$Config/DatasetId$'

  IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'PerformanceStage' AND TABLE_SCHEMA = 'Perf' AND COLUMN_NAME = 'PerformanceStageRowId')
  BEGIN
    ALTER TABLE Perf.PerformanceStage
      ADD PerformanceStageRowId bigint NOT NULL IDENTITY(1, 1) CONSTRAINT PK_PerformanceStage PRIMARY KEY
  END

  -- rename PerformanceStage2Process table if exists
  -- because it may be huge and may prevent perf data from flowing
  IF (OBJECT_ID('Perf.PerformanceStage2Process') IS NOT NULL)
  BEGIN
    EXEC sp_rename 'Perf.PerformanceStage2Process', 'PerformanceStage2Process_Sp2_Upgrade_Backup'
  END
END TRY
BEGIN CATCH
  IF (@@TRANCOUNT &gt; 0)
    ROLLBACK TRAN

  SELECT 
     @ErrorNumber = ERROR_NUMBER()
    ,@ErrorSeverity = ERROR_SEVERITY()
    ,@ErrorState = ERROR_STATE()
    ,@ErrorLine = ERROR_LINE()
    ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
    ,@ErrorMessageText = ERROR_MESSAGE()

  SET @ErrorInd = 1
END CATCH

-- cleanup  
IF (@StagingLockSetInd = 1)
BEGIN
  EXEC @ExecResult = sp_releaseapplock
             @Resource = @StagingLockResourceName
            ,@LockOwner = 'Session'
            
  SET @StagingLockSetInd = 0
END

-- report error if any
IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO
 
                    /* raw indexes for UI perf widget perf */

IF NOT EXISTS (SELECT *
               FROM StandardDatasetAggregationStorage s
                      JOIN StandardDatasetAggregationStorageindex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
               WHERE (s.DatasetId = '$Config/DatasetId$')
                 AND (s.AggregationTypeId = 0)
                 AND (si.IndexGuid = 'A136E27D-A83E-4F38-B9A3-35EAAFBFCBE8')
              )
BEGIN
  EXEC StandardDatasetIndexInsert
     @DatasetId = '$Config/DatasetId$'
    ,@AggregationTypeId = 0
    ,@DependentTableInd = 0
    ,@TableTag = NULL
    ,@UniqueInd = 0
    ,@IndexGuid = 'A136E27D-A83E-4F38-B9A3-35EAAFBFCBE8'
    ,@IndexDefinition = '(
	  [ManagedEntityRowId],
	  [PerformanceRuleInstanceRowId],
	  [DateTime]
  )
  INCLUDE
  (
	  [SampleValue]
  )
'
    ,@CreateIndexOnExistingTablesInd = 1
END
GO

-- Hourly data index to support Top N reports and dashboards
IF NOT EXISTS (SELECT *
               FROM StandardDatasetAggregationStorage s
                      JOIN StandardDatasetAggregationStorageindex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
               WHERE (s.DatasetId = '$Config/DatasetId$')
                 AND (s.AggregationTypeId = 20)
                 AND (si.IndexGuid = '04DE2C08-6203-4DA1-8EED-A0984463C46E')
              )
BEGIN
  EXEC StandardDatasetIndexInsert
     @DatasetId = '$Config/DatasetId$'
    ,@AggregationTypeId = 20
    ,@DependentTableInd = 0
    ,@TableTag = NULL
    ,@UniqueInd = 0
    ,@IndexGuid = '04DE2C08-6203-4DA1-8EED-A0984463C46E'
    ,@IndexDefinition = '(
          [PerformanceRuleInstanceRowId]
         ,[DateTime]
        )
        INCLUDE
        (
          [ManagedEntityRowId]
         ,[SampleCount]
         ,[AverageValue]
        )
    '
  ,@CreateIndexOnExistingTablesInd = 0
END
GO

-- Daily data index to support Top N reports and dashboards
IF NOT EXISTS (SELECT *
               FROM StandardDatasetAggregationStorage s
                      JOIN StandardDatasetAggregationStorageindex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
               WHERE (s.DatasetId = '$Config/DatasetId$')
                 AND (s.AggregationTypeId = 30)
                 AND (si.IndexGuid = '110C2981-0D21-4C6E-8185-49997A2BA0B5')
              )
BEGIN
  EXEC StandardDatasetIndexInsert
     @DatasetId = '$Config/DatasetId$'
    ,@AggregationTypeId = 30
    ,@DependentTableInd = 0
    ,@TableTag = NULL
    ,@UniqueInd = 0
    ,@IndexGuid = '110C2981-0D21-4C6E-8185-49997A2BA0B5'
    ,@IndexDefinition = '(
          [PerformanceRuleInstanceRowId]
         ,[DateTime]
        )
        INCLUDE
        (
          [ManagedEntityRowId]
         ,[SampleCount]
         ,[AverageValue]
        )
    '
  ,@CreateIndexOnExistingTablesInd = 0
END
GO


                    </Upgrade></DataWarehouseDataSet><DataWarehouseDataSet ID="Microsoft.SystemCenter.DataWarehouse.DataSet.State" Accessibility="Public"><Dependencies><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport</DataWarehouseScript><DataWarehouseScript>Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport</DataWarehouseScript></Dependencies><Configuration><IncludeSchemaTypes><SchemaType>Microsoft.SystemCenter.DataWarehouse.StandardDatasetSchema</SchemaType></IncludeSchemaTypes><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="Aggregations" type="AggregationsType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="RawInsertTableCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="DefaultAggregationIntervalCount" type="xsd:positiveInteger"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDailyStartTime" type="TimeOfDayType"/><xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="BlockingMaintenanceDurationMinutes" type="xsd:positiveInteger"/></Configuration><Install> 
                    SET NOCOUNT ON

EXEC StandardDatasetDelete @DatasetId = '$Config/DatasetId$'
GO

INSERT StandardDataset (
   DatasetId 
  ,SchemaName
  ,DefaultAggregationIntervalCount
  ,RawInsertTableCount
  ,StagingProcessorStoredProcedureName
  ,BlockingMaintenanceDailyStartTime
  ,BlockingMaintenanceDurationMinutes
)
VALUES
(
   '$Config/DatasetId$'
  ,'State'
  ,$Config/DefaultAggregationIntervalCount$
  ,$Config/RawInsertTableCount$
  ,'StateProcessStaging'
  ,'$Config/BlockingMaintenanceDailyStartTime$'
  ,$Config/BlockingMaintenanceDurationMinutes$
)

                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'StateAggregation', @ExecResult)

  INSERT StandardDatasetAggregation
  (                               
     DatasetId
    ,AggregationTypeId
    ,AggregationIntervalDurationMinutes
    ,AggregationStartDelayMinutes
    ,BuildAggregationStoredProcedureName
    ,DeleteAggregationStoredProcedureName
    ,GroomStoredProcedureName
    ,IndexOptimizationIntervalMinutes
    ,MaxDataAgeDays
    ,GroomingIntervalMinutes
    ,MaxRowsToGroom
    ,LastGroomingDateTime
    ,DataFileGroupName
    ,IndexFileGroupName
  )
  SELECT
     '$Config/DatasetId$'
    ,CASE AggregationType
       WHEN 'Raw' THEN 0
       WHEN 'Subhourly' THEN 10
       WHEN 'Hourly' THEN 20
       WHEN 'Daily' THEN 30
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       WHEN 'Subhourly' THEN AggregationIntervalDurationMinutes
       WHEN 'Hourly' THEN 60
       WHEN 'Daily' THEN 24*60
     END
    ,AggregationStartDelayMinutes
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       ELSE 'StateAggregate'
     END
    ,CASE AggregationType
       WHEN 'Raw' THEN NULL
       ELSE 'StateAggregationDelete'
     END
    ,'StateGroom'
    ,IndexOptimizationIntervalMinutes
    ,MaxDataAgeDays
    ,GroomingIntervalMinutes
    ,MaxRowsToGroom
    ,GETUTCDATE()
    ,DataFileGroupName
    ,IndexFileGroupName
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
       AggregationType                    varchar(50)   '@mp:localname'
      ,MaxTableRowCount                   int
      ,MaxTableSizeKb                     int
      ,AggregationStartDelayMinutes       int
      ,MaxDataAgeDays                     int
      ,GroomingIntervalMinutes            int
      ,MaxRowsToGroom                     int
      ,IndexOptimizationIntervalMinutes   int
      ,DataFileGroupName                  sysname
      ,IndexFileGroupName                 sysname
      ,AggregationIntervalDurationMinutes int
  )
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO

                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'StateAggregationStorage', @ExecResult)

  INSERT StandardDatasetAggregationStorage
  (                               
     DatasetId
    ,AggregationTypeId
    ,BaseTableName
    ,DependentTableInd
    ,TableTemplate
    ,CoverViewSelectClause
    ,MaxTableRowCount
    ,MaxTableSizeKb 
  )
  SELECT
     '$Config/DatasetId$'
    ,CASE xml.AggregationType
       WHEN 'Raw' THEN 0
       WHEN 'Subhourly' THEN 10
       WHEN 'Hourly' THEN 20
       WHEN 'Daily' THEN 30
     END
    ,xml.BaseTableName
    ,0
    ,CASE xml.AggregationType
       WHEN 'Raw' THEN '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(xml.BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(xml.BaseTableName + 'RowId') + ' int  NOT NULL  IDENTITY(1, 1)
                    ,EventOriginId                  uniqueidentifier  NOT NULL
                    ,ManagedEntityMonitorRowId      int  NOT NULL
                    ,[DateTime]                     datetime NOT NULL
                    ,OldHealthState                 tinyint  NOT NULL
                    ,NewHealthState                 tinyint  NOT NULL
                    
                    ,CONSTRAINT ' + QUOTENAME('PK_' + xml.BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED ('
                       + QUOTENAME(xml.BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       '
       ELSE '
                CREATE TABLE ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME(xml.BaseTableName + '_$Guid$') + '
                (
                     ' + QUOTENAME(xml.BaseTableName + 'RowId') + ' int  NOT NULL  IDENTITY(1, 1)
                    ,[DateTime]                             datetime  NOT NULL
                    ,ManagedEntityMonitorRowId              int  NOT NULL
                    ,InRedStateMilliseconds                 int  NOT NULL
                    ,InYellowStateMilliseconds              int  NOT NULL
                    ,InDisabledStateMilliseconds            int  NOT NULL
                    ,InPlannedMaintenanceMilliseconds       int  NOT NULL
                    ,InUnplannedMaintenanceMilliseconds     int  NOT NULL
                    ,HealthServiceUnavailableMilliseconds   int  NOT NULL
                    ,IntervalEndHealthState                 tinyint NULL
                    
                    ,CONSTRAINT ' + QUOTENAME('PK_' + xml.BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED (' +
                      + QUOTENAME(xml.BaseTableName + 'RowId') + ') ON $DataFileGroupName$
                ) ON $DataFileGroupName$
       '
     END
    ,CASE xml.AggregationType
       WHEN 'Raw' THEN '
          SELECT
             EventOriginId
            ,ManagedEntityMonitorRowId
            ,[DateTime]
            ,OldHealthState
            ,NewHealthState
       '
       ELSE '
          SELECT
             ManagedEntityMonitorRowId
            ,[DateTime]
            ,InRedStateMilliseconds
            ,InYellowStateMilliseconds
            ,InDisabledStateMilliseconds
            ,InPlannedMaintenanceMilliseconds
            ,InUnplannedMaintenanceMilliseconds
            ,HealthServiceUnavailableMilliseconds
            ,IntervalEndHealthState
       '
     END
    ,xml.MaxTableRowCount
    ,xml.MaxTableSizeKb 
  FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
         AggregationType      varchar(50)   '@mp:localname'
        ,BaseTableName        sysname
        ,MaxTableRowCount     int
        ,MaxTableSizeKb       int
        ,DataFileGroupName    sysname
        ,IndexFileGroupName   sysname
      ) xml
      CROSS JOIN StandardDataset d
  WHERE (d.DatasetId = '$Config/DatasetId$')
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO
 
                    SET NOCOUNT ON
GO

-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@IndeGuid uniqueidentifier

SET @AggregationTypeId = -1

WHILE EXISTS (SELECT *
              FROM StandardDatasetAggregation
              WHERE (DatasetId = '$Config/DatasetId$')
                AND (AggregationTypeId &gt; @AggregationTypeId)
             )
BEGIN
  SELECT @IndeGuid = NEWID()

  SELECT TOP 1 
     @AggregationTypeId = AggregationTypeId
    ,@Statement = CASE
                    WHEN AggregationTypeId = 0 THEN
                          ' EXEC StandardDatasetIndexDelete'
                        + '    @DatasetId = ''$Config/DatasetId$'''
                        + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
	                      + '   ,@DeleteIndexOnExistingTablesInd = 0'
                        + ' EXEC StandardDatasetIndexInsert'
                        + '    @DatasetId = ''$Config/DatasetId$'''
                        + '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
                        + '   ,@DependentTableInd = 0'
                        + '   ,@TableTag = NULL'
                        + '   ,@UniqueInd = 0'
                        + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
                        + '   ,@IndexDefinition = ''(DateTime, ManagedEntityMonitorRowId) INCLUDE (OldHealthState, NewHealthState)'''
                        + '   ,@CreateIndexOnExistingTablesInd = 0'
                    ELSE
                          ' EXEC StandardDatasetIndexDelete'
                        + '    @DatasetId = ''$Config/DatasetId$'''
                        + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
	                      + '   ,@DeleteIndexOnExistingTablesInd = 0'
                        + ' EXEC StandardDatasetIndexInsert'
                        + '    @DatasetId = ''$Config/DatasetId$'''
                        + '   ,@AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10))
                        + '   ,@DependentTableInd = 0'
                        + '   ,@TableTag = NULL'
                        + '   ,@UniqueInd = 0'
                        + '   ,@IndexGuid = ''' + CAST(@IndeGuid AS varchar(100)) + ''''
                        + '   ,@IndexDefinition = ''(DateTime, ManagedEntityMonitorRowId) INCLUDE (InRedStateMilliseconds, InYellowStateMilliseconds, InDisabledStateMilliseconds, InPlannedMaintenanceMilliseconds, InUnplannedMaintenanceMilliseconds, HealthServiceUnavailableMilliseconds)'''
                        + '   ,@CreateIndexOnExistingTablesInd = 0'
                  END
  FROM StandardDatasetAggregation
  WHERE (DatasetId = '$Config/DatasetId$')
    AND (AggregationTypeId &gt; @AggregationTypeId)
  ORDER BY AggregationTypeId
  
  EXECUTE (@Statement)
END
GO

                    IF NOT EXISTS (SELECT * FROM sys.schemas WHERE [name] = 'State')
BEGIN
  EXECUTE('CREATE SCHEMA State')
END
GO

-- change schema ownership to allow index rebuild and reorganize
ALTER AUTHORIZATION ON SCHEMA::State TO OpsMgrWriter
GO

-- change schema alter to allow domain table index rebuild
GRANT ALTER ON SCHEMA::dbo TO OpsMgrWriter
GO

-- grant create table permissions
GRANT CREATE TABLE TO OpsMgrWriter
GO

SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)
  
SET @ErrorInd = 0

DECLARE
   @ExecResult int
  ,@XmlDocHandle int
  ,@XmlDocText nvarchar(max)
  
BEGIN TRY
  SET @XmlDocText = '&lt;Aggregations&gt;$Config/Aggregations$&lt;/Aggregations&gt;'

  EXEC @ExecResult = sp_xml_preparedocument @XmlDocHandle OUTPUT, @XmlDocText
  IF @ExecResult &lt;&gt; 0 RAISERROR(777971000, 16, 1, 'StateAggregation', @ExecResult)

  DECLARE
     @AggregationType varchar(50)
    ,@Statement nvarchar(max)
     
  SET @AggregationType = ''

  WHILE EXISTS (SELECT *
                FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
                      AggregationType      varchar(50)   '@mp:localname')
                WHERE AggregationType &gt; @AggregationType
               )
  BEGIN
    SELECT TOP 1 @AggregationType = AggregationType
    FROM OPENXML(@XmlDocHandle, 'Aggregations/*', 2) WITH (
          AggregationType      varchar(50)   '@mp:localname')
    WHERE AggregationType &gt; @AggregationType
    ORDER BY AggregationType
    
    SET @Statement = 'EXEC StandardDatasetAllocateStorage @DatasetId = ''$Config/DatasetId$'', @AggregationTypeId='
                    + CASE @AggregationType
                        WHEN 'Raw' THEN '0'
                        WHEN 'Subhourly' THEN '10'
                        WHEN 'Hourly' THEN '20'
                        WHEN 'Daily' THEN '30'
                      END
    EXECUTE (@Statement)
  END
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@XmlDocHandle IS NOT NULL)
  EXEC sp_xml_removedocument @XmlDocHandle

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO

                    
                    IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ManagedEntityMonitor' AND TABLE_SCHEMA = 'dbo')
BEGIN
  DROP TABLE dbo.ManagedEntityMonitor
END
GO

CREATE TABLE dbo.ManagedEntityMonitor
(                               
     ManagedEntityMonitorRowId    int           NOT NULL    IDENTITY(1,1)
    ,ManagedEntityRowId           int           NOT NULL
    ,MonitorRowId                 int           NOT NULL
    ,DWCreatedDateTime            datetime      NOT NULL    DEFAULT(GETUTCDATE())
    
    ,CONSTRAINT PK_ManagedEntityMonitor PRIMARY KEY CLUSTERED (ManagedEntityMonitorRowId)
    ,CONSTRAINT UN_ManagedEntityMonitor_ManagedEntityRowIdMonitorRowId UNIQUE (ManagedEntityRowId, MonitorRowId)
)
GO

CREATE INDEX IX_ManagedEntityMonitor_ManagedEntityRowId ON ManagedEntityMonitor(ManagedEntityRowId)
GO

CREATE INDEX IX_ManagedEntityMonitor_MonitorRowId ON ManagedEntityMonitor(MonitorRowId)
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'ManagedEntityMonitor'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateAggregationProcessing' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('CREATE TABLE dbo.StateAggregationProcessing (                               
       DatasetId                                          uniqueidentifier  NOT NULL
      ,LastProcessedMaintenanceModeModifiedDateTime       datetime          NULL
      ,LastProcessedHealthServiceOutageModifiedDateTime   datetime          NULL
)')
END
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateHealthServiceOutage
  (                               
       ReasonCode           tinyint       NOT NULL
      ,DWCreatedDateTime    datetime      NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateHealthServiceOutage PRIMARY KEY CLUSTERED (ReasonCode)
  )
END
GO

 
                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateInvalidatedHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateInvalidatedHealthServiceOutage
  (                               
       HealthServiceOutageRowId   int         NOT NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateInvalidatedHealthServiceOutage PRIMARY KEY CLUSTERED (HealthServiceOutageRowId)
  )
END
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateInvalidatedHealthServiceOutage'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateProcessedHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateProcessedHealthServiceOutage
  (                               
       HealthServiceOutageRowId   int         NOT NULL
      ,StartDateTime              datetime    NOT NULL
      ,EndDateTime                datetime    NULL
      ,ReasonCode                 tinyint     NOT NULL
      ,HealthServiceOutageDWLastModifiedDateTime datetime    NULL
      ,InvalidatedDateTime        datetime    NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      ,DWLastModifiedDateTime     datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateProcessedHealthServiceOutage PRIMARY KEY CLUSTERED (HealthServiceOutageRowId)
  )
END
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateProcessedHealthServiceOutage'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateProcessedMaintenanceMode' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateProcessedMaintenanceMode
  (                               
       MaintenanceModeRowId       int         NOT NULL
      ,StartDateTime              datetime    NOT NULL
      ,EndDateTime                datetime    NULL
      ,PlannedMaintenanceInd      bit         NOT NULL
      ,MaintenanceModeDWLastModifiedDateTime datetime    NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      ,DWLastModifiedDateTime     datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateProcessedMaintenanceMode PRIMARY KEY CLUSTERED (MaintenanceModeRowId)
  )
END
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_StateProcessedMaintenanceMode_EndDateTime_Inc')
BEGIN
  CREATE INDEX IX_StateProcessedMaintenanceMode_EndDateTime_Inc ON dbo.StateProcessedMaintenanceMode(EndDateTime) INCLUDE (MaintenanceModeRowId)
END

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateProcessedMaintenanceMode'
      ,@DatasetId = '$Config/DatasetId$'
GO
 
                    -- insert staging definition into StandardDatasetStagingArea
BEGIN TRAN

IF EXISTS (SELECT * FROM StandardDatasetStagingArea WHERE DatasetId = '$Config/DatasetId$')
BEGIN
  DELETE StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'
END

INSERT StandardDatasetStagingArea
(
   DatasetId
  ,StagingTableColumnDefinition
  ,BatchedProcessingSupportedInd
)
VALUES
(
   '$Config/DatasetId$'
  ,'
   DatasetId					        uniqueidentifier  NOT NULL
  ,ManagementGroupGuid		    uniqueidentifier  NOT NULL
  ,EventOriginId              uniqueidentifier  NOT NULL
  ,[DateTime]                 datetime          NOT NULL
  ,ManagedEntityGuid          uniqueidentifier  NOT NULL
  ,MonitorGuid                uniqueidentifier  NOT NULL
  ,OldHealthState             tinyint           NOT NULL
  ,NewHealthState             tinyint           NOT NULL
  ,ManagedEntityMonitorRowId  int               NULL
  ,InsertReadyInd             AS (ISNULL(ManagedEntityMonitorRowId, 0))
  ,DWCreatedDateTime          datetime          NOT NULL    DEFAULT(GETUTCDATE())
  '
 ,0
)

COMMIT

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateStage' AND TABLE_SCHEMA = 'State')
BEGIN
  DECLARE @Statement nvarchar(max)

  SELECT @Statement = 'CREATE TABLE State.StateStage (' + StagingTableColumnDefinition + ')'
  FROM StandardDatasetStagingArea
  WHERE DatasetId = '$Config/DatasetId$'

  EXECUTE (@Statement)
END
GO

GRANT SELECT, INSERT, UPDATE, DELETE ON State.StateStage TO OpsMgrWriter
GO

                    
                    SET NOCOUNT ON

IF NOT EXISTS (SELECT * FROM StateHealthServiceOutage WHERE ReasonCode = 0)
BEGIN
  INSERT StateHealthServiceOutage(ReasonCode) VALUES (0)
END

IF NOT EXISTS (SELECT * FROM StateHealthServiceOutage WHERE ReasonCode = 1)
BEGIN
  INSERT StateHealthServiceOutage(ReasonCode) VALUES (1)
END
GO


                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vManagedEntityMonitor')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vManagedEntityMonitor AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vManagedEntityMonitor
AS
  SELECT *
  FROM dbo.ManagedEntityMonitor (NOLOCK)
GO

GRANT SELECT ON dbo.vManagedEntityMonitor TO OpsMgrWriter, OpsMgrReader
GO



                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

DECLARE
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@FullViewStatement nvarchar(max)
  ,@FullViewStatementConcatenator nvarchar(20)
  ,@BaseTableName nvarchar(256)

SET @ErrorInd = 0

BEGIN TRY
  -- roll through all aggregations created
  -- and build "full" state views
  
  SET @AggregationTypeId = 0
  SET @FullViewStatement = 'ALTER VIEW dbo.[vStateFull] AS '
  SET @FullViewStatementConcatenator = ''
  
  WHILE EXISTS (SELECT * FROM StandardDatasetAggregationStorage
                WHERE (DatasetId = '$Config/DatasetId$')
                  AND (AggregationTypeId &gt; @AggregationTypeId)
                  AND (DependentTableInd = 0)
               )
  BEGIN
    SELECT TOP 1
       @AggregationTypeId = AggregationTypeId
      ,@BaseTableName = BaseTableName
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = '$Config/DatasetId$')
      AND (AggregationTypeId &gt; @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- create dummy view if not yet exists  
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'v' + REPLACE(@BaseTableName, '''', '''''') + 'Full')
    BEGIN
      SET @Statement = 'CREATE VIEW dbo.' + QUOTENAME('v' + @BaseTableName + 'Full') + ' AS SELECT A = 1'
      EXECUTE (@Statement)

      SET @Statement = 'GRANT SELECT ON dbo.' + QUOTENAME('v' + @BaseTableName + 'Full') + ' TO OpsMgrReader'
      EXECUTE (@Statement)
    END
    
    SELECT @Statement = 
          'ALTER VIEW dbo.' + CAST(QUOTENAME('v' + @BaseTableName + 'Full') as nvarchar(max))
        + ' AS'
        + '  SELECT '
        -- daily aggregations appear to be in "midnight" or thereabouts
        -- to aid UI to present data in different timezones
        + '     [DateTime]'
        + '    ,[Date]'
        + '    ,[Time]'
        + '    ,ManagedEntityMonitorRowId'
        + '    ,ManagedEntityRowId'
        + '    ,MonitorRowId'
        + '    ,IntervalDurationMilliseconds'
        + '    ,InYellowStateMilliseconds'
        + '    ,InRedStateMilliseconds'
        + '    ,InPlannedMaintenanceMilliseconds'
        + '    ,InUnplannedMaintenanceMilliseconds'
        + '    ,InDisabledStateMilliseconds'
        + '    ,HealthServiceUnavailableMilliseconds'
        + '    ,InWhiteStateMilliseconds ='
        + '      CASE'
        + '        WHEN ((ManagedEntityMonitorExistedInd = 0) OR '
        + '              (ah.AggregationCount = 0) OR '
        + '              (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) ' 
        + '             THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds'
        + '        ELSE 0'
        + '      END'
        + '    ,InGreenStateMilliseconds ='
        + '      CASE'
        + '        WHEN (ManagedEntityMonitorExistedInd = 1) AND '
        + '                  ((ah.AggregationCount &gt; 0) OR '
        + '                  ((ah.AggregationCount IS NULL) AND '
        + '                   (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) ' 
        + '            THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds'
        + '        ELSE 0'
        + '      END'
        + '  FROM ('
        + '    SELECT'
        + '       dt.[DateTime]'
        + '      ,dt.[Date]'
        + '      ,dt.[Time]'
        + '      ,ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId'
        + '      ,ManagedEntityRowId = mem.ManagedEntityRowId'
        + '      ,MonitorRowId = mem.MonitorRowId'
        + '      ,ManagedEntityMonitorExistedInd = CASE WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1 END'
        + '      ,IntervalDurationMilliseconds = 60 * 1000 * ' + CAST(a.AggregationIntervalDurationMinutes AS varchar)
        + '      ,InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0)'
        + '      ,InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0)'
        + '      ,InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0)'
        + '      ,InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0)'
        + '      ,InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0)'
        + '      ,HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)'
        + '    FROM vDateTime dt'
        + '          CROSS JOIN vManagedEntityMonitor mem'
        + '          LEFT JOIN ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME('v' + @BaseTableName) + ' s ON '
        +             CASE @AggregationTypeId
                        WHEN 30 THEN '((s.[DateTime] &gt;= dt.[DateTime]) AND (s.[DateTime] &lt; DATEADD(day, 1, dt.[DateTime])) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))'
                        ELSE '((s.[DateTime] = dt.[DateTime]) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))'
                      END
        + '          LEFT JOIN (SELECT DISTINCT mem2.ManagedEntityMonitorRowId, dt2.[Date], dt2.[Time]'
                            + ' FROM vDateTime dt2'
                                  + ' CROSS JOIN vManagedEntityMonitor mem2'
                                  + ' JOIN vManagedEntity me ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)'
                                  + ' JOIN vMonitorManagementPackVersion mmpv ON (mmpv.MonitorRowId = mem2.MonitorRowId)'
		                              + ' JOIN vManagementGroupManagementPackVersion mgmpv ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND'
				                                                                               + ' (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND'
				                                                                               + ' (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND '
				                                                                               + ' (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, ''99991231'')))'
		                              + ' JOIN vManagedEntityManagementGroup memg ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND'
				                                                                      + ' (dt2.[DateTime] &gt;= memg.FromDateTime) AND '
				                                                                      + ' (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, ''99991231'')))'
        + CASE @AggregationTypeId
            WHEN 10 /* subhourly */ THEN ' WHERE (dt2.Minute % ' + CAST(a.AggregationIntervalDurationMinutes AS varchar) + ' = 0)'
            WHEN 20 /* hourly */ THEN ' WHERE (dt2.Minute = 0)'
            -- Perform daily aggregations at midnight UTC times, even in x:30 timezones where dt2.minute != 0
            WHEN 30 /* daily */ THEN ' WHERE (dt2.Minute = ABS(DATEDIFF(minute, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt2.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt2.[DateTime]), 112), 112)'
          END
        + '                    ) AS mem_exists ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])'
        + CASE @AggregationTypeId
            WHEN 10 /* subhourly */ THEN ' WHERE (dt.Minute % ' + CAST(a.AggregationIntervalDurationMinutes AS varchar) + ' = 0)'
            WHEN 20 /* hourly */ THEN ' WHERE (dt.Minute = 0)'
            -- Perform daily aggregations at midnight UTC times, even in x:30 timezones where dt.Minute != 0
            WHEN 30 /* daily */ THEN ' WHERE (dt.Minute = ABS(DATEDIFF(minute, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt.[DateTime]), 112), 112)'
          END
        + '  ) AS tbl'
        + '  LEFT JOIN StandardDatasetAggregationHistory (NOLOCK) ah ON'
        + '             ('
        +             CASE @AggregationTypeId
                        WHEN 30 THEN '(ah.AggregationDateTime &gt;= tbl.[DateTime]) AND (ah.AggregationDateTime &lt; DATEADD(day, 1, tbl.[DateTime]))'
                        ELSE '(ah.AggregationDateTime = tbl.[DateTime])'
                      END
        + '          AND (ah.DatasetId = ''$Config/DatasetId$'')'
        + '          AND (ah.AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10)) + '))'
    FROM StandardDatasetAggregation a
          JOIN StandardDataset d ON (d.DatasetId = a.DatasetId)
    WHERE (d.DatasetId = '$Config/DatasetId$')
      AND (a.AggregationTypeId = @AggregationTypeId)
    
    EXECUTE (@Statement)
      
    SET @FullViewStatement = @FullViewStatement + @FullViewStatementConcatenator
      + ' SELECT'
      + '   AggregationTypeId = ' + CAST(@AggregationTypeId AS varchar)
      + '  ,[DateTime]'
      + '  ,ManagedEntityMonitorRowId'
      + '  ,IntervalDurationMilliseconds'
      + '  ,InWhiteStateMilliseconds'
      + '  ,InGreenStateMilliseconds'
      + '  ,InYellowStateMilliseconds'
      + '  ,InRedStateMilliseconds'
      + '  ,InDisabledStateMilliseconds'
      + '  ,InPlannedMaintenanceMilliseconds'
      + '  ,InUnplannedMaintenanceMilliseconds'
      + '  ,HealthServiceUnavailableMilliseconds'
      + ' FROM dbo.' + QUOTENAME('v' + @BaseTableName + 'Full')
    
    SET @FullViewStatementConcatenator = ' UNION ALL '
  END
  
  -- create dummy 
  IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vStateFull')
  BEGIN
    EXECUTE ('CREATE VIEW dbo.[vStateFull] AS SELECT A = 1')
    EXECUTE ('GRANT SELECT ON dbo.[vStateFull] TO OpsMgrReader')
  END
  
  -- create covering "full" view
  EXECUTE (@FullViewStatement)
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vStateHealthServiceOutage')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vStateHealthServiceOutage AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vStateHealthServiceOutage
AS
  SELECT *
  FROM dbo.StateHealthServiceOutage (NOLOCK)
GO

GRANT SELECT ON dbo.vStateHealthServiceOutage TO OpsMgrWriter, OpsMgrReader
GO
 
                    
                     IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'dbo.GetStateHourly') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('CREATE FUNCTION dbo.GetStateHourly() RETURNS TABLE AS RETURN SELECT NULL as Blank')
GO

ALTER FUNCTION dbo.GetStateHourly
(
    @StartDate datetime
   ,@EndDate datetime
)
RETURNS TABLE
AS
RETURN (
WITH DateTimeCTE
AS (
    SELECT
        DateTime,
        Date,
        Time,
        Minute
    FROM vDateTime dt WHERE dt.Minute = 0 
        AND dt.DateTime &gt;= @StartDate 
        AND dt.DateTime &lt; @EndDate 
        AND dt.[Date] BETWEEN DATEADD(day, -1, @StartDate) AND DATEADD(day, 1, @EndDate)
)
SELECT
  [DateTime],
  [Date],
  [Time],
  ManagedEntityMonitorRowId,
  ManagedEntityRowId,
  MonitorRowId,
  IntervalDurationMilliseconds,
  InYellowStateMilliseconds,
  InRedStateMilliseconds,
  InPlannedMaintenanceMilliseconds,
  InUnplannedMaintenanceMilliseconds,
  InDisabledStateMilliseconds,
  HealthServiceUnavailableMilliseconds,
  InWhiteStateMilliseconds =
    CASE
      WHEN ((ManagedEntityMonitorExistedInd = 0) OR (ah.AggregationCount = 0) OR (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END,
  InGreenStateMilliseconds =
    CASE
      WHEN (ManagedEntityMonitorExistedInd = 1) AND ((ah.AggregationCount &gt; 0) OR ((ah.AggregationCount IS NULL) AND (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END
FROM (SELECT
  dt.[DateTime],
  dt.[Date],
  dt.[Time],
  ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId,
  ManagedEntityRowId = mem.ManagedEntityRowId,
  MonitorRowId = mem.MonitorRowId,
  ManagedEntityMonitorExistedInd =
    CASE
      WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1
    END,
  IntervalDurationMilliseconds = 60 * 1000 * 60,
  InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0),
  InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0),
  InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0),
  InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0),
  InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0),
  HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)
FROM DateTimeCTE dt
CROSS JOIN vManagedEntityMonitor mem
LEFT JOIN [State].[vStateHourly] s
  ON ((s.[DateTime] = dt.[DateTime]) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))
LEFT JOIN (SELECT DISTINCT
  mem2.ManagedEntityMonitorRowId,
  dt2.[Date],
  dt2.[Time]
FROM DateTimeCTE dt2
CROSS JOIN vManagedEntityMonitor mem2
JOIN vManagedEntity me
  ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)
JOIN vMonitorManagementPackVersion mmpv
  ON (mmpv.MonitorRowId = mem2.MonitorRowId)
JOIN vManagementGroupManagementPackVersion mgmpv
  ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, '99991231')))
JOIN vManagedEntityManagementGroup memg
  ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND (dt2.[DateTime] &gt;= memg.FromDateTime) AND (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, '99991231')))
WHERE (dt2.Minute = 0)) AS mem_exists
  ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])
WHERE (dt.Minute = 0)) AS tbl
LEFT JOIN StandardDataset sd ON sd.SchemaName = 'State'
LEFT JOIN StandardDatasetAggregationHistory(NOLOCK) ah
  ON ((ah.AggregationDateTime = tbl.[DateTime]) AND (ah.DatasetId = sd.DatasetId) AND (ah.AggregationTypeId = 20))
)
GO

GRANT SELECT ON GetStateHourly TO OpsMgrReader, OpsMgrWriter
GO
 
                     IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'dbo.GetStateDaily') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('CREATE FUNCTION dbo.GetStateDaily() RETURNS TABLE AS RETURN SELECT NULL as Blank')
GO

ALTER FUNCTION dbo.GetStateDaily
(
    @StartDate datetime
   ,@EndDate datetime
)
RETURNS TABLE
AS
RETURN (
WITH DateTimeCTE
AS (
    SELECT
        DateTime,
        Date,
        Time,
        Minute
    FROM vDateTime dt WHERE dt.Minute = 0 
        AND dt.DateTime &gt;= @StartDate 
        AND dt.DateTime &lt; @EndDate 
        AND dt.[Date] BETWEEN DATEADD(day, -1, @StartDate) AND DATEADD(day, 1, @EndDate)
)
SELECT
  [DateTime],
  [Date],
  [Time],
  ManagedEntityMonitorRowId,
  ManagedEntityRowId,
  MonitorRowId,
  IntervalDurationMilliseconds,
  InYellowStateMilliseconds,
  InRedStateMilliseconds,
  InPlannedMaintenanceMilliseconds,
  InUnplannedMaintenanceMilliseconds,
  InDisabledStateMilliseconds,
  HealthServiceUnavailableMilliseconds,
  InWhiteStateMilliseconds =
    CASE
      WHEN ((ManagedEntityMonitorExistedInd = 0) OR (ah.AggregationCount = 0) OR (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END,
  InGreenStateMilliseconds =
    CASE
      WHEN (ManagedEntityMonitorExistedInd = 1) AND ((ah.AggregationCount &gt; 0) OR ((ah.AggregationCount IS NULL) AND (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END
FROM (SELECT
  dt.[DateTime],
  dt.[Date],
  dt.[Time],
  ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId,
  ManagedEntityRowId = mem.ManagedEntityRowId,
  MonitorRowId = mem.MonitorRowId,
  ManagedEntityMonitorExistedInd =
    CASE
      WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1
    END,
  IntervalDurationMilliseconds = 60 * 1000 * 1440,
  InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0),
  InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0),
  InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0),
  InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0),
  InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0),
  HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)
FROM DateTimeCTE dt
CROSS JOIN vManagedEntityMonitor mem
LEFT JOIN [State].[vStateDaily] s
  ON ((s.[DateTime] &gt;= dt.[DateTime]) AND (s.[DateTime] &lt; DATEADD(DAY, 1, dt.[DateTime])) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))
LEFT JOIN (SELECT DISTINCT
  mem2.ManagedEntityMonitorRowId,
  dt2.[Date],
  dt2.[Time]
FROM DateTimeCTE dt2
CROSS JOIN vManagedEntityMonitor mem2
JOIN vManagedEntity me
  ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)
JOIN vMonitorManagementPackVersion mmpv
  ON (mmpv.MonitorRowId = mem2.MonitorRowId)
JOIN vManagementGroupManagementPackVersion mgmpv
  ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, '99991231')))
JOIN vManagedEntityManagementGroup memg
  ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND (dt2.[DateTime] &gt;= memg.FromDateTime) AND (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, '99991231')))
WHERE (dt2.Minute = ABS(DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt2.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt2.[DateTime]), 112), 112)) AS mem_exists
  ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])
WHERE (dt.Minute = ABS(DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt.[DateTime]), 112), 112)) AS tbl
LEFT JOIN StandardDataset sd ON sd.SchemaName = 'State'
LEFT JOIN StandardDatasetAggregationHistory(NOLOCK) ah
  ON ((ah.AggregationDateTime &gt;= tbl.[DateTime]) AND (ah.AggregationDateTime &lt; DATEADD(DAY, 1, tbl.[DateTime])) AND (ah.DatasetId = sd.DatasetId) AND (ah.AggregationTypeId = 30))
)
GO

GRANT SELECT ON GetStateDaily TO OpsMgrReader, OpsMgrWriter
GO

 
                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'ManagedEntityMonitorDependencyList')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.ManagedEntityMonitorDependencyList AS RETURN 1')
	END
GO

ALTER PROCEDURE ManagedEntityMonitorDependencyList
   @ParentManagedEntityMonitorRowId   int
  ,@LevelCount                        int = 0
AS
BEGIN
  CREATE TABLE #ResultTable
  (
     [Level]                          int   NOT NULL
    ,ParentManagedEntityMonitorRowId  int   NULL
    ,ChildManagedEntityMonitorRowId   int   NOT NULL
  )

  DECLARE
     @CurrentLevel int
    ,@RowCount int
  
  SET @CurrentLevel = 1
  SET @RowCount = 1
  
  INSERT #ResultTable ([Level], ParentManagedEntityMonitorRowId, ChildManagedEntityMonitorRowId)
  VALUES (0, NULL, @ParentManagedEntityMonitorRowId)
  
  WHILE (((@LevelCount &gt;= @CurrentLevel) OR (@LevelCount = 0)) AND (@RowCount &gt; 0))
  BEGIN
    SET @RowCount = 0
    
    INSERT #ResultTable (
       [Level]
      ,ParentManagedEntityMonitorRowId
      ,ChildManagedEntityMonitorRowId
    )
    SELECT DISTINCT
       @CurrentLevel
      ,mem_parent.ManagedEntityMonitorRowId
      ,mem_child.ManagedEntityMonitorRowId
    FROM vManagedEntityMonitor mem_parent
          JOIN vManagedEntityMonitor mem_child ON (mem_parent.ManagedEntityRowId = mem_child.ManagedEntityRowId)
          JOIN vManagedEntity me ON (mem_parent.ManagedEntityRowId = me.ManagedEntityRowId)
          JOIN vMonitorManagementPackVersion mmpv_parent ON (mem_parent.MonitorRowId = mmpv_parent.MonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_child ON (mem_child.MonitorRowId = mmpv_child.MonitorRowId)
          JOIN #ResultTable r ON (mem_parent.ManagedEntityMonitorRowId = r.ChildManagedEntityMonitorRowId)
    WHERE (r.[Level] = @CurrentLevel - 1)
      AND (mmpv_parent.AggregateMonitorInd = 1)
      AND (mmpv_child.ParentMonitorRowId = mem_parent.MonitorRowId)
    
    SET @RowCount = @RowCount + @@ROWCOUNT
    
    INSERT #ResultTable (
       [Level]
      ,ParentManagedEntityMonitorRowId
      ,ChildManagedEntityMonitorRowId
    )
    SELECT DISTINCT
       @CurrentLevel
      ,mem_parent.ManagedEntityMonitorRowId
      ,mem_child.ManagedEntityMonitorRowId
    FROM vManagedEntityMonitor mem_parent
          JOIN #ResultTable res ON (mem_parent.ManagedEntityMonitorRowId = res.ChildManagedEntityMonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_parent ON (mem_parent.MonitorRowId = mmpv_parent.MonitorRowId)
          JOIN vManagedEntityMonitor mem_child ON (mem_child.MonitorRowId = mmpv_parent.DependencyMonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_child ON (mem_child.MonitorRowId = mmpv_child.MonitorRowId)
          JOIN vRelationship r ON ((mem_parent.ManagedEntityRowId = r.SourceManagedEntityRowId) AND (mem_child.ManagedEntityRowId = r.TargetManagedEntityRowId))
    WHERE (res.[Level] = @CurrentLevel - 1)
      AND (mmpv_parent.DependencyMonitorInd = 1)
      AND (mmpv_parent.RelationshipTypeRowId IN (SELECT RelationshipTypeRowId FROM dbo.RelationshipBaseTypeHierarchy(r.RelationshipTypeRowId, 0)))

    SET @RowCount = @RowCount + @@ROWCOUNT
    SET @CurrentLevel = @CurrentLevel + 1
  END
  
  SELECT 
     [Level]
    ,ParentManagedEntityMonitorRowId
    ,ChildManagedEntityMonitorRowId
  FROM #ResultTable
  
  DROP TABLE #ResultTable
END
GO

GRANT EXECUTE ON ManagedEntityMonitorDependencyList TO OpsMgrReader, OpsMgrWriter
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregate')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateAggregate AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateAggregate
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId int
  ,@InsertTableGuid varchar(256)
  ,@IntervalStartDateTime datetime
  ,@IntervalEndDateTime datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY
    DECLARE
       @Statement nvarchar(max)
      ,@DebugLevel tinyint
      ,@AggregationCoverViewName sysname
      ,@InsertTableName sysname
      ,@PreviousIntervalStartDateTime datetime
      ,@DebugMessage nvarchar(4000)
      ,@AggregationStartDateTime datetime
      ,@LowerAggregationTypeId int
      ,@LowerAggregationIntervalMinutes int
      ,@NonDirtyLowerAggregationCount int
      ,@LowerAggregationCoverViewName sysname
      ,@UseAggregatesToBuildStartOfIntervalStateInd bit
      ,@SchemaName sysname
      
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- check to see if non-dirty lower rank
    -- aggregations are available to build this
    -- layer of aggregations
    SELECT TOP 1
       @LowerAggregationTypeId = AggregationTypeId
      ,@LowerAggregationIntervalMinutes = AggregationIntervalDurationMinutes
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId &gt; 0)
      AND (AggregationTypeId &lt; @AggregationTypeId)
      
    IF (@LowerAggregationTypeId IS NOT NULL)
    BEGIN
      -- check if once-calculated aggregations of lower rank
      -- cover the entire interval of this aggregation
      SELECT @NonDirtyLowerAggregationCount = COUNT(*)
      FROM StandardDatasetAggregationHistory
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @LowerAggregationTypeId)
        AND (AggregationCount &gt; 0)
        AND (AggregationDateTime &gt;= @IntervalStartDateTime)
        AND (AggregationDateTime &lt; @IntervalEndDateTime)
    END
    
    IF (@NonDirtyLowerAggregationCount = (ABS(DATEDIFF(minute, @IntervalStartDateTime, @IntervalEndDateTime))) / @LowerAggregationIntervalMinutes)
    BEGIN
      IF (@DebugLevel &gt; 2)
      BEGIN
      -- lower aggregation is available
      -- use is to build aggregates
        SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                           + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                           + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC. Using existing non-dirty aggregations of type ' + CAST(@LowerAggregationTypeId AS varchar)
        SET @AggregationStartDateTime = GETUTCDATE()
        
        EXEC DebugMessageInsert
           @DatasetId = @DatasetId
          ,@MessageLevel = 3
          ,@MessageText = @DebugMessage
      END
      
      SELECT @LowerAggregationCoverViewName = 'v' + BaseTableName
      FROM StandardDatasetAggregationStorage
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @LowerAggregationTypeId)
        AND (DependentTableInd = 0)
        
      SET @Statement =
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' (
              ManagedEntityMonitorRowId
             ,[DateTime]
             ,InRedStateMilliseconds
             ,InYellowStateMilliseconds
             ,InDisabledStateMilliseconds
             ,InPlannedMaintenanceMilliseconds
             ,InUnplannedMaintenanceMilliseconds
             ,HealthServiceUnavailableMilliseconds
           )
            SELECT
               ManagedEntityMonitorRowId
              ,@IntervalStartDateTime
              ,SUM(InRedStateMilliseconds)
              ,SUM(InYellowStateMilliseconds)
              ,SUM(InDisabledStateMilliseconds)
              ,SUM(InPlannedMaintenanceMilliseconds)
              ,SUM(InUnplannedMaintenanceMilliseconds)
              ,SUM(HealthServiceUnavailableMilliseconds)
            FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@LowerAggregationCoverViewName) + '
            WHERE ([DateTime] &gt;= @IntervalStartDateTime)
              AND ([DateTime] &lt; @IntervalEndDateTime)
            GROUP BY ManagedEntityMonitorRowId'
        
      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime
    END
    ELSE
    BEGIN
      -- lower aggregation is dirty or not available
      -- use raw data to build aggregates
      IF (@DebugLevel &gt; 2)
      BEGIN
        SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                           + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                           + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC. Using raw data'
        SET @AggregationStartDateTime = GETUTCDATE()
        
        EXEC DebugMessageInsert
           @DatasetId = @DatasetId
          ,@MessageLevel = 3
          ,@MessageText = @DebugMessage
      END
      
      SET @PreviousIntervalStartDateTime = DATEADD(minute, -ABS(DATEDIFF(minute, @IntervalStartDateTime, @IntervalEndDateTime)), @IntervalStartDateTime)
      
      -- load states for monitors that were
      -- not green at the beginning of this period
      IF EXISTS (SELECT * FROM StandardDatasetAggregationHistory
                 WHERE (AggregationCount &gt; 0)
                   AND (AggregationTypeId = @AggregationTypeId)
                   AND (AggregationDateTime = @PreviousIntervalStartDateTime)
                )
      BEGIN
        -- we have non-dirty previous aggregation
        -- use its info to get all non-green monitors
        SET @UseAggregatesToBuildStartOfIntervalStateInd = 1
        
        SELECT @AggregationCoverViewName = 'v' + BaseTableName
        FROM StandardDatasetAggregationStorage
        WHERE (DatasetId = @DatasetId)
          AND (AggregationTypeId = @AggregationTypeId)
          AND (DependentTableInd = 0)
      END
      ELSE
      BEGIN
        -- pick up the latest state change
        -- for all me/monitor pairs when
        -- there was a change during the period
        -- or the last state wasn't green
        SET @UseAggregatesToBuildStartOfIntervalStateInd = 0
      END
      
      IF (OBJECT_ID('tempdb..#StateEvent') IS NOT NULL)
        DROP TABLE #StateEvent

      CREATE TABLE #StateEvent (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
      
      INSERT #StateEvent (ManagedEntityMonitorRowId, [DateTime], OldHealthState, NewHealthState)
      EXEC StateChangeEventList 
            @ManagedEntityMonitorRowId = NULL
           ,@IntervalStartDateTime = @IntervalStartDateTime
           ,@IntervalEndDateTime = @IntervalEndDateTime
           ,@UseAggregatesToBuildStartOfIntervalStateInd = @UseAggregatesToBuildStartOfIntervalStateInd
           ,@AggregationCoverViewName = @AggregationCoverViewName
           ,@AggregationDateTime = @PreviousIntervalStartDateTime


      IF (OBJECT_ID('tempdb..#StateEventRanked') IS NOT NULL)
        DROP TABLE #StateEventRanked

      CREATE TABLE #StateEventRanked (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,IntervalNumber       int
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
  
      INSERT #StateEventRanked (ManagedEntityMonitorRowId, [DateTime], IntervalNumber, OldHealthState, NewHealthState)
      SELECT 
         ManagedEntityMonitorRowId
        ,[DateTime]
        ,IntervalNumber = RANK() OVER (PARTITION BY ManagedEntityMonitorRowId ORDER BY [DateTime])
        ,OldHealthState
        ,NewHealthState
      FROM #StateEvent

      IF (OBJECT_ID('tempdb..#StateInterval') IS NOT NULL)
        DROP TABLE #StateInterval

      CREATE TABLE #StateInterval (
         ManagedEntityMonitorRowId int
        ,IntervalStartDateTime  datetime
        ,IntervalEndDateTime    datetime
        ,HealthState            tinyint
      )
      
      INSERT #StateInterval (
         ManagedEntityMonitorRowId
        ,IntervalStartDateTime
        ,IntervalEndDateTime
        ,HealthState
      )
      SELECT
         l.ManagedEntityMonitorRowId
        ,CASE WHEN l.[DateTime] &lt; @IntervalStartDateTime
           THEN @IntervalStartDateTime
           ELSE l.[DateTime]
         END
        ,CASE WHEN ISNULL(r.[DateTime], '99991231') &gt; @IntervalEndDateTime
           THEN @IntervalEndDateTime
           ELSE r.[DateTime]
         END
        ,CASE WHEN l.NewHealthState &gt; ISNULL(r.OldHealthState, l.NewHealthState)
           THEN l.NewHealthState
           ELSE ISNULL(r.OldHealthState, l.NewHealthState)
         END
      FROM #StateEventRanked AS l 
              LEFT JOIN #StateEventRanked AS r ON (l.ManagedEntityMonitorRowId = r.ManagedEntityMonitorRowId) AND (l.IntervalNumber + 1 = r.IntervalNumber)
      WHERE (l.[DateTime] &lt; @IntervalEndDateTime)
      
      SET @Statement =
          ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' (
              [DateTime]
             ,ManagedEntityMonitorRowId
             ,InRedStateMilliseconds
             ,InYellowStateMilliseconds
             ,InDisabledStateMilliseconds
             ,InPlannedMaintenanceMilliseconds
             ,InUnplannedMaintenanceMilliseconds
             ,HealthServiceUnavailableMilliseconds
             ,IntervalEndHealthState
           )
            SELECT
               @IntervalStartDateTime
              ,si.ManagedEntityMonitorRowId
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 3 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 2 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 0 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 101 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 100 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 50 THEN 1 ELSE 0 END) )
              ,MAX(ISNULL(se.NewHealthState, 1)) *
                CASE WHEN MAX(ISNULL(se.NewHealthState, 1)) = 1 THEN 1
                     WHEN EXISTS (SELECT *
                                  FROM vManagedEntityMonitor mem
                                        JOIN vManagedEntity me ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)
                                        JOIN vMonitorManagementPackVersion mmpv ON (mmpv.MonitorRowId = mem.MonitorRowId)
                                        JOIN vManagementGroupManagementPackVersion mgmpv ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND
                                                                                             (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND
                                                                                             (@IntervalEndDateTime &gt;= mgmpv.InstalledDateTime) AND 
                                                                                             (@IntervalEndDateTime &lt; ISNULL(mgmpv.DeletedDateTime, ''99991231'')))
                                        JOIN vManagedEntityManagementGroup memg ON ((mem.ManagedEntityRowId = memg.ManagedEntityRowId) AND
                                                                                    (@IntervalEndDateTime &gt;= memg.FromDateTime) AND 
                                                                                    (@IntervalEndDateTime &lt; ISNULL(memg.ToDateTime, ''99991231'') ))
                                  WHERE (mem.ManagedEntityMonitorRowId = si.ManagedEntityMonitorRowId)
                                 )
                     THEN 1
                     ELSE NULL
                END
            FROM #StateInterval si 
              LEFT JOIN ( 
                    SELECT
                       ser.ManagedEntityMonitorRowId
                      ,IntervalNumber = MAX(ser.IntervalNumber)
                    FROM #StateEventRanked ser 
                    WHERE (ser.OldHealthState &lt; 50)
                      AND (ser.NewHealthState &lt; 50)
                    GROUP BY ser.ManagedEntityMonitorRowId
                   ) AS last_transition ON (si.ManagedEntityMonitorRowId = last_transition.ManagedEntityMonitorRowId)
              LEFT JOIN #StateEventRanked se ON (si.ManagedEntityMonitorRowId = se.ManagedEntityMonitorRowId) AND (se.IntervalNumber = last_transition.IntervalNumber)
            WHERE (si.HealthState &lt;&gt; 1)
            GROUP BY si.ManagedEntityMonitorRowId'

      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime

      DROP TABLE #StateInterval
      
      DROP TABLE #StateEventRanked

      DROP TABLE #StateEvent
    END
    
    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Finished aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      
      DECLARE @OperationDurationMs bigint
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @AggregationStartDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END

  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
      
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to build aggregates for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregationDelete')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateAggregationDelete AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateAggregationDelete
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@AggregationDateTime datetime
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugMessage nvarchar(max)
    ,@DeleteStartedDateTime datetime
    ,@OperationDurationMs bigint
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- Index hint in the query below ensures that SQL won't
    -- consider index on DateTime field to be a good source
    -- to find rows to delete - it may happen periodically
    -- if SQL thinks there's no rows to delete due to
    -- lack of [recently updated] statistics    
    SET @Statement = 'DELETE t' + 
				   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' t WITH (INDEX(1))'
                   + ' WHERE (t.[DateTime] = CONVERT(datetime, ''' + CONVERT(varchar(50), @AggregationDateTime, 120) + ''', 120))'

    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Starting delete of existing aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      
      SET @DeleteStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
   
    EXECUTE(@Statement)
    
    SET @RowsDeleted = @@ROWCOUNT
  
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Finished delete of existing aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @DeleteStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to delete aggregated data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
 
                      IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateChangeEventList')
	  BEGIN
		  EXECUTE ('CREATE PROCEDURE dbo.StateChangeEventList AS RETURN 1')
	  END
  GO

  /*******************************************************

  Builds list of all state change events that a relevant
  for a given interval. If MEMRowId is provided only
  that monitor instance is considered otherwise all
  monitors are considered.

  If @UseAggregatesToBuildStartOfIntervalStateInd is 0 the
  proc will return last state change that happened
  just before @IntervalStartDateTime for each monitor
  that had a state change within the interval OR for the one
  provided in parameters

  If @UseAggregatesToBuildStartOfIntervalStateInd is 1, the
  proc will use existing aggregated data specified
  by parameters @AggregationCoverViewName, @AggregationDateTime
  to build fake state change event that happened at
  @AggregationDateTime (this method is used by aggregations
  to save time when calculating aggregates and previous
  aggregation is available)

  *******************************************************/
  ALTER PROCEDURE StateChangeEventList
     @ManagedEntityMonitorRowId     int = NULL
    ,@IntervalStartDateTime         datetime
    ,@IntervalEndDateTime           datetime
    ,@UseAggregatesToBuildStartOfIntervalStateInd  bit = 0
    ,@AggregationCoverViewName      sysname = NULL
    ,@AggregationDateTime           datetime = NULL
  AS
  BEGIN
    SET NOCOUNT ON

    DECLARE 
       @ErrorInd        bit
      ,@ErrorMessage    nvarchar(4000)
      ,@ErrorNumber     int
      ,@ErrorSeverity   int
      ,@ErrorState      int
      ,@ErrorLine       int
      ,@ErrorProcedure  nvarchar(256)
      ,@ErrorMessageText nvarchar(4000)

    SET @ErrorInd = 0
    
    BEGIN TRY
      DECLARE
         @Statement nvarchar(max)
        ,@RawCoverViewName sysname
        ,@ExtraCondition nvarchar(max)
    
      SET @ExtraCondition =
         CASE
           WHEN @ManagedEntityMonitorRowId IS NULL THEN 
              CASE 
                WHEN (OBJECT_ID('tempdb..#ManagedEntityMonitor') IS NOT NULL) THEN ' AND (ManagedEntityMonitorRowId IN (SELECT ManagedEntityMonitorRowId FROM #ManagedEntityMonitor)) '
                ELSE ''
              END
           ELSE ' AND (ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId)'
         END
         
      IF (OBJECT_ID('tempdb..#StateEventChange') IS NOT NULL)
        DROP TABLE #StateEventChange

      CREATE TABLE #StateEventChange (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
        
      -- get all state changes
      -- that happened within the interval
      SET @Statement =
          ' INSERT #StateEventChange(
               ManagedEntityMonitorRowId
              ,[DateTime]
              ,OldHealthState
              ,NewHealthState
            )
            SELECT
               ManagedEntityMonitorRowId
              ,[DateTime]
              ,OldHealthState
              ,NewHealthState
            FROM [State].[vStateRaw] s
            WHERE ([DateTime] BETWEEN @IntervalStartDateTime AND @IntervalEndDateTime)'
        + @ExtraCondition
        
      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime, @ManagedEntityMonitorRowId int'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime
        ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

      IF (@UseAggregatesToBuildStartOfIntervalStateInd = 1)
      BEGIN
		    -- NOTE: We do not return intervals where end state is 1 (healthy)
        SET @Statement =
            ' INSERT #StateEventChange(
                 ManagedEntityMonitorRowId
                ,[DateTime]
                ,OldHealthState
                ,NewHealthState
              )
              SELECT
                 s.ManagedEntityMonitorRowId
                ,@IntervalStartDateTime
                ,0
                ,ISNULL(s.IntervalEndHealthState, 0)
              FROM [State].' + QUOTENAME(@AggregationCoverViewName) + ' s
              WHERE (s.[DateTime] = @AggregationDateTime)
                AND (s.IntervalEndHealthState &lt;&gt; 1)'
          + @ExtraCondition

        EXEC sp_executesql
           @stmt = @Statement
          ,@params = N'@IntervalStartDateTime datetime, @AggregationDateTime datetime, @ManagedEntityMonitorRowId int'
          ,@IntervalStartDateTime = @IntervalStartDateTime
          ,@AggregationDateTime = @AggregationDateTime
          ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
      END
      ELSE
      BEGIN
        -- pick up the latest state change
        -- for all me/monitor pairs when
        -- there was a change during the period
        -- or the last state wasn't green
        SET @Statement =
            ' INSERT #StateEventChange(
                 ManagedEntityMonitorRowId
                ,[DateTime]
                ,OldHealthState
                ,NewHealthState
              )
              SELECT
                 s.ManagedEntityMonitorRowId
                ,@IntervalStartDateTime
                ,0
                ,MAX(s.NewHealthState)
              FROM [State].[vStateRaw] s
		         			JOIN 
             		 (SELECT ManagedEntityMonitorRowId, [DateTime] = MAX(DateTime)
                    FROM [State].[vStateRaw]
                    WHERE ([DateTime] &lt; @IntervalStartDateTime)'
             + @ExtraCondition + '
                    GROUP BY ManagedEntityMonitorRowId
                   ) AS sd
		             ON (s.ManagedEntityMonitorRowId = sd.ManagedEntityMonitorRowId) AND (s.[DateTime] = sd.[DateTime])
              GROUP BY s.ManagedEntityMonitorRowId'

        EXEC sp_executesql
           @stmt = @Statement
          ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
          ,@IntervalStartDateTime = @IntervalStartDateTime
          ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
      END
          
      -- factor in HS availability/outage
      IF EXISTS (SELECT * FROM StateHealthServiceOutage)
      BEGIN
        -- store all relationship types that represent 'manages'
        -- concept in the table
        IF (OBJECT_ID('tempdb..#ManagesRelationshipType') IS NOT NULL)
          DROP TABLE #ManagesRelationshipType
          
        CREATE TABLE #ManagesRelationshipType (
           RelationshipTypeRowId        int NOT NULL
        )

        -- R2 style 'manages' relationship between HS and an object
        INSERT #ManagesRelationshipType (RelationshipTypeRowId)
        SELECT RelationshipTypeRowId
        FROM RelationshipType rt
        WHERE (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.HealthServiceManagesEntity')

        -- OM12 style 'manages' relationship between HS2(Management Service) or pool and an object
        INSERT #ManagesRelationshipType (RelationshipTypeRowId)
        SELECT RelationshipTypeRowId
        FROM RelationshipType rt
        WHERE (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.ManagementActionPointManagesEntity')

        -- get a list of all relevant HSOs occurring in the given period of time
        -- NOTE: we store two rows for every HSO - one for start of interval and one for the end
        IF (OBJECT_ID('tempdb..#HealthServiceOutageEvent') IS NOT NULL)
          DROP TABLE #HealthServiceOutageEvent
          
        CREATE TABLE #HealthServiceOutageEvent (
           ManagedEntityRowId int       NOT NULL
          ,[DateTime]         datetime  NOT NULL
          ,OldHealthState     tinyint   NOT NULL
          ,NewHealthState     tinyint   NOT NULL
        )

        INSERT #HealthServiceOutageEvent (
           ManagedEntityRowId
          ,[DateTime]
          ,OldHealthState
          ,NewHealthState
        )
        SELECT
           hso.ManagedEntityRowId
          ,CASE
            WHEN interval.StartIntervalInd = 1 THEN 
              CASE
                WHEN hso.StartDateTime &lt; @IntervalStartDateTime THEN @IntervalStartDateTime
                ELSE hso.StartDateTime
              END
            ELSE
              CASE
                WHEN ISNULL(hso.EndDateTime, '99991231') &gt; @IntervalEndDateTime THEN @IntervalEndDateTime
                ELSE hso.EndDateTime
              END
           END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN  0 ELSE 50 END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN 50 ELSE  1 END
        FROM vHealthServiceOutage hso
              JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
              CROSS JOIN (SELECT StartIntervalInd = 0
                          UNION ALL
                          SELECT 1
                         ) AS interval
        -- Only go back a maximum of 60 days to prevent infinite growth
        WHERE (hso.StartDateTime BETWEEN DateAdd(DAY, -60, GETUTCDATE()) AND @IntervalEndDateTime)
          AND (ISNULL(hso.EndDateTime, '99991231') &gt;= @IntervalStartDateTime)
          AND (NOT EXISTS (SELECT *
                           FROM StateInvalidatedHealthServiceOutage
                           WHERE (HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                          )
              )

        IF EXISTS (SELECT * FROM #HealthServiceOutageEvent)
        BEGIN
          -- take care of HSO outages that indicate HS or a pool outage
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,hso.[DateTime]
                  ,hso.OldHealthState
                  ,hso.NewHealthState
                FROM #HealthServiceOutageEvent hso
                      JOIN vRelationship r ON (r.SourceManagedEntityRowId = hso.ManagedEntityRowId)
                      JOIN #ManagesRelationshipType mrt ON (mrt.RelationshipTypeRowId = r.RelationshipTypeRowId)
                      JOIN vRelationshipManagementGroup rmg ON (r.RelationshipRowId = rmg.RelationshipRowId)
                      JOIN vManagedEntity me ON (r.TargetManagedEntityRowId = me.TopLevelHostManagedEntityRowId)
                      JOIN vManagedEntityMonitor mem ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)
                WHERE (@IntervalStartDateTime BETWEEN rmg.FromDateTime AND ISNULL(rmg.ToDateTime, ''99991231''))'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
            ,@IntervalStartDateTime = @IntervalStartDateTime
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

          -- take care of HSO outages that indicate entity (which is TLH) outage
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,hso.[DateTime]
                  ,hso.OldHealthState
                  ,hso.NewHealthState
                FROM #HealthServiceOutageEvent hso
                      JOIN vManagedEntity me ON (hso.ManagedEntityRowId = me.TopLevelHostManagedEntityRowId)
                      JOIN vManagedEntityMonitor mem ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
            ,@IntervalStartDateTime = @IntervalStartDateTime
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

          -- set new state of the periods where hso ended to 'last reported state transition'
          CREATE INDEX temp1 ON #StateEventChange (ManagedEntityMonitorRowId)

          SET @Statement = '
            UPDATE se
            SET se.NewHealthState = ISNULL(previous_real_transition.NewHealthState, 1)
            FROM #StateEventChange se
                JOIN (
                      SELECT
                         MEMRowId = previous_se.ManagedEntityMonitorRowId
                        ,CutOffDateTime = cutoff_se.[DateTime]
                        ,previous_se.NewHealthState
                        ,StateEventNumber = RANK() OVER (PARTITION BY previous_se.ManagedEntityMonitorRowId, cutoff_se.[DateTime] ORDER BY previous_se.[DateTime] DESC, previous_se.NewHealthState DESC)
                      FROM #StateEventChange cutoff_se
                            JOIN #StateEventChange previous_se ON (cutoff_se.ManagedEntityMonitorRowId = previous_se.ManagedEntityMonitorRowId) AND (cutoff_se.[DateTime] &gt; previous_se.[DateTime])
                      WHERE (cutoff_se.OldHealthState = 50)
                        AND (previous_se.OldHealthState &lt; 50)
                        AND (previous_se.NewHealthState &lt; 50) -- real state transition, not hso or mmode
                     ) AS previous_real_transition ON (se.ManagedEntityMonitorRowId = previous_real_transition.MEMRowId) AND (se.[DateTime] = previous_real_transition.CutOffDateTime)
            WHERE (se.OldHealthState = 50)
              AND (previous_real_transition.StateEventNumber = 1)'
          + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@ManagedEntityMonitorRowId int'
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
        END
      END

      -- factor in maintenance mode
      -- using two itertions - first for unlanned maintenance
      -- then second for planned maintenance
      DECLARE @i int
      SET @i = 0

      WHILE (@i &lt; 2)
      BEGIN
        -- find all relevant mmode intervals
        IF (OBJECT_ID('tempdb..#MaintenanceModeEvent') IS NOT NULL)
          DROP TABLE #MaintenanceModeEvent
          
        CREATE TABLE #MaintenanceModeEvent (
           ManagedEntityRowId int       NOT NULL
          ,[DateTime]         datetime  NOT NULL
          ,OldHealthState     tinyint   NOT NULL
          ,NewHealthState     tinyint   NOT NULL
        )

        INSERT #MaintenanceModeEvent (
           ManagedEntityRowId
          ,[DateTime]
          ,OldHealthState
          ,NewHealthState
        )
        SELECT
           mm.ManagedEntityRowId
          ,CASE
            WHEN interval.StartIntervalInd = 1 THEN 
              CASE
                WHEN mm.StartDateTime &lt; @IntervalStartDateTime THEN @IntervalStartDateTime
                ELSE mm.StartDateTime
              END
            ELSE
              CASE
                WHEN ISNULL(mm.EndDateTime, '99991231') &gt; @IntervalEndDateTime THEN @IntervalEndDateTime
                ELSE mm.EndDateTime
              END
           END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN        0 ELSE 100 + @i END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN 100 + @i ELSE        1 END
        FROM vMaintenanceMode mm
              CROSS JOIN (SELECT StartIntervalInd = 0
                          UNION ALL
                          SELECT 1
                         ) AS interval
        -- Only go back a maximum of 60 days to prevent infinite growth
        WHERE (mm.StartDateTime BETWEEN DateAdd(DAY, -60, GETUTCDATE()) AND @IntervalEndDateTime)
          AND (ISNULL(mm.EndDateTime, '99991231') &gt;= @IntervalStartDateTime)
          AND (mm.PlannedMaintenanceInd = @i)

        IF EXISTS (SELECT * FROM #MaintenanceModeEvent)
        BEGIN
          DELETE se
          FROM #StateEventChange se
                JOIN vManagedEntityMonitor mem ON (se.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId)
                JOIN vMaintenanceMode mm ON (mem.ManagedEntityRowId = mm.ManagedEntityRowId)
          WHERE (se.[DateTime] BETWEEN mm.StartDateTime AND ISNULL(mm.EndDateTime, '99990101'))
            AND (mm.PlannedMaintenanceInd = @i)
     
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,mm.[DateTime]
                  ,mm.OldHealthState
                  ,mm.NewHealthState
                FROM #MaintenanceModeEvent mm
                      JOIN vManagedEntityMonitor mem ON (mm.ManagedEntityRowId = mem.ManagedEntityRowId)
                WHERE (1 = 1)'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@ManagedEntityMonitorRowId int'
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
        END

        SET @i = @i + 1
      END
      
      -- clean out dupes in state transition
      SELECT
         ManagedEntityMonitorRowId
        ,[DateTime]
        ,OldHealthState = MAX(OldHealthState)
        ,NewHealthState = MAX(NewHealthState)
      FROM #StateEventChange
      GROUP BY ManagedEntityMonitorRowId, [DateTime]

      DROP TABLE #StateEventChange
    END TRY
    BEGIN CATCH
      SELECT 
         @ErrorNumber = ERROR_NUMBER()
        ,@ErrorSeverity = ERROR_SEVERITY()
        ,@ErrorState = ERROR_STATE()
        ,@ErrorLine = ERROR_LINE()
        ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
        ,@ErrorMessageText = ERROR_MESSAGE()

      SET @ErrorInd = 1
    END CATCH
    
    -- report error if any
    IF (@ErrorInd = 1)
    BEGIN
      DECLARE @AdjustedErrorSeverity int

      SET @AdjustedErrorSeverity = CASE
                                     WHEN @ErrorSeverity &gt; 18 THEN 18
                                     ELSE @ErrorSeverity
                                   END
      
      RAISERROR (777971002, @AdjustedErrorSeverity, 1
        ,@ErrorNumber
        ,@ErrorSeverity
        ,@ErrorState
        ,@ErrorProcedure
        ,@ErrorLine
        ,@ErrorMessageText
      )
    END
  END
  GO
   
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateDowntimeList')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateDowntimeList AS RETURN 1')
	END
GO

ALTER PROCEDURE StateDowntimeList
   @ManagedEntityMonitorRowId    int
  ,@FromDateTime                 datetime
  ,@ToDateTime                   datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY

    IF (OBJECT_ID('tempdb..#StateEvent') IS NOT NULL)
      DROP TABLE #StateEvent

    CREATE TABLE #StateEvent (
       ManagedEntityMonitorRowId int
      ,[DateTime]           datetime
      ,OldHealthState       tinyint
      ,NewHealthState       tinyint
    )
  
    IF (OBJECT_ID('tempdb..#StateEventRanked') IS NOT NULL)
      DROP TABLE #StateEventRanked

    CREATE TABLE #StateEventRanked (
       ManagedEntityMonitorRowId int
      ,[DateTime]           datetime
      ,IntervalNumber       int
      ,OldHealthState       tinyint
      ,NewHealthState       tinyint
    )
  
    INSERT #StateEvent (ManagedEntityMonitorRowId, [DateTime], OldHealthState, NewHealthState)
    EXEC StateChangeEventList 
          @ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
         ,@IntervalStartDateTime = @FromDateTime
         ,@IntervalEndDateTime = @ToDateTime

    INSERT #StateEventRanked (ManagedEntityMonitorRowId, [DateTime], IntervalNumber, OldHealthState, NewHealthState)
    SELECT 
       ManagedEntityMonitorRowId
      ,[DateTime]
      ,IntervalNumber = RANK() OVER (PARTITION BY ManagedEntityMonitorRowId ORDER BY [DateTime])
      ,OldHealthState
      ,NewHealthState
      FROM #StateEvent

    SELECT 
       ManagedEntityMonitorRowId
      ,FromDateTime = 
        CASE 
          WHEN FromDateTime &lt; @FromDateTime THEN @FromDateTime
          ELSE FromDateTime
        END
      ,ToDateTime = ISNULL(ToDateTime, @ToDateTime)
      ,HealthState
    FROM (SELECT
             l.ManagedEntityMonitorRowId
            ,FromDateTime = l.[DateTime]
            ,ToDateTime = r.[DateTime]
            ,HealthState = 
               CASE WHEN l.NewHealthState &gt; ISNULL(r.OldHealthState, l.NewHealthState)
                 THEN l.NewHealthState
                 ELSE ISNULL(r.OldHealthState, l.NewHealthState)
               END
          FROM #StateEventRanked AS l 
                LEFT JOIN #StateEventRanked AS r ON (l.ManagedEntityMonitorRowId = r.ManagedEntityMonitorRowId) AND (l.IntervalNumber + 1 = r.IntervalNumber)
        ) AS tbl
    WHERE (HealthState &lt;&gt; 1)
      AND (FromDateTime &lt; ISNULL(ToDateTime, @ToDateTime)) -- eliminate zero-length intervals
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
      
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON StateDowntimeList TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'DELETE TOP (' + CAST(@MaxRowsToGroom AS varchar(15)) + ')'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'

    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    -- groom dynamic dimentions
    DELETE mem
    FROM ManagedEntityMonitor mem
    WHERE NOT EXISTS (SELECT * FROM vMonitor m WHERE (m.MonitorRowId = mem.MonitorRowId))
    
    DELETE mem
    FROM ManagedEntityMonitor mem
    WHERE NOT EXISTS (SELECT * FROM vManagedEntity me WHERE (me.ManagedEntityRowId = mem.ManagedEntityRowId))
    
    -- groom staging of data for rejected MGs
    DELETE State.StateStage
    WHERE ManagementGroupGuid NOT IN (SELECT ManagementGroupGuid
                                      FROM ManagementGroup mg
                                      WHERE (ConnectConfirmedDateTime IS NOT NULL)
                                        AND (ConnectRejectedInd = 0)
                                     )
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- groom records that are &gt; month old since
    -- aggregations only kept one month long
    DELETE State.StateStage WITH (TABLOCK)
    WHERE ([DateTime] &lt; DATEADD(month, -1, GETUTCDATE()))

    -- process staging to create ME Monitor records for newly discovered monitors
    INSERT ManagedEntityMonitor (
       ManagedEntityRowId
      ,MonitorRowId
    )
    SELECT DISTINCT
       me.ManagedEntityRowId
      ,m.MonitorRowId
    FROM State.StateStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((me.ManagedEntityGuid = s.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
          JOIN vMonitor m ON (m.MonitorGuid = s.MonitorGuid)
    WHERE (s.DatasetId = @DatasetId)
      AND NOT EXISTS (SELECT *
                      FROM vManagedEntityMonitor
                      WHERE (ManagedEntityRowId = me.ManagedEntityRowId)
                        AND (MonitorRowId = m.MonitorRowId)
                     )
    
    -- process events in staging setting MEM id if it is not yet determined
    
    -- NOTE: The force order hint below is meant to avoid situation when 
    -- dw has more records in ME then in MEM and SQL thinks that querying
    -- MEM first and then ME is beneficial (which is not true really)
    UPDATE s
    SET ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId
    FROM State.StateStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((me.ManagedEntityGuid = s.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
          JOIN vMonitor m ON (m.MonitorGuid = s.MonitorGuid)
          JOIN vManagedEntityMonitor mem ON ((mem.ManagedEntityRowId = me.ManagedEntityRowId) AND (mem.MonitorRowId = m.MonitorRowId))
    WHERE (s.DatasetId = @DatasetId)
      AND (s.InsertReadyInd = 0)
    OPTION (FORCE ORDER)

    -- delete sate transitions older then 48 hours to 
    -- not to go back 'too much' - such state transitions
    -- are cut of by the agents, but they can linger in staging
    -- if object existed but then was deleted
    DELETE State.StateStage
    WHERE (DatasetId = @DatasetId)
      AND (InsertReadyInd &gt; 0)
      AND ([DateTime] &lt; DATEADD(hour, -48, GETUTCDATE()))
    
    -- invalidate HSO intervals when the HS in question
    -- did send some state changes during the interval
    -- NOTE: Starting OM2012 SP1 we do not invalidate
    -- HS outage intervals to close map to operational
    -- side of the house and not to throw state aggregations
    -- back too much when HS coming out of long outage period
    /*
    IF EXISTS (SELECT * FROM StateHealthServiceOutage)
    BEGIN
      INSERT StateInvalidatedHealthServiceOutage (HealthServiceOutageRowId)
      SELECT DISTINCT hso.HealthServiceOutageRowId
      FROM State.StateStage s
            JOIN vManagedEntity me ON (me.ManagedEntityGuid = s.ManagedEntityGuid)
            JOIN vRelationship r ON (me.TopLevelHostManagedEntityRowId = r.TargetManagedEntityRowId)
            JOIN vRelationshipManagementGroup rmg ON (r.RelationshipRowId = rmg.RelationshipRowId)
            JOIN vRelationshipType rt ON (r.RelationshipTypeRowId = rt.RelationshipTypeRowId)
            JOIN vHealthServiceOutage hso ON (r.SourceManagedEntityRowId = hso.ManagedEntityRowId)
            JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
      WHERE (s.InsertReadyInd &gt; 0)
        AND (s.[DateTime] BETWEEN rmg.FromDateTime AND ISNULL(rmg.ToDateTime, '99991231'))
        AND (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.HealthServiceManagesEntity')
        AND (s.[DateTime] BETWEEN hso.StartDateTime AND ISNULL(hso.EndDateTime, '99991231'))
        AND (NOT EXISTS (SELECT *
                         FROM StateInvalidatedHealthServiceOutage
                         WHERE (HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                        )
            )
    END
    */

    -- mark existing aggregations as dirty when
    -- new information about mmode is received
    BEGIN TRAN
    
    DECLARE
       @LastProcessedMModeModifiedDateTime datetime
      ,@NewLastProcessedMModeModifiedDateTime datetime
      ,@MinDate datetime
    
    SELECT @LastProcessedMModeModifiedDateTime = LastProcessedMaintenanceModeModifiedDateTime
    FROM StateAggregationProcessing
    WHERE (DatasetId = @DatasetId)
    
    IF (@LastProcessedMModeModifiedDateTime IS NULL)
    BEGIN
      SET @LastProcessedMModeModifiedDateTime = '20050101'
    END
    
    SELECT @NewLastProcessedMModeModifiedDateTime = DATEADD(second, -5, GETUTCDATE())
    
    -- build a list of all mmode intervals
    -- touched since last processing up until [almost] now
    CREATE TABLE #UpdatedMaintenanceMode (
       MaintenanceModeRowId     int       NOT NULL PRIMARY KEY
      ,StartDateTime            datetime  NOT NULL
      ,EndDateTime              datetime  NULL
      ,PlannedMaintenanceInd    bit       NOT NULL
      ,DWLastModifiedDateTime   datetime  NOT NULL
    )
    
    INSERT #UpdatedMaintenanceMode (
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    )
    SELECT 
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    FROM vMaintenanceMode mmode
    WHERE (mmode.DWLastModifiedDateTime &gt;= @LastProcessedMModeModifiedDateTime)
      AND (mmode.DWLastModifiedDateTime &lt; @NewLastProcessedMModeModifiedDateTime)
    
    -- calculate minimum date for re-aggregations
    SET @MinDate = NULL
    
    SELECT @MinDate = MIN(
            CASE
              WHEN (processed_mmode.MaintenanceModeRowId IS NULL) -- not yet processed
                THEN mmode.StartDateTime
              ELSE
                CASE
                  WHEN (processed_mmode.PlannedMaintenanceInd != mmode.PlannedMaintenanceInd) -- changed planned / unplanned
                    THEN mmode.StartDateTime
                  WHEN (mmode.EndDateTime IS NOT NULL) -- end time update - pick up minimum of end times
                   AND (ISNULL(processed_mmode.EndDateTime, '99991231') != mmode.EndDateTime)
                      THEN CASE
                             WHEN mmode.EndDateTime &lt; ISNULL(processed_mmode.EndDateTime, '99991231') THEN mmode.EndDateTime
                             ELSE processed_mmode.EndDateTime
                           END
                  ELSE NULL
                END
            END
    )
    FROM #UpdatedMaintenanceMode mmode
          LEFT JOIN StateProcessedMaintenanceMode processed_mmode ON (mmode.MaintenanceModeRowId = processed_mmode.MaintenanceModeRowId)

    -- update processed mmode for the intervals that were updated
    UPDATE processed_mmode
    SET StartDateTime = mmode.StartDateTime
       ,EndDateTime = mmode.EndDateTime
       ,PlannedMaintenanceInd = mmode.PlannedMaintenanceInd
       ,MaintenanceModeDWLastModifiedDateTime = mmode.DWLastModifiedDateTime
       ,DWLastModifiedDateTime = GETUTCDATE()
    FROM #UpdatedMaintenanceMode mmode
           JOIN StateProcessedmaintenanceMode processed_mmode ON (mmode.MaintenanceModeRowId = processed_mmode.MaintenanceModeRowId)
    
    -- add records to processed HSO for the outages that are new
    INSERT StateProcessedMaintenanceMode (
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,MaintenanceModeDWLastModifiedDateTime
    )
    SELECT
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    FROM #UpdatedMaintenanceMode mmode
    WHERE (NOT EXISTS (SELECT * FROM StateProcessedMaintenanceMode WHERE MaintenanceModeRowId = mmode.MaintenanceModeRowId))
    
    -- groom processed mmode table
    DELETE StateProcessedMaintenanceMode
    WHERE EndDateTime &lt; DATEADD(month, -1, GETUTCDATE())

    DROP TABLE #UpdatedMaintenanceMode

    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END
    
    UPDATE StateAggregationProcessing
    SET LastProcessedMaintenanceModeModifiedDateTime = @NewLastProcessedMModeModifiedDateTime
    WHERE (DatasetId = @DatasetId)
    
    IF (@@ROWCOUNT = 0)
    BEGIN
      INSERT StateAggregationProcessing(DatasetId, LastProcessedMaintenanceModeModifiedDateTime)
      VALUES (@DatasetId, @NewLastProcessedMModeModifiedDateTime)
    END

    COMMIT      

    -- mark existing aggregations as dirty when
    -- new information about health service outage is received
    BEGIN TRAN
    
    DECLARE
       @LastProcessedHsoModifiedDateTime datetime
      ,@NewLastProcessedHsoModifiedDateTime datetime
    
    SELECT @LastProcessedHsoModifiedDateTime = LastProcessedHealthServiceOutageModifiedDateTime
    FROM StateAggregationProcessing
    WHERE (DatasetId = @DatasetId)
    
    IF (@LastProcessedHsoModifiedDateTime IS NULL)
    BEGIN
      SET @LastProcessedHsoModifiedDateTime = '20050101'
    END
    
    SELECT @NewLastProcessedHsoModifiedDateTime = DATEADD(second, -5, GETUTCDATE())
    
    -- calculate the minimum date to 
    -- declare aggregations as dirty
    
    -- build a list of all HSO records and invalidation
    -- records touched since last processing up until [almost] now
    CREATE TABLE #UpdatedHealthServiceOutage (
       HealthServiceOutageRowId     int       NOT NULL PRIMARY KEY
      ,StartDateTime                datetime  NOT NULL
      ,EndDateTime                  datetime  NULL
      ,ReasonCode                   tinyint   NOT NULL
      ,DWLastModifiedDateTime       datetime  NOT NULL
      ,InvalidatedDateTime          datetime  NULL
    )
    
    INSERT #UpdatedHealthServiceOutage (
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,DWLastModifiedDateTime
      ,InvalidatedDateTime
    )
    SELECT
       hso.HealthServiceOutageRowId
      ,hso.StartDateTime
      ,hso.EndDateTime
      ,hso.ReasonCode
      ,hso.DWLastModifiedDateTime
      ,sihso.DWCreatedDateTime
    FROM vHealthServiceOutage hso
          JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
          LEFT JOIN StateInvalidatedHealthServiceOutage sihso ON (hso.HealthServiceOutageRowId = sihso.HealthServiceOutageRowId)
    WHERE (hso.DWLastModifiedDateTime &gt;= @LastProcessedHsoModifiedDateTime)
      AND (hso.DWLastModifiedDateTime &lt; @NewLastProcessedHsoModifiedDateTime)
    
    UNION
    
    SELECT
       hso.HealthServiceOutageRowId
      ,hso.StartDateTime
      ,hso.EndDateTime
      ,hso.ReasonCode
      ,hso.DWLastModifiedDateTime
      ,sihso.DWCreatedDateTime
    FROM vHealthServiceOutage hso
          JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
          JOIN StateInvalidatedHealthServiceOutage sihso ON (hso.HealthServiceOutageRowId = sihso.HealthServiceOutageRowId)
    WHERE (sihso.DWCreatedDateTime &gt;= @LastProcessedHsoModifiedDateTime)
      AND (sihso.DWCreatedDateTime &lt; @NewLastProcessedHsoModifiedDateTime)
      
    SET @MinDate = NULL
      
    SELECT @MinDate = MIN(
              CASE
                WHEN (processed_hso.HealthServiceOutageRowId IS NULL) -- this hso was never processed before
                  THEN
                    CASE
                      WHEN (uhso.InvalidatedDateTime IS NULL) -- not invalidated
                        THEN uhso.StartDateTime
                      ELSE -- this hso is already invalidated - do not process
                        NULL
                    END
                ELSE  -- this hso was seen before
                    CASE
                      WHEN (processed_hso.InvalidatedDateTime IS NOT NULL) -- already invalidated, does not count
                        THEN NULL
                      WHEN (uhso.InvalidatedDateTime IS NOT NULL) -- hso invalidated
                        THEN uhso.InvalidatedDateTime -- look at invalidated date time not Start date time for perf optimizations. Otherwise we throw aggregation process back all the time
                      WHEN (uhso.EndDateTime IS NOT NULL) -- end time update - pick up minimum of end times
                       AND (ISNULL(processed_hso.EndDateTime, '99991231') != uhso.EndDateTime)
                          THEN CASE
                                 WHEN uhso.EndDateTime &lt; ISNULL(processed_hso.EndDateTime, '99991231') THEN uhso.EndDateTime
                                 ELSE processed_hso.EndDateTime
                               END
                      ELSE NULL
                    END
              END
           )
    FROM #UpdatedHealthServiceOutage AS uhso
           LEFT JOIN StateProcessedHealthServiceOutage processed_hso ON (uhso.HealthServiceOutageRowId = processed_hso.HealthServiceOutageRowId)
    
    -- update processed HSO for the outages that were updated
    UPDATE processed_hso
    SET StartDateTime = hso.StartDateTime
       ,EndDateTime = hso.EndDateTime
       ,ReasonCode = hso.ReasonCode
       ,HealthServiceOutageDWLastModifiedDateTime = hso.DWLastModifiedDateTime
       ,InvalidatedDateTime = hso.InvalidatedDateTime
       ,DWLastModifiedDateTime = GETUTCDATE()
    FROM #UpdatedHealthServiceOutage hso
           JOIN StateProcessedHealthServiceOutage processed_hso ON (hso.HealthServiceOutageRowId = processed_hso.HealthServiceOutageRowId)
    
    -- add records to processed HSO for the outages that are new
    INSERT StateProcessedHealthServiceOutage (
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,HealthServiceOutageDWLastModifiedDateTime
      ,InvalidatedDateTime
    )
    SELECT
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,DWLastModifiedDateTime
      ,InvalidatedDateTime
    FROM #UpdatedHealthServiceOutage hso
    WHERE (NOT EXISTS (SELECT * FROM StateProcessedHealthServiceOutage WHERE HealthServiceOutageRowId = hso.HealthServiceOutageRowId))
    
    -- groom invalidated Health Service Outage table
    DELETE sihso
    FROM StateInvalidatedHealthServiceOutage sihso
    WHERE NOT EXISTS (SELECT *
                      FROM HealthServiceOutage hso
                      WHERE (sihso.HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                     )

    -- groom processed Health Service Outage table
    DELETE StateProcessedHealthServiceOutage
    WHERE EndDateTime &lt; DATEADD(month, -1, GETUTCDATE())

    DROP TABLE #UpdatedHealthServiceOutage

    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END
    
    UPDATE StateAggregationProcessing
    SET LastProcessedHealthServiceOutageModifiedDateTime = @NewLastProcessedHsoModifiedDateTime
    WHERE (DatasetId = @DatasetId)
    
    IF (@@ROWCOUNT = 0)
    BEGIN
      INSERT StateAggregationProcessing(DatasetId, LastProcessedHealthServiceOutageModifiedDateTime)
      VALUES (@DatasetId, @NewLastProcessedHsoModifiedDateTime)
    END

    COMMIT

    BEGIN TRAN
    
    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
  
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,ManagedEntityMonitorRowId'
      + '   ,[DateTime]'
      + '   ,OldHealthState'
      + '   ,NewHealthState'
      + ' )'
      + ' SELECT '
      + '    EventOriginId'
      + '   ,ManagedEntityMonitorRowId'
      + '   ,[DateTime]'
      + '   ,OldHealthState'
      + '   ,NewHealthState'
      + ' FROM State.StateStage'
      + ' WHERE (DatasetId = ''' + CAST(@DatasetId AS varchar(50)) + ''')'
      + '   AND (InsertReadyInd &gt; 0)'

    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert state raw change event(s) into ' + @InsertTableName
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
   
    EXECUTE(@Statement)
    
    -- mark existing affected aggregations as dirty
    SET @MinDate = NULL
    
    SELECT @MinDate = MIN([DateTime]) 
    FROM State.StateStage 
    WHERE (DatasetId = @DatasetId) 
      AND (InsertReadyInd &gt; 0)
      
    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END

    -- make sure at least one interval of the lowest
    -- aggregation type is not invalidated - if they all are
    -- aggregation process may have problems on high volume

    -- find lowest type aggregations we need to perform
    DECLARE @LowestAggregationTypeId int
    
    SELECT @LowestAggregationTypeId = MIN(AggregationTypeId)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId &gt; 0)
      
    UPDATE StandardDatasetAggregationHistory
    SET DirtyInd = 0
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @LowestAggregationTypeId)
      AND (AggregationDateTime = (SELECT MIN(AggregationDateTime)
                                  FROM StandardDatasetAggregationHistory
                                  WHERE (DatasetId = @DatasetId)
                                    AND (AggregationTypeId = @LowestAggregationTypeId)
                                 )
          )

    -- remove rows from staging
    DELETE State.StateStage WITH (TABLOCK)
    WHERE (DatasetId = @DatasetId)
      AND (InsertReadyInd &gt; 0)
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting state change events into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the state data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

                    </Install><Uninstall>
                    -- drop SPs
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregate')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateAggregate')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregationDelete')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateAggregationDelete')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateChangeEventList')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateChangeEventList')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateDowntimeList')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateDowntimeList')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateGroom')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateGroom')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateInsert')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateInsert')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateProcessStaging')
BEGIN
	EXECUTE ('DROP PROCEDURE dbo.StateProcessStaging')
END

-- drop functions
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'ManagedEntityMonitorDependency') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('DROP FUNCTION ManagedEntityMonitorDependency')
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'GetStateHourly') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('DROP FUNCTION GetStateHourly')
GO

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'GetStateDaily') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('DROP FUNCTION GetStateDaily')
GO

-- drop views
IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vManagedEntityMonitor')
BEGIN
  EXECUTE ('DROP VIEW vManagedEntityMonitor')
END

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vHealthServiceOutage')
BEGIN
  EXECUTE ('DROP VIEW vHealthServiceOutage')
END

-- drop tables
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.StateHealthServiceOutage')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateInvalidatedHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.StateInvalidatedHealthServiceOutage')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateAggregationProcessing' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.StateAggregationProcessing')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateStage' AND TABLE_SCHEMA = 'State')
BEGIN
  EXECUTE('DROP TABLE State.StateStage')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ManagedEntityMonitor' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.ManagedEntityMonitor')
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'HealthSerfviceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  EXECUTE('DROP TABLE dbo.HealthSerfviceOutage')
END

-- drop "full" views

IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vStateFull')
BEGIN
  EXECUTE ('DROP VIEW [vStateFull]')
END

DECLARE
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@BaseTableName nvarchar(256)

-- roll through all aggregations created
-- and drop "full" state views

SET @AggregationTypeId = 0

WHILE EXISTS (SELECT * FROM StandardDatasetAggregationStorage
              WHERE (DatasetId = '$Config/DatasetId$')
                AND (AggregationTypeId &gt; @AggregationTypeId)
                AND (DependentTableInd = 0)
             )
BEGIN
  SELECT TOP 1
     @AggregationTypeId = AggregationTypeId
    ,@BaseTableName = BaseTableName
  FROM StandardDatasetAggregationStorage
  WHERE (DatasetId = '$Config/DatasetId$')
    AND (AggregationTypeId &gt; @AggregationTypeId)
    AND (DependentTableInd = 0)
  
  -- create dummy view if not yet exists  
  IF EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'v' + REPLACE(@BaseTableName, '''', '''''') + 'Full')
  BEGIN
    SET @Statement = 'DROP VIEW ' + QUOTENAME('v' + @BaseTableName + 'Full')
    EXECUTE (@Statement)
  END
END

-- delete std dataset related data
EXEC StandardDatasetDelete '$Config/DatasetId$'
GO

                    </Uninstall><Upgrade>
                    SET NOCOUNT ON

-- update table definition templates
UPDATE sdas
SET TableTemplate = '
              CREATE TABLE ' + QUOTENAME(sd.SchemaName) + '.' + QUOTENAME(sdas.BaseTableName + '_$Guid$') + '
              (
                   ' + QUOTENAME(sdas.BaseTableName + 'RowId') + ' int  NOT NULL  IDENTITY(1, 1)
                  ,[DateTime]                             datetime  NOT NULL
                  ,ManagedEntityMonitorRowId              int  NOT NULL
                  ,InRedStateMilliseconds                 int  NOT NULL
                  ,InYellowStateMilliseconds              int  NOT NULL
                  ,InDisabledStateMilliseconds            int  NOT NULL
                  ,InPlannedMaintenanceMilliseconds       int  NOT NULL
                  ,InUnplannedMaintenanceMilliseconds     int  NOT NULL
                  ,HealthServiceUnavailableMilliseconds   int  NOT NULL
                  ,IntervalEndHealthState                 tinyint NULL
                  
                  ,CONSTRAINT ' + QUOTENAME('PK_' + sdas.BaseTableName + '_$Guid$') + ' PRIMARY KEY CLUSTERED (' +
                    + QUOTENAME(sdas.BaseTableName + 'RowId') + ') ON $DataFileGroupName$
              ) ON $DataFileGroupName$
     '
   , CoverViewSelectClause = '
        SELECT
           ManagedEntityMonitorRowId
          ,[DateTime]
          ,InRedStateMilliseconds
          ,InYellowStateMilliseconds
          ,InDisabledStateMilliseconds
          ,InPlannedMaintenanceMilliseconds
          ,InUnplannedMaintenanceMilliseconds
          ,HealthServiceUnavailableMilliseconds
          ,IntervalEndHealthState
     '
FROM StandardDatasetAggregationStorage sdas
        JOIN StandardDataset sd ON (sdas.DatasetId = sd.DatasetId)
WHERE (sd.DatasetId = '$Config/DatasetId$')
  AND (sdas.AggregationTypeId &gt; 0)
GO
 
-- update all tables that were already created
DECLARE 
   @StandardDatasetTableMapRowId int
  ,@Statement nvarchar(max)
  ,@SchemaName sysname
  ,@TableNameSuffix sysname
  ,@BaseTableName sysname

SET @StandardDatasetTableMapRowId = 0

WHILE EXISTS (SELECT *
              FROM StandardDatasetTableMap tm
              WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
                AND (tm.DatasetId = '$Config/DatasetId$')
                AND (tm.AggregationTypeId &gt; 0)
             )
BEGIN
  SELECT TOP 1
     @StandardDatasetTableMapRowId = tm.StandardDatasetTableMapRowId
    ,@SchemaName = sd.SchemaName
    ,@TableNameSuffix = tm.TableNameSuffix
    ,@BaseTableName = sdas.BaseTableName
  FROM StandardDatasetTableMap tm
          JOIN StandardDataset sd ON (tm.DatasetId = sd.DatasetId)
          JOIN StandardDatasetAggregationStorage sdas ON (sdas.DatasetId = tm.DatasetId) AND (sdas.AggregationTypeId = tm.AggregationTypeId)
  WHERE (tm.StandardDatasetTableMapRowId &gt; @StandardDatasetTableMapRowId)
    AND (tm.DatasetId = '$Config/DatasetId$')
    AND (tm.AggregationTypeId &gt; 0)
  ORDER BY tm.StandardDatasetTableMapRowId
  
  SET @Statement = 'IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ''' + @BaseTableName + '_' + @TableNameSuffix + ''' AND COLUMN_NAME = ''HealthServiceUnavailableMilliseconds'' AND TABLE_SCHEMA = ''' + @SchemaName + ''')'
                 + ' ALTER TABLE ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@BaseTableName + '_' + @TableNameSuffix)
                 + '  ADD HealthServiceUnavailableMilliseconds int NOT NULL DEFAULT 0'
                 
  EXECUTE (@Statement)
END
GO

-- alter cover views
DECLARE 
   @AggregationTypeId int

SET @AggregationTypeId = 0

WHILE EXISTS (SELECT *
              FROM StandardDatasetAggregation
              WHERE (DatasetId = '$Config/DatasetId$')
                AND (AggregationTypeId &gt; @AggregationTypeId)
             )
BEGIN
  SELECT TOP 1 
     @AggregationTypeId = AggregationTypeId
  FROM StandardDatasetAggregation
  WHERE (DatasetId = '$Config/DatasetId$')
    AND (AggregationTypeId &gt; @AggregationTypeId)
  ORDER BY AggregationTypeId
  
  EXEC StandardDatasetBuildCoverView '$Config/DatasetId$', @AggregationTypeId
END
GO


                    SET NOCOUNT ON
GO

-- create [DateTime] field indexes for all aggregation levels
DECLARE 
   @AggregationTypeId int
  ,@IndexGuid uniqueidentifier

SET @AggregationTypeId = 0

WHILE EXISTS (SELECT *
              FROM StandardDatasetAggregation
              WHERE (DatasetId = '$Config/DatasetId$')
                AND (AggregationTypeId &gt; @AggregationTypeId)
             )
BEGIN
  SELECT TOP 1 
     @AggregationTypeId = AggregationTypeId
  FROM StandardDatasetAggregation
  WHERE (DatasetId = '$Config/DatasetId$')
    AND (AggregationTypeId &gt; @AggregationTypeId)
  ORDER BY AggregationTypeId
  
  -- check to see if covering index exists
  SET @IndexGuid = NULL
  
  SELECT 
     @IndexGuid = si.IndexGuid
  FROM StandardDatasetAggregationStorage s
        JOIN StandardDatasetAggregationStorageindex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
  WHERE (s.DatasetId = '$Config/DatasetId$')
    AND (s.AggregationTypeId = @AggregationTypeId)
    AND (si.IndexDefinition LIKE '(DateTime, ManagedEntityMonitorRowId) INCLUDE%')
    
  IF (@IndexGuid IS NOT NULL)
  BEGIN
    EXEC StandardDatasetIndexDelete '$Config/DatasetId$', @IndexGuid, 1
  END
  ELSE
  BEGIN
    SET @IndexGuid = NEWID()
  END
  
  EXEC StandardDatasetIndexInsert
    @DatasetId = '$Config/DatasetId$'
   ,@AggregationTypeId = @AggregationTypeId
   ,@DependentTableInd = 0
   ,@TableTag = NULL
   ,@UniqueInd = 0
   ,@IndexGuid = @IndexGuid
   ,@IndexDefinition = '(DateTime, ManagedEntityMonitorRowId) INCLUDE (InRedStateMilliseconds, InYellowStateMilliseconds, InDisabledStateMilliseconds, InPlannedMaintenanceMilliseconds, InUnplannedMaintenanceMilliseconds, HealthServiceUnavailableMilliseconds)'
   ,@CreateIndexOnExistingTablesInd = 1
END
GO

                    SET NOCOUNT ON 

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'StateAggregationProcessing' AND COLUMN_NAME = 'LastProcessedHealthServiceOutageModifiedDateTime')
BEGIN
  EXECUTE ('ALTER TABLE StateAggregationProcessing ADD LastProcessedHealthServiceOutageModifiedDateTime datetime NULL')
END
GO

                    
                    SET NOCOUNT ON

-- create [DateTime] index for raw aggregations
DECLARE @IndexGuid uniqueidentifier

-- check to see if index exists
SET @IndexGuid = NULL

SELECT 
   @IndexGuid = si.IndexGuid
FROM StandardDatasetAggregationStorage s
      JOIN StandardDatasetAggregationStorageIndex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
WHERE (s.DatasetId = '$Config/DatasetId$')
  AND (s.AggregationTypeId = 0)
  AND (si.IndexDefinition LIKE '(DateTime, ManagedEntityMonitorRowId) INCLUDE%')
  
IF (@IndexGuid IS NULL)
BEGIN
  SET @IndexGuid = NEWID()
  
  EXEC StandardDatasetIndexInsert
    @DatasetId = '$Config/DatasetId$'
   ,@AggregationTypeId = 0
   ,@DependentTableInd = 0
   ,@TableTag = NULL
   ,@UniqueInd = 0
   ,@IndexGuid = @IndexGuid
   ,@IndexDefinition = '(DateTime, ManagedEntityMonitorRowId) INCLUDE (OldHealthState, NewHealthState)'
   ,@CreateIndexOnExistingTablesInd = 1
END

-- delete index w/o included fields if one still exists
SET @IndexGuid = NULL

SELECT 
   @IndexGuid = si.IndexGuid
FROM StandardDatasetAggregationStorage s
      JOIN StandardDatasetAggregationStorageIndex si ON (s.StandardDatasetAggregationStorageRowId = si.StandardDatasetAggregationStorageRowId)
WHERE (s.DatasetId = '$Config/DatasetId$')
  AND (s.AggregationTypeId = 0)
  AND (si.IndexDefinition LIKE '(DateTime, ManagedEntityMonitorRowId)')
  
IF (@IndexGuid IS NOT NULL)
BEGIN
  EXEC StandardDatasetIndexDelete '$Config/DatasetId$', @IndexGuid, 1
END
GO


                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateInvalidatedHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateInvalidatedHealthServiceOutage
  (                               
       HealthServiceOutageRowId   int         NOT NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateInvalidatedHealthServiceOutage PRIMARY KEY CLUSTERED (HealthServiceOutageRowId)
  )
END
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateInvalidatedHealthServiceOutage'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateProcessedHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateProcessedHealthServiceOutage
  (                               
       HealthServiceOutageRowId   int         NOT NULL
      ,StartDateTime              datetime    NOT NULL
      ,EndDateTime                datetime    NULL
      ,ReasonCode                 tinyint     NOT NULL
      ,HealthServiceOutageDWLastModifiedDateTime datetime    NULL
      ,InvalidatedDateTime        datetime    NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      ,DWLastModifiedDateTime     datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateProcessedHealthServiceOutage PRIMARY KEY CLUSTERED (HealthServiceOutageRowId)
  )
END
GO

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateProcessedHealthServiceOutage'
      ,@DatasetId = '$Config/DatasetId$'
GO

                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateProcessedMaintenanceMode' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateProcessedMaintenanceMode
  (                               
       MaintenanceModeRowId       int         NOT NULL
      ,StartDateTime              datetime    NOT NULL
      ,EndDateTime                datetime    NULL
      ,PlannedMaintenanceInd      bit         NOT NULL
      ,MaintenanceModeDWLastModifiedDateTime datetime    NULL
      ,DWCreatedDateTime          datetime    NOT NULL    DEFAULT(GETUTCDATE())
      ,DWLastModifiedDateTime     datetime    NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateProcessedMaintenanceMode PRIMARY KEY CLUSTERED (MaintenanceModeRowId)
  )
END
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_StateProcessedMaintenanceMode_EndDateTime_Inc')
BEGIN
  CREATE INDEX IX_StateProcessedMaintenanceMode_EndDateTime_Inc ON dbo.StateProcessedMaintenanceMode(EndDateTime) INCLUDE (MaintenanceModeRowId)
END

EXEC DomainTableRegisterIndexOptimization
       @TableName = 'StateProcessedMaintenanceMode'
      ,@DatasetId = '$Config/DatasetId$'
GO
 
                    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'StateHealthServiceOutage' AND TABLE_SCHEMA = 'dbo')
BEGIN
  CREATE TABLE dbo.StateHealthServiceOutage
  (                               
       ReasonCode           tinyint       NOT NULL
      ,DWCreatedDateTime    datetime      NOT NULL    DEFAULT(GETUTCDATE())
      
      ,CONSTRAINT PK_StateHealthServiceOutage PRIMARY KEY CLUSTERED (ReasonCode)
  )
END
GO

 

                    SET NOCOUNT ON

IF NOT EXISTS (SELECT * FROM StateHealthServiceOutage WHERE ReasonCode = 0)
BEGIN
  INSERT StateHealthServiceOutage(ReasonCode) VALUES (0)
END

IF NOT EXISTS (SELECT * FROM StateHealthServiceOutage WHERE ReasonCode = 1)
BEGIN
  INSERT StateHealthServiceOutage(ReasonCode) VALUES (1)
END
GO


                    SET NOCOUNT ON

DECLARE 
   @ErrorInd        bit
  ,@ErrorMessageText nvarchar(4000)
  ,@ErrorNumber     int
  ,@ErrorSeverity   int
  ,@ErrorState      int
  ,@ErrorLine       int
  ,@ErrorProcedure  nvarchar(256)

DECLARE
   @AggregationTypeId int
  ,@Statement nvarchar(max)
  ,@FullViewStatement nvarchar(max)
  ,@FullViewStatementConcatenator nvarchar(20)
  ,@BaseTableName nvarchar(256)

SET @ErrorInd = 0

BEGIN TRY
  -- roll through all aggregations created
  -- and build "full" state views
  
  SET @AggregationTypeId = 0
  SET @FullViewStatement = 'ALTER VIEW dbo.[vStateFull] AS '
  SET @FullViewStatementConcatenator = ''
  
  WHILE EXISTS (SELECT * FROM StandardDatasetAggregationStorage
                WHERE (DatasetId = '$Config/DatasetId$')
                  AND (AggregationTypeId &gt; @AggregationTypeId)
                  AND (DependentTableInd = 0)
               )
  BEGIN
    SELECT TOP 1
       @AggregationTypeId = AggregationTypeId
      ,@BaseTableName = BaseTableName
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = '$Config/DatasetId$')
      AND (AggregationTypeId &gt; @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- create dummy view if not yet exists  
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'v' + REPLACE(@BaseTableName, '''', '''''') + 'Full')
    BEGIN
      SET @Statement = 'CREATE VIEW dbo.' + QUOTENAME('v' + @BaseTableName + 'Full') + ' AS SELECT A = 1'
      EXECUTE (@Statement)

      SET @Statement = 'GRANT SELECT ON dbo.' + QUOTENAME('v' + @BaseTableName + 'Full') + ' TO OpsMgrReader'
      EXECUTE (@Statement)
    END
    
    SELECT @Statement = 
          'ALTER VIEW dbo.' + CAST(QUOTENAME('v' + @BaseTableName + 'Full') as nvarchar(max))
        + ' AS'
        + '  SELECT '
        -- daily aggregations appear to be in "midnight" or thereabouts
        -- to aid UI to present data in different timezones
        + '     [DateTime]'
        + '    ,[Date]'
        + '    ,[Time]'
        + '    ,ManagedEntityMonitorRowId'
        + '    ,ManagedEntityRowId'
        + '    ,MonitorRowId'
        + '    ,IntervalDurationMilliseconds'
        + '    ,InYellowStateMilliseconds'
        + '    ,InRedStateMilliseconds'
        + '    ,InPlannedMaintenanceMilliseconds'
        + '    ,InUnplannedMaintenanceMilliseconds'
        + '    ,InDisabledStateMilliseconds'
        + '    ,HealthServiceUnavailableMilliseconds'
        + '    ,InWhiteStateMilliseconds ='
        + '      CASE'
        + '        WHEN ((ManagedEntityMonitorExistedInd = 0) OR '
        + '              (ah.AggregationCount = 0) OR '
        + '              (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) ' 
        + '             THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds'
        + '        ELSE 0'
        + '      END'
        + '    ,InGreenStateMilliseconds ='
        + '      CASE'
        + '        WHEN (ManagedEntityMonitorExistedInd = 1) AND '
        + '                  ((ah.AggregationCount &gt; 0) OR '
        + '                  ((ah.AggregationCount IS NULL) AND '
        + '                   (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) ' 
        + '            THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds'
        + '        ELSE 0'
        + '      END'
        + '  FROM ('
        + '    SELECT'
        + '       dt.[DateTime]'
        + '      ,dt.[Date]'
        + '      ,dt.[Time]'
        + '      ,ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId'
        + '      ,ManagedEntityRowId = mem.ManagedEntityRowId'
        + '      ,MonitorRowId = mem.MonitorRowId'
        + '      ,ManagedEntityMonitorExistedInd = CASE WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1 END'
        + '      ,IntervalDurationMilliseconds = 60 * 1000 * ' + CAST(a.AggregationIntervalDurationMinutes AS varchar)
        + '      ,InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0)'
        + '      ,InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0)'
        + '      ,InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0)'
        + '      ,InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0)'
        + '      ,InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0)'
        + '      ,HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)'
        + '    FROM vDateTime dt'
        + '          CROSS JOIN vManagedEntityMonitor mem'
        + '          LEFT JOIN ' + QUOTENAME(d.SchemaName) + '.' + QUOTENAME('v' + @BaseTableName) + ' s ON '
        +             CASE @AggregationTypeId
                        WHEN 30 THEN '((s.[DateTime] &gt;= dt.[DateTime]) AND (s.[DateTime] &lt; DATEADD(day, 1, dt.[DateTime])) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))'
                        ELSE '((s.[DateTime] = dt.[DateTime]) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))'
                      END
        + '          LEFT JOIN (SELECT DISTINCT mem2.ManagedEntityMonitorRowId, dt2.[Date], dt2.[Time]'
                            + ' FROM vDateTime dt2'
                                  + ' CROSS JOIN vManagedEntityMonitor mem2'
                                  + ' JOIN vManagedEntity me ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)'
                                  + ' JOIN vMonitorManagementPackVersion mmpv ON (mmpv.MonitorRowId = mem2.MonitorRowId)'
		                              + ' JOIN vManagementGroupManagementPackVersion mgmpv ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND'
				                                                                               + ' (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND'
				                                                                               + ' (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND '
				                                                                               + ' (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, ''99991231'')))'
		                              + ' JOIN vManagedEntityManagementGroup memg ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND'
				                                                                      + ' (dt2.[DateTime] &gt;= memg.FromDateTime) AND '
				                                                                      + ' (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, ''99991231'')))'
        + CASE @AggregationTypeId
            WHEN 10 /* subhourly */ THEN ' WHERE (dt2.Minute % ' + CAST(a.AggregationIntervalDurationMinutes AS varchar) + ' = 0)'
            WHEN 20 /* hourly */ THEN ' WHERE (dt2.Minute = 0)'
            -- Perform daily aggregations at midnight UTC times, even in x:30 timezones where dt2.minute != 0
            WHEN 30 /* daily */ THEN ' WHERE (dt2.Minute = ABS(DATEDIFF(minute, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt2.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt2.[DateTime]), 112), 112)'
          END
        + '                    ) AS mem_exists ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])'
        + CASE @AggregationTypeId
            WHEN 10 /* subhourly */ THEN ' WHERE (dt.Minute % ' + CAST(a.AggregationIntervalDurationMinutes AS varchar) + ' = 0)'
            WHEN 20 /* hourly */ THEN ' WHERE (dt.Minute = 0)'
            -- Perform daily aggregations at midnight UTC times, even in x:30 timezones where dt.Minute != 0
            WHEN 30 /* daily */ THEN ' WHERE (dt.Minute = ABS(DATEDIFF(minute, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), GETDATE()), dt.[DateTime]), 112), 112)'
          END
        + '  ) AS tbl'
        + '  LEFT JOIN StandardDatasetAggregationHistory (NOLOCK) ah ON'
        + '             ('
        +             CASE @AggregationTypeId
                        WHEN 30 THEN '(ah.AggregationDateTime &gt;= tbl.[DateTime]) AND (ah.AggregationDateTime &lt; DATEADD(day, 1, tbl.[DateTime]))'
                        ELSE '(ah.AggregationDateTime = tbl.[DateTime])'
                      END
        + '          AND (ah.DatasetId = ''$Config/DatasetId$'')'
        + '          AND (ah.AggregationTypeId = ' + CAST(AggregationTypeId AS varchar(10)) + '))'
    FROM StandardDatasetAggregation a
          JOIN StandardDataset d ON (d.DatasetId = a.DatasetId)
    WHERE (d.DatasetId = '$Config/DatasetId$')
      AND (a.AggregationTypeId = @AggregationTypeId)
    
    EXECUTE (@Statement)
      
    SET @FullViewStatement = @FullViewStatement + @FullViewStatementConcatenator
      + ' SELECT'
      + '   AggregationTypeId = ' + CAST(@AggregationTypeId AS varchar)
      + '  ,[DateTime]'
      + '  ,ManagedEntityMonitorRowId'
      + '  ,IntervalDurationMilliseconds'
      + '  ,InWhiteStateMilliseconds'
      + '  ,InGreenStateMilliseconds'
      + '  ,InYellowStateMilliseconds'
      + '  ,InRedStateMilliseconds'
      + '  ,InDisabledStateMilliseconds'
      + '  ,InPlannedMaintenanceMilliseconds'
      + '  ,InUnplannedMaintenanceMilliseconds'
      + '  ,HealthServiceUnavailableMilliseconds'
      + ' FROM dbo.' + QUOTENAME('v' + @BaseTableName + 'Full')
    
    SET @FullViewStatementConcatenator = ' UNION ALL '
  END
  
  -- create dummy 
  IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vStateFull')
  BEGIN
    EXECUTE ('CREATE VIEW dbo.[vStateFull] AS SELECT A = 1')
    EXECUTE ('GRANT SELECT ON dbo.[vStateFull] TO OpsMgrReader')
  END
  
  -- create covering "full" view
  EXECUTE (@FullViewStatement)
END TRY
BEGIN CATCH
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
END CATCH

IF (@ErrorInd = 1)
BEGIN
  DECLARE @AdjustedErrorSeverity int

  SET @AdjustedErrorSeverity = CASE
                                 WHEN @ErrorSeverity &gt; 18 THEN 18
                                 ELSE @ErrorSeverity
                               END
  
  RAISERROR (777971002, @AdjustedErrorSeverity, 1
    ,@ErrorNumber
    ,@ErrorSeverity
    ,@ErrorState
    ,@ErrorProcedure
    ,@ErrorLine
    ,@ErrorMessageText
  )
END
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'V' AND name = 'vStateHealthServiceOutage')
BEGIN
  EXECUTE ('CREATE VIEW dbo.vStateHealthServiceOutage AS SELECT A = 1')
END
GO

ALTER VIEW dbo.vStateHealthServiceOutage
AS
  SELECT *
  FROM dbo.StateHealthServiceOutage (NOLOCK)
GO

GRANT SELECT ON dbo.vStateHealthServiceOutage TO OpsMgrWriter, OpsMgrReader
GO
 
                    
                     IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'dbo.GetStateHourly') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('CREATE FUNCTION dbo.GetStateHourly() RETURNS TABLE AS RETURN SELECT NULL as Blank')
GO

ALTER FUNCTION dbo.GetStateHourly
(
    @StartDate datetime
   ,@EndDate datetime
)
RETURNS TABLE
AS
RETURN (
WITH DateTimeCTE
AS (
    SELECT
        DateTime,
        Date,
        Time,
        Minute
    FROM vDateTime dt WHERE dt.Minute = 0 
        AND dt.DateTime &gt;= @StartDate 
        AND dt.DateTime &lt; @EndDate 
        AND dt.[Date] BETWEEN DATEADD(day, -1, @StartDate) AND DATEADD(day, 1, @EndDate)
)
SELECT
  [DateTime],
  [Date],
  [Time],
  ManagedEntityMonitorRowId,
  ManagedEntityRowId,
  MonitorRowId,
  IntervalDurationMilliseconds,
  InYellowStateMilliseconds,
  InRedStateMilliseconds,
  InPlannedMaintenanceMilliseconds,
  InUnplannedMaintenanceMilliseconds,
  InDisabledStateMilliseconds,
  HealthServiceUnavailableMilliseconds,
  InWhiteStateMilliseconds =
    CASE
      WHEN ((ManagedEntityMonitorExistedInd = 0) OR (ah.AggregationCount = 0) OR (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END,
  InGreenStateMilliseconds =
    CASE
      WHEN (ManagedEntityMonitorExistedInd = 1) AND ((ah.AggregationCount &gt; 0) OR ((ah.AggregationCount IS NULL) AND (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END
FROM (SELECT
  dt.[DateTime],
  dt.[Date],
  dt.[Time],
  ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId,
  ManagedEntityRowId = mem.ManagedEntityRowId,
  MonitorRowId = mem.MonitorRowId,
  ManagedEntityMonitorExistedInd =
    CASE
      WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1
    END,
  IntervalDurationMilliseconds = 60 * 1000 * 60,
  InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0),
  InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0),
  InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0),
  InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0),
  InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0),
  HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)
FROM DateTimeCTE dt
CROSS JOIN vManagedEntityMonitor mem
LEFT JOIN [State].[vStateHourly] s
  ON ((s.[DateTime] = dt.[DateTime]) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))
LEFT JOIN (SELECT DISTINCT
  mem2.ManagedEntityMonitorRowId,
  dt2.[Date],
  dt2.[Time]
FROM DateTimeCTE dt2
CROSS JOIN vManagedEntityMonitor mem2
JOIN vManagedEntity me
  ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)
JOIN vMonitorManagementPackVersion mmpv
  ON (mmpv.MonitorRowId = mem2.MonitorRowId)
JOIN vManagementGroupManagementPackVersion mgmpv
  ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, '99991231')))
JOIN vManagedEntityManagementGroup memg
  ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND (dt2.[DateTime] &gt;= memg.FromDateTime) AND (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, '99991231')))
WHERE (dt2.Minute = 0)) AS mem_exists
  ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])
WHERE (dt.Minute = 0)) AS tbl
LEFT JOIN StandardDataset sd ON sd.SchemaName = 'State'
LEFT JOIN StandardDatasetAggregationHistory(NOLOCK) ah
  ON ((ah.AggregationDateTime = tbl.[DateTime]) AND (ah.DatasetId = sd.DatasetId) AND (ah.AggregationTypeId = 20))
)
GO

GRANT SELECT ON GetStateHourly TO OpsMgrReader, OpsMgrWriter
GO
 
                     IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'dbo.GetStateDaily') and xtype in (N'FN', N'IF', N'TF'))
  EXECUTE('CREATE FUNCTION dbo.GetStateDaily() RETURNS TABLE AS RETURN SELECT NULL as Blank')
GO

ALTER FUNCTION dbo.GetStateDaily
(
    @StartDate datetime
   ,@EndDate datetime
)
RETURNS TABLE
AS
RETURN (
WITH DateTimeCTE
AS (
    SELECT
        DateTime,
        Date,
        Time,
        Minute
    FROM vDateTime dt WHERE dt.Minute = 0 
        AND dt.DateTime &gt;= @StartDate 
        AND dt.DateTime &lt; @EndDate 
        AND dt.[Date] BETWEEN DATEADD(day, -1, @StartDate) AND DATEADD(day, 1, @EndDate)
)
SELECT
  [DateTime],
  [Date],
  [Time],
  ManagedEntityMonitorRowId,
  ManagedEntityRowId,
  MonitorRowId,
  IntervalDurationMilliseconds,
  InYellowStateMilliseconds,
  InRedStateMilliseconds,
  InPlannedMaintenanceMilliseconds,
  InUnplannedMaintenanceMilliseconds,
  InDisabledStateMilliseconds,
  HealthServiceUnavailableMilliseconds,
  InWhiteStateMilliseconds =
    CASE
      WHEN ((ManagedEntityMonitorExistedInd = 0) OR (ah.AggregationCount = 0) OR (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &gt;= GETUTCDATE())) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END,
  InGreenStateMilliseconds =
    CASE
      WHEN (ManagedEntityMonitorExistedInd = 1) AND ((ah.AggregationCount &gt; 0) OR ((ah.AggregationCount IS NULL) AND (DATEADD(ms, IntervalDurationMilliseconds, [DateTime]) &lt; GETUTCDATE()))) THEN IntervalDurationMilliseconds - InYellowStateMilliseconds - InRedStateMilliseconds - InDisabledStateMilliseconds - InPlannedMaintenanceMilliseconds - InUnplannedMaintenanceMilliseconds - HealthServiceUnavailableMilliseconds ELSE 0
    END
FROM (SELECT
  dt.[DateTime],
  dt.[Date],
  dt.[Time],
  ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId,
  ManagedEntityRowId = mem.ManagedEntityRowId,
  MonitorRowId = mem.MonitorRowId,
  ManagedEntityMonitorExistedInd =
    CASE
      WHEN mem_exists.ManagedEntityMonitorRowId IS NULL THEN 0 ELSE 1
    END,
  IntervalDurationMilliseconds = 60 * 1000 * 1440,
  InYellowStateMilliseconds = ISNULL(s.InYellowStateMilliseconds, 0),
  InRedStateMilliseconds = ISNULL(s.InRedStateMilliseconds, 0),
  InDisabledStateMilliseconds = ISNULL(s.InDisabledStateMilliseconds, 0),
  InPlannedMaintenanceMilliseconds = ISNULL(s.InPlannedMaintenanceMilliseconds, 0),
  InUnplannedMaintenanceMilliseconds = ISNULL(s.InUnplannedMaintenanceMilliseconds, 0),
  HealthServiceUnavailableMilliseconds = ISNULL(s.HealthServiceUnavailableMilliseconds, 0)
FROM DateTimeCTE dt
CROSS JOIN vManagedEntityMonitor mem
LEFT JOIN [State].[vStateDaily] s
  ON ((s.[DateTime] &gt;= dt.[DateTime]) AND (s.[DateTime] &lt; DATEADD(DAY, 1, dt.[DateTime])) AND (s.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId))
LEFT JOIN (SELECT DISTINCT
  mem2.ManagedEntityMonitorRowId,
  dt2.[Date],
  dt2.[Time]
FROM DateTimeCTE dt2
CROSS JOIN vManagedEntityMonitor mem2
JOIN vManagedEntity me
  ON (me.ManagedEntityRowId = mem2.ManagedEntityRowId)
JOIN vMonitorManagementPackVersion mmpv
  ON (mmpv.MonitorRowId = mem2.MonitorRowId)
JOIN vManagementGroupManagementPackVersion mgmpv
  ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND (dt2.[DateTime] &gt;= mgmpv.InstalledDateTime) AND (dt2.[DateTime] &lt; ISNULL(mgmpv.DeletedDateTime, '99991231')))
JOIN vManagedEntityManagementGroup memg
  ON ((mem2.ManagedEntityRowId = memg.ManagedEntityRowId) AND (dt2.[DateTime] &gt;= memg.FromDateTime) AND (dt2.[DateTime] &lt; ISNULL(memg.ToDateTime, '99991231')))
WHERE (dt2.Minute = ABS(DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt2.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt2.[DateTime]), 112), 112)) AS mem_exists
  ON (mem_exists.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId) AND (mem_exists.[Date] = dt.[Date]) AND (mem_exists.[Time] = dt.[Time])
WHERE (dt.Minute = ABS(DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()) % 60)) AND DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt.[DateTime]) = CONVERT(datetime, CONVERT(char(8), DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), dt.[DateTime]), 112), 112)) AS tbl
LEFT JOIN StandardDataset sd ON sd.SchemaName = 'State'
LEFT JOIN StandardDatasetAggregationHistory(NOLOCK) ah
  ON ((ah.AggregationDateTime &gt;= tbl.[DateTime]) AND (ah.AggregationDateTime &lt; DATEADD(DAY, 1, tbl.[DateTime])) AND (ah.DatasetId = sd.DatasetId) AND (ah.AggregationTypeId = 30))
)
GO

GRANT SELECT ON GetStateDaily TO OpsMgrReader, OpsMgrWriter
GO

 
                    
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'ManagedEntityMonitorDependencyList')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.ManagedEntityMonitorDependencyList AS RETURN 1')
	END
GO

ALTER PROCEDURE ManagedEntityMonitorDependencyList
   @ParentManagedEntityMonitorRowId   int
  ,@LevelCount                        int = 0
AS
BEGIN
  CREATE TABLE #ResultTable
  (
     [Level]                          int   NOT NULL
    ,ParentManagedEntityMonitorRowId  int   NULL
    ,ChildManagedEntityMonitorRowId   int   NOT NULL
  )

  DECLARE
     @CurrentLevel int
    ,@RowCount int
  
  SET @CurrentLevel = 1
  SET @RowCount = 1
  
  INSERT #ResultTable ([Level], ParentManagedEntityMonitorRowId, ChildManagedEntityMonitorRowId)
  VALUES (0, NULL, @ParentManagedEntityMonitorRowId)
  
  WHILE (((@LevelCount &gt;= @CurrentLevel) OR (@LevelCount = 0)) AND (@RowCount &gt; 0))
  BEGIN
    SET @RowCount = 0
    
    INSERT #ResultTable (
       [Level]
      ,ParentManagedEntityMonitorRowId
      ,ChildManagedEntityMonitorRowId
    )
    SELECT DISTINCT
       @CurrentLevel
      ,mem_parent.ManagedEntityMonitorRowId
      ,mem_child.ManagedEntityMonitorRowId
    FROM vManagedEntityMonitor mem_parent
          JOIN vManagedEntityMonitor mem_child ON (mem_parent.ManagedEntityRowId = mem_child.ManagedEntityRowId)
          JOIN vManagedEntity me ON (mem_parent.ManagedEntityRowId = me.ManagedEntityRowId)
          JOIN vMonitorManagementPackVersion mmpv_parent ON (mem_parent.MonitorRowId = mmpv_parent.MonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_child ON (mem_child.MonitorRowId = mmpv_child.MonitorRowId)
          JOIN #ResultTable r ON (mem_parent.ManagedEntityMonitorRowId = r.ChildManagedEntityMonitorRowId)
    WHERE (r.[Level] = @CurrentLevel - 1)
      AND (mmpv_parent.AggregateMonitorInd = 1)
      AND (mmpv_child.ParentMonitorRowId = mem_parent.MonitorRowId)
    
    SET @RowCount = @RowCount + @@ROWCOUNT
    
    INSERT #ResultTable (
       [Level]
      ,ParentManagedEntityMonitorRowId
      ,ChildManagedEntityMonitorRowId
    )
    SELECT DISTINCT
       @CurrentLevel
      ,mem_parent.ManagedEntityMonitorRowId
      ,mem_child.ManagedEntityMonitorRowId
    FROM vManagedEntityMonitor mem_parent
          JOIN #ResultTable res ON (mem_parent.ManagedEntityMonitorRowId = res.ChildManagedEntityMonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_parent ON (mem_parent.MonitorRowId = mmpv_parent.MonitorRowId)
          JOIN vManagedEntityMonitor mem_child ON (mem_child.MonitorRowId = mmpv_parent.DependencyMonitorRowId)
          JOIN vMonitorManagementPackVersion mmpv_child ON (mem_child.MonitorRowId = mmpv_child.MonitorRowId)
          JOIN vRelationship r ON ((mem_parent.ManagedEntityRowId = r.SourceManagedEntityRowId) AND (mem_child.ManagedEntityRowId = r.TargetManagedEntityRowId))
    WHERE (res.[Level] = @CurrentLevel - 1)
      AND (mmpv_parent.DependencyMonitorInd = 1)
      AND (mmpv_parent.RelationshipTypeRowId IN (SELECT RelationshipTypeRowId FROM dbo.RelationshipBaseTypeHierarchy(r.RelationshipTypeRowId, 0)))

    SET @RowCount = @RowCount + @@ROWCOUNT
    SET @CurrentLevel = @CurrentLevel + 1
  END
  
  SELECT 
     [Level]
    ,ParentManagedEntityMonitorRowId
    ,ChildManagedEntityMonitorRowId
  FROM #ResultTable
  
  DROP TABLE #ResultTable
END
GO

GRANT EXECUTE ON ManagedEntityMonitorDependencyList TO OpsMgrReader, OpsMgrWriter
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregate')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateAggregate AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateAggregate
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId int
  ,@InsertTableGuid varchar(256)
  ,@IntervalStartDateTime datetime
  ,@IntervalEndDateTime datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY
    DECLARE
       @Statement nvarchar(max)
      ,@DebugLevel tinyint
      ,@AggregationCoverViewName sysname
      ,@InsertTableName sysname
      ,@PreviousIntervalStartDateTime datetime
      ,@DebugMessage nvarchar(4000)
      ,@AggregationStartDateTime datetime
      ,@LowerAggregationTypeId int
      ,@LowerAggregationIntervalMinutes int
      ,@NonDirtyLowerAggregationCount int
      ,@LowerAggregationCoverViewName sysname
      ,@UseAggregatesToBuildStartOfIntervalStateInd bit
      ,@SchemaName sysname
      
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- check to see if non-dirty lower rank
    -- aggregations are available to build this
    -- layer of aggregations
    SELECT TOP 1
       @LowerAggregationTypeId = AggregationTypeId
      ,@LowerAggregationIntervalMinutes = AggregationIntervalDurationMinutes
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId &gt; 0)
      AND (AggregationTypeId &lt; @AggregationTypeId)
      
    IF (@LowerAggregationTypeId IS NOT NULL)
    BEGIN
      -- check if once-calculated aggregations of lower rank
      -- cover the entire interval of this aggregation
      SELECT @NonDirtyLowerAggregationCount = COUNT(*)
      FROM StandardDatasetAggregationHistory
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @LowerAggregationTypeId)
        AND (AggregationCount &gt; 0)
        AND (AggregationDateTime &gt;= @IntervalStartDateTime)
        AND (AggregationDateTime &lt; @IntervalEndDateTime)
    END
    
    IF (@NonDirtyLowerAggregationCount = (ABS(DATEDIFF(minute, @IntervalStartDateTime, @IntervalEndDateTime))) / @LowerAggregationIntervalMinutes)
    BEGIN
      IF (@DebugLevel &gt; 2)
      BEGIN
      -- lower aggregation is available
      -- use is to build aggregates
        SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                           + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                           + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC. Using existing non-dirty aggregations of type ' + CAST(@LowerAggregationTypeId AS varchar)
        SET @AggregationStartDateTime = GETUTCDATE()
        
        EXEC DebugMessageInsert
           @DatasetId = @DatasetId
          ,@MessageLevel = 3
          ,@MessageText = @DebugMessage
      END
      
      SELECT @LowerAggregationCoverViewName = 'v' + BaseTableName
      FROM StandardDatasetAggregationStorage
      WHERE (DatasetId = @DatasetId)
        AND (AggregationTypeId = @LowerAggregationTypeId)
        AND (DependentTableInd = 0)
        
      SET @Statement =
          'INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' (
              ManagedEntityMonitorRowId
             ,[DateTime]
             ,InRedStateMilliseconds
             ,InYellowStateMilliseconds
             ,InDisabledStateMilliseconds
             ,InPlannedMaintenanceMilliseconds
             ,InUnplannedMaintenanceMilliseconds
             ,HealthServiceUnavailableMilliseconds
           )
            SELECT
               ManagedEntityMonitorRowId
              ,@IntervalStartDateTime
              ,SUM(InRedStateMilliseconds)
              ,SUM(InYellowStateMilliseconds)
              ,SUM(InDisabledStateMilliseconds)
              ,SUM(InPlannedMaintenanceMilliseconds)
              ,SUM(InUnplannedMaintenanceMilliseconds)
              ,SUM(HealthServiceUnavailableMilliseconds)
            FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@LowerAggregationCoverViewName) + '
            WHERE ([DateTime] &gt;= @IntervalStartDateTime)
              AND ([DateTime] &lt; @IntervalEndDateTime)
            GROUP BY ManagedEntityMonitorRowId'
        
      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime
    END
    ELSE
    BEGIN
      -- lower aggregation is dirty or not available
      -- use raw data to build aggregates
      IF (@DebugLevel &gt; 2)
      BEGIN
        SET @DebugMessage = 'Starting aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                           + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                           + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC. Using raw data'
        SET @AggregationStartDateTime = GETUTCDATE()
        
        EXEC DebugMessageInsert
           @DatasetId = @DatasetId
          ,@MessageLevel = 3
          ,@MessageText = @DebugMessage
      END
      
      SET @PreviousIntervalStartDateTime = DATEADD(minute, -ABS(DATEDIFF(minute, @IntervalStartDateTime, @IntervalEndDateTime)), @IntervalStartDateTime)
      
      -- load states for monitors that were
      -- not green at the beginning of this period
      IF EXISTS (SELECT * FROM StandardDatasetAggregationHistory
                 WHERE (AggregationCount &gt; 0)
                   AND (AggregationTypeId = @AggregationTypeId)
                   AND (AggregationDateTime = @PreviousIntervalStartDateTime)
                )
      BEGIN
        -- we have non-dirty previous aggregation
        -- use its info to get all non-green monitors
        SET @UseAggregatesToBuildStartOfIntervalStateInd = 1
        
        SELECT @AggregationCoverViewName = 'v' + BaseTableName
        FROM StandardDatasetAggregationStorage
        WHERE (DatasetId = @DatasetId)
          AND (AggregationTypeId = @AggregationTypeId)
          AND (DependentTableInd = 0)
      END
      ELSE
      BEGIN
        -- pick up the latest state change
        -- for all me/monitor pairs when
        -- there was a change during the period
        -- or the last state wasn't green
        SET @UseAggregatesToBuildStartOfIntervalStateInd = 0
      END
      
      IF (OBJECT_ID('tempdb..#StateEvent') IS NOT NULL)
        DROP TABLE #StateEvent

      CREATE TABLE #StateEvent (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
      
      INSERT #StateEvent (ManagedEntityMonitorRowId, [DateTime], OldHealthState, NewHealthState)
      EXEC StateChangeEventList 
            @ManagedEntityMonitorRowId = NULL
           ,@IntervalStartDateTime = @IntervalStartDateTime
           ,@IntervalEndDateTime = @IntervalEndDateTime
           ,@UseAggregatesToBuildStartOfIntervalStateInd = @UseAggregatesToBuildStartOfIntervalStateInd
           ,@AggregationCoverViewName = @AggregationCoverViewName
           ,@AggregationDateTime = @PreviousIntervalStartDateTime


      IF (OBJECT_ID('tempdb..#StateEventRanked') IS NOT NULL)
        DROP TABLE #StateEventRanked

      CREATE TABLE #StateEventRanked (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,IntervalNumber       int
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
  
      INSERT #StateEventRanked (ManagedEntityMonitorRowId, [DateTime], IntervalNumber, OldHealthState, NewHealthState)
      SELECT 
         ManagedEntityMonitorRowId
        ,[DateTime]
        ,IntervalNumber = RANK() OVER (PARTITION BY ManagedEntityMonitorRowId ORDER BY [DateTime])
        ,OldHealthState
        ,NewHealthState
      FROM #StateEvent

      IF (OBJECT_ID('tempdb..#StateInterval') IS NOT NULL)
        DROP TABLE #StateInterval

      CREATE TABLE #StateInterval (
         ManagedEntityMonitorRowId int
        ,IntervalStartDateTime  datetime
        ,IntervalEndDateTime    datetime
        ,HealthState            tinyint
      )
      
      INSERT #StateInterval (
         ManagedEntityMonitorRowId
        ,IntervalStartDateTime
        ,IntervalEndDateTime
        ,HealthState
      )
      SELECT
         l.ManagedEntityMonitorRowId
        ,CASE WHEN l.[DateTime] &lt; @IntervalStartDateTime
           THEN @IntervalStartDateTime
           ELSE l.[DateTime]
         END
        ,CASE WHEN ISNULL(r.[DateTime], '99991231') &gt; @IntervalEndDateTime
           THEN @IntervalEndDateTime
           ELSE r.[DateTime]
         END
        ,CASE WHEN l.NewHealthState &gt; ISNULL(r.OldHealthState, l.NewHealthState)
           THEN l.NewHealthState
           ELSE ISNULL(r.OldHealthState, l.NewHealthState)
         END
      FROM #StateEventRanked AS l 
              LEFT JOIN #StateEventRanked AS r ON (l.ManagedEntityMonitorRowId = r.ManagedEntityMonitorRowId) AND (l.IntervalNumber + 1 = r.IntervalNumber)
      WHERE (l.[DateTime] &lt; @IntervalEndDateTime)
      
      SET @Statement =
          ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' (
              [DateTime]
             ,ManagedEntityMonitorRowId
             ,InRedStateMilliseconds
             ,InYellowStateMilliseconds
             ,InDisabledStateMilliseconds
             ,InPlannedMaintenanceMilliseconds
             ,InUnplannedMaintenanceMilliseconds
             ,HealthServiceUnavailableMilliseconds
             ,IntervalEndHealthState
           )
            SELECT
               @IntervalStartDateTime
              ,si.ManagedEntityMonitorRowId
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 3 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 2 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 0 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 101 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 100 THEN 1 ELSE 0 END) )
              ,SUM(ABS(DATEDIFF(ms, si.IntervalEndDateTime, si.IntervalStartDateTime)) * (CASE si.HealthState WHEN 50 THEN 1 ELSE 0 END) )
              ,MAX(ISNULL(se.NewHealthState, 1)) *
                CASE WHEN MAX(ISNULL(se.NewHealthState, 1)) = 1 THEN 1
                     WHEN EXISTS (SELECT *
                                  FROM vManagedEntityMonitor mem
                                        JOIN vManagedEntity me ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)
                                        JOIN vMonitorManagementPackVersion mmpv ON (mmpv.MonitorRowId = mem.MonitorRowId)
                                        JOIN vManagementGroupManagementPackVersion mgmpv ON ((mgmpv.ManagementPackVersionRowId = mmpv.ManagementPackVersionRowId) AND
                                                                                             (mgmpv.ManagementGroupRowId = me.ManagementGroupRowId) AND
                                                                                             (@IntervalEndDateTime &gt;= mgmpv.InstalledDateTime) AND 
                                                                                             (@IntervalEndDateTime &lt; ISNULL(mgmpv.DeletedDateTime, ''99991231'')))
                                        JOIN vManagedEntityManagementGroup memg ON ((mem.ManagedEntityRowId = memg.ManagedEntityRowId) AND
                                                                                    (@IntervalEndDateTime &gt;= memg.FromDateTime) AND 
                                                                                    (@IntervalEndDateTime &lt; ISNULL(memg.ToDateTime, ''99991231'') ))
                                  WHERE (mem.ManagedEntityMonitorRowId = si.ManagedEntityMonitorRowId)
                                 )
                     THEN 1
                     ELSE NULL
                END
            FROM #StateInterval si 
              LEFT JOIN ( 
                    SELECT
                       ser.ManagedEntityMonitorRowId
                      ,IntervalNumber = MAX(ser.IntervalNumber)
                    FROM #StateEventRanked ser 
                    WHERE (ser.OldHealthState &lt; 50)
                      AND (ser.NewHealthState &lt; 50)
                    GROUP BY ser.ManagedEntityMonitorRowId
                   ) AS last_transition ON (si.ManagedEntityMonitorRowId = last_transition.ManagedEntityMonitorRowId)
              LEFT JOIN #StateEventRanked se ON (si.ManagedEntityMonitorRowId = se.ManagedEntityMonitorRowId) AND (se.IntervalNumber = last_transition.IntervalNumber)
            WHERE (si.HealthState &lt;&gt; 1)
            GROUP BY si.ManagedEntityMonitorRowId'

      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime

      DROP TABLE #StateInterval
      
      DROP TABLE #StateEventRanked

      DROP TABLE #StateEvent
    END
    
    IF (@DebugLevel &gt; 2)
    BEGIN
      SET @DebugMessage = 'Finished aggregation of type ' + CAST(@AggregationTypeId AS varchar) + ' for interval from '
                         + CONVERT(varchar(20), @IntervalStartDateTime, 120) + 'UTC to '
                         + CONVERT(varchar(20), @IntervalEndDateTime, 120) + 'UTC'
      
      DECLARE @OperationDurationMs bigint
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @AggregationStartDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END

  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
      
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to build aggregates for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO
 
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateAggregationDelete')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateAggregationDelete AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateAggregationDelete
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@AggregationDateTime datetime
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugMessage nvarchar(max)
    ,@DeleteStartedDateTime datetime
    ,@OperationDurationMs bigint
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    -- Index hint in the query below ensures that SQL won't
    -- consider index on DateTime field to be a good source
    -- to find rows to delete - it may happen periodically
    -- if SQL thinks there's no rows to delete due to
    -- lack of [recently updated] statistics    
    SET @Statement = 'DELETE t' + 
				   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' t WITH (INDEX(1))'
                   + ' WHERE (t.[DateTime] = CONVERT(datetime, ''' + CONVERT(varchar(50), @AggregationDateTime, 120) + ''', 120))'

    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Starting delete of existing aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      
      SET @DeleteStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
    END
   
    EXECUTE(@Statement)
    
    SET @RowsDeleted = @@ROWCOUNT
  
    IF (@DebugLevel &gt; 2)
    BEGIN
      SELECT @DebugMessage = 'Finished delete of existing aggregated data. Table: ' + @TableName + ', aggregation date: ' + CONVERT(varchar(20), @AggregationDateTime, 120)
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @DeleteStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 3
        ,@MessageText = @DebugMessage
        ,@OperationDurationMs = @OperationDurationMs
    END
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to delete aggregated data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
 
                      IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateChangeEventList')
	  BEGIN
		  EXECUTE ('CREATE PROCEDURE dbo.StateChangeEventList AS RETURN 1')
	  END
  GO

  /*******************************************************

  Builds list of all state change events that a relevant
  for a given interval. If MEMRowId is provided only
  that monitor instance is considered otherwise all
  monitors are considered.

  If @UseAggregatesToBuildStartOfIntervalStateInd is 0 the
  proc will return last state change that happened
  just before @IntervalStartDateTime for each monitor
  that had a state change within the interval OR for the one
  provided in parameters

  If @UseAggregatesToBuildStartOfIntervalStateInd is 1, the
  proc will use existing aggregated data specified
  by parameters @AggregationCoverViewName, @AggregationDateTime
  to build fake state change event that happened at
  @AggregationDateTime (this method is used by aggregations
  to save time when calculating aggregates and previous
  aggregation is available)

  *******************************************************/
  ALTER PROCEDURE StateChangeEventList
     @ManagedEntityMonitorRowId     int = NULL
    ,@IntervalStartDateTime         datetime
    ,@IntervalEndDateTime           datetime
    ,@UseAggregatesToBuildStartOfIntervalStateInd  bit = 0
    ,@AggregationCoverViewName      sysname = NULL
    ,@AggregationDateTime           datetime = NULL
  AS
  BEGIN
    SET NOCOUNT ON

    DECLARE 
       @ErrorInd        bit
      ,@ErrorMessage    nvarchar(4000)
      ,@ErrorNumber     int
      ,@ErrorSeverity   int
      ,@ErrorState      int
      ,@ErrorLine       int
      ,@ErrorProcedure  nvarchar(256)
      ,@ErrorMessageText nvarchar(4000)

    SET @ErrorInd = 0
    
    BEGIN TRY
      DECLARE
         @Statement nvarchar(max)
        ,@RawCoverViewName sysname
        ,@ExtraCondition nvarchar(max)
    
      SET @ExtraCondition =
         CASE
           WHEN @ManagedEntityMonitorRowId IS NULL THEN 
              CASE 
                WHEN (OBJECT_ID('tempdb..#ManagedEntityMonitor') IS NOT NULL) THEN ' AND (ManagedEntityMonitorRowId IN (SELECT ManagedEntityMonitorRowId FROM #ManagedEntityMonitor)) '
                ELSE ''
              END
           ELSE ' AND (ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId)'
         END
         
      IF (OBJECT_ID('tempdb..#StateEventChange') IS NOT NULL)
        DROP TABLE #StateEventChange

      CREATE TABLE #StateEventChange (
         ManagedEntityMonitorRowId int
        ,[DateTime]           datetime
        ,OldHealthState       tinyint
        ,NewHealthState       tinyint
      )
        
      -- get all state changes
      -- that happened within the interval
      SET @Statement =
          ' INSERT #StateEventChange(
               ManagedEntityMonitorRowId
              ,[DateTime]
              ,OldHealthState
              ,NewHealthState
            )
            SELECT
               ManagedEntityMonitorRowId
              ,[DateTime]
              ,OldHealthState
              ,NewHealthState
            FROM [State].[vStateRaw] s
            WHERE ([DateTime] BETWEEN @IntervalStartDateTime AND @IntervalEndDateTime)'
        + @ExtraCondition
        
      EXEC sp_executesql
         @stmt = @Statement
        ,@params = N'@IntervalStartDateTime datetime, @IntervalEndDateTime datetime, @ManagedEntityMonitorRowId int'
        ,@IntervalStartDateTime = @IntervalStartDateTime
        ,@IntervalEndDateTime = @IntervalEndDateTime
        ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

      IF (@UseAggregatesToBuildStartOfIntervalStateInd = 1)
      BEGIN
		    -- NOTE: We do not return intervals where end state is 1 (healthy)
        SET @Statement =
            ' INSERT #StateEventChange(
                 ManagedEntityMonitorRowId
                ,[DateTime]
                ,OldHealthState
                ,NewHealthState
              )
              SELECT
                 s.ManagedEntityMonitorRowId
                ,@IntervalStartDateTime
                ,0
                ,ISNULL(s.IntervalEndHealthState, 0)
              FROM [State].' + QUOTENAME(@AggregationCoverViewName) + ' s
              WHERE (s.[DateTime] = @AggregationDateTime)
                AND (s.IntervalEndHealthState &lt;&gt; 1)'
          + @ExtraCondition

        EXEC sp_executesql
           @stmt = @Statement
          ,@params = N'@IntervalStartDateTime datetime, @AggregationDateTime datetime, @ManagedEntityMonitorRowId int'
          ,@IntervalStartDateTime = @IntervalStartDateTime
          ,@AggregationDateTime = @AggregationDateTime
          ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
      END
      ELSE
      BEGIN
        -- pick up the latest state change
        -- for all me/monitor pairs when
        -- there was a change during the period
        -- or the last state wasn't green
        SET @Statement =
            ' INSERT #StateEventChange(
                 ManagedEntityMonitorRowId
                ,[DateTime]
                ,OldHealthState
                ,NewHealthState
              )
              SELECT
                 s.ManagedEntityMonitorRowId
                ,@IntervalStartDateTime
                ,0
                ,MAX(s.NewHealthState)
              FROM [State].[vStateRaw] s
		         			JOIN 
             		 (SELECT ManagedEntityMonitorRowId, [DateTime] = MAX(DateTime)
                    FROM [State].[vStateRaw]
                    WHERE ([DateTime] &lt; @IntervalStartDateTime)'
             + @ExtraCondition + '
                    GROUP BY ManagedEntityMonitorRowId
                   ) AS sd
		             ON (s.ManagedEntityMonitorRowId = sd.ManagedEntityMonitorRowId) AND (s.[DateTime] = sd.[DateTime])
              GROUP BY s.ManagedEntityMonitorRowId'

        EXEC sp_executesql
           @stmt = @Statement
          ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
          ,@IntervalStartDateTime = @IntervalStartDateTime
          ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
      END
          
      -- factor in HS availability/outage
      IF EXISTS (SELECT * FROM StateHealthServiceOutage)
      BEGIN
        -- store all relationship types that represent 'manages'
        -- concept in the table
        IF (OBJECT_ID('tempdb..#ManagesRelationshipType') IS NOT NULL)
          DROP TABLE #ManagesRelationshipType
          
        CREATE TABLE #ManagesRelationshipType (
           RelationshipTypeRowId        int NOT NULL
        )

        -- R2 style 'manages' relationship between HS and an object
        INSERT #ManagesRelationshipType (RelationshipTypeRowId)
        SELECT RelationshipTypeRowId
        FROM RelationshipType rt
        WHERE (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.HealthServiceManagesEntity')

        -- OM12 style 'manages' relationship between HS2(Management Service) or pool and an object
        INSERT #ManagesRelationshipType (RelationshipTypeRowId)
        SELECT RelationshipTypeRowId
        FROM RelationshipType rt
        WHERE (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.ManagementActionPointManagesEntity')

        -- get a list of all relevant HSOs occurring in the given period of time
        -- NOTE: we store two rows for every HSO - one for start of interval and one for the end
        IF (OBJECT_ID('tempdb..#HealthServiceOutageEvent') IS NOT NULL)
          DROP TABLE #HealthServiceOutageEvent
          
        CREATE TABLE #HealthServiceOutageEvent (
           ManagedEntityRowId int       NOT NULL
          ,[DateTime]         datetime  NOT NULL
          ,OldHealthState     tinyint   NOT NULL
          ,NewHealthState     tinyint   NOT NULL
        )

        INSERT #HealthServiceOutageEvent (
           ManagedEntityRowId
          ,[DateTime]
          ,OldHealthState
          ,NewHealthState
        )
        SELECT
           hso.ManagedEntityRowId
          ,CASE
            WHEN interval.StartIntervalInd = 1 THEN 
              CASE
                WHEN hso.StartDateTime &lt; @IntervalStartDateTime THEN @IntervalStartDateTime
                ELSE hso.StartDateTime
              END
            ELSE
              CASE
                WHEN ISNULL(hso.EndDateTime, '99991231') &gt; @IntervalEndDateTime THEN @IntervalEndDateTime
                ELSE hso.EndDateTime
              END
           END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN  0 ELSE 50 END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN 50 ELSE  1 END
        FROM vHealthServiceOutage hso
              JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
              CROSS JOIN (SELECT StartIntervalInd = 0
                          UNION ALL
                          SELECT 1
                         ) AS interval
        -- Only go back a maximum of 60 days to prevent infinite growth
        WHERE (hso.StartDateTime BETWEEN DateAdd(DAY, -60, GETUTCDATE()) AND @IntervalEndDateTime)
          AND (ISNULL(hso.EndDateTime, '99991231') &gt;= @IntervalStartDateTime)
          AND (NOT EXISTS (SELECT *
                           FROM StateInvalidatedHealthServiceOutage
                           WHERE (HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                          )
              )

        IF EXISTS (SELECT * FROM #HealthServiceOutageEvent)
        BEGIN
          -- take care of HSO outages that indicate HS or a pool outage
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,hso.[DateTime]
                  ,hso.OldHealthState
                  ,hso.NewHealthState
                FROM #HealthServiceOutageEvent hso
                      JOIN vRelationship r ON (r.SourceManagedEntityRowId = hso.ManagedEntityRowId)
                      JOIN #ManagesRelationshipType mrt ON (mrt.RelationshipTypeRowId = r.RelationshipTypeRowId)
                      JOIN vRelationshipManagementGroup rmg ON (r.RelationshipRowId = rmg.RelationshipRowId)
                      JOIN vManagedEntity me ON (r.TargetManagedEntityRowId = me.TopLevelHostManagedEntityRowId)
                      JOIN vManagedEntityMonitor mem ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)
                WHERE (@IntervalStartDateTime BETWEEN rmg.FromDateTime AND ISNULL(rmg.ToDateTime, ''99991231''))'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
            ,@IntervalStartDateTime = @IntervalStartDateTime
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

          -- take care of HSO outages that indicate entity (which is TLH) outage
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,hso.[DateTime]
                  ,hso.OldHealthState
                  ,hso.NewHealthState
                FROM #HealthServiceOutageEvent hso
                      JOIN vManagedEntity me ON (hso.ManagedEntityRowId = me.TopLevelHostManagedEntityRowId)
                      JOIN vManagedEntityMonitor mem ON (me.ManagedEntityRowId = mem.ManagedEntityRowId)'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@IntervalStartDateTime datetime, @ManagedEntityMonitorRowId int'
            ,@IntervalStartDateTime = @IntervalStartDateTime
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId

          -- set new state of the periods where hso ended to 'last reported state transition'
          CREATE INDEX temp1 ON #StateEventChange (ManagedEntityMonitorRowId)

          SET @Statement = '
            UPDATE se
            SET se.NewHealthState = ISNULL(previous_real_transition.NewHealthState, 1)
            FROM #StateEventChange se
                JOIN (
                      SELECT
                         MEMRowId = previous_se.ManagedEntityMonitorRowId
                        ,CutOffDateTime = cutoff_se.[DateTime]
                        ,previous_se.NewHealthState
                        ,StateEventNumber = RANK() OVER (PARTITION BY previous_se.ManagedEntityMonitorRowId, cutoff_se.[DateTime] ORDER BY previous_se.[DateTime] DESC, previous_se.NewHealthState DESC)
                      FROM #StateEventChange cutoff_se
                            JOIN #StateEventChange previous_se ON (cutoff_se.ManagedEntityMonitorRowId = previous_se.ManagedEntityMonitorRowId) AND (cutoff_se.[DateTime] &gt; previous_se.[DateTime])
                      WHERE (cutoff_se.OldHealthState = 50)
                        AND (previous_se.OldHealthState &lt; 50)
                        AND (previous_se.NewHealthState &lt; 50) -- real state transition, not hso or mmode
                     ) AS previous_real_transition ON (se.ManagedEntityMonitorRowId = previous_real_transition.MEMRowId) AND (se.[DateTime] = previous_real_transition.CutOffDateTime)
            WHERE (se.OldHealthState = 50)
              AND (previous_real_transition.StateEventNumber = 1)'
          + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@ManagedEntityMonitorRowId int'
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
        END
      END

      -- factor in maintenance mode
      -- using two itertions - first for unlanned maintenance
      -- then second for planned maintenance
      DECLARE @i int
      SET @i = 0

      WHILE (@i &lt; 2)
      BEGIN
        -- find all relevant mmode intervals
        IF (OBJECT_ID('tempdb..#MaintenanceModeEvent') IS NOT NULL)
          DROP TABLE #MaintenanceModeEvent
          
        CREATE TABLE #MaintenanceModeEvent (
           ManagedEntityRowId int       NOT NULL
          ,[DateTime]         datetime  NOT NULL
          ,OldHealthState     tinyint   NOT NULL
          ,NewHealthState     tinyint   NOT NULL
        )

        INSERT #MaintenanceModeEvent (
           ManagedEntityRowId
          ,[DateTime]
          ,OldHealthState
          ,NewHealthState
        )
        SELECT
           mm.ManagedEntityRowId
          ,CASE
            WHEN interval.StartIntervalInd = 1 THEN 
              CASE
                WHEN mm.StartDateTime &lt; @IntervalStartDateTime THEN @IntervalStartDateTime
                ELSE mm.StartDateTime
              END
            ELSE
              CASE
                WHEN ISNULL(mm.EndDateTime, '99991231') &gt; @IntervalEndDateTime THEN @IntervalEndDateTime
                ELSE mm.EndDateTime
              END
           END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN        0 ELSE 100 + @i END
          ,CASE WHEN interval.StartIntervalInd = 1 THEN 100 + @i ELSE        1 END
        FROM vMaintenanceMode mm
              CROSS JOIN (SELECT StartIntervalInd = 0
                          UNION ALL
                          SELECT 1
                         ) AS interval
        -- Only go back a maximum of 60 days to prevent infinite growth
        WHERE (mm.StartDateTime BETWEEN DateAdd(DAY, -60, GETUTCDATE()) AND @IntervalEndDateTime)
          AND (ISNULL(mm.EndDateTime, '99991231') &gt;= @IntervalStartDateTime)
          AND (mm.PlannedMaintenanceInd = @i)

        IF EXISTS (SELECT * FROM #MaintenanceModeEvent)
        BEGIN
          DELETE se
          FROM #StateEventChange se
                JOIN vManagedEntityMonitor mem ON (se.ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId)
                JOIN vMaintenanceMode mm ON (mem.ManagedEntityRowId = mm.ManagedEntityRowId)
          WHERE (se.[DateTime] BETWEEN mm.StartDateTime AND ISNULL(mm.EndDateTime, '99990101'))
            AND (mm.PlannedMaintenanceInd = @i)
     
          SET @Statement = 
              ' INSERT #StateEventChange (
                    ManagedEntityMonitorRowId
                   ,[DateTime]
                   ,OldHealthState
                   ,NewHealthState
                )
                SELECT
                   mem.ManagedEntityMonitorRowId
                  ,mm.[DateTime]
                  ,mm.OldHealthState
                  ,mm.NewHealthState
                FROM #MaintenanceModeEvent mm
                      JOIN vManagedEntityMonitor mem ON (mm.ManagedEntityRowId = mem.ManagedEntityRowId)
                WHERE (1 = 1)'
            + @ExtraCondition

          EXEC sp_executesql
             @stmt = @Statement
            ,@params = N'@ManagedEntityMonitorRowId int'
            ,@ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
        END

        SET @i = @i + 1
      END
      
      -- clean out dupes in state transition
      SELECT
         ManagedEntityMonitorRowId
        ,[DateTime]
        ,OldHealthState = MAX(OldHealthState)
        ,NewHealthState = MAX(NewHealthState)
      FROM #StateEventChange
      GROUP BY ManagedEntityMonitorRowId, [DateTime]

      DROP TABLE #StateEventChange
    END TRY
    BEGIN CATCH
      SELECT 
         @ErrorNumber = ERROR_NUMBER()
        ,@ErrorSeverity = ERROR_SEVERITY()
        ,@ErrorState = ERROR_STATE()
        ,@ErrorLine = ERROR_LINE()
        ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
        ,@ErrorMessageText = ERROR_MESSAGE()

      SET @ErrorInd = 1
    END CATCH
    
    -- report error if any
    IF (@ErrorInd = 1)
    BEGIN
      DECLARE @AdjustedErrorSeverity int

      SET @AdjustedErrorSeverity = CASE
                                     WHEN @ErrorSeverity &gt; 18 THEN 18
                                     ELSE @ErrorSeverity
                                   END
      
      RAISERROR (777971002, @AdjustedErrorSeverity, 1
        ,@ErrorNumber
        ,@ErrorSeverity
        ,@ErrorState
        ,@ErrorProcedure
        ,@ErrorLine
        ,@ErrorMessageText
      )
    END
  END
  GO
   
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateDowntimeList')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateDowntimeList AS RETURN 1')
	END
GO

ALTER PROCEDURE StateDowntimeList
   @ManagedEntityMonitorRowId    int
  ,@FromDateTime                 datetime
  ,@ToDateTime                   datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  BEGIN TRY

    IF (OBJECT_ID('tempdb..#StateEvent') IS NOT NULL)
      DROP TABLE #StateEvent

    CREATE TABLE #StateEvent (
       ManagedEntityMonitorRowId int
      ,[DateTime]           datetime
      ,OldHealthState       tinyint
      ,NewHealthState       tinyint
    )
  
    IF (OBJECT_ID('tempdb..#StateEventRanked') IS NOT NULL)
      DROP TABLE #StateEventRanked

    CREATE TABLE #StateEventRanked (
       ManagedEntityMonitorRowId int
      ,[DateTime]           datetime
      ,IntervalNumber       int
      ,OldHealthState       tinyint
      ,NewHealthState       tinyint
    )
  
    INSERT #StateEvent (ManagedEntityMonitorRowId, [DateTime], OldHealthState, NewHealthState)
    EXEC StateChangeEventList 
          @ManagedEntityMonitorRowId = @ManagedEntityMonitorRowId
         ,@IntervalStartDateTime = @FromDateTime
         ,@IntervalEndDateTime = @ToDateTime

    INSERT #StateEventRanked (ManagedEntityMonitorRowId, [DateTime], IntervalNumber, OldHealthState, NewHealthState)
    SELECT 
       ManagedEntityMonitorRowId
      ,[DateTime]
      ,IntervalNumber = RANK() OVER (PARTITION BY ManagedEntityMonitorRowId ORDER BY [DateTime])
      ,OldHealthState
      ,NewHealthState
      FROM #StateEvent

    SELECT 
       ManagedEntityMonitorRowId
      ,FromDateTime = 
        CASE 
          WHEN FromDateTime &lt; @FromDateTime THEN @FromDateTime
          ELSE FromDateTime
        END
      ,ToDateTime = ISNULL(ToDateTime, @ToDateTime)
      ,HealthState
    FROM (SELECT
             l.ManagedEntityMonitorRowId
            ,FromDateTime = l.[DateTime]
            ,ToDateTime = r.[DateTime]
            ,HealthState = 
               CASE WHEN l.NewHealthState &gt; ISNULL(r.OldHealthState, l.NewHealthState)
                 THEN l.NewHealthState
                 ELSE ISNULL(r.OldHealthState, l.NewHealthState)
               END
          FROM #StateEventRanked AS l 
                LEFT JOIN #StateEventRanked AS r ON (l.ManagedEntityMonitorRowId = r.ManagedEntityMonitorRowId) AND (l.IntervalNumber + 1 = r.IntervalNumber)
        ) AS tbl
    WHERE (HealthState &lt;&gt; 1)
      AND (FromDateTime &lt; ISNULL(ToDateTime, @ToDateTime)) -- eliminate zero-length intervals
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
      
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
  
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO

GRANT EXECUTE ON StateDowntimeList TO OpsMgrReader, OpsMgrWriter
GO

                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateGroom')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateGroom AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateGroom
   @DatasetId   uniqueidentifier
  ,@AggregationTypeId tinyint
  ,@TableGuid uniqueidentifier
  ,@CutoffDateTime datetime
  ,@MaxRowsToGroom int
  ,@RowsDeleted int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(4000)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(4000)

  SET @ErrorInd = 0
  
  DECLARE
     @TableName sysname
    ,@Statement nvarchar(max)
    ,@DebugLevel tinyint
    ,@SchemaName sysname
  
  BEGIN TRY
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- there are no dependent tables in state data set
    SELECT @TableName = BaseTableName + '_' + REPLACE(CAST(@TableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @AggregationTypeId)
      AND (DependentTableInd = 0)
    
    SET @Statement = 'DELETE TOP (' + CAST(@MaxRowsToGroom AS varchar(15)) + ')'
                   + ' FROM ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                   + ' WHERE ([DateTime] &lt; CONVERT(datetime, ''' + CONVERT(varchar(50), @CutoffDateTime, 120) + ''', 120))'

    EXECUTE (@Statement)
    SET @RowsDeleted = @@ROWCOUNT
    
    -- groom dynamic dimentions
    DELETE mem
    FROM ManagedEntityMonitor mem
    WHERE NOT EXISTS (SELECT * FROM vMonitor m WHERE (m.MonitorRowId = mem.MonitorRowId))
    
    DELETE mem
    FROM ManagedEntityMonitor mem
    WHERE NOT EXISTS (SELECT * FROM vManagedEntity me WHERE (me.ManagedEntityRowId = mem.ManagedEntityRowId))
    
    -- groom staging of data for rejected MGs
    DELETE State.StateStage
    WHERE ManagementGroupGuid NOT IN (SELECT ManagementGroupGuid
                                      FROM ManagementGroup mg
                                      WHERE (ConnectConfirmedDateTime IS NOT NULL)
                                        AND (ConnectRejectedInd = 0)
                                     )
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN

    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH
    
  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)

      SET @DebugMessageText = N'Failed to groom data for state data set. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
  
  RETURN @RowsDeleted
END
GO
  
                    IF NOT EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'StateProcessStaging')
	BEGIN
		EXECUTE ('CREATE PROCEDURE dbo.StateProcessStaging AS RETURN 1')
	END
GO

ALTER PROCEDURE dbo.StateProcessStaging
   @DatasetId           uniqueidentifier
AS
BEGIN
  SET NOCOUNT ON
  
  DECLARE 
     @ErrorInd        bit
    ,@ErrorMessage    nvarchar(max)
    ,@ErrorNumber     int
    ,@ErrorSeverity   int
    ,@ErrorState      int
    ,@ErrorLine       int
    ,@ErrorProcedure  nvarchar(256)
    ,@ErrorMessageText nvarchar(max)

  SET @ErrorInd = 0

  BEGIN TRY
    DECLARE
       @DebugLevel int
      ,@SchemaName sysname
      ,@ExecResult int
      ,@LockResourceName sysname
      ,@InsertTableName sysname
      ,@InsertTableGuid uniqueidentifier
      ,@InsertStartedDateTime datetime
      ,@Statement nvarchar(max)
      ,@MessageText varchar(max)
      ,@OperationDurationMs bigint
    
    SELECT
       @DebugLevel = DebugLevel
      ,@SchemaName = SchemaName
    FROM StandardDataset
    WHERE DatasetId = @DatasetId

    -- groom records that are &gt; month old since
    -- aggregations only kept one month long
    DELETE State.StateStage WITH (TABLOCK)
    WHERE ([DateTime] &lt; DATEADD(month, -1, GETUTCDATE()))

    -- process staging to create ME Monitor records for newly discovered monitors
    INSERT ManagedEntityMonitor (
       ManagedEntityRowId
      ,MonitorRowId
    )
    SELECT DISTINCT
       me.ManagedEntityRowId
      ,m.MonitorRowId
    FROM State.StateStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((me.ManagedEntityGuid = s.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
          JOIN vMonitor m ON (m.MonitorGuid = s.MonitorGuid)
    WHERE (s.DatasetId = @DatasetId)
      AND NOT EXISTS (SELECT *
                      FROM vManagedEntityMonitor
                      WHERE (ManagedEntityRowId = me.ManagedEntityRowId)
                        AND (MonitorRowId = m.MonitorRowId)
                     )
    
    -- process events in staging setting MEM id if it is not yet determined
    
    -- NOTE: The force order hint below is meant to avoid situation when 
    -- dw has more records in ME then in MEM and SQL thinks that querying
    -- MEM first and then ME is beneficial (which is not true really)
    UPDATE s
    SET ManagedEntityMonitorRowId = mem.ManagedEntityMonitorRowId
    FROM State.StateStage s
          JOIN vManagementGroup mg ON (s.ManagementGroupGuid = mg.ManagementGroupGuid)
          JOIN vManagedEntity me ON ((me.ManagedEntityGuid = s.ManagedEntityGuid) AND (mg.ManagementGroupRowId = me.ManagementGroupRowId))
          JOIN vMonitor m ON (m.MonitorGuid = s.MonitorGuid)
          JOIN vManagedEntityMonitor mem ON ((mem.ManagedEntityRowId = me.ManagedEntityRowId) AND (mem.MonitorRowId = m.MonitorRowId))
    WHERE (s.DatasetId = @DatasetId)
      AND (s.InsertReadyInd = 0)
    OPTION (FORCE ORDER)

    -- delete sate transitions older then 48 hours to 
    -- not to go back 'too much' - such state transitions
    -- are cut of by the agents, but they can linger in staging
    -- if object existed but then was deleted
    DELETE State.StateStage
    WHERE (DatasetId = @DatasetId)
      AND (InsertReadyInd &gt; 0)
      AND ([DateTime] &lt; DATEADD(hour, -48, GETUTCDATE()))
    
    -- invalidate HSO intervals when the HS in question
    -- did send some state changes during the interval
    -- NOTE: Starting OM2012 SP1 we do not invalidate
    -- HS outage intervals to close map to operational
    -- side of the house and not to throw state aggregations
    -- back too much when HS coming out of long outage period
    /*
    IF EXISTS (SELECT * FROM StateHealthServiceOutage)
    BEGIN
      INSERT StateInvalidatedHealthServiceOutage (HealthServiceOutageRowId)
      SELECT DISTINCT hso.HealthServiceOutageRowId
      FROM State.StateStage s
            JOIN vManagedEntity me ON (me.ManagedEntityGuid = s.ManagedEntityGuid)
            JOIN vRelationship r ON (me.TopLevelHostManagedEntityRowId = r.TargetManagedEntityRowId)
            JOIN vRelationshipManagementGroup rmg ON (r.RelationshipRowId = rmg.RelationshipRowId)
            JOIN vRelationshipType rt ON (r.RelationshipTypeRowId = rt.RelationshipTypeRowId)
            JOIN vHealthServiceOutage hso ON (r.SourceManagedEntityRowId = hso.ManagedEntityRowId)
            JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
      WHERE (s.InsertReadyInd &gt; 0)
        AND (s.[DateTime] BETWEEN rmg.FromDateTime AND ISNULL(rmg.ToDateTime, '99991231'))
        AND (rt.RelationshipTypeSystemName = 'Microsoft.SystemCenter.HealthServiceManagesEntity')
        AND (s.[DateTime] BETWEEN hso.StartDateTime AND ISNULL(hso.EndDateTime, '99991231'))
        AND (NOT EXISTS (SELECT *
                         FROM StateInvalidatedHealthServiceOutage
                         WHERE (HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                        )
            )
    END
    */

    -- mark existing aggregations as dirty when
    -- new information about mmode is received
    BEGIN TRAN
    
    DECLARE
       @LastProcessedMModeModifiedDateTime datetime
      ,@NewLastProcessedMModeModifiedDateTime datetime
      ,@MinDate datetime
    
    SELECT @LastProcessedMModeModifiedDateTime = LastProcessedMaintenanceModeModifiedDateTime
    FROM StateAggregationProcessing
    WHERE (DatasetId = @DatasetId)
    
    IF (@LastProcessedMModeModifiedDateTime IS NULL)
    BEGIN
      SET @LastProcessedMModeModifiedDateTime = '20050101'
    END
    
    SELECT @NewLastProcessedMModeModifiedDateTime = DATEADD(second, -5, GETUTCDATE())
    
    -- build a list of all mmode intervals
    -- touched since last processing up until [almost] now
    CREATE TABLE #UpdatedMaintenanceMode (
       MaintenanceModeRowId     int       NOT NULL PRIMARY KEY
      ,StartDateTime            datetime  NOT NULL
      ,EndDateTime              datetime  NULL
      ,PlannedMaintenanceInd    bit       NOT NULL
      ,DWLastModifiedDateTime   datetime  NOT NULL
    )
    
    INSERT #UpdatedMaintenanceMode (
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    )
    SELECT 
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    FROM vMaintenanceMode mmode
    WHERE (mmode.DWLastModifiedDateTime &gt;= @LastProcessedMModeModifiedDateTime)
      AND (mmode.DWLastModifiedDateTime &lt; @NewLastProcessedMModeModifiedDateTime)
    
    -- calculate minimum date for re-aggregations
    SET @MinDate = NULL
    
    SELECT @MinDate = MIN(
            CASE
              WHEN (processed_mmode.MaintenanceModeRowId IS NULL) -- not yet processed
                THEN mmode.StartDateTime
              ELSE
                CASE
                  WHEN (processed_mmode.PlannedMaintenanceInd != mmode.PlannedMaintenanceInd) -- changed planned / unplanned
                    THEN mmode.StartDateTime
                  WHEN (mmode.EndDateTime IS NOT NULL) -- end time update - pick up minimum of end times
                   AND (ISNULL(processed_mmode.EndDateTime, '99991231') != mmode.EndDateTime)
                      THEN CASE
                             WHEN mmode.EndDateTime &lt; ISNULL(processed_mmode.EndDateTime, '99991231') THEN mmode.EndDateTime
                             ELSE processed_mmode.EndDateTime
                           END
                  ELSE NULL
                END
            END
    )
    FROM #UpdatedMaintenanceMode mmode
          LEFT JOIN StateProcessedMaintenanceMode processed_mmode ON (mmode.MaintenanceModeRowId = processed_mmode.MaintenanceModeRowId)

    -- update processed mmode for the intervals that were updated
    UPDATE processed_mmode
    SET StartDateTime = mmode.StartDateTime
       ,EndDateTime = mmode.EndDateTime
       ,PlannedMaintenanceInd = mmode.PlannedMaintenanceInd
       ,MaintenanceModeDWLastModifiedDateTime = mmode.DWLastModifiedDateTime
       ,DWLastModifiedDateTime = GETUTCDATE()
    FROM #UpdatedMaintenanceMode mmode
           JOIN StateProcessedmaintenanceMode processed_mmode ON (mmode.MaintenanceModeRowId = processed_mmode.MaintenanceModeRowId)
    
    -- add records to processed HSO for the outages that are new
    INSERT StateProcessedMaintenanceMode (
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,MaintenanceModeDWLastModifiedDateTime
    )
    SELECT
       MaintenanceModeRowId
      ,StartDateTime
      ,EndDateTime
      ,PlannedMaintenanceInd
      ,DWLastModifiedDateTime
    FROM #UpdatedMaintenanceMode mmode
    WHERE (NOT EXISTS (SELECT * FROM StateProcessedMaintenanceMode WHERE MaintenanceModeRowId = mmode.MaintenanceModeRowId))
    
    -- groom processed mmode table
    DELETE StateProcessedMaintenanceMode
    WHERE EndDateTime &lt; DATEADD(month, -1, GETUTCDATE())

    DROP TABLE #UpdatedMaintenanceMode

    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END
    
    UPDATE StateAggregationProcessing
    SET LastProcessedMaintenanceModeModifiedDateTime = @NewLastProcessedMModeModifiedDateTime
    WHERE (DatasetId = @DatasetId)
    
    IF (@@ROWCOUNT = 0)
    BEGIN
      INSERT StateAggregationProcessing(DatasetId, LastProcessedMaintenanceModeModifiedDateTime)
      VALUES (@DatasetId, @NewLastProcessedMModeModifiedDateTime)
    END

    COMMIT      

    -- mark existing aggregations as dirty when
    -- new information about health service outage is received
    BEGIN TRAN
    
    DECLARE
       @LastProcessedHsoModifiedDateTime datetime
      ,@NewLastProcessedHsoModifiedDateTime datetime
    
    SELECT @LastProcessedHsoModifiedDateTime = LastProcessedHealthServiceOutageModifiedDateTime
    FROM StateAggregationProcessing
    WHERE (DatasetId = @DatasetId)
    
    IF (@LastProcessedHsoModifiedDateTime IS NULL)
    BEGIN
      SET @LastProcessedHsoModifiedDateTime = '20050101'
    END
    
    SELECT @NewLastProcessedHsoModifiedDateTime = DATEADD(second, -5, GETUTCDATE())
    
    -- calculate the minimum date to 
    -- declare aggregations as dirty
    
    -- build a list of all HSO records and invalidation
    -- records touched since last processing up until [almost] now
    CREATE TABLE #UpdatedHealthServiceOutage (
       HealthServiceOutageRowId     int       NOT NULL PRIMARY KEY
      ,StartDateTime                datetime  NOT NULL
      ,EndDateTime                  datetime  NULL
      ,ReasonCode                   tinyint   NOT NULL
      ,DWLastModifiedDateTime       datetime  NOT NULL
      ,InvalidatedDateTime          datetime  NULL
    )
    
    INSERT #UpdatedHealthServiceOutage (
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,DWLastModifiedDateTime
      ,InvalidatedDateTime
    )
    SELECT
       hso.HealthServiceOutageRowId
      ,hso.StartDateTime
      ,hso.EndDateTime
      ,hso.ReasonCode
      ,hso.DWLastModifiedDateTime
      ,sihso.DWCreatedDateTime
    FROM vHealthServiceOutage hso
          JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
          LEFT JOIN StateInvalidatedHealthServiceOutage sihso ON (hso.HealthServiceOutageRowId = sihso.HealthServiceOutageRowId)
    WHERE (hso.DWLastModifiedDateTime &gt;= @LastProcessedHsoModifiedDateTime)
      AND (hso.DWLastModifiedDateTime &lt; @NewLastProcessedHsoModifiedDateTime)
    
    UNION
    
    SELECT
       hso.HealthServiceOutageRowId
      ,hso.StartDateTime
      ,hso.EndDateTime
      ,hso.ReasonCode
      ,hso.DWLastModifiedDateTime
      ,sihso.DWCreatedDateTime
    FROM vHealthServiceOutage hso
          JOIN StateHealthServiceOutage shso ON (hso.ReasonCode = shso.ReasonCode)
          JOIN StateInvalidatedHealthServiceOutage sihso ON (hso.HealthServiceOutageRowId = sihso.HealthServiceOutageRowId)
    WHERE (sihso.DWCreatedDateTime &gt;= @LastProcessedHsoModifiedDateTime)
      AND (sihso.DWCreatedDateTime &lt; @NewLastProcessedHsoModifiedDateTime)
      
    SET @MinDate = NULL
      
    SELECT @MinDate = MIN(
              CASE
                WHEN (processed_hso.HealthServiceOutageRowId IS NULL) -- this hso was never processed before
                  THEN
                    CASE
                      WHEN (uhso.InvalidatedDateTime IS NULL) -- not invalidated
                        THEN uhso.StartDateTime
                      ELSE -- this hso is already invalidated - do not process
                        NULL
                    END
                ELSE  -- this hso was seen before
                    CASE
                      WHEN (processed_hso.InvalidatedDateTime IS NOT NULL) -- already invalidated, does not count
                        THEN NULL
                      WHEN (uhso.InvalidatedDateTime IS NOT NULL) -- hso invalidated
                        THEN uhso.InvalidatedDateTime -- look at invalidated date time not Start date time for perf optimizations. Otherwise we throw aggregation process back all the time
                      WHEN (uhso.EndDateTime IS NOT NULL) -- end time update - pick up minimum of end times
                       AND (ISNULL(processed_hso.EndDateTime, '99991231') != uhso.EndDateTime)
                          THEN CASE
                                 WHEN uhso.EndDateTime &lt; ISNULL(processed_hso.EndDateTime, '99991231') THEN uhso.EndDateTime
                                 ELSE processed_hso.EndDateTime
                               END
                      ELSE NULL
                    END
              END
           )
    FROM #UpdatedHealthServiceOutage AS uhso
           LEFT JOIN StateProcessedHealthServiceOutage processed_hso ON (uhso.HealthServiceOutageRowId = processed_hso.HealthServiceOutageRowId)
    
    -- update processed HSO for the outages that were updated
    UPDATE processed_hso
    SET StartDateTime = hso.StartDateTime
       ,EndDateTime = hso.EndDateTime
       ,ReasonCode = hso.ReasonCode
       ,HealthServiceOutageDWLastModifiedDateTime = hso.DWLastModifiedDateTime
       ,InvalidatedDateTime = hso.InvalidatedDateTime
       ,DWLastModifiedDateTime = GETUTCDATE()
    FROM #UpdatedHealthServiceOutage hso
           JOIN StateProcessedHealthServiceOutage processed_hso ON (hso.HealthServiceOutageRowId = processed_hso.HealthServiceOutageRowId)
    
    -- add records to processed HSO for the outages that are new
    INSERT StateProcessedHealthServiceOutage (
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,HealthServiceOutageDWLastModifiedDateTime
      ,InvalidatedDateTime
    )
    SELECT
       HealthServiceOutageRowId
      ,StartDateTime
      ,EndDateTime
      ,ReasonCode
      ,DWLastModifiedDateTime
      ,InvalidatedDateTime
    FROM #UpdatedHealthServiceOutage hso
    WHERE (NOT EXISTS (SELECT * FROM StateProcessedHealthServiceOutage WHERE HealthServiceOutageRowId = hso.HealthServiceOutageRowId))
    
    -- groom invalidated Health Service Outage table
    DELETE sihso
    FROM StateInvalidatedHealthServiceOutage sihso
    WHERE NOT EXISTS (SELECT *
                      FROM HealthServiceOutage hso
                      WHERE (sihso.HealthServiceOutageRowId = hso.HealthServiceOutageRowId)
                     )

    -- groom processed Health Service Outage table
    DELETE StateProcessedHealthServiceOutage
    WHERE EndDateTime &lt; DATEADD(month, -1, GETUTCDATE())

    DROP TABLE #UpdatedHealthServiceOutage

    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END
    
    UPDATE StateAggregationProcessing
    SET LastProcessedHealthServiceOutageModifiedDateTime = @NewLastProcessedHsoModifiedDateTime
    WHERE (DatasetId = @DatasetId)
    
    IF (@@ROWCOUNT = 0)
    BEGIN
      INSERT StateAggregationProcessing(DatasetId, LastProcessedHealthServiceOutageModifiedDateTime)
      VALUES (@DatasetId, @NewLastProcessedHsoModifiedDateTime)
    END

    COMMIT

    BEGIN TRAN
    
    -- lock table map to ensure we insert into table opened for insertion
    SET @LockResourceName = CAST(@DatasetId AS varchar(50)) + '_TableMap'
  
    EXEC @ExecResult = sp_getapplock
           @Resource = @LockResourceName
          ,@LockMode = 'Shared'
          ,@LockOwner = 'Transaction'

    IF (@ExecResult &lt; 0)
    BEGIN
      RAISERROR(777971001, 16, 1, 'Shared:StandardDatasetTableMap', @ExecResult)
    END
  
    EXEC dbo.StandardDatasetGetInsertTableGuid @DatasetId, 0, @InsertTableGuid OUTPUT
    
    SELECT @InsertTableName = BaseTableName + '_' + REPLACE(CAST(@InsertTableGuid AS varchar(50)), '-', '')
    FROM StandardDatasetAggregationStorage
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = 0)
      AND (DependentTableInd = 0)
  
    SELECT @Statement =
        ' INSERT ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@InsertTableName) + ' ('
      + '    EventOriginId'
      + '   ,ManagedEntityMonitorRowId'
      + '   ,[DateTime]'
      + '   ,OldHealthState'
      + '   ,NewHealthState'
      + ' )'
      + ' SELECT '
      + '    EventOriginId'
      + '   ,ManagedEntityMonitorRowId'
      + '   ,[DateTime]'
      + '   ,OldHealthState'
      + '   ,NewHealthState'
      + ' FROM State.StateStage'
      + ' WHERE (DatasetId = ''' + CAST(@DatasetId AS varchar(50)) + ''')'
      + '   AND (InsertReadyInd &gt; 0)'

    IF (@DebugLevel &gt; 3)
    BEGIN
      SELECT @MessageText = 'Starting to insert state raw change event(s) into ' + @InsertTableName
      
      SET @InsertStartedDateTime = GETUTCDATE()
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
    END
   
    EXECUTE(@Statement)
    
    -- mark existing affected aggregations as dirty
    SET @MinDate = NULL
    
    SELECT @MinDate = MIN([DateTime]) 
    FROM State.StateStage 
    WHERE (DatasetId = @DatasetId) 
      AND (InsertReadyInd &gt; 0)
      
    IF (@MinDate IS NOT NULL)
    BEGIN
      UPDATE ah
      SET DirtyInd = 1
         ,DataLastReceivedDateTime = GETUTCDATE()
      FROM StandardDatasetAggregationHistory ah
            JOIN StandardDatasetAggregation a ON (ah.DatasetId = a.DatasetId AND ah.AggregationTypeId = a.AggregationTypeId)
      WHERE (ah.DatasetId = @DatasetId)
        AND (ah.AggregationDateTime &gt; DATEADD(minute, -a.AggregationIntervalDurationMinutes, @MinDate))
    END

    -- make sure at least one interval of the lowest
    -- aggregation type is not invalidated - if they all are
    -- aggregation process may have problems on high volume

    -- find lowest type aggregations we need to perform
    DECLARE @LowestAggregationTypeId int
    
    SELECT @LowestAggregationTypeId = MIN(AggregationTypeId)
    FROM StandardDatasetAggregation
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId &gt; 0)
      
    UPDATE StandardDatasetAggregationHistory
    SET DirtyInd = 0
    WHERE (DatasetId = @DatasetId)
      AND (AggregationTypeId = @LowestAggregationTypeId)
      AND (AggregationDateTime = (SELECT MIN(AggregationDateTime)
                                  FROM StandardDatasetAggregationHistory
                                  WHERE (DatasetId = @DatasetId)
                                    AND (AggregationTypeId = @LowestAggregationTypeId)
                                 )
          )

    -- remove rows from staging
    DELETE State.StateStage WITH (TABLOCK)
    WHERE (DatasetId = @DatasetId)
      AND (InsertReadyInd &gt; 0)
    
    IF (@DebugLevel &gt; 3)
    BEGIN
      SET @MessageText = 'Finished inserting state change events into ' + @InsertTableName
      SET @OperationDurationMs = ABS(DATEDIFF(ms, GETUTCDATE(), @InsertStartedDateTime))
      
      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 4
        ,@MessageText = @MessageText
        ,@OperationDurationMs = @OperationDurationMs
    END
   
    COMMIT
  END TRY
  BEGIN CATCH
    IF (@@TRANCOUNT &gt; 0)
      ROLLBACK TRAN
  
    SELECT 
       @ErrorNumber = ERROR_NUMBER()
      ,@ErrorSeverity = ERROR_SEVERITY()
      ,@ErrorState = ERROR_STATE()
      ,@ErrorLine = ERROR_LINE()
      ,@ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-')
      ,@ErrorMessageText = ERROR_MESSAGE()

    SET @ErrorInd = 1
  END CATCH

  -- report error if any
  IF (@ErrorInd = 1)
  BEGIN
    IF (@DebugLevel &gt; 0)
    BEGIN
      DECLARE @DebugMessageText nvarchar(max)
      
      SET @DebugMessageText = N'Failed to process data in the state data set staging area. Error ' + CAST(@ErrorNumber AS varchar(15))
                      + ', Procedure ' + @ErrorProcedure
                      + ', Line ' + CAST(@ErrorLine AS varchar(15))
                      + ', Message: '+ @ErrorMessageText

      EXEC DebugMessageInsert
         @DatasetId = @DatasetId
        ,@MessageLevel = 1
        ,@MessageText = @DebugMessageText
    END
      
    DECLARE @AdjustedErrorSeverity int

    SET @AdjustedErrorSeverity = CASE
                                   WHEN @ErrorSeverity &gt; 18 THEN 18
                                   ELSE @ErrorSeverity
                                 END
    
    RAISERROR (777971002, @AdjustedErrorSeverity, 1
      ,@ErrorNumber
      ,@ErrorSeverity
      ,@ErrorState
      ,@ErrorProcedure
      ,@ErrorLine
      ,@ErrorMessageText
    )
  END
END
GO


										-- defrag State.StateStage table (its a heap) by creating and dropping clustered index

CREATE CLUSTERED INDEX IDX_StateStage_Temporary ON State.StateStage (DWCreatedDateTime)
GO

DROP INDEX IDX_StateStage_Temporary ON State.StateStage
GO

                    </Upgrade></DataWarehouseDataSet></DataWarehouseDataSets></Reporting><LanguagePacks><LanguagePack ID="ENU" IsDefault="true"><DisplayStrings><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse"><Name>Microsoft System Center Data Warehouse</Name><Description>Microsoft System Center Data Warehouse</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse" SubElementID="MainDatabaseName"><Name>Data Warehouse main database name</Name><Description>Data Warehouse main database name</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse" SubElementID="MainDatabaseServerName"><Name>Data Warehouse main database server name</Name><Description>Data Warehouse main database server name</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AppMonitoring"><Name>App Advisor DB</Name><Description>App Advisor DB</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse" SubElementID="MyReportsFolderName"><Name>Data Warehouse My Reports folder</Name><Description>Data Warehouse My Reports folder name</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse" SubElementID="ReportingServerUrl"><Name>Data Warehouse Reporting Server Url</Name><Description>Data Warehouse Reporting Server (Sql Reporting Services Server) Url</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse" SubElementID="ReportRootFolderName"><Name>Data Warehouse report root folder</Name><Description>Data Warehouse report root folder name</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLog2StateUnitMonitorType"><Name>Two-state event based monitor</Name><Description>Two state monitor switching states based on event configured for each state</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLog2StateUnitMonitorType" SubElementID="FirstEventRaised"><Name>First event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLog2StateUnitMonitorType" SubElementID="SecondEventRaised"><Name>Second event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLogTimed2StateUnitMonitorType"><Name>Two-state event based monitor with timer</Name><Description>Monitor switches to good state if a given good event appears; monitor switches to bad state if given bad event appears and no good event is registered within a given time frame</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLogTimed2StateUnitMonitorType" SubElementID="SecondEventRaised"><Name>Second event raised</Name><Description/></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLogTimed2StateUnitMonitorType" SubElementID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval"><Name>First event raised and second event not raised within a given time interval</Name><Description/></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.2SingleEventLogTimed2StateUnitMonitorType" SubElementID="TimeIntervalSeconds"><Name>Maximum allowed recovery time (seconds)</Name><Description>Time interval in seconds the monitor will wait before switching to bad state after bad event in registered</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.3SingleEventLog3StateUnitMonitorType"><Name>Three-state event based monitor</Name><Description>Three state monitor switching states based on event configured for each state</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.3SingleEventLog3StateUnitMonitorType" SubElementID="FirstEventRaised"><Name>First event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.3SingleEventLog3StateUnitMonitorType" SubElementID="SecondEventRaised"><Name>Second event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.3SingleEventLog3StateUnitMonitorType" SubElementID="ThirdEventRaised"><Name>Third event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ActionAccount"><Name>Data Warehouse Account</Name><Description>If specified, this account is used to run all Data Warehouse collection and synchronization rules instead of the default action account. If not overridden by Data Warehouse Sql Authentication Account, this account is used by collection and synchronization rules to connect to the Data Warehouse databases using Windows integrated authentication</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter"><Name>Data Warehouse alert data writer (custom routing)</Name><Description>Use this module to write alert data to the Data Warehouse with custom routing (custom data set)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter" SubElementID="BulkInsertBatchSize"><Name>Bulk Insert Batch Size</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Execution Attempt Timeout Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Max Batches To Process Before Maintenance Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriter" SubElementID="MaxExecutionAttemptCount"><Name>Max Execution Attempt Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting"><Name>Data Warehouse alert data writer (default routing)</Name><Description>Writes alert data to the Data Warehouse default store</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting" SubElementID="BulkInsertBatchSize"><Name>Bulk Insert Batch Size</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Execution Attempt Timeout Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Max Batches To Process Before Maintenance Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterDefaultRouting" SubElementID="MaxExecutionAttemptCount"><Name>Max Execution Attempt Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal"><Name>Data Warehouse base alert data writer</Name><Description>Base module for all alert data writers</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" SubElementID="BulkInsertBatchSize"><Name>Bulk insert batch size</Name><Description>Maximum size of the batch for bulk insert operation</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Maximum number of data item batches to process before maintenance</Name><Description>Maximum number of data item batches module will process before running data set maintenance operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter"><Name>Base Data Warehouse bulk insert data writer</Name><Description>Base module to create custom Data Warehouse data writers that insert data using SQL's bulk insert functionality</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" SubElementID="BulkInsertBatchSize"><Name>Bulk insert batch size</Name><Description>Maximum size of the batch for bulk insert operation</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Maximum number of data item batches to process before maintenance</Name><Description>Maximum number of data item batches module will process before running data set maintenance operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.CollectEntityHealthStateChange"><Name>Entity state change collector</Name><Description>This rule collects all published (on default channel) entity state change events for Data Warehouse collection (to default store)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.CollectEventData"><Name>Event data collector</Name><Description>This rule collects all published (on default channel) event data for Data Warehouse collection (to default store)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.CollectPerformanceData"><Name>Performance data collector</Name><Description>This rule collects all published (on default channel) performance data for Data Warehouse collection (to default store)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ConfigSynchronizationReaderAccount"><Name>Reserved</Name><Description>This profile is reserved and must not be used.</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType"><Name>Data Warehouse data collection speed monitor</Name><Description>This monitor switches states based on events degradation of the data insertion speed</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType" SubElementID="AllowedProcessingDelaySeconds"><Name>Allowed processing delay</Name><Description>The allowed data processing delay in seconds</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType" SubElementID="CollectionSlow"><Name>Collection is slow</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType" SubElementID="CollectionUpToSpeed"><Name>Collection up to speed</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataCollectionSlowdownUnitMonitorType" SubElementID="WatchWindowSeconds"><Name>Watch window</Name><Description>The duration of time monitor will be looking for an event indicating data processing is slow</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet"><Name>Data Set</Name><Description>All Data Warehouse data sets</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet" SubElementID="Description"><Name>Data Set Description</Name><Description>Data Set Description</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet" SubElementID="InstanceGuid"><Name>Data Set Globally Unique Id</Name><Description>Data Set Globally Unique Id</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Alert"><Name>Alert data set</Name><Description>Defines storage and aggregation for alert information</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Alert.DefaultConfiguration"><Name>State data set default configuration</Name><Description>
                    &lt;Configuration&gt;
    &lt;Storage&gt;
        &lt;BaseTableName&gt;Alert&lt;/BaseTableName&gt;
        &lt;MaxTableRowCount&gt;1000000&lt;/MaxTableRowCount&gt;
        &lt;MaxDataAgeDays&gt;400&lt;/MaxDataAgeDays&gt;
        &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
        &lt;MaxRowsToGroom&gt;50000&lt;/MaxRowsToGroom&gt;
        &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
    &lt;/Storage&gt;
    &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
    &lt;BlockingMaintenanceDailyStartTime&gt;01:00&lt;/BlockingMaintenanceDailyStartTime&gt;
    &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
&lt;/Configuration&gt;

                    </Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Event"><Name>Event data set</Name><Description>Defines storage and aggregation for event information</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Event.DefaultConfiguration"><Name>State data set default configuration</Name><Description>
                    &lt;Configuration&gt;
    &lt;Storage&gt;
        &lt;BaseTableName&gt;Event&lt;/BaseTableName&gt;
        &lt;MaxTableRowCount&gt;15000000&lt;/MaxTableRowCount&gt;
        &lt;MaxDataAgeDays&gt;100&lt;/MaxDataAgeDays&gt;
        &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
        &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;
        &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
    &lt;/Storage&gt;
    &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
    &lt;BlockingMaintenanceDailyStartTime&gt;01:00&lt;/BlockingMaintenanceDailyStartTime&gt;
    &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
&lt;/Configuration&gt;

                    </Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Performance"><Name>Performance data set</Name><Description>Defines storage and aggregation for performance information</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.Performance.DefaultConfiguration"><Name>Performance data set default configuration</Name><Description>
                    &lt;Configuration&gt;
    &lt;Aggregations&gt;
        &lt;Raw&gt;
            &lt;BaseTableName&gt;PerfRaw&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;10&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
        &lt;/Raw&gt;
        &lt;Hourly&gt;
            &lt;BaseTableName&gt;PerfHourly&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;400&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;

            &lt;AggregationStartDelayMinutes&gt;20&lt;/AggregationStartDelayMinutes&gt;
        &lt;/Hourly&gt;
        &lt;Daily&gt;
            &lt;BaseTableName&gt;PerfDaily&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;10000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;400&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;240&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;100000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;

            &lt;AggregationStartDelayMinutes&gt;30&lt;/AggregationStartDelayMinutes&gt;
        &lt;/Daily&gt;
    &lt;/Aggregations&gt;
    &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
    &lt;DefaultAggregationIntervalCount&gt;48&lt;/DefaultAggregationIntervalCount&gt;
    &lt;BlockingMaintenanceDailyStartTime&gt;01:00&lt;/BlockingMaintenanceDailyStartTime&gt;
    &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
&lt;/Configuration&gt;

                    </Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.State"><Name>State data set</Name><Description>Defines storage and aggregation for object state and availability information</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataSet.State.DefaultConfiguration"><Name>State data set default configuration</Name><Description>
                    &lt;Configuration&gt;
    &lt;Aggregations&gt;
        &lt;Raw&gt;
            &lt;BaseTableName&gt;StateRaw&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;5000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;180&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;60&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;50000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;
        &lt;/Raw&gt;
        &lt;Hourly&gt;
            &lt;BaseTableName&gt;StateHourly&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;15000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;400&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;60&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;50000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;

            &lt;AggregationStartDelayMinutes&gt;5&lt;/AggregationStartDelayMinutes&gt;
        &lt;/Hourly&gt;
        &lt;Daily&gt;
            &lt;BaseTableName&gt;StateDaily&lt;/BaseTableName&gt;
            &lt;MaxTableRowCount&gt;5000000&lt;/MaxTableRowCount&gt;

            &lt;MaxDataAgeDays&gt;400&lt;/MaxDataAgeDays&gt;
            &lt;GroomingIntervalMinutes&gt;60&lt;/GroomingIntervalMinutes&gt;
            &lt;MaxRowsToGroom&gt;50000&lt;/MaxRowsToGroom&gt;

            &lt;IndexOptimizationIntervalMinutes&gt;240&lt;/IndexOptimizationIntervalMinutes&gt;

            &lt;AggregationStartDelayMinutes&gt;5&lt;/AggregationStartDelayMinutes&gt;
        &lt;/Daily&gt;
    &lt;/Aggregations&gt;
    &lt;RawInsertTableCount&gt;1&lt;/RawInsertTableCount&gt;
    &lt;DefaultAggregationIntervalCount&gt;48&lt;/DefaultAggregationIntervalCount&gt;
    &lt;BlockingMaintenanceDailyStartTime&gt;01:00&lt;/BlockingMaintenanceDailyStartTime&gt;
    &lt;BlockingMaintenanceDurationMinutes&gt;240&lt;/BlockingMaintenanceDurationMinutes&gt;
&lt;/Configuration&gt;

                    </Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DataWarehouseContainsDataSet"><Name>Data Warehouse contains data set</Name><Description>Relationship indicating that Data Warehouse contains specified data set</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EnableServerEntityHealthStateDataStallHandling"><Name>Management Server Data Warehouse Health Collection Stall Handing</Name><Description>This override enables the management server specific setting for handling stalled processing to the Data Warehouse for collecting health state information</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EnableServerEventDataStallHandling"><Name>Management Server Data Warehouse Event Collection Stall Handing</Name><Description>This override enables the management server specific setting for handling stalled processing to the Data Warehouse for collecting events</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EnableServerPerformanceDataStallHandling"><Name>Management Server Data Warehouse Health Performance Stall Handing</Name><Description>This override enables the management server specific setting for handling stalled processing to the Data Warehouse for collecting performance data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriter"><Name>Data Warehouse entity state change event writer (custom routing)</Name><Description>Use this module to write state change event data to the Data Warehouse with custom routing (custom data set)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EntityHealthStateChangeDataWriterDefaultRouting"><Name>Data Warehouse entity state change writer (default routing)</Name><Description>Writes entity state change data to the Data Warehouse default store</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter"><Name>Data Warehouse event data writer (custom routing)</Name><Description>Use this module to write event data to the Data Warehouse with custom routing (custom data set)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter" SubElementID="BulkInsertBatchSize"><Name>Bulk Insert Batch Size</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Execution Attempt Timeout Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Max Batches To Process Before Maintenance Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriter" SubElementID="MaxExecutionAttemptCount"><Name>Max Execution Attempt Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting"><Name>Data Warehouse event data writer (default routing)</Name><Description>Writes event data to the Data Warehouse default store</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" SubElementID="BulkInsertBatchSize"><Name>Bulk Insert Batch Size</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Execution Attempt Timeout Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Max Batches To Process Before Maintenance Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterDefaultRouting" SubElementID="MaxExecutionAttemptCount"><Name>Max Execution Attempt Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal"><Name>Data Warehouse base event data writer</Name><Description>Base module for all event data writers</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" SubElementID="BulkInsertBatchSize"><Name>Bulk Insert Batch Size</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Execution Attempt Timeout Interval Seconds</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Max Batches To Process Before Maintenance Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" SubElementID="MaxExecutionAttemptCount"><Name>Max Execution Attempt Count</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.Library"><Name>Data Warehouse Library</Name><Description>Microsoft System Center Data Warehouse Library: This Management Pack contains definitions and workflows for MOM data Warehousing features.</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Collection.Performance.Rollup"><Name>Data Warehouse Data Collection Performance State</Name><Description>Rollup monitor for Data Warehouse data collection process performance state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Collection.Rollup"><Name>Data Warehouse Data Collection State</Name><Description>Rollup monitor for Data Warehouse data collection state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Maintenance.Rollup"><Name>Data Warehouse Data Maintenance State</Name><Description>Rollup monitor for Data Warehouse data maintenance state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.DedicatedMaintenance.Rollup"><Name>Data Warehouse Data Dedicated Maintenance Process State</Name><Description>Rollup monitor for Data Warehouse dedicated data maintenance process state</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.WriterMaintenance.Rollup"><Name>Data Warehouse Data Writer Maintenance State</Name><Description>Rollup monitor for Data Warehouse data writer maintenance state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Performance.Rollup"><Name>Data Warehouse Performance State</Name><Description>Rollup monitor for Data Warehouse performance state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Rollup"><Name>Data Warehouse Connectivity and Processes State</Name><Description>Rollup monitor for Data Warehouse processes state from the perspective of a Management Server</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter"><Name>Data Warehouse performance data writer (custom routing)</Name><Description>Use this module to write performance data to the Data Warehouse with custom routing (custom data set)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter" SubElementID="BulkInsertBatchSize"><Name>Bulk insert batch size</Name><Description>Maximum size of the batch for bulk insert operation</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Maximum number of data item batches to process before maintenance</Name><Description>Maximum number of data item batches module will process before running data set maintenance operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriter" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting"><Name>Data Warehouse performance data writer (default routing)</Name><Description>Writes performance data to the Data Warehouse default store</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" SubElementID="BulkInsertBatchSize"><Name>Bulk insert batch size</Name><Description>Maximum size of the batch for bulk insert operation</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Maximum number of data item batches to process before maintenance</Name><Description>Maximum number of data item batches module will process before running data set maintenance operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterDefaultRouting" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal"><Name>Data Warehouse base performance data writer</Name><Description>Base module for all performance data writers</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" SubElementID="BulkInsertBatchSize"><Name>Bulk insert batch size</Name><Description>Maximum size of the batch for bulk insert operation</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" SubElementID="MaxBatchesToProcessBeforeMaintenanceCount"><Name>Maximum number of data item batches to process before maintenance</Name><Description>Maximum number of data item batches module will process before running data set maintenance operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProvider"><Name>Data Warehouse published (on default channel) entity state change provider</Name><Description>This module is used as a listener on default channel that provides published entity state change event data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProvider" SubElementID="DropItems"><Name>Drop Items</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderCustomChannel"><Name>Data Warehouse published (on custom channel) entity state change provider</Name><Description>This module is used as a listener on custom channel (indicated by unique identifier) that provides published (on that channel) entity state change event data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEntityHealthStateChangeProviderInternal"><Name>Base Data Warehouse published entity state change provider</Name><Description>Base module to provide published (by publishers) entity state change events for Data Warehouse collection</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProvider"><Name>Data Warehouse published (on default channel) event data provider</Name><Description>This module is used as a listener on default channel that provides published event data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProvider" SubElementID="DropItems"><Name>Drop Items</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderCustomChannel"><Name>Data Warehouse published (on custom channel) event data provider</Name><Description>This module is used as a listener on custom channel (indicated by unique identifier) that provides published (on that channel) event data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedEventDataProviderInternal"><Name>Base Data Warehouse published event data provider</Name><Description>Base module to provide published (by publishers) event data for Data Warehouse collection</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProvider"><Name>Data Warehouse published (on default channel) performance data provider</Name><Description>This module is used as a listener on default channel that provides published performance data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProvider" SubElementID="DropItems"><Name>Drop Items</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderCustomChannel"><Name>Data Warehouse published (on custom channel) performance data provider</Name><Description>This module is used as a listener on custom channel (indicated by unique identifier) that provides published (on that channel) performance data</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishedPerformanceDataProviderInternal"><Name>Base Data Warehouse published performance data provider</Name><Description>Base module to provide published (by publishers) performance data for Data Warehouse collection</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChange"><Name>Entity state change publisher (default channel)</Name><Description>Publishes entity state change information on Operations Manager default channel</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeCustomChannel"><Name>Entity state change event publisher (custom channel)</Name><Description>This module is used to publish entity state change events on a custom channel</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeForCollection"><Name>Entity state change publisher</Name><Description>This rule collects entity state change information from all managed entities and publishes it for Data Warehouse collection on default channel</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEventData"><Name>Event data publisher</Name><Description>This module is used to publish event data for Data Warehouse collection using standard collection rule provided with the Data Warehouse</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEventDataCustomChannel"><Name>Event data publisher (custom channel)</Name><Description>This module is used to publish event data on a custom channel for collection by a custom rule</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData"><Name>Performance data publisher</Name><Description>This module is used to publish performance data for Data Warehouse collection using standard collection rule provided with the Data Warehouse</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.PublishPerformanceDataCustomChannel"><Name>Performance data publisher (custom channel)</Name><Description>This module is used to publish performance data on a custom channel for collection by a custom rule</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.ReportDeploymentActionAccount"><Name>Data Warehouse Report Deployment Account</Name><Description>This account is used by Data Warehouse report auto-deployment procedures to execute various report deployment related operations</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport"><Name>Data Set debugging support script</Name><Description>Creates database objects necessary to produce debug output for a data set</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase"><Name>Data Warehouse member database initialization script</Name><Description>Creates database objects required in the Data Warehouse member database</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport"><Name>Standard Data Set support script</Name><Description>Creates database objects required for the operations of the standard data set</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.SdkSqlAuthenticationActionAccount"><Name>Reporting SDK SQL Server Authentication Account</Name><Description>If specified, this login name and password is used by Data Access service to connect to the Data Warehouse databases using SQL Server authentication</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.SqlAuthenticationActionAccount"><Name>Data Warehouse SQL Server Authentication Account</Name><Description>If specified, this login name and password is used by collection and synchronization rules to connect to the Data Warehouse databases using SQL Server authentication</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.StandardDataSet"><Name>Standard Data Set</Name><Description>All Data Warehouse Standard Data Sets</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.WorkflowSqlServerAuthUnitMonitorType"><Name>Data Warehouse workflow SQL Server Authentication configuration monitor</Name><Description>This monitor switches states based on events indicating that SQL Server Authentication was or was not configured for a specific workflow</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.WorkflowSqlServerAuthUnitMonitorType" SubElementID="ConfigReloadRequested"><Name>Configuration reload requested event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.WorkflowSqlServerAuthUnitMonitorType" SubElementID="SqlAuthProfileEmptyEventRaised"><Name>Sql Server Authentication Profile missing event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedFirstChanceUnitMonitorType"><Name>Dataset based two-state event based monitor</Name><Description>Two state monitor switching states based on event configured for each state for a dataset provided as parameter</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedFirstChanceUnitMonitorType" SubElementID="FirstEventRaised"><Name>First event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedFirstChanceUnitMonitorType" SubElementID="SecondEventRaised"><Name>Second event raised</Name></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedRecoveryUnitMonitorType"><Name>Dataset based two-state event based monitor with timer</Name><Description>Monitor switches to good state if a given good event appears; monitor switches to bad state if given bad event appears and no good event is registered within a given time frame for a given dataset</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedRecoveryUnitMonitorType" SubElementID="SecondEventRaised"><Name>Second event raised</Name><Description/></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedRecoveryUnitMonitorType" SubElementID="FirstEventRaisedAndNoSecondEventRaisedInTimeInterval"><Name>First event raised and second event not raised within a given time interval</Name><Description/></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.DatasetRelatedRecoveryUnitMonitorType" SubElementID="TimeIntervalSeconds"><Name>Maximum allowed recovery time (seconds)</Name><Description>Time interval in seconds the monitor will wait before switching to bad state after bad event in registered</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter"><Name>Base Data Warehouse XML data writer</Name><Description>Base module to create custom Data Warehouse data writers that pass data in the form of XML</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter" SubElementID="ExecutionAttemptTimeoutIntervalSeconds"><Name>Subsequent execution attempt timeout interval in seconds</Name><Description>Interval in seconds between two subsequent execution attempts</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter" SubElementID="MaxExecutionAttemptCount"><Name>Maximum write operation execution attempt count</Name><Description>Maximum number of attempts module will perform before declaring inability to process data item. Value of zero indicates the module will continue execution (unlimited attempts)</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.DataWarehouseConnectorServer"><Name>Data Warehouse Connection Server</Name><Description>All Management Servers capable of sending data to the System Center Data Warehouse</Description></DisplayString><DisplayString ElementID="Microsoft.SystemCenter.OpsMgrDWWatchers.ReferenceDWConnectorServer"><Name>Operations Manager DW Watcher Reference DW Connector server</Name><Description>This is the relationship between Ops Mg DW Watcher and DW connector server.</Description></DisplayString></DisplayStrings><KnowledgeArticles><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Collection.Rollup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>Availability rollup monitor for Data Warehouse connectivity and data collection state from the perspective of a Management Server</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.ManagementServer.Rollup" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>Availability rollup monitor for Data Warehouse connectivity and processes state from the perspective of a Management Server</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.CollectEntityHealthStateChange" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects all published (on default channel) entity state change events for Data Warehouse collection (to default store)</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Causes</maml:title><maml:para>This section is not applicable to event collection rules.</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Resolutions</maml:title><maml:para>There is no resolution to perform for event collection rules since they do not generate state or alerts.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.CollectEventData" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects all published (on default channel) event data for Data Warehouse collection (to default store)</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Causes</maml:title><maml:para>This section is not applicable to event collection rules.</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Resolutions</maml:title><maml:para>There is no resolution to perform for event collection rules since they do not generate state or alerts.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.CollectPerformanceData" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects all published (on default channel) performance data for Data Warehouse collection (to default store)</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Causes</maml:title><maml:para>This section is not applicable to performance collection rules.</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Resolutions</maml:title><maml:para>There is no resolution to perform for performance collection rules since they do not generate state or alerts.</maml:para></maml:section></MamlContent></KnowledgeArticle><KnowledgeArticle ElementID="Microsoft.SystemCenter.DataWarehouse.PublishEntityHealthStateChangeForCollection" Visible="true"><MamlContent><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Summary</maml:title><maml:para>This rule collects entity state change information from all managed entities and publishes it for Data Warehouse collection on default channel</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Causes</maml:title><maml:para>This section is not applicable to event collection rules.</maml:para></maml:section><maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"><maml:title>Resolutions</maml:title><maml:para>There is no resolution to perform for event collection rules since they do not generate state or alerts.</maml:para></maml:section></MamlContent></KnowledgeArticle></KnowledgeArticles></LanguagePack></LanguagePacks><Resources><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Install" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Install" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Uninstall" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Uninstall" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Upgrade" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.DatasetDebuggingSupport.Upgrade" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Install" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Install" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Uninstall" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Uninstall" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Upgrade" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.MemberDatabase.Upgrade" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Install" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Install" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Uninstall" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Uninstall" HasNullStream="false"/><Resource ID="Res.Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Upgrade" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.Script.StandardDatasetSupport.Upgrade" HasNullStream="false"/><Assembly ID="Res.Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.AlertDataWriterInternal" HasNullStream="true" QualifiedName="Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse, Culture=&quot;&quot;, PublicKeyToken=&quot;31bf3856ad364e35&quot;, Version=&quot;7.0.5000.0&quot;"/><Assembly ID="Res.Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.BulkInsertBulkDataWriter" HasNullStream="true" QualifiedName="Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse, Culture=&quot;&quot;, PublicKeyToken=&quot;31bf3856ad364e35&quot;, Version=&quot;7.0.5000.0&quot;"/><Assembly ID="Res.Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.EventDataWriterInternal" HasNullStream="true" QualifiedName="Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse, Culture=&quot;&quot;, PublicKeyToken=&quot;31bf3856ad364e35&quot;, Version=&quot;7.0.5000.0&quot;"/><Assembly ID="Res.Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.PerformanceDataWriterInternal" HasNullStream="true" QualifiedName="Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse, Culture=&quot;&quot;, PublicKeyToken=&quot;31bf3856ad364e35&quot;, Version=&quot;7.0.5000.0&quot;"/><Assembly ID="Res.Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter" Accessibility="Public" FileName="Microsoft.SystemCenter.DataWarehouse.XmlBulkDataWriter" HasNullStream="true" QualifiedName="Microsoft.EnterpriseManagement.HealthService.Modules.DataWarehouse, Culture=&quot;&quot;, PublicKeyToken=&quot;31bf3856ad364e35&quot;, Version=&quot;7.0.5000.0&quot;"/></Resources></ManagementPack>
